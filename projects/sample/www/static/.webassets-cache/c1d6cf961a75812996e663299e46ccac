V;!function(){\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Contains the first and essential part of the {@link CKEDITOR}\u000a *		object definition.\u000a */\u000a\u000a// #### Compressed Code\u000a// Compressed code in ckeditor.js must be be updated on changes in the script.\u000a// The Closure Compiler online service should be used when updating this manually:\u000a// http://closure-compiler.appspot.com/\u000a\u000a// #### Raw code\u000a// ATTENTION: read the above "Compressed Code" notes when changing this code.\u000a\u000aif ( !window.CKEDITOR ) {\u000a	/**\u000a	 * This is the API entry point. The entire CKEditor code runs under this object.\u000a	 * @class CKEDITOR\u000a	 * @singleton\u000a	 */\u000a	window.CKEDITOR = ( function() {\u000a		var basePathSrcPattern = /(^|.*[\u005c\u005c\u005c/])ckeditor\u005c.js(?:\u005c?.*|;.*)?$/i;\u000a\u000a		var CKEDITOR = {\u000a\u000a			/**\u000a			 * A constant string unique for each release of CKEditor. Its value\u000a			 * is used, by default, to build the URL for all resources loaded\u000a			 * by the editor code, guaranteeing clean cache results when\u000a			 * upgrading.\u000a			 *\u000a			 *		alert( CKEDITOR.timestamp ); // e.g. '87dm'\u000a			 */\u000a			timestamp: '',				// %REMOVE_LINE%\u000a			/*							// %REMOVE_LINE%\u000a			// The production implementation contains a fixed timestamp, unique\u000a			// for each release and generated by the releaser.\u000a			// (Base 36 value of each component of YYMMDDHH - 4 chars total - e.g. 87bm == 08071122)\u000a			timestamp: '%TIMESTAMP%',\u000a			// %REMOVE_LINE% */\u000a\u000a			/**\u000a			 * Contains the CKEditor version number.\u000a			 *\u000a			 *		alert( CKEDITOR.version ); // e.g. 'CKEditor 3.4.1'\u000a			 */\u000a			version: '%VERSION%',\u000a\u000a			/**\u000a			 * Contains the CKEditor revision number.\u000a			 * The revision number is incremented automatically, following each\u000a			 * modification to the CKEditor source code.\u000a			 *\u000a			 *		alert( CKEDITOR.revision ); // e.g. '3975'\u000a			 */\u000a			revision: '%REV%',\u000a\u000a			/**\u000a			 * A 3-digit random integer, valid for the entire life of the CKEDITOR object.\u000a			 *\u000a			 *		alert( CKEDITOR.rnd ); // e.g. 319\u000a			 *\u000a			 * @property {Number}\u000a			 */\u000a			rnd: Math.floor( Math.random() * ( 999 /*Max*/ - 100 /*Min*/ + 1 ) ) + 100 /*Min*/,\u000a\u000a			/**\u000a			 * Private object used to hold core stuff. It should not be used outside of\u000a			 * the API code as properties defined here may change at any time\u000a			 * without notice.\u000a			 *\u000a			 * @private\u000a			 */\u000a			_: {\u000a				pending: [],\u000a				basePathSrcPattern: basePathSrcPattern\u000a			},\u000a\u000a			/**\u000a			 * Indicates the API loading status. The following statuses are available:\u000a			 *\u000a			 * * **unloaded**: the API is not yet loaded.\u000a			 * * **basic_loaded**: the basic API features are available.\u000a			 * * **basic_ready**: the basic API is ready to load the full core code.\u000a			 * * **loaded**: the API can be fully used.\u000a			 *\u000a			 * Example:\u000a			 *\u000a			 *		if ( CKEDITOR.status == 'loaded' ) {\u000a			 *			// The API can now be fully used.\u000a			 *			doSomething();\u000a			 *		} else {\u000a			 *			// Wait for the full core to be loaded and fire its loading.\u000a			 *			CKEDITOR.on( 'load', doSomething );\u000a			 *			CKEDITOR.loadFullCore && CKEDITOR.loadFullCore();\u000a			 *		}\u000a			 */\u000a			status: 'unloaded',\u000a\u000a			/**\u000a			 * The full URL for the CKEditor installation directory.\u000a			 * It is possible to manually provide the base path by setting a\u000a			 * global variable named `CKEDITOR_BASEPATH`. This global variable\u000a			 * must be set **before** the editor script loading.\u000a			 *\u000a			 *		alert( CKEDITOR.basePath ); // e.g. 'http://www.example.com/ckeditor/'\u000a			 *\u000a			 * @property {String}\u000a			 */\u000a			basePath: ( function() {\u000a				// Find out the editor directory path, based on its <script> tag.\u000a				var path = window.CKEDITOR_BASEPATH || '';\u000a\u000a				if ( !path ) {\u000a					var scripts = document.getElementsByTagName( 'script' );\u000a\u000a					for ( var i = 0; i < scripts.length; i++ ) {\u000a						var match = scripts[ i ].src.match( basePathSrcPattern );\u000a\u000a						if ( match ) {\u000a							path = match[ 1 ];\u000a							break;\u000a						}\u000a					}\u000a				}\u000a\u000a				// In IE (only) the script.src string is the raw value entered in the\u000a				// HTML source. Other browsers return the full resolved URL instead.\u000a				if ( path.indexOf( ':/' ) == -1 && path.slice( 0, 2 ) != '//' ) {\u000a					// Absolute path.\u000a					if ( path.indexOf( '/' ) === 0 )\u000a						path = location.href.match( /^.*?:\u005c/\u005c/[^\u005c/]*/ )[ 0 ] + path;\u000a					// Relative path.\u000a					else\u000a						path = location.href.match( /^[^\u005c?]*\u005c/(?:)/ )[ 0 ] + path;\u000a				}\u000a\u000a				if ( !path )\u000a					throw 'The CKEditor installation path could not be automatically detected. Please set the global variable "CKEDITOR_BASEPATH" before creating editor instances.';\u000a\u000a				return path;\u000a			} )(),\u000a\u000a			/**\u000a			 * Gets the full URL for CKEditor resources. By default, URLs\u000a			 * returned by this function contain a querystring parameter ("t")\u000a			 * set to the {@link CKEDITOR#timestamp} value.\u000a			 *\u000a			 * It is possible to provide a custom implementation of this\u000a			 * function by setting a global variable named `CKEDITOR_GETURL`.\u000a			 * This global variable must be set **before** the editor script\u000a			 * loading. If the custom implementation returns nothing (`==null`), the\u000a			 * default implementation is used.\u000a			 *\u000a			 *		// e.g. 'http://www.example.com/ckeditor/skins/default/editor.css?t=87dm'\u000a			 *		alert( CKEDITOR.getUrl( 'skins/default/editor.css' ) );\u000a			 *\u000a			 *		// e.g. 'http://www.example.com/skins/default/editor.css?t=87dm'\u000a			 *		alert( CKEDITOR.getUrl( '/skins/default/editor.css' ) );\u000a			 *\u000a			 *		// e.g. 'http://www.somesite.com/skins/default/editor.css?t=87dm'\u000a			 *		alert( CKEDITOR.getUrl( 'http://www.somesite.com/skins/default/editor.css' ) );\u000a			 *\u000a			 * @param {String} resource The resource whose full URL we want to get.\u000a			 * It may be a full, absolute, or relative URL.\u000a			 * @returns {String} The full URL.\u000a			 */\u000a			getUrl: function( resource ) {\u000a				// If this is not a full or absolute path.\u000a				if ( resource.indexOf( ':/' ) == -1 && resource.indexOf( '/' ) !== 0 )\u000a					resource = this.basePath + resource;\u000a\u000a				// Add the timestamp, except for directories.\u000a				if ( this.timestamp && resource.charAt( resource.length - 1 ) != '/' && !( /[&?]t=/ ).test( resource ) )\u000a					resource += ( resource.indexOf( '?' ) >= 0 ? '&' : '?' ) + 't=' + this.timestamp;\u000a\u000a				return resource;\u000a			},\u000a\u000a			/**\u000a			 * Specify a function to execute when the DOM is fully loaded.\u000a			 *\u000a			 * If called after the DOM has been initialized, the function passed in will\u000a			 * be executed immediately.\u000a			 *\u000a			 * @method\u000a			 * @todo\u000a			 */\u000a			domReady: ( function() {\u000a				// Based on the original jQuery code.\u000a\u000a				var callbacks = [];\u000a\u000a				function onReady() {\u000a					try {\u000a						// Cleanup functions for the document ready method\u000a						if ( document.addEventListener ) {\u000a							document.removeEventListener( 'DOMContentLoaded', onReady, false );\u000a							executeCallbacks();\u000a						}\u000a						// Make sure body exists, at least, in case IE gets a little overzealous.\u000a						else if ( document.attachEvent && document.readyState === 'complete' ) {\u000a							document.detachEvent( 'onreadystatechange', onReady );\u000a							executeCallbacks();\u000a						}\u000a					} catch ( er ) {}\u000a				}\u000a\u000a				function executeCallbacks() {\u000a					var i;\u000a					while ( ( i = callbacks.shift() ) )\u000a						i();\u000a				}\u000a\u000a				return function( fn ) {\u000a					callbacks.push( fn );\u000a\u000a					// Catch cases where this is called after the\u000a					// browser event has already occurred.\u000a					if ( document.readyState === 'complete' )\u000a						// Handle it asynchronously to allow scripts the opportunity to delay ready\u000a						setTimeout( onReady, 1 );\u000a\u000a					// Run below once on demand only.\u000a					if ( callbacks.length != 1 )\u000a						return;\u000a\u000a					// For IE>8, Firefox, Opera and Webkit.\u000a					if ( document.addEventListener ) {\u000a						// Use the handy event callback\u000a						document.addEventListener( 'DOMContentLoaded', onReady, false );\u000a\u000a						// A fallback to window.onload, that will always work\u000a						window.addEventListener( 'load', onReady, false );\u000a\u000a					}\u000a					// If old IE event model is used\u000a					else if ( document.attachEvent ) {\u000a						// ensure firing before onload,\u000a						// maybe late but safe also for iframes\u000a						document.attachEvent( 'onreadystatechange', onReady );\u000a\u000a						// A fallback to window.onload, that will always work\u000a						window.attachEvent( 'onload', onReady );\u000a\u000a						// If IE and not a frame\u000a						// continually check to see if the document is ready\u000a						// use the trick by Diego Perini\u000a						// http://javascript.nwbox.com/IEContentLoaded/\u000a						var toplevel = false;\u000a\u000a						try {\u000a							toplevel = !window.frameElement;\u000a						} catch ( e ) {}\u000a\u000a						if ( document.documentElement.doScroll && toplevel ) {\u000a							scrollCheck();\u000a						}\u000a					}\u000a\u000a					function scrollCheck() {\u000a						try {\u000a							document.documentElement.doScroll( 'left' );\u000a						} catch ( e ) {\u000a							setTimeout( scrollCheck, 1 );\u000a							return;\u000a						}\u000a						onReady();\u000a					}\u000a				};\u000a\u000a			} )()\u000a		};\u000a\u000a		// Make it possible to override the "url" function with a custom\u000a		// implementation pointing to a global named CKEDITOR_GETURL.\u000a		var newGetUrl = window.CKEDITOR_GETURL;\u000a		if ( newGetUrl ) {\u000a			var originalGetUrl = CKEDITOR.getUrl;\u000a			CKEDITOR.getUrl = function( resource ) {\u000a				return newGetUrl.call( CKEDITOR, resource ) || originalGetUrl.call( CKEDITOR, resource );\u000a			};\u000a		}\u000a\u000a		return CKEDITOR;\u000a	} )();\u000a}\u000a\u000a/**\u000a * Function called upon loading a custom configuration file that can\u000a * modify the editor instance configuration ({@link CKEDITOR.editor#config}).\u000a * It is usually defined inside the custom configuration files that can\u000a * include developer defined settings.\u000a *\u000a *		// This is supposed to be placed in the config.js file.\u000a *		CKEDITOR.editorConfig = function( config ) {\u000a *			// Define changes to default configuration here. For example:\u000a *			config.language = 'fr';\u000a *			config.uiColor = '#AADC6E';\u000a *		};\u000a *\u000a * @method editorConfig\u000a * @param {CKEDITOR.config} config A configuration object containing the\u000a * settings defined for a {@link CKEDITOR.editor} instance up to this\u000a * function call. Note that not all settings may still be available. See\u000a * [Configuration Loading Order](http://docs.cksource.com/CKEditor_3.x/Developers_Guide/Setting_Configurations#Configuration_Loading_Order)\u000a * for details.\u000a */\u000a\u000a// PACKAGER_RENAME( CKEDITOR )\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.event} class, which serves as the\u000a *		base for classes and objects that require event handling features.\u000a */\u000a\u000aif ( !CKEDITOR.event ) {\u000a	/**\u000a	 * Creates an event class instance. This constructor is rarely used, being\u000a	 * the {@link #implementOn} function used in class prototypes directly\u000a	 * instead.\u000a	 *\u000a	 * This is a base class for classes and objects that require event\u000a	 * handling features.\u000a	 *\u000a	 * Do not confuse this class with {@link CKEDITOR.dom.event} which is\u000a	 * instead used for DOM events. The CKEDITOR.event class implements the\u000a	 * internal event system used by the CKEditor to fire API related events.\u000a	 *\u000a	 * @class\u000a	 * @constructor Creates an event class instance.\u000a	 */\u000a	CKEDITOR.event = function() {};\u000a\u000a	/**\u000a	 * Implements the {@link CKEDITOR.event} features in an object.\u000a	 *\u000a	 *		var myObject = { message: 'Example' };\u000a	 *		CKEDITOR.event.implementOn( myObject );\u000a	 *\u000a	 *		myObject.on( 'testEvent', function() {\u000a	 *			alert( this.message );\u000a	 *		} );\u000a	 *		myObject.fire( 'testEvent' ); // 'Example'\u000a	 *\u000a	 * @static\u000a	 * @param {Object} targetObject The object into which implement the features.\u000a	 */\u000a	CKEDITOR.event.implementOn = function( targetObject ) {\u000a		var eventProto = CKEDITOR.event.prototype;\u000a\u000a		for ( var prop in eventProto ) {\u000a			if ( targetObject[ prop ] == null )\u000a				targetObject[ prop ] = eventProto[ prop ];\u000a		}\u000a	};\u000a\u000a	CKEDITOR.event.prototype = ( function() {\u000a		// Returns the private events object for a given object.\u000a		var getPrivate = function( obj ) {\u000a				var _ = ( obj.getPrivate && obj.getPrivate() ) || obj._ || ( obj._ = {} );\u000a				return _.events || ( _.events = {} );\u000a			};\u000a\u000a		var eventEntry = function( eventName ) {\u000a				this.name = eventName;\u000a				this.listeners = [];\u000a			};\u000a\u000a		eventEntry.prototype = {\u000a			// Get the listener index for a specified function.\u000a			// Returns -1 if not found.\u000a			getListenerIndex: function( listenerFunction ) {\u000a				for ( var i = 0, listeners = this.listeners; i < listeners.length; i++ ) {\u000a					if ( listeners[ i ].fn == listenerFunction )\u000a						return i;\u000a				}\u000a				return -1;\u000a			}\u000a		};\u000a\u000a		// Retrieve the event entry on the event host (create it if needed).\u000a		function getEntry( name ) {\u000a			// Get the event entry (create it if needed).\u000a			var events = getPrivate( this );\u000a			return events[ name ] || ( events[ name ] = new eventEntry( name ) );\u000a		}\u000a\u000a		return {\u000a			/**\u000a			 * Predefine some intrinsic properties on a specific event name.\u000a			 *\u000a			 * @param {String} name The event name\u000a			 * @param meta\u000a			 * @param [meta.errorProof=false] Whether the event firing should catch error thrown from a per listener call.\u000a			 */\u000a			define: function( name, meta ) {\u000a				var entry = getEntry.call( this, name );\u000a				CKEDITOR.tools.extend( entry, meta, true );\u000a			},\u000a\u000a			/**\u000a			 * Registers a listener to a specific event in the current object.\u000a			 *\u000a			 *		someObject.on( 'someEvent', function() {\u000a			 *			alert( this == someObject );		// true\u000a			 *		} );\u000a			 *\u000a			 *		someObject.on( 'someEvent', function() {\u000a			 *			alert( this == anotherObject );		// true\u000a			 *		}, anotherObject );\u000a			 *\u000a			 *		someObject.on( 'someEvent', function( event ) {\u000a			 *			alert( event.listenerData );		// 'Example'\u000a			 *		}, null, 'Example' );\u000a			 *\u000a			 *		someObject.on( 'someEvent', function() { ... } );						// 2nd called\u000a			 *		someObject.on( 'someEvent', function() { ... }, null, null, 100 );		// 3rd called\u000a			 *		someObject.on( 'someEvent', function() { ... }, null, null, 1 );		// 1st called\u000a			 *\u000a			 * @param {String} eventName The event name to which listen.\u000a			 * @param {Function} listenerFunction The function listening to the\u000a			 * event. A single {@link CKEDITOR.eventInfo} object instanced\u000a			 * is passed to this function containing all the event data.\u000a			 * @param {Object} [scopeObj] The object used to scope the listener\u000a			 * call (the `this` object). If omitted, the current object is used.\u000a			 * @param {Object} [listenerData] Data to be sent as the\u000a			 * {@link CKEDITOR.eventInfo#listenerData} when calling the\u000a			 * listener.\u000a			 * @param {Number} [priority=10] The listener priority. Lower priority\u000a			 * listeners are called first. Listeners with the same priority\u000a			 * value are called in registration order.\u000a			 * @returns {Object} An object containing the `removeListener`\u000a			 * function, which can be used to remove the listener at any time.\u000a			 */\u000a			on: function( eventName, listenerFunction, scopeObj, listenerData, priority ) {\u000a				// Create the function to be fired for this listener.\u000a				function listenerFirer( editor, publisherData, stopFn, cancelFn ) {\u000a					var ev = {\u000a						name: eventName,\u000a						sender: this,\u000a						editor: editor,\u000a						data: publisherData,\u000a						listenerData: listenerData,\u000a						stop: stopFn,\u000a						cancel: cancelFn,\u000a						removeListener: removeListener\u000a					};\u000a\u000a					var ret = listenerFunction.call( scopeObj, ev );\u000a\u000a					return ret === false ? false : ev.data;\u000a				}\u000a\u000a				function removeListener() {\u000a					me.removeListener( eventName, listenerFunction );\u000a				}\u000a\u000a				var event = getEntry.call( this, eventName );\u000a\u000a				if ( event.getListenerIndex( listenerFunction ) < 0 ) {\u000a					// Get the listeners.\u000a					var listeners = event.listeners;\u000a\u000a					// Fill the scope.\u000a					if ( !scopeObj )\u000a						scopeObj = this;\u000a\u000a					// Default the priority, if needed.\u000a					if ( isNaN( priority ) )\u000a						priority = 10;\u000a\u000a					var me = this;\u000a\u000a					listenerFirer.fn = listenerFunction;\u000a					listenerFirer.priority = priority;\u000a\u000a					// Search for the right position for this new listener, based on its\u000a					// priority.\u000a					for ( var i = listeners.length - 1; i >= 0; i-- ) {\u000a						// Find the item which should be before the new one.\u000a						if ( listeners[ i ].priority <= priority ) {\u000a							// Insert the listener in the array.\u000a							listeners.splice( i + 1, 0, listenerFirer );\u000a							return { removeListener: removeListener };\u000a						}\u000a					}\u000a\u000a					// If no position has been found (or zero length), put it in\u000a					// the front of list.\u000a					listeners.unshift( listenerFirer );\u000a				}\u000a\u000a				return { removeListener: removeListener };\u000a			},\u000a\u000a			/**\u000a			 * Similiar with {@link #on} but the listener will be called only once upon the next event firing.\u000a			 *\u000a			 * @see CKEDITOR.event#on\u000a			 */\u000a			once: function() {\u000a				var args = Array.prototype.slice.call( arguments ),\u000a					fn = args[ 1 ];\u000a\u000a				args[ 1 ] = function( evt ) {\u000a					evt.removeListener();\u000a					return fn.apply( this, arguments );\u000a				};\u000a\u000a				return this.on.apply( this, args );\u000a			},\u000a\u000a			/**\u000a			 * @static\u000a			 * @property {Boolean} useCapture\u000a			 * @todo\u000a			 */\u000a\u000a			/**\u000a			 * Register event handler under the capturing stage on supported target.\u000a			 */\u000a			capture: function() {\u000a				CKEDITOR.event.useCapture = 1;\u000a				var retval = this.on.apply( this, arguments );\u000a				CKEDITOR.event.useCapture = 0;\u000a				return retval;\u000a			},\u000a\u000a			/**\u000a			 * Fires an specific event in the object. All registered listeners are\u000a			 * called at this point.\u000a			 *\u000a			 *		someObject.on( 'someEvent', function() { ... } );\u000a			 *		someObject.on( 'someEvent', function() { ... } );\u000a			 *		someObject.fire( 'someEvent' );				// Both listeners are called.\u000a			 *\u000a			 *		someObject.on( 'someEvent', function( event ) {\u000a			 *			alert( event.data );					// 'Example'\u000a			 *		} );\u000a			 *		someObject.fire( 'someEvent', 'Example' );\u000a			 *\u000a			 * @method\u000a			 * @param {String} eventName The event name to fire.\u000a			 * @param {Object} [data] Data to be sent as the\u000a			 * {@link CKEDITOR.eventInfo#data} when calling the listeners.\u000a			 * @param {CKEDITOR.editor} [editor] The editor instance to send as the\u000a			 * {@link CKEDITOR.eventInfo#editor} when calling the listener.\u000a			 * @returns {Boolean/Object} A boolean indicating that the event is to be\u000a			 * canceled, or data returned by one of the listeners.\u000a			 */\u000a			fire: ( function() {\u000a				// Create the function that marks the event as stopped.\u000a				var stopped = 0;\u000a				var stopEvent = function() {\u000a						stopped = 1;\u000a					};\u000a\u000a				// Create the function that marks the event as canceled.\u000a				var canceled = 0;\u000a				var cancelEvent = function() {\u000a						canceled = 1;\u000a					};\u000a\u000a				return function( eventName, data, editor ) {\u000a					// Get the event entry.\u000a					var event = getPrivate( this )[ eventName ];\u000a\u000a					// Save the previous stopped and cancelled states. We may\u000a					// be nesting fire() calls.\u000a					var previousStopped = stopped,\u000a						previousCancelled = canceled;\u000a\u000a					// Reset the stopped and canceled flags.\u000a					stopped = canceled = 0;\u000a\u000a					if ( event ) {\u000a						var listeners = event.listeners;\u000a\u000a						if ( listeners.length ) {\u000a							// As some listeners may remove themselves from the\u000a							// event, the original array length is dinamic. So,\u000a							// let's make a copy of all listeners, so we are\u000a							// sure we'll call all of them.\u000a							listeners = listeners.slice( 0 );\u000a\u000a							var retData;\u000a							// Loop through all listeners.\u000a							for ( var i = 0; i < listeners.length; i++ ) {\u000a								// Call the listener, passing the event data.\u000a								if ( event.errorProof ) {\u000a									try {\u000a										retData = listeners[ i ].call( this, editor, data, stopEvent, cancelEvent );\u000a									} catch ( er ) {}\u000a								} else {\u000a									retData = listeners[ i ].call( this, editor, data, stopEvent, cancelEvent );\u000a								}\u000a\u000a								if ( retData === false )\u000a									canceled = 1;\u000a								else if ( typeof retData != 'undefined' )\u000a									data = retData;\u000a\u000a								// No further calls is stopped or canceled.\u000a								if ( stopped || canceled )\u000a									break;\u000a							}\u000a						}\u000a					}\u000a\u000a					var ret = canceled ? false : ( typeof data == 'undefined' ? true : data );\u000a\u000a					// Restore the previous stopped and canceled states.\u000a					stopped = previousStopped;\u000a					canceled = previousCancelled;\u000a\u000a					return ret;\u000a				};\u000a			} )(),\u000a\u000a			/**\u000a			 * Fires an specific event in the object, releasing all listeners\u000a			 * registered to that event. The same listeners are not called again on\u000a			 * successive calls of it or of {@link #fire}.\u000a			 *\u000a			 *		someObject.on( 'someEvent', function() { ... } );\u000a			 *		someObject.fire( 'someEvent' );			// Above listener called.\u000a			 *		someObject.fireOnce( 'someEvent' );		// Above listener called.\u000a			 *		someObject.fire( 'someEvent' );			// No listeners called.\u000a			 *\u000a			 * @param {String} eventName The event name to fire.\u000a			 * @param {Object} [data] Data to be sent as the\u000a			 * {@link CKEDITOR.eventInfo#data} when calling the listeners.\u000a			 * @param {CKEDITOR.editor} [editor] The editor instance to send as the\u000a			 * {@link CKEDITOR.eventInfo#editor} when calling the listener.\u000a			 * @returns {Boolean/Object} A booloan indicating that the event is to be\u000a			 * canceled, or data returned by one of the listeners.\u000a			 */\u000a			fireOnce: function( eventName, data, editor ) {\u000a				var ret = this.fire( eventName, data, editor );\u000a				delete getPrivate( this )[ eventName ];\u000a				return ret;\u000a			},\u000a\u000a			/**\u000a			 * Unregisters a listener function from being called at the specified\u000a			 * event. No errors are thrown if the listener has not been registered previously.\u000a			 *\u000a			 *		var myListener = function() { ... };\u000a			 *		someObject.on( 'someEvent', myListener );\u000a			 *		someObject.fire( 'someEvent' );					// myListener called.\u000a			 *		someObject.removeListener( 'someEvent', myListener );\u000a			 *		someObject.fire( 'someEvent' );					// myListener not called.\u000a			 *\u000a			 * @param {String} eventName The event name.\u000a			 * @param {Function} listenerFunction The listener function to unregister.\u000a			 */\u000a			removeListener: function( eventName, listenerFunction ) {\u000a				// Get the event entry.\u000a				var event = getPrivate( this )[ eventName ];\u000a\u000a				if ( event ) {\u000a					var index = event.getListenerIndex( listenerFunction );\u000a					if ( index >= 0 )\u000a						event.listeners.splice( index, 1 );\u000a				}\u000a			},\u000a\u000a			/**\u000a			 * Remove all existing listeners on this object, for cleanup purpose.\u000a			 */\u000a			removeAllListeners: function() {\u000a				var events = getPrivate( this );\u000a				for ( var i in events )\u000a					delete events[ i ];\u000a			},\u000a\u000a			/**\u000a			 * Checks if there is any listener registered to a given event.\u000a			 *\u000a			 *		var myListener = function() { ... };\u000a			 *		someObject.on( 'someEvent', myListener );\u000a			 *		alert( someObject.hasListeners( 'someEvent' ) );	// true\u000a			 *		alert( someObject.hasListeners( 'noEvent' ) );		// false\u000a			 *\u000a			 * @param {String} eventName The event name.\u000a			 * @returns {Boolean}\u000a			 */\u000a			hasListeners: function( eventName ) {\u000a				var event = getPrivate( this )[ eventName ];\u000a				return ( event && event.listeners.length > 0 );\u000a			}\u000a		};\u000a	} )();\u000a}\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000aif ( !CKEDITOR.editor ) {\u000a	// Documented at editor.js.\u000a	CKEDITOR.editor = function() {\u000a		// Push this editor to the pending list. It'll be processed later once\u000a		// the full editor code is loaded.\u000a		CKEDITOR._.pending.push( [ this, arguments ] );\u000a\u000a		// Call the CKEDITOR.event constructor to initialize this instance.\u000a		CKEDITOR.event.call( this );\u000a	};\u000a\u000a	// Both fire and fireOnce will always pass this editor instance as the\u000a	// "editor" param in CKEDITOR.event.fire. So, we override it to do that\u000a	// automaticaly.\u000a	CKEDITOR.editor.prototype.fire = function( eventName, data ) {\u000a		if ( eventName in { instanceReady: 1, loaded: 1 } )\u000a			this[ eventName ] = true;\u000a\u000a		return CKEDITOR.event.prototype.fire.call( this, eventName, data, this );\u000a	};\u000a\u000a	CKEDITOR.editor.prototype.fireOnce = function( eventName, data ) {\u000a		if ( eventName in { instanceReady: 1, loaded: 1 } )\u000a			this[ eventName ] = true;\u000a\u000a		return CKEDITOR.event.prototype.fireOnce.call( this, eventName, data, this );\u000a	};\u000a\u000a	// "Inherit" (copy actually) from CKEDITOR.event.\u000a	CKEDITOR.event.implementOn( CKEDITOR.editor.prototype );\u000a}\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.env} object which contains\u000a *		environment and browser information.\u000a */\u000a\u000aif ( !CKEDITOR.env ) {\u000a	/**\u000a	 * Environment and browser information.\u000a	 *\u000a	 * @class CKEDITOR.env\u000a	 * @singleton\u000a	 */\u000a	CKEDITOR.env = ( function() {\u000a		var agent = navigator.userAgent.toLowerCase();\u000a\u000a		var env = {\u000a			/**\u000a			 * Indicates that CKEditor is running in Internet Explorer.\u000a			 *\u000a			 *		if ( CKEDITOR.env.ie )\u000a			 *			alert( 'I\u005c'm running in IE!' );\u000a			 *\u000a			 * @property {Boolean}\u000a			 */\u000a			ie: ( agent.indexOf( 'trident/' ) > -1 ),\u000a\u000a			/**\u000a			 * Indicates that CKEditor is running in a WebKit-based browser, like Safari.\u000a			 *\u000a			 *		if ( CKEDITOR.env.webkit )\u000a			 *			alert( 'I\u005c'm running in a WebKit browser!' );\u000a			 *\u000a			 * @property {Boolean}\u000a			 */\u000a			webkit: ( agent.indexOf( ' applewebkit/' ) > -1 ),\u000a\u000a			/**\u000a			 * Indicates that CKEditor is running in Adobe AIR.\u000a			 *\u000a			 *		if ( CKEDITOR.env.air )\u000a			 *			alert( 'I\u005c'm on AIR!' );\u000a			 *\u000a			 * @property {Boolean}\u000a			 */\u000a			air: ( agent.indexOf( ' adobeair/' ) > -1 ),\u000a\u000a			/**\u000a			 * Indicates that CKEditor is running on Macintosh.\u000a			 *\u000a			 *		if ( CKEDITOR.env.mac )\u000a			 *			alert( 'I love apples!'' );\u000a			 *\u000a			 * @property {Boolean}\u000a			 */\u000a			mac: ( agent.indexOf( 'macintosh' ) > -1 ),\u000a\u000a			/**\u000a			 * Indicates that CKEditor is running in a Quirks Mode environment.\u000a			 *\u000a			 *		if ( CKEDITOR.env.quirks )\u000a			 *			alert( 'Nooooo!' );\u000a			 *\u000a			 * Internet Explorer 10 introduced the _New Quirks Mode_, which is similar to the _Quirks Mode_\u000a			 * implemented in other modern browsers and defined in the HTML5 specification. It can be handled\u000a			 * as the Standards mode, so the value of this property will be set to `false`.\u000a			 *\u000a			 * The _Internet Explorer 5 Quirks_ mode which is still available in Internet Explorer 10+\u000a			 * sets this value to `true` and {@link #version} to `7`.\u000a			 *\u000a			 * Read more: [IEBlog](http://blogs.msdn.com/b/ie/archive/2011/12/14/interoperable-html5-quirks-mode-in-ie10.aspx)\u000a			 *\u000a			 * @property {Boolean}\u000a			 */\u000a			quirks: ( document.compatMode == 'BackCompat' && ( !document.documentMode || document.documentMode < 10 ) ),\u000a\u000a			/**\u000a			 * Indicates that CKEditor is running in a mobile environemnt.\u000a			 *\u000a			 *		if ( CKEDITOR.env.mobile )\u000a			 *			alert( 'I\u005c'm running with CKEditor today!' );\u000a			 *\u000a			 * @property {Boolean}\u000a			 */\u000a			mobile: ( agent.indexOf( 'mobile' ) > -1 ),\u000a\u000a			/**\u000a			 * Indicates that CKEditor is running on Apple iPhone/iPad/iPod devices.\u000a			 *\u000a			 *		if ( CKEDITOR.env.iOS )\u000a			 *			alert( 'I like little apples!' );\u000a			 *\u000a			 * @property {Boolean}\u000a			 */\u000a			iOS: /(ipad|iphone|ipod)/.test( agent ),\u000a\u000a			/**\u000a			 * Indicates that the browser has a custom domain enabled. This has\u000a			 * been set with `document.domain`.\u000a			 *\u000a			 *		if ( CKEDITOR.env.isCustomDomain() )\u000a			 *			alert( 'I\u005c'm in a custom domain!' );\u000a			 *\u000a			 * @returns {Boolean} `true` if a custom domain is enabled.\u000a			 * @deprecated\u000a			 */\u000a			isCustomDomain: function() {\u000a				if ( !this.ie )\u000a					return false;\u000a\u000a				var domain = document.domain,\u000a					hostname = window.location.hostname;\u000a\u000a				return domain != hostname && domain != ( '[' + hostname + ']' ); // IPv6 IP support (#5434)\u000a			},\u000a\u000a			/**\u000a			 * Indicates that the page is running under an encrypted connection.\u000a			 *\u000a			 *		if ( CKEDITOR.env.secure )\u000a			 *			alert( 'I\u005c'm on SSL!' );\u000a			 *\u000a			 * @returns {Boolean} `true` if the page has an encrypted connection.\u000a			 */\u000a			secure: location.protocol == 'https:'\u000a		};\u000a\u000a		/**\u000a		 * Indicates that CKEditor is running in a Gecko-based browser, like\u000a		 * Firefox.\u000a		 *\u000a		 *		if ( CKEDITOR.env.gecko )\u000a		 *			alert( 'I\u005c'm riding a gecko!' );\u000a		 *\u000a		 * @property {Boolean}\u000a		 */\u000a		env.gecko = ( navigator.product == 'Gecko' && !env.webkit && !env.ie );\u000a\u000a		/**\u000a		 * Indicates that CKEditor is running in Chrome.\u000a		 *\u000a		 *		if ( CKEDITOR.env.chrome )\u000a		 *			alert( 'I\u005c'm running in Chrome!' );\u000a		 *\u000a		 * @property {Boolean} chrome\u000a		 */\u000a\u000a		/**\u000a		 * Indicates that CKEditor is running in Safari (including the mobile version).\u000a		 *\u000a		 *		if ( CKEDITOR.env.safari )\u000a		 *			alert( 'I\u005c'm on Safari!' );\u000a		 *\u000a		 * @property {Boolean} safari\u000a		 */\u000a		if ( env.webkit ) {\u000a			if ( agent.indexOf( 'chrome' ) > -1 )\u000a				env.chrome = true;\u000a			else\u000a				env.safari = true;\u000a		}\u000a\u000a		var version = 0;\u000a\u000a		// Internet Explorer 6.0+\u000a		if ( env.ie ) {\u000a			// We use env.version for feature detection, so set it properly.\u000a			if ( env.quirks || !document.documentMode )\u000a				version = parseFloat( agent.match( /msie (\u005cd+)/ )[ 1 ] );\u000a			else\u000a				version = document.documentMode;\u000a\u000a			// Deprecated features available just for backwards compatibility.\u000a			env.ie9Compat = version == 9;\u000a			env.ie8Compat = version == 8;\u000a			env.ie7Compat = version == 7;\u000a			env.ie6Compat = version < 7 || env.quirks;\u000a\u000a			/**\u000a			 * Indicates that CKEditor is running in an IE6-like environment, which\u000a			 * includes IE6 itself as well as IE7, IE8 and IE9 in Quirks Mode.\u000a			 *\u000a			 * @deprecated\u000a			 * @property {Boolean} ie6Compat\u000a			 */\u000a\u000a			/**\u000a			 * Indicates that CKEditor is running in an IE7-like environment, which\u000a			 * includes IE7 itself and IE8's IE7 Document Mode.\u000a			 *\u000a			 * @deprecated\u000a			 * @property {Boolean} ie7Compat\u000a			 */\u000a\u000a			/**\u000a			 * Indicates that CKEditor is running in Internet Explorer 8 on\u000a			 * Standards Mode.\u000a			 *\u000a			 * @deprecated\u000a			 * @property {Boolean} ie8Compat\u000a			 */\u000a\u000a			/**\u000a			 * Indicates that CKEditor is running in Internet Explorer 9 on\u000a			 * Standards Mode.\u000a			 *\u000a			 * @deprecated\u000a			 * @property {Boolean} ie9Compat\u000a			 */\u000a		}\u000a\u000a		// Gecko.\u000a		if ( env.gecko ) {\u000a			var geckoRelease = agent.match( /rv:([\u005cd\u005c.]+)/ );\u000a			if ( geckoRelease ) {\u000a				geckoRelease = geckoRelease[ 1 ].split( '.' );\u000a				version = geckoRelease[ 0 ] * 10000 + ( geckoRelease[ 1 ] || 0 ) * 100 + ( geckoRelease[ 2 ] || 0 ) * 1;\u000a			}\u000a		}\u000a\u000a		// Adobe AIR 1.0+\u000a		// Checked before Safari because AIR have the WebKit rich text editor\u000a		// features from Safari 3.0.4, but the version reported is 420.\u000a		if ( env.air )\u000a			version = parseFloat( agent.match( / adobeair\u005c/(\u005cd+)/ )[ 1 ] );\u000a\u000a		// WebKit 522+ (Safari 3+)\u000a		if ( env.webkit )\u000a			version = parseFloat( agent.match( / applewebkit\u005c/(\u005cd+)/ )[ 1 ] );\u000a\u000a		/**\u000a		 * Contains the browser version.\u000a		 *\u000a		 * For Gecko-based browsers (like Firefox) it contains the revision\u000a		 * number with first three parts concatenated with a padding zero\u000a		 * (e.g. for revision 1.9.0.2 we have 10900).\u000a		 *\u000a		 * For WebKit-based browsers (like Safari and Chrome) it contains the\u000a		 * WebKit build version (e.g. 522).\u000a		 *\u000a		 * For IE browsers, it matches the "Document Mode".\u000a		 *\u000a		 *		if ( CKEDITOR.env.ie && CKEDITOR.env.version <= 6 )\u000a		 *			alert( 'Ouch!' );\u000a		 *\u000a		 * @property {Number}\u000a		 */\u000a		env.version = version;\u000a\u000a		/**\u000a		 * Indicates that CKEditor is running in a compatible browser.\u000a		 *\u000a		 *		if ( CKEDITOR.env.isCompatible )\u000a		 *			alert( 'Your browser is pretty cool!' );\u000a		 *\u000a		 * See the [Enabling CKEditor in Unsupported Environments](#!/guide/dev_unsupported_environments)\u000a		 * article for more information.\u000a		 *\u000a		 * @property {Boolean}\u000a		 */\u000a		env.isCompatible =\u000a			// White list of mobile devices that CKEditor supports.\u000a			env.iOS && version >= 534 ||\u000a			!env.mobile && (\u000a				( env.ie && version > 6 ) ||\u000a				( env.gecko && version >= 20000 ) ||\u000a				( env.air && version >= 1 ) ||\u000a				( env.webkit && version >= 522 ) ||\u000a				false\u000a			);\u000a\u000a		/**\u000a		 * Indicates that CKEditor is running in the HiDPI environment.\u000a		 *\u000a		 *		if ( CKEDITOR.env.hidpi )\u000a		 *			alert( 'You are using a screen with high pixel density.' );\u000a		 *\u000a		 * @property {Boolean}\u000a		 */\u000a		env.hidpi = window.devicePixelRatio >= 2;\u000a\u000a		/**\u000a		 * Indicates that CKEditor is running in a browser which uses a bogus\u000a		 * `<br>` filler in order to correctly display caret in empty blocks.\u000a		 *\u000a		 * @since 4.3\u000a		 * @property {Boolean}\u000a		 */\u000a		env.needsBrFiller = env.gecko || env.webkit || ( env.ie && version > 10 );\u000a\u000a		/**\u000a		 * Indicates that CKEditor is running in a browser which needs a\u000a		 * non-breaking space filler in order to correctly display caret in empty blocks.\u000a		 *\u000a		 * @since 4.3\u000a		 * @property {Boolean}\u000a		 */\u000a		env.needsNbspFiller = env.ie && version < 11;\u000a\u000a		/**\u000a		 * A CSS class that denotes the browser where CKEditor runs and is appended\u000a		 * to the HTML element that contains the editor. It makes it easier to apply\u000a		 * browser-specific styles to editor instances.\u000a		 *\u000a		 *		myDiv.className = CKEDITOR.env.cssClass;\u000a		 *\u000a		 * @property {String}\u000a		 */\u000a		env.cssClass = 'cke_browser_' + ( env.ie ? 'ie' : env.gecko ? 'gecko' : env.webkit ? 'webkit' : 'unknown' );\u000a\u000a		if ( env.quirks )\u000a			env.cssClass += ' cke_browser_quirks';\u000a\u000a		if ( env.ie )\u000a			env.cssClass += ' cke_browser_ie' + ( env.quirks ? '6 cke_browser_iequirks' : env.version );\u000a\u000a		if ( env.air )\u000a			env.cssClass += ' cke_browser_air';\u000a\u000a		if ( env.iOS )\u000a			env.cssClass += ' cke_browser_ios';\u000a\u000a		if ( env.hidpi )\u000a			env.cssClass += ' cke_hidpi';\u000a\u000a		return env;\u000a	} )();\u000a}\u000a\u000a// PACKAGER_RENAME( CKEDITOR.env )\u000a// PACKAGER_RENAME( CKEDITOR.env.ie )\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Contains the second part of the {@link CKEDITOR} object\u000a *		definition, which defines the basic editor features to be available in\u000a *		the root ckeditor_basic.js file.\u000a */\u000a\u000aif ( CKEDITOR.status == 'unloaded' ) {\u000a	( function() {\u000a		CKEDITOR.event.implementOn( CKEDITOR );\u000a\u000a		/**\u000a		 * Forces the full CKEditor core code, in the case only the basic code has been\u000a		 * loaded (`ckeditor_basic.js`). This method self-destroys (becomes undefined) in\u000a		 * the first call or as soon as the full code is available.\u000a		 *\u000a		 *		// Check if the full core code has been loaded and load it.\u000a		 *		if ( CKEDITOR.loadFullCore )\u000a		 *			CKEDITOR.loadFullCore();\u000a		 *\u000a		 * @member CKEDITOR\u000a		 */\u000a		CKEDITOR.loadFullCore = function() {\u000a			// If the basic code is not ready, just mark it to be loaded.\u000a			if ( CKEDITOR.status != 'basic_ready' ) {\u000a				CKEDITOR.loadFullCore._load = 1;\u000a				return;\u000a			}\u000a\u000a			// Destroy this function.\u000a			delete CKEDITOR.loadFullCore;\u000a\u000a			// Append the script to the head.\u000a			var script = document.createElement( 'script' );\u000a			script.type = 'text/javascript';\u000a			script.src = CKEDITOR.basePath + 'ckeditor.js';\u000a			script.src = CKEDITOR.basePath + 'ckeditor_source.js'; // %REMOVE_LINE%\u000a\u000a			document.getElementsByTagName( 'head' )[ 0 ].appendChild( script );\u000a		};\u000a\u000a		/**\u000a		 * The time to wait (in seconds) to load the full editor code after the\u000a		 * page load, if the "ckeditor_basic" file is used. If set to zero, the\u000a		 * editor is loaded on demand, as soon as an instance is created.\u000a		 *\u000a		 * This value must be set on the page before the page load completion.\u000a		 *\u000a		 *		// Loads the full source after five seconds.\u000a		 *		CKEDITOR.loadFullCoreTimeout = 5;\u000a		 *\u000a		 * @property\u000a		 * @member CKEDITOR\u000a		 */\u000a		CKEDITOR.loadFullCoreTimeout = 0;\u000a\u000a		// Documented at ckeditor.js.\u000a		CKEDITOR.add = function( editor ) {\u000a			// For now, just put the editor in the pending list. It will be\u000a			// processed as soon as the full code gets loaded.\u000a			var pending = this._.pending || ( this._.pending = [] );\u000a			pending.push( editor );\u000a		};\u000a\u000a		( function() {\u000a			var onload = function() {\u000a					var loadFullCore = CKEDITOR.loadFullCore,\u000a						loadFullCoreTimeout = CKEDITOR.loadFullCoreTimeout;\u000a\u000a					if ( !loadFullCore )\u000a						return;\u000a\u000a					CKEDITOR.status = 'basic_ready';\u000a\u000a					if ( loadFullCore && loadFullCore._load )\u000a						loadFullCore();\u000a					else if ( loadFullCoreTimeout ) {\u000a						setTimeout( function() {\u000a							if ( CKEDITOR.loadFullCore )\u000a								CKEDITOR.loadFullCore();\u000a						}, loadFullCoreTimeout * 1000 );\u000a					}\u000a				};\u000a\u000a			CKEDITOR.domReady( onload );\u000a		} )();\u000a\u000a		CKEDITOR.status = 'basic_loaded';\u000a	} )();\u000a}\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.dom} object, which contains DOM\u000a *		manipulation objects and function.\u000a */\u000a\u000aCKEDITOR.dom = {};\u000a\u000a// PACKAGER_RENAME( CKEDITOR.dom )\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.tools} object that contains\u000a *		utility functions.\u000a */\u000a\u000a( function() {\u000a	var functions = [],\u000a		cssVendorPrefix =\u000a			CKEDITOR.env.gecko ? '-moz-' :\u000a			CKEDITOR.env.webkit ? '-webkit-' :\u000a			CKEDITOR.env.ie ? '-ms-' :\u000a			'',\u000a		ampRegex = /&/g,\u000a		gtRegex = />/g,\u000a		ltRegex = /</g,\u000a		quoteRegex = /"/g,\u000a\u000a		ampEscRegex = /&amp;/g,\u000a		gtEscRegex = /&gt;/g,\u000a		ltEscRegex = /&lt;/g,\u000a		quoteEscRegex = /&quot;/g;\u000a\u000a	CKEDITOR.on( 'reset', function() {\u000a		functions = [];\u000a	} );\u000a\u000a	/**\u000a	 * Utility functions.\u000a	 *\u000a	 * @class\u000a	 * @singleton\u000a	 */\u000a	CKEDITOR.tools = {\u000a		/**\u000a		 * Compares the elements of two arrays.\u000a		 *\u000a		 *		var a = [ 1, 'a', 3 ];\u000a		 *		var b = [ 1, 3, 'a' ];\u000a		 *		var c = [ 1, 'a', 3 ];\u000a		 *		var d = [ 1, 'a', 3, 4 ];\u000a		 *\u000a		 *		alert( CKEDITOR.tools.arrayCompare( a, b ) );  // false\u000a		 *		alert( CKEDITOR.tools.arrayCompare( a, c ) );  // true\u000a		 *		alert( CKEDITOR.tools.arrayCompare( a, d ) );  // false\u000a		 *\u000a		 * @param {Array} arrayA An array to be compared.\u000a		 * @param {Array} arrayB The other array to be compared.\u000a		 * @returns {Boolean} `true` if the arrays have the same length and\u000a		 * their elements match.\u000a		 */\u000a		arrayCompare: function( arrayA, arrayB ) {\u000a			if ( !arrayA && !arrayB )\u000a				return true;\u000a\u000a			if ( !arrayA || !arrayB || arrayA.length != arrayB.length )\u000a				return false;\u000a\u000a			for ( var i = 0; i < arrayA.length; i++ ) {\u000a				if ( arrayA[ i ] != arrayB[ i ] )\u000a					return false;\u000a			}\u000a\u000a			return true;\u000a		},\u000a\u000a		/**\u000a		 * Creates a deep copy of an object.\u000a		 *\u000a		 * **Note**: Recursive references are not supported.\u000a		 *\u000a		 *		var obj = {\u000a		 *			name: 'John',\u000a		 *			cars: {\u000a		 *				Mercedes: { color: 'blue' },\u000a		 *				Porsche: { color: 'red' }\u000a		 *			}\u000a		 *		};\u000a		 *		var clone = CKEDITOR.tools.clone( obj );\u000a		 *		clone.name = 'Paul';\u000a		 *		clone.cars.Porsche.color = 'silver';\u000a		 *\u000a		 *		alert( obj.name );					// 'John'\u000a		 *		alert( clone.name );				// 'Paul'\u000a		 *		alert( obj.cars.Porsche.color );	// 'red'\u000a		 *		alert( clone.cars.Porsche.color );	// 'silver'\u000a		 *\u000a		 * @param {Object} object The object to be cloned.\u000a		 * @returns {Object} The object clone.\u000a		 */\u000a		clone: function( obj ) {\u000a			var clone;\u000a\u000a			// Array.\u000a			if ( obj && ( obj instanceof Array ) ) {\u000a				clone = [];\u000a\u000a				for ( var i = 0; i < obj.length; i++ )\u000a					clone[ i ] = CKEDITOR.tools.clone( obj[ i ] );\u000a\u000a				return clone;\u000a			}\u000a\u000a			// "Static" types.\u000a			if ( obj === null || ( typeof( obj ) != 'object' ) || ( obj instanceof String ) || ( obj instanceof Number ) || ( obj instanceof Boolean ) || ( obj instanceof Date ) || ( obj instanceof RegExp ) )\u000a				return obj;\u000a\u000a			// DOM objects and window.\u000a			if ( obj.nodeType || obj.window === obj )\u000a				return obj;\u000a\u000a			// Objects.\u000a			clone = new obj.constructor();\u000a\u000a			for ( var propertyName in obj ) {\u000a				var property = obj[ propertyName ];\u000a				clone[ propertyName ] = CKEDITOR.tools.clone( property );\u000a			}\u000a\u000a			return clone;\u000a		},\u000a\u000a		/**\u000a		 * Turns the first letter of a string to upper-case.\u000a		 *\u000a		 * @param {String} str\u000a		 * @param {Boolean} [keepCase] Keep the case of 2nd to last letter.\u000a		 * @returns {String}\u000a		 */\u000a		capitalize: function( str, keepCase ) {\u000a			return str.charAt( 0 ).toUpperCase() + ( keepCase ? str.slice( 1 ) : str.slice( 1 ).toLowerCase() );\u000a		},\u000a\u000a		/**\u000a		 * Copies the properties from one object to another. By default, properties\u000a		 * already present in the target object **are not** overwritten.\u000a		 *\u000a		 *		// Create the sample object.\u000a		 *		var myObject = {\u000a		 *			prop1: true\u000a		 *		};\u000a		 *\u000a		 *		// Extend the above object with two properties.\u000a		 *		CKEDITOR.tools.extend( myObject, {\u000a		 *			prop2: true,\u000a		 *			prop3: true\u000a		 *		} );\u000a		 *\u000a		 *		// Alert 'prop1', 'prop2' and 'prop3'.\u000a		 *		for ( var p in myObject )\u000a		 *			alert( p );\u000a		 *\u000a		 * @param {Object} target The object to be extended.\u000a		 * @param {Object...} source The object(s) from properties will be\u000a		 * copied. Any number of objects can be passed to this function.\u000a		 * @param {Boolean} [overwrite] If `true` is specified, it indicates that\u000a		 * properties already present in the target object could be\u000a		 * overwritten by subsequent objects.\u000a		 * @param {Object} [properties] Only properties within the specified names\u000a		 * list will be received from the source object.\u000a		 * @returns {Object} The extended object (target).\u000a		 */\u000a		extend: function( target ) {\u000a			var argsLength = arguments.length,\u000a				overwrite, propertiesList;\u000a\u000a			if ( typeof( overwrite = arguments[ argsLength - 1 ] ) == 'boolean' )\u000a				argsLength--;\u000a			else if ( typeof( overwrite = arguments[ argsLength - 2 ] ) == 'boolean' ) {\u000a				propertiesList = arguments[ argsLength - 1 ];\u000a				argsLength -= 2;\u000a			}\u000a			for ( var i = 1; i < argsLength; i++ ) {\u000a				var source = arguments[ i ];\u000a				for ( var propertyName in source ) {\u000a					// Only copy existed fields if in overwrite mode.\u000a					if ( overwrite === true || target[ propertyName ] == null ) {\u000a						// Only copy  specified fields if list is provided.\u000a						if ( !propertiesList || ( propertyName in propertiesList ) )\u000a							target[ propertyName ] = source[ propertyName ];\u000a\u000a					}\u000a				}\u000a			}\u000a\u000a			return target;\u000a		},\u000a\u000a		/**\u000a		 * Creates an object which is an instance of a class whose prototype is a\u000a		 * predefined object. All properties defined in the source object are\u000a		 * automatically inherited by the resulting object, including future\u000a		 * changes to it.\u000a		 *\u000a		 * @param {Object} source The source object to be used as the prototype for\u000a		 * the final object.\u000a		 * @returns {Object} The resulting copy.\u000a		 */\u000a		prototypedCopy: function( source ) {\u000a			var copy = function() {};\u000a			copy.prototype = source;\u000a			return new copy();\u000a		},\u000a\u000a		/**\u000a		 * Makes fast (shallow) copy of an object.\u000a		 * This method is faster than {@link #clone} which does\u000a		 * a deep copy of an object (including arrays).\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {Object} source The object to be copied.\u000a		 * @returns {Object} Copy of `source`.\u000a		 */\u000a		copy: function( source ) {\u000a			var obj = {},\u000a				name;\u000a\u000a			for ( name in source )\u000a				obj[ name ] = source[ name ];\u000a\u000a			return obj;\u000a		},\u000a\u000a		/**\u000a		 * Checks if an object is an Array.\u000a		 *\u000a		 *		alert( CKEDITOR.tools.isArray( [] ) );		// true\u000a		 *		alert( CKEDITOR.tools.isArray( 'Test' ) );	// false\u000a		 *\u000a		 * @param {Object} object The object to be checked.\u000a		 * @returns {Boolean} `true` if the object is an Array, otherwise `false`.\u000a		 */\u000a		isArray: function( object ) {\u000a			return Object.prototype.toString.call( object ) == '[object Array]';\u000a		},\u000a\u000a		/**\u000a		 * Whether the object contains no properties of its own.\u000a		 *\u000a		 * @param object\u000a		 * @returns {Boolean}\u000a		 */\u000a		isEmpty: function( object ) {\u000a			for ( var i in object ) {\u000a				if ( object.hasOwnProperty( i ) )\u000a					return false;\u000a			}\u000a			return true;\u000a		},\u000a\u000a		/**\u000a		 * Generates an object or a string containing vendor-specific and vendor-free CSS properties.\u000a		 *\u000a		 *		CKEDITOR.tools.cssVendorPrefix( 'border-radius', '0', true );\u000a		 *		// On Firefox: '-moz-border-radius:0;border-radius:0'\u000a		 *		// On Chrome: '-webkit-border-radius:0;border-radius:0'\u000a		 *\u000a		 * @param {String} property The CSS property name.\u000a		 * @param {String} value The CSS value.\u000a		 * @param {Boolean} [asString=false] If `true`, then the returned value will be a CSS string.\u000a		 * @returns {Object/String} The object containing CSS properties or its stringified version.\u000a		 */\u000a		cssVendorPrefix: function( property, value, asString ) {\u000a			if ( asString )\u000a				return cssVendorPrefix + property + ':' + value + ';' + property + ':' + value;\u000a\u000a			var ret = {};\u000a			ret[ property ] = value;\u000a			ret[ cssVendorPrefix + property ] = value;\u000a\u000a			return ret;\u000a		},\u000a\u000a		/**\u000a		 * Transforms a CSS property name to its relative DOM style name.\u000a		 *\u000a		 *		alert( CKEDITOR.tools.cssStyleToDomStyle( 'background-color' ) );	// 'backgroundColor'\u000a		 *		alert( CKEDITOR.tools.cssStyleToDomStyle( 'float' ) );				// 'cssFloat'\u000a		 *\u000a		 * @method\u000a		 * @param {String} cssName The CSS property name.\u000a		 * @returns {String} The transformed name.\u000a		 */\u000a		cssStyleToDomStyle: ( function() {\u000a			var test = document.createElement( 'div' ).style;\u000a\u000a			var cssFloat = ( typeof test.cssFloat != 'undefined' ) ? 'cssFloat' : ( typeof test.styleFloat != 'undefined' ) ? 'styleFloat' : 'float';\u000a\u000a			return function( cssName ) {\u000a				if ( cssName == 'float' )\u000a					return cssFloat;\u000a				else {\u000a					return cssName.replace( /-./g, function( match ) {\u000a						return match.substr( 1 ).toUpperCase();\u000a					} );\u000a				}\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Builds a HTML snippet from a set of `<style>/<link>`.\u000a		 *\u000a		 * @param {String/Array} css Each of which are URLs (absolute) of a CSS file or\u000a		 * a trunk of style text.\u000a		 * @returns {String}\u000a		 */\u000a		buildStyleHtml: function( css ) {\u000a			css = [].concat( css );\u000a			var item,\u000a				retval = [];\u000a			for ( var i = 0; i < css.length; i++ ) {\u000a				if ( ( item = css[ i ] ) ) {\u000a					// Is CSS style text ?\u000a					if ( /@import|[{}]/.test( item ) )\u000a						retval.push( '<style>' + item + '</style>' );\u000a					else\u000a						retval.push( '<link type="text/css" rel=stylesheet href="' + item + '">' );\u000a				}\u000a			}\u000a			return retval.join( '' );\u000a		},\u000a\u000a		/**\u000a		 * Replaces special HTML characters in a string with their relative HTML\u000a		 * entity values.\u000a		 *\u000a		 *		alert( CKEDITOR.tools.htmlEncode( 'A > B & C < D' ) ); // 'A &gt; B &amp; C &lt; D'\u000a		 *\u000a		 * @param {String} text The string to be encoded.\u000a		 * @returns {String} The encoded string.\u000a		 */\u000a		htmlEncode: function( text ) {\u000a			return String( text ).replace( ampRegex, '&amp;' ).replace( gtRegex, '&gt;' ).replace( ltRegex, '&lt;' );\u000a		},\u000a\u000a		/**\u000a		 * Decodes HTML entities.\u000a		 *\u000a		 *		alert( CKEDITOR.tools.htmlDecode( '&lt;a &amp; b &gt;' ) ); // '<a & b >'\u000a		 *\u000a		 * @param {String} The string to be decoded.\u000a		 * @returns {String} The decoded string.\u000a		 */\u000a		htmlDecode: function( text ) {\u000a			return text.replace( ampEscRegex, '&' ).replace( gtEscRegex, '>' ).replace( ltEscRegex, '<' );\u000a		},\u000a\u000a		/**\u000a		 * Replaces special HTML characters in HTMLElement attribute with their relative HTML entity values.\u000a		 *\u000a		 *		alert( CKEDITOR.tools.htmlEncodeAttr( '<a " b >' ) ); // '&lt;a &quot; b &gt;'\u000a		 *\u000a		 * @param {String} The attribute value to be encoded.\u000a		 * @returns {String} The encoded value.\u000a		 */\u000a		htmlEncodeAttr: function( text ) {\u000a			return text.replace( quoteRegex, '&quot;' ).replace( ltRegex, '&lt;' ).replace( gtRegex, '&gt;' );\u000a		},\u000a\u000a		/**\u000a		 * Replace HTML entities previously encoded by\u000a		 * {@link #htmlEncodeAttr htmlEncodeAttr} back to their plain character\u000a		 * representation.\u000a		 *\u000a		 *		alert( CKEDITOR.tools.htmlDecodeAttr( '&lt;a &quot; b&gt;' ) ); // '<a " b>'\u000a		 *\u000a		 * @param {String} text The text to be decoded.\u000a		 * @returns {String} The decoded text.\u000a		 */\u000a		htmlDecodeAttr: function( text ) {\u000a			return text.replace( quoteEscRegex, '"' ).replace( ltEscRegex, '<' ).replace( gtEscRegex, '>' );\u000a		},\u000a\u000a		/**\u000a		 * Gets a unique number for this CKEDITOR execution session. It returns\u000a		 * consecutive numbers starting from 1.\u000a		 *\u000a		 *		alert( CKEDITOR.tools.getNextNumber() ); // (e.g.) 1\u000a		 *		alert( CKEDITOR.tools.getNextNumber() ); // 2\u000a		 *\u000a		 * @method\u000a		 * @returns {Number} A unique number.\u000a		 */\u000a		getNextNumber: ( function() {\u000a			var last = 0;\u000a			return function() {\u000a				return ++last;\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Gets a unique ID for CKEditor interface elements. It returns a\u000a		 * string with the "cke_" prefix and a consecutive number.\u000a		 *\u000a		 *		alert( CKEDITOR.tools.getNextId() ); // (e.g.) 'cke_1'\u000a		 *		alert( CKEDITOR.tools.getNextId() ); // 'cke_2'\u000a		 *\u000a		 * @returns {String} A unique ID.\u000a		 */\u000a		getNextId: function() {\u000a			return 'cke_' + this.getNextNumber();\u000a		},\u000a\u000a		/**\u000a		 * Creates a function override.\u000a		 *\u000a		 *		var obj = {\u000a		 *			myFunction: function( name ) {\u000a		 *				alert( 'Name: ' + name );\u000a		 *			}\u000a		 *		};\u000a		 *\u000a		 *		obj.myFunction = CKEDITOR.tools.override( obj.myFunction, function( myFunctionOriginal ) {\u000a		 *			return function( name ) {\u000a		 *				alert( 'Overriden name: ' + name );\u000a		 *				myFunctionOriginal.call( this, name );\u000a		 *			};\u000a		 *		} );\u000a		 *\u000a		 * @param {Function} originalFunction The function to be overridden.\u000a		 * @param {Function} functionBuilder A function that returns the new\u000a		 * function. The original function reference will be passed to this function.\u000a		 * @returns {Function} The new function.\u000a		 */\u000a		override: function( originalFunction, functionBuilder ) {\u000a			var newFn = functionBuilder( originalFunction );\u000a			newFn.prototype = originalFunction.prototype;\u000a			return newFn;\u000a		},\u000a\u000a		/**\u000a		 * Executes a function after specified delay.\u000a		 *\u000a		 *		CKEDITOR.tools.setTimeout( function() {\u000a		 *			alert( 'Executed after 2 seconds' );\u000a		 *		}, 2000 );\u000a		 *\u000a		 * @param {Function} func The function to be executed.\u000a		 * @param {Number} [milliseconds=0] The amount of time (in millisecods) to wait\u000a		 * to fire the function execution.\u000a		 * @param {Object} [scope=window] The object to store the function execution scope\u000a		 * (the `this` object).\u000a		 * @param {Object/Array} [args] A single object, or an array of objects, to\u000a		 * pass as argument to the function.\u000a		 * @param {Object} [ownerWindow=window] The window that will be used to set the\u000a		 * timeout.\u000a		 * @returns {Object} A value that can be used to cancel the function execution.\u000a		 */\u000a		setTimeout: function( func, milliseconds, scope, args, ownerWindow ) {\u000a			if ( !ownerWindow )\u000a				ownerWindow = window;\u000a\u000a			if ( !scope )\u000a				scope = ownerWindow;\u000a\u000a			return ownerWindow.setTimeout( function() {\u000a				if ( args )\u000a					func.apply( scope, [].concat( args ) );\u000a				else\u000a					func.apply( scope );\u000a			}, milliseconds || 0 );\u000a		},\u000a\u000a		/**\u000a		 * Removes spaces from the start and the end of a string. The following\u000a		 * characters are removed: space, tab, line break, line feed.\u000a		 *\u000a		 *		alert( CKEDITOR.tools.trim( '  example ' ); // 'example'\u000a		 *\u000a		 * @method\u000a		 * @param {String} str The text from which the spaces will be removed.\u000a		 * @returns {String} The modified string without the boundary spaces.\u000a		 */\u000a		trim: ( function() {\u000a			// We are not using \u005cs because we don't want "non-breaking spaces" to be caught.\u000a			var trimRegex = /(?:^[ \u005ct\u005cn\u005cr]+)|(?:[ \u005ct\u005cn\u005cr]+$)/g;\u000a			return function( str ) {\u000a				return str.replace( trimRegex, '' );\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Removes spaces from the start (left) of a string. The following\u000a		 * characters are removed: space, tab, line break, line feed.\u000a		 *\u000a		 *		alert( CKEDITOR.tools.ltrim( '  example ' ); // 'example '\u000a		 *\u000a		 * @method\u000a		 * @param {String} str The text from which the spaces will be removed.\u000a		 * @returns {String} The modified string excluding the removed spaces.\u000a		 */\u000a		ltrim: ( function() {\u000a			// We are not using \u005cs because we don't want "non-breaking spaces" to be caught.\u000a			var trimRegex = /^[ \u005ct\u005cn\u005cr]+/g;\u000a			return function( str ) {\u000a				return str.replace( trimRegex, '' );\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Removes spaces from the end (right) of a string. The following\u000a		 * characters are removed: space, tab, line break, line feed.\u000a		 *\u000a		 *		alert( CKEDITOR.tools.ltrim( '  example ' ); // '  example'\u000a		 *\u000a		 * @method\u000a		 * @param {String} str The text from which spaces will be removed.\u000a		 * @returns {String} The modified string excluding the removed spaces.\u000a		 */\u000a		rtrim: ( function() {\u000a			// We are not using \u005cs because we don't want "non-breaking spaces" to be caught.\u000a			var trimRegex = /[ \u005ct\u005cn\u005cr]+$/g;\u000a			return function( str ) {\u000a				return str.replace( trimRegex, '' );\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Returns the index of an element in an array.\u000a		 *\u000a		 *		var letters = [ 'a', 'b', 0, 'c', false ];\u000a		 *		alert( CKEDITOR.tools.indexOf( letters, '0' ) );		// -1 because 0 !== '0'\u000a		 *		alert( CKEDITOR.tools.indexOf( letters, false ) );		// 4 because 0 !== false\u000a		 *\u000a		 * @param {Array} array The array to be searched.\u000a		 * @param {Object/Function} value The element to be found. This can be an\u000a		 * evaluation function which receives a single parameter call for\u000a		 * each entry in the array, returning `true` if the entry matches.\u000a		 * @returns {Number} The (zero-based) index of the first entry that matches\u000a		 * the entry, or `-1` if not found.\u000a		 */\u000a		indexOf: function( array, value ) {\u000a			if ( typeof value == 'function' ) {\u000a				for ( var i = 0, len = array.length; i < len; i++ ) {\u000a					if ( value( array[ i ] ) )\u000a						return i;\u000a				}\u000a			} else if ( array.indexOf )\u000a				return array.indexOf( value );\u000a			else {\u000a				for ( i = 0, len = array.length; i < len; i++ ) {\u000a					if ( array[ i ] === value )\u000a						return i;\u000a				}\u000a			}\u000a			return -1;\u000a		},\u000a\u000a		/**\u000a		 * Returns the index of an element in an array.\u000a		 *\u000a		 *		var obj = { prop: true };\u000a		 *		var letters = [ 'a', 'b', 0, obj, false ];\u000a		 *\u000a		 *		alert( CKEDITOR.tools.indexOf( letters, '0' ) ); // null\u000a		 *		alert( CKEDITOR.tools.indexOf( letters, function( value ) {\u000a		 *			// Return true when passed value has property 'prop'.\u000a		 *			return value && 'prop' in value;\u000a		 *		} ) );											// obj\u000a		 *\u000a		 * @param {Array} array The array to be searched.\u000a		 * @param {Object/Function} value The element to be found. Can be an\u000a		 * evaluation function which receives a single parameter call for\u000a		 * each entry in the array, returning `true` if the entry matches.\u000a		 * @returns Object The value that was found in an array.\u000a		 */\u000a		search: function( array, value ) {\u000a			var index = CKEDITOR.tools.indexOf( array, value );\u000a			return index >= 0 ? array[ index ] : null;\u000a		},\u000a\u000a		/**\u000a		 * Creates a function that will always execute in the context of a\u000a		 * specified object.\u000a		 *\u000a		 *		var obj = { text: 'My Object' };\u000a		 *\u000a		 *		function alertText() {\u000a		 *			alert( this.text );\u000a		 *		}\u000a		 *\u000a		 *		var newFunc = CKEDITOR.tools.bind( alertText, obj );\u000a		 *		newFunc(); // Alerts 'My Object'.\u000a		 *\u000a		 * @param {Function} func The function to be executed.\u000a		 * @param {Object} obj The object to which the execution context will be bound.\u000a		 * @returns {Function} The function that can be used to execute the\u000a		 * `func` function in the context of `obj`.\u000a		 */\u000a		bind: function( func, obj ) {\u000a			return function() {\u000a				return func.apply( obj, arguments );\u000a			};\u000a		},\u000a\u000a		/**\u000a		 * Class creation based on prototype inheritance which supports of the\u000a		 * following features:\u000a		 *\u000a		 * * Static fields\u000a		 * * Private fields\u000a		 * * Public (prototype) fields\u000a		 * * Chainable base class constructor\u000a		 *\u000a		 * @param {Object} definition The class definition object.\u000a		 * @returns {Function} A class-like JavaScript function.\u000a		 */\u000a		createClass: function( definition ) {\u000a			var $ = definition.$,\u000a				baseClass = definition.base,\u000a				privates = definition.privates || definition._,\u000a				proto = definition.proto,\u000a				statics = definition.statics;\u000a\u000a			// Create the constructor, if not present in the definition.\u000a			!$ && ( $ = function() {\u000a				baseClass && this.base.apply( this, arguments );\u000a			} );\u000a\u000a			if ( privates ) {\u000a				var originalConstructor = $;\u000a				$ = function() {\u000a					// Create (and get) the private namespace.\u000a					var _ = this._ || ( this._ = {} );\u000a\u000a					// Make some magic so "this" will refer to the main\u000a					// instance when coding private functions.\u000a					for ( var privateName in privates ) {\u000a						var priv = privates[ privateName ];\u000a\u000a						_[ privateName ] = ( typeof priv == 'function' ) ? CKEDITOR.tools.bind( priv, this ) : priv;\u000a					}\u000a\u000a					originalConstructor.apply( this, arguments );\u000a				};\u000a			}\u000a\u000a			if ( baseClass ) {\u000a				$.prototype = this.prototypedCopy( baseClass.prototype );\u000a				$.prototype.constructor = $;\u000a				// Super references.\u000a				$.base = baseClass;\u000a				$.baseProto = baseClass.prototype;\u000a				// Super constructor.\u000a				$.prototype.base = function() {\u000a					this.base = baseClass.prototype.base;\u000a					baseClass.apply( this, arguments );\u000a					this.base = arguments.callee;\u000a				};\u000a			}\u000a\u000a			if ( proto )\u000a				this.extend( $.prototype, proto, true );\u000a\u000a			if ( statics )\u000a				this.extend( $, statics, true );\u000a\u000a			return $;\u000a		},\u000a\u000a		/**\u000a		 * Creates a function reference that can be called later using\u000a		 * {@link #callFunction}. This approach is especially useful to\u000a		 * make DOM attribute function calls to JavaScript-defined functions.\u000a		 *\u000a		 *		var ref = CKEDITOR.tools.addFunction( function() {\u000a		 *			alert( 'Hello!');\u000a		 *		} );\u000a		 *		CKEDITOR.tools.callFunction( ref ); // 'Hello!'\u000a		 *\u000a		 * @param {Function} fn The function to be executed on call.\u000a		 * @param {Object} [scope] The object to have the context on `fn` execution.\u000a		 * @returns {Number} A unique reference to be used in conjuction with\u000a		 * {@link #callFunction}.\u000a		 */\u000a		addFunction: function( fn, scope ) {\u000a			return functions.push( function() {\u000a				return fn.apply( scope || this, arguments );\u000a			} ) - 1;\u000a		},\u000a\u000a		/**\u000a		 * Removes the function reference created with {@link #addFunction}.\u000a		 *\u000a		 * @param {Number} ref The function reference created with\u000a		 * {@link #addFunction}.\u000a		 */\u000a		removeFunction: function( ref ) {\u000a			functions[ ref ] = null;\u000a		},\u000a\u000a		/**\u000a		 * Executes a function based on the reference created with {@link #addFunction}.\u000a		 *\u000a		 *		var ref = CKEDITOR.tools.addFunction( function() {\u000a		 *			alert( 'Hello!');\u000a		 *		} );\u000a		 *		CKEDITOR.tools.callFunction( ref ); // 'Hello!'\u000a		 *\u000a		 * @param {Number} ref The function reference created with {@link #addFunction}.\u000a		 * @param {Mixed} params Any number of parameters to be passed to the executed function.\u000a		 * @returns {Mixed} The return value of the function.\u000a		 */\u000a		callFunction: function( ref ) {\u000a			var fn = functions[ ref ];\u000a			return fn && fn.apply( window, Array.prototype.slice.call( arguments, 1 ) );\u000a		},\u000a\u000a		/**\u000a		 * Appends the `px` length unit to the size value if it is missing.\u000a		 *\u000a		 *		var cssLength = CKEDITOR.tools.cssLength;\u000a		 *		cssLength( 42 );		// '42px'\u000a		 *		cssLength( '42' );		// '42px'\u000a		 *		cssLength( '42px' );	// '42px'\u000a		 *		cssLength( '42%' );		// '42%'\u000a		 *		cssLength( 'bold' );	// 'bold'\u000a		 *		cssLength( false );		// ''\u000a		 *		cssLength( NaN );		// ''\u000a		 *\u000a		 * @method\u000a		 * @param {Number/String/Boolean} length\u000a		 */\u000a		cssLength: ( function() {\u000a			var pixelRegex = /^-?\u005cd+\u005c.?\u005cd*px$/,\u000a				lengthTrimmed;\u000a\u000a			return function( length ) {\u000a				lengthTrimmed = CKEDITOR.tools.trim( length + '' ) + 'px';\u000a\u000a				if ( pixelRegex.test( lengthTrimmed ) )\u000a					return lengthTrimmed;\u000a				else\u000a					return length || '';\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Converts the specified CSS length value to the calculated pixel length inside this page.\u000a		 *\u000a		 * **Note:** Percentage-based value is left intact.\u000a		 *\u000a		 * @method\u000a		 * @param {String} cssLength CSS length value.\u000a		 */\u000a		convertToPx: ( function() {\u000a			var calculator;\u000a\u000a			return function( cssLength ) {\u000a				if ( !calculator ) {\u000a					calculator = CKEDITOR.dom.element.createFromHtml( '<div style="position:absolute;left:-9999px;' +\u000a						'top:-9999px;margin:0px;padding:0px;border:0px;"' +\u000a						'></div>', CKEDITOR.document );\u000a					CKEDITOR.document.getBody().append( calculator );\u000a				}\u000a\u000a				if ( !( /%$/ ).test( cssLength ) ) {\u000a					calculator.setStyle( 'width', cssLength );\u000a					return calculator.$.clientWidth;\u000a				}\u000a\u000a				return cssLength;\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * String specified by `str` repeats `times` times.\u000a		 *\u000a		 * @param {String} str\u000a		 * @param {Number} times\u000a		 * @returns {String}\u000a		 */\u000a		repeat: function( str, times ) {\u000a			return new Array( times + 1 ).join( str );\u000a		},\u000a\u000a		/**\u000a		 * Returns the first successfully executed return value of a function that\u000a		 * does not throw any exception.\u000a		 *\u000a		 * @param {Function...} fn\u000a		 * @returns {Mixed}\u000a		 */\u000a		tryThese: function() {\u000a			var returnValue;\u000a			for ( var i = 0, length = arguments.length; i < length; i++ ) {\u000a				var lambda = arguments[ i ];\u000a				try {\u000a					returnValue = lambda();\u000a					break;\u000a				} catch ( e ) {}\u000a			}\u000a			return returnValue;\u000a		},\u000a\u000a		/**\u000a		 * Generates a combined key from a series of params.\u000a		 *\u000a		 *		var key = CKEDITOR.tools.genKey( 'key1', 'key2', 'key3' );\u000a		 *		alert( key ); // 'key1-key2-key3'.\u000a		 *\u000a		 * @param {String} subKey One or more strings used as subkeys.\u000a		 * @returns {String}\u000a		 */\u000a		genKey: function() {\u000a			return Array.prototype.slice.call( arguments ).join( '-' );\u000a		},\u000a\u000a		/**\u000a		 * Creates a "deferred" function which will not run immediately,\u000a		 * but rather runs as soon as the interpreter\u2019s call stack is empty.\u000a		 * Behaves much like `window.setTimeout` with a delay.\u000a		 *\u000a		 * **Note:** The return value of the original function will be lost.\u000a		 *\u000a		 * @param {Function} fn The callee function.\u000a		 * @returns {Function} The new deferred function.\u000a		 */\u000a		defer: function( fn ) {\u000a			return function() {\u000a				var args = arguments,\u000a					self = this;\u000a				window.setTimeout( function() {\u000a					fn.apply( self, args );\u000a				}, 0 );\u000a			};\u000a		},\u000a\u000a		/**\u000a		 * Normalizes CSS data in order to avoid differences in the style attribute.\u000a		 *\u000a		 * @param {String} styleText The style data to be normalized.\u000a		 * @param {Boolean} [nativeNormalize=false] Parse the data using the browser.\u000a		 * @returns {String} The normalized value.\u000a		 */\u000a		normalizeCssText: function( styleText, nativeNormalize ) {\u000a			var props = [],\u000a				name,\u000a				parsedProps = CKEDITOR.tools.parseCssText( styleText, true, nativeNormalize );\u000a\u000a			for ( name in parsedProps )\u000a				props.push( name + ':' + parsedProps[ name ] );\u000a\u000a			props.sort();\u000a\u000a			return props.length ? ( props.join( ';' ) + ';' ) : '';\u000a		},\u000a\u000a		/**\u000a		 * Finds and converts `rgb(x,x,x)` color definition to hexadecimal notation.\u000a		 *\u000a		 * @param {String} styleText The style data (or just a string containing RGB colors) to be converted.\u000a		 * @returns {String} The style data with RGB colors converted to hexadecimal equivalents.\u000a		 */\u000a		convertRgbToHex: function( styleText ) {\u000a			return styleText.replace( /(?:rgb\u005c(\u005cs*(\u005cd+)\u005cs*,\u005cs*(\u005cd+)\u005cs*,\u005cs*(\u005cd+)\u005cs*\u005c))/gi, function( match, red, green, blue ) {\u000a				var color = [ red, green, blue ];\u000a				// Add padding zeros if the hex value is less than 0x10.\u000a				for ( var i = 0; i < 3; i++ )\u000a					color[ i ] = ( '0' + parseInt( color[ i ], 10 ).toString( 16 ) ).slice( -2 );\u000a				return '#' + color.join( '' );\u000a			} );\u000a		},\u000a\u000a		/**\u000a		 * Turns inline style text properties into one hash.\u000a		 *\u000a		 * @param {String} styleText The style data to be parsed.\u000a		 * @param {Boolean} [normalize=false] Normalize properties and values\u000a		 * (e.g. trim spaces, convert to lower case).\u000a		 * @param {Boolean} [nativeNormalize=false] Parse the data using the browser.\u000a		 * @returns {Object} The object containing parsed properties.\u000a		 */\u000a		parseCssText: function( styleText, normalize, nativeNormalize ) {\u000a			var retval = {};\u000a\u000a			if ( nativeNormalize ) {\u000a				// Injects the style in a temporary span object, so the browser parses it,\u000a				// retrieving its final format.\u000a				var temp = new CKEDITOR.dom.element( 'span' );\u000a				temp.setAttribute( 'style', styleText );\u000a				styleText = CKEDITOR.tools.convertRgbToHex( temp.getAttribute( 'style' ) || '' );\u000a			}\u000a\u000a			// IE will leave a single semicolon when failed to parse the style text. (#3891)\u000a			if ( !styleText || styleText == ';' )\u000a				return retval;\u000a\u000a			styleText.replace( /&quot;/g, '"' ).replace( /\u005cs*([^:;\u005cs]+)\u005cs*:\u005cs*([^;]+)\u005cs*(?=;|$)/g, function( match, name, value ) {\u000a				if ( normalize ) {\u000a					name = name.toLowerCase();\u000a					// Normalize font-family property, ignore quotes and being case insensitive. (#7322)\u000a					// http://www.w3.org/TR/css3-fonts/#font-family-the-font-family-property\u000a					if ( name == 'font-family' )\u000a						value = value.toLowerCase().replace( /["']/g, '' ).replace( /\u005cs*,\u005cs*/g, ',' );\u000a					value = CKEDITOR.tools.trim( value );\u000a				}\u000a\u000a				retval[ name ] = value;\u000a			} );\u000a			return retval;\u000a		},\u000a\u000a		/**\u000a		 * Serializes the `style name => value` hash to a style text.\u000a		 *\u000a		 *		var styleObj = CKEDITOR.tools.parseCssText( 'color: red; border: none' );\u000a		 *		console.log( styleObj.color ); // -> 'red'\u000a		 *		CKEDITOR.tools.writeCssText( styleObj ); // -> 'color:red; border:none'\u000a		 *		CKEDITOR.tools.writeCssText( styleObj, true ); // -> 'border:none; color:red'\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {Object} styles The object contaning style properties.\u000a		 * @param {Boolean} [sort] Whether to sort CSS properties.\u000a		 * @returns {String} The serialized style text.\u000a		 */\u000a		writeCssText: function( styles, sort ) {\u000a			var name,\u000a				stylesArr = [];\u000a\u000a			for ( name in styles )\u000a				stylesArr.push( name + ':' + styles[ name ] );\u000a\u000a			if ( sort )\u000a				stylesArr.sort();\u000a\u000a			return stylesArr.join( '; ' );\u000a		},\u000a\u000a		/**\u000a		 * Compares two objects.\u000a		 *\u000a		 * **Note:** This method performs shallow, non-strict comparison.\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {Object} left\u000a		 * @param {Object} right\u000a		 * @param {Boolean} [onlyLeft] Check only the properties that are present in the `left` object.\u000a		 * @returns {Boolean} Whether objects are identical.\u000a		 */\u000a		objectCompare: function( left, right, onlyLeft ) {\u000a			var name;\u000a\u000a			if ( !left && !right )\u000a				return true;\u000a			if ( !left || !right )\u000a				return false;\u000a\u000a			for ( name in left ) {\u000a				if ( left[ name ] != right[ name ] )\u000a					return false;\u000a\u000a			}\u000a\u000a			if ( !onlyLeft ) {\u000a				for ( name in right ) {\u000a					if ( left[ name ] != right[ name ] )\u000a						return false;\u000a				}\u000a			}\u000a\u000a			return true;\u000a		},\u000a\u000a		/**\u000a		 * Returns an array of passed object's keys.\u000a		 *\u000a		 *		console.log( CKEDITOR.tools.objectKeys( { foo: 1, bar: false } );\u000a		 *		// -> [ 'foo', 'bar' ]\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {Object} obj\u000a		 * @returns {Array} Object's keys.\u000a		 */\u000a		objectKeys: function( obj ) {\u000a			var keys = [];\u000a			for ( var i in obj )\u000a				keys.push( i );\u000a\u000a			return keys;\u000a		},\u000a\u000a		/**\u000a		 * Converts an array to an object by rewriting array items\u000a		 * to object properties.\u000a		 *\u000a		 *		var arr = [ 'foo', 'bar', 'foo' ];\u000a		 *		console.log( CKEDITOR.tools.convertArrayToObject( arr ) );\u000a		 *		// -> { foo: true, bar: true }\u000a		 *		console.log( CKEDITOR.tools.convertArrayToObject( arr, 1 ) );\u000a		 *		// -> { foo: 1, bar: 1 }\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {Array} arr The array to be converted to an object.\u000a		 * @param [fillWith=true] Set each property of an object to `fillWith` value.\u000a		 */\u000a		convertArrayToObject: function( arr, fillWith ) {\u000a			var obj = {};\u000a\u000a			if ( arguments.length == 1 )\u000a				fillWith = true;\u000a\u000a			for ( var i = 0, l = arr.length; i < l; ++i )\u000a				obj[ arr[ i ] ] = fillWith;\u000a\u000a			return obj;\u000a		},\u000a\u000a		/**\u000a		 * Tries to fix the `document.domain` of the current document to match the\u000a		 * parent window domain, avoiding "Same Origin" policy issues.\u000a		 * This is an Internet Explorer only requirement.\u000a		 *\u000a		 * @since 4.1.2\u000a		 * @returns {Boolean} `true` if the current domain is already good or if\u000a		 * it has been fixed successfully.\u000a		 */\u000a		fixDomain: function() {\u000a			var domain;\u000a\u000a			while ( 1 ) {\u000a				try {\u000a					// Try to access the parent document. It throws\u000a					// "access denied" if restricted by the "Same Origin" policy.\u000a					domain = window.parent.document.domain;\u000a					break;\u000a				} catch ( e ) {\u000a					// Calculate the value to set to document.domain.\u000a					domain = domain ?\u000a\u000a						// If it is not the first pass, strip one part of the\u000a						// name. E.g.  "test.example.com"  => "example.com"\u000a						domain.replace( /.+?(?:\u005c.|$)/, '' ) :\u000a\u000a						// In the first pass, we'll handle the\u000a						// "document.domain = document.domain" case.\u000a						document.domain;\u000a\u000a					// Stop here if there is no more domain parts available.\u000a					if ( !domain )\u000a						break;\u000a\u000a					document.domain = domain;\u000a				}\u000a			}\u000a\u000a			return !!domain;\u000a		},\u000a\u000a		/**\u000a		 * Buffers `input` events (or any `input` calls)\u000a		 * and triggers `output` not more often than once per `minInterval`.\u000a		 *\u000a		 *		var buffer = CKEDITOR.tools.eventsBuffer( 200, function() {\u000a		 *			console.log( 'foo!' );\u000a		 *		} );\u000a		 *\u000a		 *		buffer.input();\u000a		 *		// 'foo!' logged immediately.\u000a		 *		buffer.input();\u000a		 *		// Nothing logged.\u000a		 *		buffer.input();\u000a		 *		// Nothing logged.\u000a		 *		// ... after 200ms a single 'foo!' will be logged.\u000a		 *\u000a		 * Can be easily used with events:\u000a		 *\u000a		 *		var buffer = CKEDITOR.tools.eventsBuffer( 200, function() {\u000a		 *			console.log( 'foo!' );\u000a		 *		} );\u000a		 *\u000a		 *		editor.on( 'key', buffer.input );\u000a		 *		// Note: There is no need to bind buffer as a context.\u000a		 *\u000a		 * @since 4.2.1\u000a		 * @param {Number} minInterval Minimum interval between `output` calls in milliseconds.\u000a		 * @param {Function} output Function that will be executed as `output`.\u000a		 * @returns {Object}\u000a		 * @returns {Function} return.input Buffer's input method.\u000a		 * @returns {Function} return.reset Resets buffered events &mdash; `output` will not be executed\u000a		 * until next `input` is triggered.\u000a		 */\u000a		eventsBuffer: function( minInterval, output ) {\u000a			var scheduled,\u000a				lastOutput = 0;\u000a\u000a			function triggerOutput() {\u000a				lastOutput = ( new Date() ).getTime();\u000a				scheduled = false;\u000a				output();\u000a			}\u000a\u000a			return {\u000a				input: function() {\u000a					if ( scheduled )\u000a						return;\u000a\u000a					var diff = ( new Date() ).getTime() - lastOutput;\u000a\u000a					// If less than minInterval passed after last check,\u000a					// schedule next for minInterval after previous one.\u000a					if ( diff < minInterval )\u000a						scheduled = setTimeout( triggerOutput, minInterval - diff );\u000a					else\u000a						triggerOutput();\u000a				},\u000a\u000a				reset: function() {\u000a					if ( scheduled )\u000a						clearTimeout( scheduled );\u000a\u000a					scheduled = lastOutput = 0;\u000a				}\u000a			};\u000a		},\u000a\u000a		/**\u000a		 * Enables HTML5 elements for older browsers (IE8) in the passed document.\u000a		 *\u000a		 * In IE8 this method can also be executed on a document fragment.\u000a		 *\u000a		 * **Note:** This method has to be used in the `<head>` section of the document.\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {Object} doc Native `Document` or `DocumentFragment` in which the elements will be enabled.\u000a		 * @param {Boolean} [withAppend] Whether to append created elements to the `doc`.\u000a		 */\u000a		enableHtml5Elements: function( doc, withAppend ) {\u000a			var els = 'abbr,article,aside,audio,bdi,canvas,data,datalist,details,figcaption,figure,footer,header,hgroup,mark,meter,nav,output,progress,section,summary,time,video'.split( ',' ),\u000a				i = els.length,\u000a				el;\u000a\u000a			while ( i-- ) {\u000a				el = doc.createElement( els[ i ] );\u000a				if ( withAppend )\u000a					doc.appendChild( el );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Checks if any of the `arr` items match the provided regular expression.\u000a		 *\u000a		 * @param {Array} arr The array whose items will be checked.\u000a		 * @param {RegExp} regexp The regular expression.\u000a		 * @returns {Boolean} Returns `true` for the first occurrence of the search pattern.\u000a		 * @since 4.4\u000a		 */\u000a		checkIfAnyArrayItemMatches: function( arr, regexp ) {\u000a			for ( var i = 0, l = arr.length; i < l; ++i ) {\u000a				if ( arr[ i ].match( regexp ) )\u000a					return true;\u000a			}\u000a			return false;\u000a		},\u000a\u000a		/**\u000a		 * Checks if any of the `obj` properties match the provided regular expression.\u000a		 *\u000a		 * @param obj The object whose properties will be checked.\u000a		 * @param {RegExp} regexp The regular expression.\u000a		 * @returns {Boolean} Returns `true` for the first occurrence of the search pattern.\u000a		 * @since 4.4\u000a		 */\u000a		checkIfAnyObjectPropertyMatches: function( obj, regexp ) {\u000a			for ( var i in obj ) {\u000a				if ( i.match( regexp ) )\u000a					return true;\u000a			}\u000a			return false;\u000a		},\u000a\u000a		/**\u000a		 * The data URI of a transparent image. May be used e.g. in HTML as an image source or in CSS in `url()`.\u000a		 *\u000a		 * @since 4.4\u000a		 * @readonly\u000a		 */\u000a		transparentImageData: 'data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=='\u000a	};\u000a} )();\u000a\u000a// PACKAGER_RENAME( CKEDITOR.tools )\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.dtd} object, which holds the DTD\u000a *		mapping for XHTML 1.0 Transitional. This file was automatically\u000a *		generated from the file: xhtml1-transitional.dtd.\u000a */\u000a\u000a/**\u000a * Holds and object representation of the HTML DTD to be used by the\u000a * editor in its internal operations.\u000a *\u000a * Each element in the DTD is represented by a property in this object. Each\u000a * property contains the list of elements that can be contained by the element.\u000a * Text is represented by the `#` property.\u000a *\u000a * Several special grouping properties are also available. Their names start\u000a * with the `$` character.\u000a *\u000a *		// Check if <div> can be contained in a <p> element.\u000a *		alert( !!CKEDITOR.dtd[ 'p' ][ 'div' ] ); // false\u000a *\u000a *		// Check if <p> can be contained in a <div> element.\u000a *		alert( !!CKEDITOR.dtd[ 'div' ][ 'p' ] ); // true\u000a *\u000a *		// Check if <p> is a block element.\u000a *		alert( !!CKEDITOR.dtd.$block[ 'p' ] ); // true\u000a *\u000a * @class CKEDITOR.dtd\u000a * @singleton\u000a */\u000aCKEDITOR.dtd = ( function() {\u000a	'use strict';\u000a\u000a	var X = CKEDITOR.tools.extend,\u000a		// Subtraction rest of sets, from the first set.\u000a		Y = function( source, removed ) {\u000a			var substracted = CKEDITOR.tools.clone( source );\u000a			for ( var i = 1; i < arguments.length; i++ ) {\u000a				removed = arguments[ i ];\u000a				for ( var name in removed )\u000a					delete substracted[ name ];\u000a			}\u000a			return substracted;\u000a		};\u000a\u000a	// Phrasing elements.\u000a	// P = { a: 1, em: 1, strong: 1, small: 1, abbr: 1, dfn: 1, i: 1, b: 1, s: 1,\u000a	//		u: 1, code: 1, 'var': 1, samp: 1, kbd: 1, sup: 1, sub: 1, q: 1, cite: 1,\u000a	//		span: 1, bdo: 1, bdi: 1, br: 1, wbr: 1, ins: 1, del: 1, img: 1, embed: 1,\u000a	//		object: 1, iframe: 1, map: 1, area: 1, script: 1, noscript: 1, ruby: 1,\u000a	//		video: 1, audio: 1, input: 1, textarea: 1, select: 1, button: 1, label: 1,\u000a	//		output: 1, keygen: 1, progress: 1, command: 1, canvas: 1, time: 1,\u000a	//		meter: 1, detalist: 1 },\u000a\u000a	// Flow elements.\u000a	// F = { a: 1, p: 1, hr: 1, pre: 1, ul: 1, ol: 1, dl: 1, div: 1, h1: 1, h2: 1,\u000a	//		h3: 1, h4: 1, h5: 1, h6: 1, hgroup: 1, address: 1, blockquote: 1, ins: 1,\u000a	//		del: 1, object: 1, map: 1, noscript: 1, section: 1, nav: 1, article: 1,\u000a	//		aside: 1, header: 1, footer: 1, video: 1, audio: 1, figure: 1, table: 1,\u000a	//		form: 1, fieldset: 1, menu: 1, canvas: 1, details:1 },\u000a\u000a	// Text can be everywhere.\u000a	// X( P, T );\u000a	// Flow elements set consists of phrasing elements set.\u000a	// X( F, P );\u000a\u000a	var P = {}, F = {},\u000a		// Intersection of flow elements set and phrasing elements set.\u000a		PF = {\u000a			a: 1, abbr: 1, area: 1, audio: 1, b: 1, bdi: 1, bdo: 1, br: 1, button: 1, canvas: 1, cite: 1,\u000a			code: 1, command: 1, datalist: 1, del: 1, dfn: 1, em: 1, embed: 1, i: 1, iframe: 1, img: 1,\u000a			input: 1, ins: 1, kbd: 1, keygen: 1, label: 1, map: 1, mark: 1, meter: 1, noscript: 1, object: 1,\u000a			output: 1, progress: 1, q: 1, ruby: 1, s: 1, samp: 1, script: 1, select: 1, small: 1, span: 1,\u000a			strong: 1, sub: 1, sup: 1, textarea: 1, time: 1, u: 1, 'var': 1, video: 1, wbr: 1\u000a		},\u000a		// F - PF (Flow Only).\u000a		FO = {\u000a			address: 1, article: 1, aside: 1, blockquote: 1, details: 1, div: 1, dl: 1, fieldset: 1,\u000a			figure: 1, footer: 1, form: 1, h1: 1, h2: 1, h3: 1, h4: 1, h5: 1, h6: 1, header: 1, hgroup: 1,\u000a			hr: 1, menu: 1, nav: 1, ol: 1, p: 1, pre: 1, section: 1, table: 1, ul: 1\u000a		},\u000a		// Metadata elements.\u000a		M = { command: 1, link: 1, meta: 1, noscript: 1, script: 1, style: 1 },\u000a		// Empty.\u000a		E = {},\u000a		// Text.\u000a		T = { '#': 1 },\u000a\u000a		// Deprecated phrasing elements.\u000a		DP = { acronym: 1, applet: 1, basefont: 1, big: 1, font: 1, isindex: 1, strike: 1, style: 1, tt: 1 }, // TODO remove "style".\u000a		// Deprecated flow only elements.\u000a		DFO = { center: 1, dir: 1, noframes: 1 };\u000a\u000a	// Phrasing elements := PF + T + DP\u000a	X( P, PF, T, DP );\u000a	// Flow elements := FO + P + DFO\u000a	X( F, FO, P, DFO );\u000a\u000a	var dtd = {\u000a		a: Y( P, { a: 1, button: 1 } ), // Treat as normal inline element (not a transparent one).\u000a		abbr: P,\u000a		address: F,\u000a		area: E,\u000a		article: X( { style: 1 }, F ),\u000a		aside: X( { style: 1 }, F ),\u000a		audio: X( { source: 1, track: 1 }, F ),\u000a		b: P,\u000a		base: E,\u000a		bdi: P,\u000a		bdo: P,\u000a		blockquote: F,\u000a		body: F,\u000a		br: E,\u000a		button: Y( P, { a: 1, button: 1 } ),\u000a		canvas: P, // Treat as normal inline element (not a transparent one).\u000a		caption: F,\u000a		cite: P,\u000a		code: P,\u000a		col: E,\u000a		colgroup: { col: 1 },\u000a		command: E,\u000a		datalist: X( { option: 1 }, P ),\u000a		dd: F,\u000a		del: P, // Treat as normal inline element (not a transparent one).\u000a		details: X( { summary: 1 }, F ),\u000a		dfn: P,\u000a		div: X( { style: 1 }, F ),\u000a		dl: { dt: 1, dd: 1 },\u000a		dt: F,\u000a		em: P,\u000a		embed: E,\u000a		fieldset: X( { legend: 1 }, F ),\u000a		figcaption: F,\u000a		figure: X( { figcaption: 1 }, F ),\u000a		footer: F,\u000a		form: F,\u000a		h1: P,\u000a		h2: P,\u000a		h3: P,\u000a		h4: P,\u000a		h5: P,\u000a		h6: P,\u000a		head: X( { title: 1, base: 1 }, M ),\u000a		header: F,\u000a		hgroup: { h1: 1, h2: 1, h3: 1, h4: 1, h5: 1, h6: 1 },\u000a		hr: E,\u000a		html: X( { head: 1, body: 1 }, F, M ), // Head and body are optional...\u000a		i: P,\u000a		iframe: T,\u000a		img: E,\u000a		input: E,\u000a		ins: P, // Treat as normal inline element (not a transparent one).\u000a		kbd: P,\u000a		keygen: E,\u000a		label: P,\u000a		legend: P,\u000a		li: F,\u000a		link: E,\u000a		map: F,\u000a		mark: P, // Treat as normal inline element (not a transparent one).\u000a		menu: X( { li: 1 }, F ),\u000a		meta: E,\u000a		meter: Y( P, { meter: 1 } ),\u000a		nav: F,\u000a		noscript: X( { link: 1, meta: 1, style: 1 }, P ), // Treat as normal inline element (not a transparent one).\u000a		object: X( { param: 1 }, P ), // Treat as normal inline element (not a transparent one).\u000a		ol: { li: 1 },\u000a		optgroup: { option: 1 },\u000a		option: T,\u000a		output: P,\u000a		p: P,\u000a		param: E,\u000a		pre: P,\u000a		progress: Y( P, { progress: 1 } ),\u000a		q: P,\u000a		rp: P,\u000a		rt: P,\u000a		ruby: X( { rp: 1, rt: 1 }, P ),\u000a		s: P,\u000a		samp: P,\u000a		script: T,\u000a		section: X( { style: 1 }, F ),\u000a		select: { optgroup: 1, option: 1 },\u000a		small: P,\u000a		source: E,\u000a		span: P,\u000a		strong: P,\u000a		style: T,\u000a		sub: P,\u000a		summary: P,\u000a		sup: P,\u000a		table: { caption: 1, colgroup: 1, thead: 1, tfoot: 1, tbody: 1, tr: 1 },\u000a		tbody: { tr: 1 },\u000a		td: F,\u000a		textarea: T,\u000a		tfoot: { tr: 1 },\u000a		th: F,\u000a		thead: { tr: 1 },\u000a		time: Y( P, { time: 1 } ),\u000a		title: T,\u000a		tr: { th: 1, td: 1 },\u000a		track: E,\u000a		u: P,\u000a		ul: { li: 1 },\u000a		'var': P,\u000a		video: X( { source: 1, track: 1 }, F ),\u000a		wbr: E,\u000a\u000a		// Deprecated tags.\u000a		acronym: P,\u000a		applet: X( { param: 1 }, F ),\u000a		basefont: E,\u000a		big: P,\u000a		center: F,\u000a		dialog: E,\u000a		dir: { li: 1 },\u000a		font: P,\u000a		isindex: E,\u000a		noframes: F,\u000a		strike: P,\u000a		tt: P\u000a	};\u000a\u000a	X( dtd, {\u000a		/**\u000a		 * List of block elements, like `<p>` or `<div>`.\u000a		 */\u000a		$block: X( { audio: 1, dd: 1, dt: 1, figcaption: 1, li: 1, video: 1 }, FO, DFO ),\u000a\u000a		/**\u000a		 * List of elements that contain other blocks, in which block-level operations should be limited,\u000a		 * this property is not intended to be checked directly, use {@link CKEDITOR.dom.elementPath#blockLimit} instead.\u000a		 *\u000a		 * Some examples of editor behaviors that are impacted by block limits:\u000a		 *\u000a		 * * Enter key never split a block-limit element;\u000a		 * * Style application is constraint by the block limit of the current selection.\u000a		 * * Pasted html will be inserted into the block limit of the current selection.\u000a		 *\u000a		 * **Note:** As an exception `<li>` is not considered as a block limit, as it's generally used as a text block.\u000a		 */\u000a		$blockLimit: {\u000a			article: 1, aside: 1, audio: 1, body: 1, caption: 1, details: 1, dir: 1, div: 1, dl: 1,\u000a			fieldset: 1, figcaption: 1, figure: 1, footer: 1, form: 1, header: 1, hgroup: 1, menu: 1, nav: 1,\u000a			ol: 1, section: 1, table: 1, td: 1, th: 1, tr: 1, ul: 1, video: 1\u000a		},\u000a\u000a		/**\u000a		 * List of elements that contain character data.\u000a		 */\u000a		$cdata: { script: 1, style: 1 },\u000a\u000a		/**\u000a		 * List of elements that are accepted as inline editing hosts.\u000a		 */\u000a		$editable: {\u000a			address: 1, article: 1, aside: 1, blockquote: 1, body: 1, details: 1, div: 1, fieldset: 1,\u000a			figcaption: 1, footer: 1, form: 1, h1: 1, h2: 1, h3: 1, h4: 1, h5: 1, h6: 1, header: 1, hgroup: 1,\u000a			nav: 1, p: 1, pre: 1, section: 1\u000a		},\u000a\u000a		/**\u000a		 * List of empty (self-closing) elements, like `<br>` or `<img>`.\u000a		 */\u000a		$empty: {\u000a			area: 1, base: 1, basefont: 1, br: 1, col: 1, command: 1, dialog: 1, embed: 1, hr: 1, img: 1,\u000a			input: 1, isindex: 1, keygen: 1, link: 1, meta: 1, param: 1, source: 1, track: 1, wbr: 1\u000a		},\u000a\u000a		/**\u000a		 * List of inline (`<span>` like) elements.\u000a		 */\u000a		$inline: P,\u000a\u000a		/**\u000a		 * List of list root elements.\u000a		 */\u000a		$list: { dl: 1, ol: 1, ul: 1 },\u000a\u000a		/**\u000a		 * List of list item elements, like `<li>` or `<dd>`.\u000a		 */\u000a		$listItem: { dd: 1, dt: 1, li: 1 },\u000a\u000a		/**\u000a		 * List of elements which may live outside body.\u000a		 */\u000a		$nonBodyContent: X( { body: 1, head: 1, html: 1 }, dtd.head ),\u000a\u000a		/**\u000a		 * Elements that accept text nodes, but are not possible to edit into the browser.\u000a		 */\u000a		$nonEditable: {\u000a			applet: 1, audio: 1, button: 1, embed: 1, iframe: 1, map: 1, object: 1, option: 1,\u000a			param: 1, script: 1, textarea: 1, video: 1\u000a		},\u000a\u000a		/**\u000a		 * Elements that are considered objects, therefore selected as a whole in the editor.\u000a		 */\u000a		$object: {\u000a			applet: 1, audio: 1, button: 1, hr: 1, iframe: 1, img: 1, input: 1, object: 1, select: 1,\u000a			table: 1, textarea: 1, video: 1\u000a		},\u000a\u000a		/**\u000a		 * List of elements that can be ignored if empty, like `<b>` or `<span>`.\u000a		 */\u000a		$removeEmpty: {\u000a			abbr: 1, acronym: 1, b: 1, bdi: 1, bdo: 1, big: 1, cite: 1, code: 1, del: 1, dfn: 1,\u000a			em: 1, font: 1, i: 1, ins: 1, label: 1, kbd: 1, mark: 1, meter: 1, output: 1, q: 1, ruby: 1, s: 1,\u000a			samp: 1, small: 1, span: 1, strike: 1, strong: 1, sub: 1, sup: 1, time: 1, tt: 1, u: 1, 'var': 1\u000a		},\u000a\u000a		/**\u000a		 * List of elements that have tabindex set to zero by default.\u000a		 */\u000a		$tabIndex: { a: 1, area: 1, button: 1, input: 1, object: 1, select: 1, textarea: 1 },\u000a\u000a		/**\u000a		 * List of elements used inside the `<table>` element, like `<tbody>` or `<td>`.\u000a		 */\u000a		$tableContent: { caption: 1, col: 1, colgroup: 1, tbody: 1, td: 1, tfoot: 1, th: 1, thead: 1, tr: 1 },\u000a\u000a		/**\u000a		 * List of "transparent" elements. See [W3C's definition of "transparent" element](http://dev.w3.org/html5/markup/terminology.html#transparent).\u000a		 */\u000a		$transparent: { a: 1, audio: 1, canvas: 1, del: 1, ins: 1, map: 1, noscript: 1, object: 1, video: 1 },\u000a\u000a		/**\u000a		 * List of elements that are not to exist standalone that must live under it's parent element.\u000a		 */\u000a		$intermediate: {\u000a			caption: 1, colgroup: 1, dd: 1, dt: 1, figcaption: 1, legend: 1, li: 1, optgroup: 1,\u000a			option: 1, rp: 1, rt: 1, summary: 1, tbody: 1, td: 1, tfoot: 1, th: 1, thead: 1, tr: 1\u000a		}\u000a	} );\u000a\u000a	return dtd;\u000a} )();\u000a\u000a// PACKAGER_RENAME( CKEDITOR.dtd )\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.dom.event} class, which\u000a *		represents the a native DOM event object.\u000a */\u000a\u000a/**\u000a * Represents a native DOM event object.\u000a *\u000a * @class\u000a * @constructor Creates an event class instance.\u000a * @param {Object} domEvent A native DOM event object.\u000a */\u000aCKEDITOR.dom.event = function( domEvent ) {\u000a	/**\u000a	 * The native DOM event object represented by this class instance.\u000a	 *\u000a	 * @readonly\u000a	 */\u000a	this.$ = domEvent;\u000a};\u000a\u000aCKEDITOR.dom.event.prototype = {\u000a	/**\u000a	 * Gets the key code associated to the event.\u000a	 *\u000a	 *		alert( event.getKey() ); // '65' is 'a' has been pressed\u000a	 *\u000a	 * @returns {Number} The key code.\u000a	 */\u000a	getKey: function() {\u000a		return this.$.keyCode || this.$.which;\u000a	},\u000a\u000a	/**\u000a	 * Gets a number represeting the combination of the keys pressed during the\u000a	 * event. It is the sum with the current key code and the {@link CKEDITOR#CTRL},\u000a	 * {@link CKEDITOR#SHIFT} and {@link CKEDITOR#ALT} constants.\u000a	 *\u000a	 *		alert( event.getKeystroke() == 65 );									// 'a' key\u000a	 *		alert( event.getKeystroke() == CKEDITOR.CTRL + 65 );					// CTRL + 'a' key\u000a	 *		alert( event.getKeystroke() == CKEDITOR.CTRL + CKEDITOR.SHIFT + 65 );	// CTRL + SHIFT + 'a' key\u000a	 *\u000a	 * @returns {Number} The number representing the keys combination.\u000a	 */\u000a	getKeystroke: function() {\u000a		var keystroke = this.getKey();\u000a\u000a		if ( this.$.ctrlKey || this.$.metaKey )\u000a			keystroke += CKEDITOR.CTRL;\u000a\u000a		if ( this.$.shiftKey )\u000a			keystroke += CKEDITOR.SHIFT;\u000a\u000a		if ( this.$.altKey )\u000a			keystroke += CKEDITOR.ALT;\u000a\u000a		return keystroke;\u000a	},\u000a\u000a	/**\u000a	 * Prevents the original behavior of the event to happen. It can optionally\u000a	 * stop propagating the event in the event chain.\u000a	 *\u000a	 *		var element = CKEDITOR.document.getById( 'myElement' );\u000a	 *		element.on( 'click', function( ev ) {\u000a	 *			// The DOM event object is passed by the 'data' property.\u000a	 *			var domEvent = ev.data;\u000a	 *			// Prevent the click to chave any effect in the element.\u000a	 *			domEvent.preventDefault();\u000a	 *		} );\u000a	 *\u000a	 * @param {Boolean} [stopPropagation=false] Stop propagating this event in the\u000a	 * event chain.\u000a	 */\u000a	preventDefault: function( stopPropagation ) {\u000a		var $ = this.$;\u000a		if ( $.preventDefault )\u000a			$.preventDefault();\u000a		else\u000a			$.returnValue = false;\u000a\u000a		if ( stopPropagation )\u000a			this.stopPropagation();\u000a	},\u000a\u000a	/**\u000a	 * Stops this event propagation in the event chain.\u000a	 */\u000a	stopPropagation: function() {\u000a		var $ = this.$;\u000a		if ( $.stopPropagation )\u000a			$.stopPropagation();\u000a		else\u000a			$.cancelBubble = true;\u000a	},\u000a\u000a	/**\u000a	 * Returns the DOM node where the event was targeted to.\u000a	 *\u000a	 *		var element = CKEDITOR.document.getById( 'myElement' );\u000a	 *		element.on( 'click', function( ev ) {\u000a	 *			// The DOM event object is passed by the 'data' property.\u000a	 *			var domEvent = ev.data;\u000a	 *			// Add a CSS class to the event target.\u000a	 *			domEvent.getTarget().addClass( 'clicked' );\u000a	 *		} );\u000a	 *\u000a	 * @returns {CKEDITOR.dom.node} The target DOM node.\u000a	 */\u000a	getTarget: function() {\u000a		var rawNode = this.$.target || this.$.srcElement;\u000a		return rawNode ? new CKEDITOR.dom.node( rawNode ) : null;\u000a	},\u000a\u000a	/**\u000a	 * Returns an integer value that indicates the current processing phase of an event.\u000a	 * For browsers that doesn't support event phase, {@link CKEDITOR#EVENT_PHASE_AT_TARGET} is always returned.\u000a	 *\u000a	 * @returns {Number} One of {@link CKEDITOR#EVENT_PHASE_CAPTURING},\u000a	 * {@link CKEDITOR#EVENT_PHASE_AT_TARGET}, or {@link CKEDITOR#EVENT_PHASE_BUBBLING}.\u000a	 */\u000a	getPhase: function() {\u000a		return this.$.eventPhase || 2;\u000a	},\u000a\u000a	/**\u000a	 * Retrieves the coordinates of the mouse pointer relative to the top-left\u000a	 * corner of the document, in mouse related event.\u000a	 *\u000a	 *		element.on( 'mousemouse', function( ev ) {\u000a	 *			var pageOffset = ev.data.getPageOffset();\u000a	 *			alert( pageOffset.x );			// page offset X\u000a	 *			alert( pageOffset.y );			// page offset Y\u000a	 *     } );\u000a	 *\u000a	 * @returns {Object} The object contains the position.\u000a	 * @returns {Number} return.x\u000a	 * @returns {Number} return.y\u000a	 */\u000a	getPageOffset: function() {\u000a		var doc = this.getTarget().getDocument().$;\u000a		var pageX = this.$.pageX || this.$.clientX + ( doc.documentElement.scrollLeft || doc.body.scrollLeft );\u000a		var pageY = this.$.pageY || this.$.clientY + ( doc.documentElement.scrollTop || doc.body.scrollTop );\u000a		return { x: pageX, y: pageY };\u000a	}\u000a};\u000a\u000a// For the followind constants, we need to go over the Unicode boundaries\u000a// (0x10FFFF) to avoid collision.\u000a\u000a/**\u000a * CTRL key (0x110000).\u000a *\u000a * @readonly\u000a * @property {Number} [=0x110000]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.CTRL = 0x110000;\u000a\u000a/**\u000a * SHIFT key (0x220000).\u000a *\u000a * @readonly\u000a * @property {Number} [=0x220000]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.SHIFT = 0x220000;\u000a\u000a/**\u000a * ALT key (0x440000).\u000a *\u000a * @readonly\u000a * @property {Number} [=0x440000]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.ALT = 0x440000;\u000a\u000a/**\u000a * Capturing phase.\u000a *\u000a * @readonly\u000a * @property {Number} [=1]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.EVENT_PHASE_CAPTURING = 1;\u000a\u000a/**\u000a * Event at target.\u000a *\u000a * @readonly\u000a * @property {Number} [=2]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.EVENT_PHASE_AT_TARGET = 2;\u000a\u000a/**\u000a * Bubbling phase.\u000a *\u000a * @readonly\u000a * @property {Number} [=3]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.EVENT_PHASE_BUBBLING = 3;\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.editor} class, which is the base\u000a *		for other classes representing DOM objects.\u000a */\u000a\u000a/**\u000a * Represents a DOM object. This class is not intended to be used directly. It\u000a * serves as the base class for other classes representing specific DOM\u000a * objects.\u000a *\u000a * @class\u000a * @mixins CKEDITOR.event\u000a * @constructor Creates a domObject class instance.\u000a * @param {Object} nativeDomObject A native DOM object.\u000a */\u000aCKEDITOR.dom.domObject = function( nativeDomObject ) {\u000a	if ( nativeDomObject ) {\u000a		/**\u000a		 * The native DOM object represented by this class instance.\u000a		 *\u000a		 *		var element = new CKEDITOR.dom.element( 'span' );\u000a		 *		alert( element.$.nodeType ); // '1'\u000a		 *\u000a		 * @readonly\u000a		 * @property {Object}\u000a		 */\u000a		this.$ = nativeDomObject;\u000a	}\u000a};\u000a\u000aCKEDITOR.dom.domObject.prototype = ( function() {\u000a	// Do not define other local variables here. We want to keep the native\u000a	// listener closures as clean as possible.\u000a\u000a	var getNativeListener = function( domObject, eventName ) {\u000a			return function( domEvent ) {\u000a				// In FF, when reloading the page with the editor focused, it may\u000a				// throw an error because the CKEDITOR global is not anymore\u000a				// available. So, we check it here first. (#2923)\u000a				if ( typeof CKEDITOR != 'undefined' )\u000a					domObject.fire( eventName, new CKEDITOR.dom.event( domEvent ) );\u000a			};\u000a		};\u000a\u000a	return {\u000a\u000a		/**\u000a		 * Get the private `_` object which is bound to the native\u000a		 * DOM object using {@link #getCustomData}.\u000a		 *\u000a		 *		var elementA = new CKEDITOR.dom.element( nativeElement );\u000a		 *		elementA.getPrivate().value = 1;\u000a		 *		...\u000a		 *		var elementB = new CKEDITOR.dom.element( nativeElement );\u000a		 *		elementB.getPrivate().value; // 1\u000a		 *\u000a		 * @returns {Object} The private object.\u000a		 */\u000a		getPrivate: function() {\u000a			var priv;\u000a\u000a			// Get the main private object from the custom data. Create it if not defined.\u000a			if ( !( priv = this.getCustomData( '_' ) ) )\u000a				this.setCustomData( '_', ( priv = {} ) );\u000a\u000a			return priv;\u000a		},\u000a\u000a		// Docs inherited from event.\u000a		on: function( eventName ) {\u000a			// We customize the "on" function here. The basic idea is that we'll have\u000a			// only one listener for a native event, which will then call all listeners\u000a			// set to the event.\u000a\u000a			// Get the listeners holder object.\u000a			var nativeListeners = this.getCustomData( '_cke_nativeListeners' );\u000a\u000a			if ( !nativeListeners ) {\u000a				nativeListeners = {};\u000a				this.setCustomData( '_cke_nativeListeners', nativeListeners );\u000a			}\u000a\u000a			// Check if we have a listener for that event.\u000a			if ( !nativeListeners[ eventName ] ) {\u000a				var listener = nativeListeners[ eventName ] = getNativeListener( this, eventName );\u000a\u000a				if ( this.$.addEventListener )\u000a					this.$.addEventListener( eventName, listener, !!CKEDITOR.event.useCapture );\u000a				else if ( this.$.attachEvent )\u000a					this.$.attachEvent( 'on' + eventName, listener );\u000a			}\u000a\u000a			// Call the original implementation.\u000a			return CKEDITOR.event.prototype.on.apply( this, arguments );\u000a		},\u000a\u000a		// Docs inherited from event.\u000a		removeListener: function( eventName ) {\u000a			// Call the original implementation.\u000a			CKEDITOR.event.prototype.removeListener.apply( this, arguments );\u000a\u000a			// If we don't have listeners for this event, clean the DOM up.\u000a			if ( !this.hasListeners( eventName ) ) {\u000a				var nativeListeners = this.getCustomData( '_cke_nativeListeners' );\u000a				var listener = nativeListeners && nativeListeners[ eventName ];\u000a				if ( listener ) {\u000a					if ( this.$.removeEventListener )\u000a						this.$.removeEventListener( eventName, listener, false );\u000a					else if ( this.$.detachEvent )\u000a						this.$.detachEvent( 'on' + eventName, listener );\u000a\u000a					delete nativeListeners[ eventName ];\u000a				}\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Removes any listener set on this object.\u000a		 *\u000a		 * To avoid memory leaks we must assure that there are no\u000a		 * references left after the object is no longer needed.\u000a		 */\u000a		removeAllListeners: function() {\u000a			var nativeListeners = this.getCustomData( '_cke_nativeListeners' );\u000a			for ( var eventName in nativeListeners ) {\u000a				var listener = nativeListeners[ eventName ];\u000a				if ( this.$.detachEvent )\u000a					this.$.detachEvent( 'on' + eventName, listener );\u000a				else if ( this.$.removeEventListener )\u000a					this.$.removeEventListener( eventName, listener, false );\u000a\u000a				delete nativeListeners[ eventName ];\u000a			}\u000a\u000a			// Remove events from events object so fire() method will not call\u000a			// listeners (#11400).\u000a			CKEDITOR.event.prototype.removeAllListeners.call( this );\u000a		}\u000a	};\u000a} )();\u000a\u000a( function( domObjectProto ) {\u000a	var customData = {};\u000a\u000a	CKEDITOR.on( 'reset', function() {\u000a		customData = {};\u000a	} );\u000a\u000a	/**\u000a	 * Determines whether the specified object is equal to the current object.\u000a	 *\u000a	 *		var doc = new CKEDITOR.dom.document( document );\u000a	 *		alert( doc.equals( CKEDITOR.document ) );	// true\u000a	 *		alert( doc == CKEDITOR.document );			// false\u000a	 *\u000a	 * @param {Object} object The object to compare with the current object.\u000a	 * @returns {Boolean} `true` if the object is equal.\u000a	 */\u000a	domObjectProto.equals = function( object ) {\u000a		// Try/Catch to avoid IE permission error when object is from different document.\u000a		try {\u000a			return ( object && object.$ === this.$ );\u000a		} catch ( er ) {\u000a			return false;\u000a		}\u000a	};\u000a\u000a	/**\u000a	 * Sets a data slot value for this object. These values are shared by all\u000a	 * instances pointing to that same DOM object.\u000a	 *\u000a	 * **Note:** The created data slot is only guarantied to be available on this unique dom node,\u000a	 * thus any wish to continue access it from other element clones (either created by\u000a	 * clone node or from `innerHtml`) will fail, for such usage, please use\u000a	 * {@link CKEDITOR.dom.element#setAttribute} instead.\u000a	 *\u000a	 * **Note**: This method does not work on text nodes prior to Internet Explorer 9.\u000a	 *\u000a	 *		var element = new CKEDITOR.dom.element( 'span' );\u000a	 *		element.setCustomData( 'hasCustomData', true );\u000a	 *\u000a	 * @param {String} key A key used to identify the data slot.\u000a	 * @param {Object} value The value to set to the data slot.\u000a	 * @returns {CKEDITOR.dom.domObject} This DOM object instance.\u000a	 * @chainable\u000a	 */\u000a	domObjectProto.setCustomData = function( key, value ) {\u000a		var expandoNumber = this.getUniqueId(),\u000a			dataSlot = customData[ expandoNumber ] || ( customData[ expandoNumber ] = {} );\u000a\u000a		dataSlot[ key ] = value;\u000a\u000a		return this;\u000a	};\u000a\u000a	/**\u000a	 * Gets the value set to a data slot in this object.\u000a	 *\u000a	 *		var element = new CKEDITOR.dom.element( 'span' );\u000a	 *		alert( element.getCustomData( 'hasCustomData' ) );		// e.g. 'true'\u000a	 *		alert( element.getCustomData( 'nonExistingKey' ) );		// null\u000a	 *\u000a	 * @param {String} key The key used to identify the data slot.\u000a	 * @returns {Object} This value set to the data slot.\u000a	 */\u000a	domObjectProto.getCustomData = function( key ) {\u000a		var expandoNumber = this.$[ 'data-cke-expando' ],\u000a			dataSlot = expandoNumber && customData[ expandoNumber ];\u000a\u000a		return ( dataSlot && key in dataSlot ) ? dataSlot[ key ] : null;\u000a	};\u000a\u000a	/**\u000a	 * Removes the value in data slot under given `key`.\u000a	 *\u000a	 * @param {String} key\u000a	 * @returns {Object} Removed value or `null` if not found.\u000a	 */\u000a	domObjectProto.removeCustomData = function( key ) {\u000a		var expandoNumber = this.$[ 'data-cke-expando' ],\u000a			dataSlot = expandoNumber && customData[ expandoNumber ],\u000a			retval, hadKey;\u000a\u000a		if ( dataSlot ) {\u000a			retval = dataSlot[ key ];\u000a			hadKey = key in dataSlot;\u000a			delete dataSlot[ key ];\u000a		}\u000a\u000a		return hadKey ? retval : null;\u000a	};\u000a\u000a	/**\u000a	 * Removes any data stored on this object.\u000a	 * To avoid memory leaks we must assure that there are no\u000a	 * references left after the object is no longer needed.\u000a	 */\u000a	domObjectProto.clearCustomData = function() {\u000a		// Clear all event listeners\u000a		this.removeAllListeners();\u000a\u000a		var expandoNumber = this.$[ 'data-cke-expando' ];\u000a		expandoNumber && delete customData[ expandoNumber ];\u000a	};\u000a\u000a	/**\u000a	 * Gets an ID that can be used to identify this DOM object in\u000a	 * the running session.\u000a	 *\u000a	 * **Note**: This method does not work on text nodes prior to Internet Explorer 9.\u000a	 *\u000a	 * @returns {Number} A unique ID.\u000a	 */\u000a	domObjectProto.getUniqueId = function() {\u000a		return this.$[ 'data-cke-expando' ] || ( this.$[ 'data-cke-expando' ] = CKEDITOR.tools.getNextNumber() );\u000a	};\u000a\u000a	// Implement CKEDITOR.event.\u000a	CKEDITOR.event.implementOn( domObjectProto );\u000a\u000a} )( CKEDITOR.dom.domObject.prototype );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.dom.node} class which is the base\u000a *		class for classes that represent DOM nodes.\u000a */\u000a\u000a/**\u000a * Base class for classes representing DOM nodes. This constructor may return\u000a * an instance of a class that inherits from this class, like\u000a * {@link CKEDITOR.dom.element} or {@link CKEDITOR.dom.text}.\u000a *\u000a * @class\u000a * @extends CKEDITOR.dom.domObject\u000a * @constructor Creates a node class instance.\u000a * @param {Object} domNode A native DOM node.\u000a * @see CKEDITOR.dom.element\u000a * @see CKEDITOR.dom.text\u000a */\u000aCKEDITOR.dom.node = function( domNode ) {\u000a	if ( domNode ) {\u000a		var type =\u000a			domNode.nodeType == CKEDITOR.NODE_DOCUMENT ? 'document' :\u000a			domNode.nodeType == CKEDITOR.NODE_ELEMENT ? 'element' :\u000a			domNode.nodeType == CKEDITOR.NODE_TEXT ? 'text' :\u000a			domNode.nodeType == CKEDITOR.NODE_COMMENT ? 'comment' :\u000a			domNode.nodeType == CKEDITOR.NODE_DOCUMENT_FRAGMENT ? 'documentFragment' :\u000a			'domObject'; // Call the base constructor otherwise.\u000a\u000a		return new CKEDITOR.dom[ type ]( domNode );\u000a	}\u000a\u000a	return this;\u000a};\u000a\u000aCKEDITOR.dom.node.prototype = new CKEDITOR.dom.domObject();\u000a\u000a/**\u000a * Element node type.\u000a *\u000a * @readonly\u000a * @property {Number} [=1]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.NODE_ELEMENT = 1;\u000a\u000a/**\u000a * Document node type.\u000a *\u000a * @readonly\u000a * @property {Number} [=9]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.NODE_DOCUMENT = 9;\u000a\u000a/**\u000a * Text node type.\u000a *\u000a * @readonly\u000a * @property {Number} [=3]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.NODE_TEXT = 3;\u000a\u000a/**\u000a * Comment node type.\u000a *\u000a * @readonly\u000a * @property {Number} [=8]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.NODE_COMMENT = 8;\u000a\u000a/**\u000a * Document fragment node type.\u000a *\u000a * @readonly\u000a * @property {Number} [=11]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.NODE_DOCUMENT_FRAGMENT = 11;\u000a\u000aCKEDITOR.POSITION_IDENTICAL = 0;\u000aCKEDITOR.POSITION_DISCONNECTED = 1;\u000aCKEDITOR.POSITION_FOLLOWING = 2;\u000aCKEDITOR.POSITION_PRECEDING = 4;\u000aCKEDITOR.POSITION_IS_CONTAINED = 8;\u000aCKEDITOR.POSITION_CONTAINS = 16;\u000a\u000aCKEDITOR.tools.extend( CKEDITOR.dom.node.prototype, {\u000a	/**\u000a	 * Makes this node a child of another element.\u000a	 *\u000a	 *		var p = new CKEDITOR.dom.element( 'p' );\u000a	 *		var strong = new CKEDITOR.dom.element( 'strong' );\u000a	 *		strong.appendTo( p );\u000a	 *\u000a	 *		// Result: '<p><strong></strong></p>'.\u000a	 *\u000a	 * @param {CKEDITOR.dom.element} element The target element to which this node will be appended.\u000a	 * @returns {CKEDITOR.dom.element} The target element.\u000a	 */\u000a	appendTo: function( element, toStart ) {\u000a		element.append( this, toStart );\u000a		return element;\u000a	},\u000a\u000a	/**\u000a	 * Clones this node.\u000a	 *\u000a	 * **Note**: Values set by {#setCustomData} will not be available in the clone.\u000a	 *\u000a	 * @param {Boolean} [includeChildren=false] If `true` then all node's\u000a	 * children will be cloned recursively.\u000a	 * @param {Boolean} [cloneId=false] Whether ID attributes should be cloned, too.\u000a	 * @returns {CKEDITOR.dom.node} Clone of this node.\u000a	 */\u000a	clone: function( includeChildren, cloneId ) {\u000a		var $clone = this.$.cloneNode( includeChildren );\u000a\u000a		var removeIds = function( node ) {\u000a				// Reset data-cke-expando only when has been cloned (IE and only for some types of objects).\u000a				if ( node[ 'data-cke-expando' ] )\u000a					node[ 'data-cke-expando' ] = false;\u000a\u000a				if ( node.nodeType != CKEDITOR.NODE_ELEMENT )\u000a					return;\u000a				if ( !cloneId )\u000a					node.removeAttribute( 'id', false );\u000a\u000a				if ( includeChildren ) {\u000a					var childs = node.childNodes;\u000a					for ( var i = 0; i < childs.length; i++ )\u000a						removeIds( childs[ i ] );\u000a				}\u000a			};\u000a\u000a		// The "id" attribute should never be cloned to avoid duplication.\u000a		removeIds( $clone );\u000a\u000a		return new CKEDITOR.dom.node( $clone );\u000a	},\u000a\u000a	/**\u000a	 * Checks if the node is preceded by any sibling.\u000a	 *\u000a	 * @returns {Boolean}\u000a	 */\u000a	hasPrevious: function() {\u000a		return !!this.$.previousSibling;\u000a	},\u000a\u000a	/**\u000a	 * Checks if the node is succeeded by any sibling.\u000a	 *\u000a	 * @returns {Boolean}\u000a	 */\u000a	hasNext: function() {\u000a		return !!this.$.nextSibling;\u000a	},\u000a\u000a	/**\u000a	 * Inserts this element after a node.\u000a	 *\u000a	 *		var em = new CKEDITOR.dom.element( 'em' );\u000a	 *		var strong = new CKEDITOR.dom.element( 'strong' );\u000a	 *		strong.insertAfter( em );\u000a	 *\u000a	 *		// Result: '<em></em><strong></strong>'\u000a	 *\u000a	 * @param {CKEDITOR.dom.node} node The node that will precede this element.\u000a	 * @returns {CKEDITOR.dom.node} The node preceding this one after insertion.\u000a	 */\u000a	insertAfter: function( node ) {\u000a		node.$.parentNode.insertBefore( this.$, node.$.nextSibling );\u000a		return node;\u000a	},\u000a\u000a	/**\u000a	 * Inserts this element before a node.\u000a	 *\u000a	 *		var em = new CKEDITOR.dom.element( 'em' );\u000a	 *		var strong = new CKEDITOR.dom.element( 'strong' );\u000a	 *		strong.insertBefore( em );\u000a	 *\u000a	 *		// result: '<strong></strong><em></em>'\u000a	 *\u000a	 * @param {CKEDITOR.dom.node} node The node that will succeed this element.\u000a	 * @returns {CKEDITOR.dom.node} The node being inserted.\u000a	 */\u000a	insertBefore: function( node ) {\u000a		node.$.parentNode.insertBefore( this.$, node.$ );\u000a		return node;\u000a	},\u000a\u000a	/**\u000a	 * Inserts a node before this node.\u000a	 *\u000a	 *		var em = new CKEDITOR.dom.element( 'em' );\u000a	 *		var strong = new CKEDITOR.dom.element( 'strong' );\u000a	 *		strong.insertBeforeMe( em );\u000a	 *\u000a	 *		// result: '<em></em><strong></strong>'\u000a	 *\u000a	 * @param {CKEDITOR.dom.node} node The node that will preceed this element.\u000a	 * @returns {CKEDITOR.dom.node} The node being inserted.\u000a	 */\u000a	insertBeforeMe: function( node ) {\u000a		this.$.parentNode.insertBefore( node.$, this.$ );\u000a		return node;\u000a	},\u000a\u000a	/**\u000a	 * Retrieves a uniquely identifiable tree address for this node.\u000a	 * The tree address returned is an array of integers, with each integer\u000a	 * indicating a child index of a DOM node, starting from\u000a	 * `document.documentElement`.\u000a	 *\u000a	 * For example, assuming `<body>` is the second child\u000a	 * of `<html>` (`<head>` being the first),\u000a	 * and we would like to address the third child under the\u000a	 * fourth child of `<body>`, the tree address returned would be:\u000a	 * `[1, 3, 2]`.\u000a	 *\u000a	 * The tree address cannot be used for finding back the DOM tree node once\u000a	 * the DOM tree structure has been modified.\u000a	 *\u000a	 * @param {Boolean} [normalized=false] See {@link #getIndex}.\u000a	 * @returns {Array} The address.\u000a	 */\u000a	getAddress: function( normalized ) {\u000a		var address = [];\u000a		var $documentElement = this.getDocument().$.documentElement;\u000a		var node = this.$;\u000a\u000a		while ( node && node != $documentElement ) {\u000a			var parentNode = node.parentNode;\u000a\u000a			if ( parentNode ) {\u000a				// Get the node index. For performance, call getIndex\u000a				// directly, instead of creating a new node object.\u000a				address.unshift( this.getIndex.call( { $: node }, normalized ) );\u000a			}\u000a\u000a			node = parentNode;\u000a		}\u000a\u000a		return address;\u000a	},\u000a\u000a	/**\u000a	 * Gets the document containing this element.\u000a	 *\u000a	 *		var element = CKEDITOR.document.getById( 'example' );\u000a	 *		alert( element.getDocument().equals( CKEDITOR.document ) ); // true\u000a	 *\u000a	 * @returns {CKEDITOR.dom.document} The document.\u000a	 */\u000a	getDocument: function() {\u000a		return new CKEDITOR.dom.document( this.$.ownerDocument || this.$.parentNode.ownerDocument );\u000a	},\u000a\u000a	/**\u000a	 * Gets the index of a node in an array of its `parent.childNodes`.\u000a	 *\u000a	 * Let us assume having the following `childNodes` array:\u000a	 *\u000a	 *		[ emptyText, element1, text, text, element2 ]\u000a	 *		element1.getIndex();		// 1\u000a	 *		element1.getIndex( true );	// 0\u000a	 *		element2.getIndex();		// 4\u000a	 *		element2.getIndex( true );	// 2\u000a	 *\u000a	 * @param {Boolean} normalized When `true`, empty text nodes and one followed\u000a	 * by another one text node are not counted in.\u000a	 * @returns {Number} Index of a node.\u000a	 */\u000a	getIndex: function( normalized ) {\u000a		// Attention: getAddress depends on this.$\u000a		// getIndex is called on a plain object: { $ : node }\u000a\u000a		var current = this.$,\u000a			index = -1,\u000a			isNormalizing;\u000a\u000a		if ( !this.$.parentNode )\u000a			return index;\u000a\u000a		do {\u000a			// Bypass blank node and adjacent text nodes.\u000a			if ( normalized && current != this.$ && current.nodeType == CKEDITOR.NODE_TEXT && ( isNormalizing || !current.nodeValue ) )\u000a				continue;\u000a\u000a			index++;\u000a			isNormalizing = current.nodeType == CKEDITOR.NODE_TEXT;\u000a		}\u000a		while ( ( current = current.previousSibling ) );\u000a\u000a		return index;\u000a	},\u000a\u000a	/**\u000a	 * @todo\u000a	 */\u000a	getNextSourceNode: function( startFromSibling, nodeType, guard ) {\u000a		// If "guard" is a node, transform it in a function.\u000a		if ( guard && !guard.call ) {\u000a			var guardNode = guard;\u000a			guard = function( node ) {\u000a				return !node.equals( guardNode );\u000a			};\u000a		}\u000a\u000a		var node = ( !startFromSibling && this.getFirst && this.getFirst() ),\u000a			parent;\u000a\u000a		// Guarding when we're skipping the current element( no children or 'startFromSibling' ).\u000a		// send the 'moving out' signal even we don't actually dive into.\u000a		if ( !node ) {\u000a			if ( this.type == CKEDITOR.NODE_ELEMENT && guard && guard( this, true ) === false )\u000a				return null;\u000a			node = this.getNext();\u000a		}\u000a\u000a		while ( !node && ( parent = ( parent || this ).getParent() ) ) {\u000a			// The guard check sends the "true" paramenter to indicate that\u000a			// we are moving "out" of the element.\u000a			if ( guard && guard( parent, true ) === false )\u000a				return null;\u000a\u000a			node = parent.getNext();\u000a		}\u000a\u000a		if ( !node )\u000a			return null;\u000a\u000a		if ( guard && guard( node ) === false )\u000a			return null;\u000a\u000a		if ( nodeType && nodeType != node.type )\u000a			return node.getNextSourceNode( false, nodeType, guard );\u000a\u000a		return node;\u000a	},\u000a\u000a	/**\u000a	 * @todo\u000a	 */\u000a	getPreviousSourceNode: function( startFromSibling, nodeType, guard ) {\u000a		if ( guard && !guard.call ) {\u000a			var guardNode = guard;\u000a			guard = function( node ) {\u000a				return !node.equals( guardNode );\u000a			};\u000a		}\u000a\u000a		var node = ( !startFromSibling && this.getLast && this.getLast() ),\u000a			parent;\u000a\u000a		// Guarding when we're skipping the current element( no children or 'startFromSibling' ).\u000a		// send the 'moving out' signal even we don't actually dive into.\u000a		if ( !node ) {\u000a			if ( this.type == CKEDITOR.NODE_ELEMENT && guard && guard( this, true ) === false )\u000a				return null;\u000a			node = this.getPrevious();\u000a		}\u000a\u000a		while ( !node && ( parent = ( parent || this ).getParent() ) ) {\u000a			// The guard check sends the "true" paramenter to indicate that\u000a			// we are moving "out" of the element.\u000a			if ( guard && guard( parent, true ) === false )\u000a				return null;\u000a\u000a			node = parent.getPrevious();\u000a		}\u000a\u000a		if ( !node )\u000a			return null;\u000a\u000a		if ( guard && guard( node ) === false )\u000a			return null;\u000a\u000a		if ( nodeType && node.type != nodeType )\u000a			return node.getPreviousSourceNode( false, nodeType, guard );\u000a\u000a		return node;\u000a	},\u000a\u000a	/**\u000a	 * Gets the node that preceeds this element in its parent's child list.\u000a	 *\u000a	 *		var element = CKEDITOR.dom.element.createFromHtml( '<div><i>prev</i><b>Example</b></div>' );\u000a	 *		var first = element.getLast().getPrev();\u000a	 *		alert( first.getName() ); // 'i'\u000a	 *\u000a	 * @param {Function} [evaluator] Filtering the result node.\u000a	 * @returns {CKEDITOR.dom.node} The previous node or null if not available.\u000a	 */\u000a	getPrevious: function( evaluator ) {\u000a		var previous = this.$,\u000a			retval;\u000a		do {\u000a			previous = previous.previousSibling;\u000a\u000a			// Avoid returning the doc type node.\u000a			// http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-412266927\u000a			retval = previous && previous.nodeType != 10 && new CKEDITOR.dom.node( previous );\u000a		}\u000a		while ( retval && evaluator && !evaluator( retval ) );\u000a		return retval;\u000a	},\u000a\u000a	/**\u000a	 * Gets the node that follows this element in its parent's child list.\u000a	 *\u000a	 *		var element = CKEDITOR.dom.element.createFromHtml( '<div><b>Example</b><i>next</i></div>' );\u000a	 *		var last = element.getFirst().getNext();\u000a	 *		alert( last.getName() ); // 'i'\u000a	 *\u000a	 * @param {Function} [evaluator] Filtering the result node.\u000a	 * @returns {CKEDITOR.dom.node} The next node or null if not available.\u000a	 */\u000a	getNext: function( evaluator ) {\u000a		var next = this.$,\u000a			retval;\u000a		do {\u000a			next = next.nextSibling;\u000a			retval = next && new CKEDITOR.dom.node( next );\u000a		}\u000a		while ( retval && evaluator && !evaluator( retval ) );\u000a		return retval;\u000a	},\u000a\u000a	/**\u000a	 * Gets the parent element for this node.\u000a	 *\u000a	 *		var node = editor.document.getBody().getFirst();\u000a	 *		var parent = node.getParent();\u000a	 *		alert( parent.getName() ); // 'body'\u000a	 *\u000a	 * @param {Boolean} [allowFragmentParent=false] Consider also parent node that is of\u000a	 * fragment type {@link CKEDITOR#NODE_DOCUMENT_FRAGMENT}.\u000a	 * @returns {CKEDITOR.dom.element} The parent element.\u000a	 */\u000a	getParent: function( allowFragmentParent ) {\u000a		var parent = this.$.parentNode;\u000a		return ( parent && ( parent.nodeType == CKEDITOR.NODE_ELEMENT || allowFragmentParent && parent.nodeType == CKEDITOR.NODE_DOCUMENT_FRAGMENT ) ) ? new CKEDITOR.dom.node( parent ) : null;\u000a	},\u000a\u000a	/**\u000a	 * Returns an array containing node parents and the node itself. By default nodes are in _descending_ order.\u000a	 *\u000a	 *		// Assuming that body has paragraph as the first child.\u000a	 *		var node = editor.document.getBody().getFirst();\u000a	 *		var parents = node.getParents();\u000a	 *		alert( parents[ 0 ].getName() + ',' + parents[ 2 ].getName() ); // 'html,p'\u000a	 *\u000a	 * @param {Boolean} [closerFirst=false] Determines the order of returned nodes.\u000a	 * @returns {Array} Returns an array of {@link CKEDITOR.dom.node}.\u000a	 */\u000a	getParents: function( closerFirst ) {\u000a		var node = this;\u000a		var parents = [];\u000a\u000a		do {\u000a			parents[ closerFirst ? 'push' : 'unshift' ]( node );\u000a		}\u000a		while ( ( node = node.getParent() ) );\u000a\u000a		return parents;\u000a	},\u000a\u000a	/**\u000a	 * @todo\u000a	 */\u000a	getCommonAncestor: function( node ) {\u000a		if ( node.equals( this ) )\u000a			return this;\u000a\u000a		if ( node.contains && node.contains( this ) )\u000a			return node;\u000a\u000a		var start = this.contains ? this : this.getParent();\u000a\u000a		do {\u000a			if ( start.contains( node ) ) return start;\u000a		}\u000a		while ( ( start = start.getParent() ) );\u000a\u000a		return null;\u000a	},\u000a\u000a	/**\u000a	 * @todo\u000a	 */\u000a	getPosition: function( otherNode ) {\u000a		var $ = this.$;\u000a		var $other = otherNode.$;\u000a\u000a		if ( $.compareDocumentPosition )\u000a			return $.compareDocumentPosition( $other );\u000a\u000a		// IE and Safari have no support for compareDocumentPosition.\u000a\u000a		if ( $ == $other )\u000a			return CKEDITOR.POSITION_IDENTICAL;\u000a\u000a		// Only element nodes support contains and sourceIndex.\u000a		if ( this.type == CKEDITOR.NODE_ELEMENT && otherNode.type == CKEDITOR.NODE_ELEMENT ) {\u000a			if ( $.contains ) {\u000a				if ( $.contains( $other ) )\u000a					return CKEDITOR.POSITION_CONTAINS + CKEDITOR.POSITION_PRECEDING;\u000a\u000a				if ( $other.contains( $ ) )\u000a					return CKEDITOR.POSITION_IS_CONTAINED + CKEDITOR.POSITION_FOLLOWING;\u000a			}\u000a\u000a			if ( 'sourceIndex' in $ )\u000a				return ( $.sourceIndex < 0 || $other.sourceIndex < 0 ) ? CKEDITOR.POSITION_DISCONNECTED : ( $.sourceIndex < $other.sourceIndex ) ? CKEDITOR.POSITION_PRECEDING : CKEDITOR.POSITION_FOLLOWING;\u000a\u000a		}\u000a\u000a		// For nodes that don't support compareDocumentPosition, contains\u000a		// or sourceIndex, their "address" is compared.\u000a\u000a		var addressOfThis = this.getAddress(),\u000a			addressOfOther = otherNode.getAddress(),\u000a			minLevel = Math.min( addressOfThis.length, addressOfOther.length );\u000a\u000a		// Determinate preceed/follow relationship.\u000a		for ( var i = 0; i <= minLevel - 1; i++ ) {\u000a			if ( addressOfThis[ i ] != addressOfOther[ i ] ) {\u000a				if ( i < minLevel )\u000a					return addressOfThis[ i ] < addressOfOther[ i ] ? CKEDITOR.POSITION_PRECEDING : CKEDITOR.POSITION_FOLLOWING;\u000a\u000a				break;\u000a			}\u000a		}\u000a\u000a		// Determinate contains/contained relationship.\u000a		return ( addressOfThis.length < addressOfOther.length ) ? CKEDITOR.POSITION_CONTAINS + CKEDITOR.POSITION_PRECEDING : CKEDITOR.POSITION_IS_CONTAINED + CKEDITOR.POSITION_FOLLOWING;\u000a	},\u000a\u000a	/**\u000a	 * Gets the closest ancestor node of this node, specified by its name or using an evaluator function.\u000a	 *\u000a	 *		// Suppose we have the following HTML structure:\u000a	 *		// <div id="outer"><div id="inner"><p><b>Some text</b></p></div></div>\u000a	 *		// If node == <b>\u000a	 *		ascendant = node.getAscendant( 'div' );				// ascendant == <div id="inner">\u000a	 *		ascendant = node.getAscendant( 'b' );				// ascendant == null\u000a	 *		ascendant = node.getAscendant( 'b', true );			// ascendant == <b>\u000a	 *		ascendant = node.getAscendant( { div:1, p:1 } );	// Searches for the first 'div' or 'p': ascendant == <div id="inner">\u000a	 *\u000a	 *		// Using custom evaluator:\u000a	 *		ascendant = node.getAscendant( function( el ) {\u000a	 *			return el.getId() == 'inner';\u000a	 *		} );\u000a	 *		// ascendant == <div id="inner">\u000a	 *\u000a	 * @since 3.6.1\u000a	 * @param {String/Function/Object} query The name of the ancestor node to search or\u000a	 * an object with the node names to search for or an evaluator function.\u000a	 * @param {Boolean} [includeSelf] Whether to include the current\u000a	 * node in the search.\u000a	 * @returns {CKEDITOR.dom.node} The located ancestor node or `null` if not found.\u000a	 */\u000a	getAscendant: function( query, includeSelf ) {\u000a		var $ = this.$,\u000a			evaluator,\u000a			isCustomEvaluator;\u000a\u000a		if ( !includeSelf ) {\u000a			$ = $.parentNode;\u000a		}\u000a\u000a		// Custom checker provided in an argument.\u000a		if ( typeof query == 'function' ) {\u000a			isCustomEvaluator = true;\u000a			evaluator = query;\u000a		} else {\u000a			// Predefined tag name checker.\u000a			isCustomEvaluator = false;\u000a			evaluator = function( $ ) {\u000a				var name = ( typeof $.nodeName == 'string' ? $.nodeName.toLowerCase() : '' );\u000a\u000a				return ( typeof query == 'string' ? name == query : name in query );\u000a			};\u000a		}\u000a\u000a		while ( $ ) {\u000a			// For user provided checker we use CKEDITOR.dom.node.\u000a			if ( evaluator( isCustomEvaluator ? new CKEDITOR.dom.node( $ ) : $ ) ) {\u000a				return new CKEDITOR.dom.node( $ );\u000a			}\u000a\u000a			try {\u000a				$ = $.parentNode;\u000a			} catch ( e ) {\u000a				$ = null;\u000a			}\u000a		}\u000a\u000a		return null;\u000a	},\u000a\u000a	/**\u000a	 * @todo\u000a	 */\u000a	hasAscendant: function( name, includeSelf ) {\u000a		var $ = this.$;\u000a\u000a		if ( !includeSelf )\u000a			$ = $.parentNode;\u000a\u000a		while ( $ ) {\u000a			if ( $.nodeName && $.nodeName.toLowerCase() == name )\u000a				return true;\u000a\u000a			$ = $.parentNode;\u000a		}\u000a		return false;\u000a	},\u000a\u000a	/**\u000a	 * @todo\u000a	 */\u000a	move: function( target, toStart ) {\u000a		target.append( this.remove(), toStart );\u000a	},\u000a\u000a	/**\u000a	 * Removes this node from the document DOM.\u000a	 *\u000a	 *		var element = CKEDITOR.document.getById( 'MyElement' );\u000a	 *		element.remove();\u000a	 *\u000a	 * @param {Boolean} [preserveChildren=false] Indicates that the children\u000a	 * elements must remain in the document, removing only the outer tags.\u000a	 */\u000a	remove: function( preserveChildren ) {\u000a		var $ = this.$;\u000a		var parent = $.parentNode;\u000a\u000a		if ( parent ) {\u000a			if ( preserveChildren ) {\u000a				// Move all children before the node.\u000a				for ( var child;\u000a				( child = $.firstChild ); ) {\u000a					parent.insertBefore( $.removeChild( child ), $ );\u000a				}\u000a			}\u000a\u000a			parent.removeChild( $ );\u000a		}\u000a\u000a		return this;\u000a	},\u000a\u000a	/**\u000a	 * @todo\u000a	 */\u000a	replace: function( nodeToReplace ) {\u000a		this.insertBefore( nodeToReplace );\u000a		nodeToReplace.remove();\u000a	},\u000a\u000a	/**\u000a	 * @todo\u000a	 */\u000a	trim: function() {\u000a		this.ltrim();\u000a		this.rtrim();\u000a	},\u000a\u000a	/**\u000a	 * @todo\u000a	 */\u000a	ltrim: function() {\u000a		var child;\u000a		while ( this.getFirst && ( child = this.getFirst() ) ) {\u000a			if ( child.type == CKEDITOR.NODE_TEXT ) {\u000a				var trimmed = CKEDITOR.tools.ltrim( child.getText() ),\u000a					originalLength = child.getLength();\u000a\u000a				if ( !trimmed ) {\u000a					child.remove();\u000a					continue;\u000a				} else if ( trimmed.length < originalLength ) {\u000a					child.split( originalLength - trimmed.length );\u000a\u000a					// IE BUG: child.remove() may raise JavaScript errors here. (#81)\u000a					this.$.removeChild( this.$.firstChild );\u000a				}\u000a			}\u000a			break;\u000a		}\u000a	},\u000a\u000a	/**\u000a	 * @todo\u000a	 */\u000a	rtrim: function() {\u000a		var child;\u000a		while ( this.getLast && ( child = this.getLast() ) ) {\u000a			if ( child.type == CKEDITOR.NODE_TEXT ) {\u000a				var trimmed = CKEDITOR.tools.rtrim( child.getText() ),\u000a					originalLength = child.getLength();\u000a\u000a				if ( !trimmed ) {\u000a					child.remove();\u000a					continue;\u000a				} else if ( trimmed.length < originalLength ) {\u000a					child.split( trimmed.length );\u000a\u000a					// IE BUG: child.getNext().remove() may raise JavaScript errors here.\u000a					// (#81)\u000a					this.$.lastChild.parentNode.removeChild( this.$.lastChild );\u000a				}\u000a			}\u000a			break;\u000a		}\u000a\u000a		if ( CKEDITOR.env.needsBrFiller ) {\u000a			child = this.$.lastChild;\u000a\u000a			if ( child && child.type == 1 && child.nodeName.toLowerCase() == 'br' ) {\u000a				// Use "eChildNode.parentNode" instead of "node" to avoid IE bug (#324).\u000a				child.parentNode.removeChild( child );\u000a			}\u000a		}\u000a	},\u000a\u000a	/**\u000a	 * Checks if this node is read-only (should not be changed).\u000a	 *\u000a	 * **Note:** When `attributeCheck` is not used, this method only works for elements\u000a	 * that are already present in the document, otherwise the result\u000a	 * is not guaranteed. It is mainly for performance consideration.\u000a	 *\u000a	 *		// For the following HTML:\u000a	 *		// <div contenteditable="false">Some <b>text</b></div>\u000a	 *\u000a	 *		// If "ele" is the above <div>\u000a	 *		element.isReadOnly(); // true\u000a	 *\u000a	 * @since 3.5\u000a	 * @returns {Boolean}\u000a	 */\u000a	isReadOnly: function() {\u000a		var element = this;\u000a		if ( this.type != CKEDITOR.NODE_ELEMENT )\u000a			element = this.getParent();\u000a\u000a		if ( element && typeof element.$.isContentEditable != 'undefined' )\u000a			return !( element.$.isContentEditable || element.data( 'cke-editable' ) );\u000a		else {\u000a			// Degrade for old browsers which don't support "isContentEditable", e.g. FF3\u000a\u000a			while ( element ) {\u000a				if ( element.data( 'cke-editable' ) )\u000a					break;\u000a\u000a				if ( element.getAttribute( 'contentEditable' ) == 'false' )\u000a					return true;\u000a				else if ( element.getAttribute( 'contentEditable' ) == 'true' )\u000a					break;\u000a\u000a				element = element.getParent();\u000a			}\u000a\u000a			// Reached the root of DOM tree, no editable found.\u000a			return !element;\u000a		}\u000a	}\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.dom.document} class, which\u000a *		represents a DOM document.\u000a */\u000a\u000a/**\u000a * Represents a DOM window.\u000a *\u000a *		var document = new CKEDITOR.dom.window( window );\u000a *\u000a * @class\u000a * @extends CKEDITOR.dom.domObject\u000a * @constructor Creates a window class instance.\u000a * @param {Object} domWindow A native DOM window.\u000a */\u000aCKEDITOR.dom.window = function( domWindow ) {\u000a	CKEDITOR.dom.domObject.call( this, domWindow );\u000a};\u000a\u000aCKEDITOR.dom.window.prototype = new CKEDITOR.dom.domObject();\u000a\u000aCKEDITOR.tools.extend( CKEDITOR.dom.window.prototype, {\u000a	/**\u000a	 * Moves the selection focus to this window.\u000a	 *\u000a	 *		var win = new CKEDITOR.dom.window( window );\u000a	 *		win.focus();\u000a	 */\u000a	focus: function() {\u000a		this.$.focus();\u000a	},\u000a\u000a	/**\u000a	 * Gets the width and height of this window's viewable area.\u000a	 *\u000a	 *		var win = new CKEDITOR.dom.window( window );\u000a	 *		var size = win.getViewPaneSize();\u000a	 *		alert( size.width );\u000a	 *		alert( size.height );\u000a	 *\u000a	 * @returns {Object} An object with the `width` and `height`\u000a	 * properties containing the size.\u000a	 */\u000a	getViewPaneSize: function() {\u000a		var doc = this.$.document,\u000a			stdMode = doc.compatMode == 'CSS1Compat';\u000a		return {\u000a			width: ( stdMode ? doc.documentElement.clientWidth : doc.body.clientWidth ) || 0,\u000a			height: ( stdMode ? doc.documentElement.clientHeight : doc.body.clientHeight ) || 0\u000a		};\u000a	},\u000a\u000a	/**\u000a	 * Gets the current position of the window's scroll.\u000a	 *\u000a	 *		var win = new CKEDITOR.dom.window( window );\u000a	 *		var pos = win.getScrollPosition();\u000a	 *		alert( pos.x );\u000a	 *		alert( pos.y );\u000a	 *\u000a	 * @returns {Object} An object with the `x` and `y` properties\u000a	 * containing the scroll position.\u000a	 */\u000a	getScrollPosition: function() {\u000a		var $ = this.$;\u000a\u000a		if ( 'pageXOffset' in $ ) {\u000a			return {\u000a				x: $.pageXOffset || 0,\u000a				y: $.pageYOffset || 0\u000a			};\u000a		} else {\u000a			var doc = $.document;\u000a			return {\u000a				x: doc.documentElement.scrollLeft || doc.body.scrollLeft || 0,\u000a				y: doc.documentElement.scrollTop || doc.body.scrollTop || 0\u000a			};\u000a		}\u000a	},\u000a\u000a	/**\u000a	 * Gets the frame element containing this window context.\u000a	 *\u000a	 * @returns {CKEDITOR.dom.element} The frame element or `null` if not in a frame context.\u000a	 */\u000a	getFrame: function() {\u000a		var iframe = this.$.frameElement;\u000a		return iframe ? new CKEDITOR.dom.element.get( iframe ) : null;\u000a	}\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.dom.document} class which\u000a *		represents a DOM document.\u000a */\u000a\u000a/**\u000a * Represents a DOM document.\u000a *\u000a *		var document = new CKEDITOR.dom.document( document );\u000a *\u000a * @class\u000a * @extends CKEDITOR.dom.domObject\u000a * @constructor Creates a document class instance.\u000a * @param {Object} domDocument A native DOM document.\u000a */\u000aCKEDITOR.dom.document = function( domDocument ) {\u000a	CKEDITOR.dom.domObject.call( this, domDocument );\u000a};\u000a\u000a// PACKAGER_RENAME( CKEDITOR.dom.document )\u000a\u000aCKEDITOR.dom.document.prototype = new CKEDITOR.dom.domObject();\u000a\u000aCKEDITOR.tools.extend( CKEDITOR.dom.document.prototype, {\u000a	/**\u000a	 * The node type. This is a constant value set to {@link CKEDITOR#NODE_DOCUMENT}.\u000a	 *\u000a	 * @readonly\u000a	 * @property {Number} [=CKEDITOR.NODE_DOCUMENT]\u000a	 */\u000a	type: CKEDITOR.NODE_DOCUMENT,\u000a\u000a	/**\u000a	 * Appends a CSS file to the document.\u000a	 *\u000a	 *		CKEDITOR.document.appendStyleSheet( '/mystyles.css' );\u000a	 *\u000a	 * @param {String} cssFileUrl The CSS file URL.\u000a	 */\u000a	appendStyleSheet: function( cssFileUrl ) {\u000a		if ( this.$.createStyleSheet )\u000a			this.$.createStyleSheet( cssFileUrl );\u000a		else {\u000a			var link = new CKEDITOR.dom.element( 'link' );\u000a			link.setAttributes( {\u000a				rel: 'stylesheet',\u000a				type: 'text/css',\u000a				href: cssFileUrl\u000a			} );\u000a\u000a			this.getHead().append( link );\u000a		}\u000a	},\u000a\u000a	/**\u000a	 * Creates a CSS stylesheet and inserts it into the document.\u000a	 *\u000a	 * @param cssStyleText {String} CSS style text.\u000a	 * @returns {Object} The created DOM native stylesheet object.\u000a	 */\u000a	appendStyleText: function( cssStyleText ) {\u000a		if ( this.$.createStyleSheet ) {\u000a			var styleSheet = this.$.createStyleSheet( '' );\u000a			styleSheet.cssText = cssStyleText;\u000a		} else {\u000a			var style = new CKEDITOR.dom.element( 'style', this );\u000a			style.append( new CKEDITOR.dom.text( cssStyleText, this ) );\u000a			this.getHead().append( style );\u000a		}\u000a\u000a		return styleSheet || style.$.sheet;\u000a	},\u000a\u000a	/**\u000a	 * Creates a {@link CKEDITOR.dom.element} instance in this document.\u000a	 *\u000a	 * @param {String} name The name of the element.\u000a	 * @param {Object} [attributesAndStyles]\u000a	 * @param {Object} [attributesAndStyles.attributes] Attributes that will be set.\u000a	 * @param {Object} [attributesAndStyles.styles] Styles that will be set.\u000a	 * @returns {CKEDITOR.dom.element}\u000a	 */\u000a	createElement: function( name, attribsAndStyles ) {\u000a		var element = new CKEDITOR.dom.element( name, this );\u000a\u000a		if ( attribsAndStyles ) {\u000a			if ( attribsAndStyles.attributes )\u000a				element.setAttributes( attribsAndStyles.attributes );\u000a\u000a			if ( attribsAndStyles.styles )\u000a				element.setStyles( attribsAndStyles.styles );\u000a		}\u000a\u000a		return element;\u000a	},\u000a\u000a	/**\u000a	 * Creates a {@link CKEDITOR.dom.text} instance in this document.\u000a	 *\u000a	 * @param {String} text Value of the text node.\u000a	 * @returns {CKEDITOR.dom.element}\u000a	 */\u000a	createText: function( text ) {\u000a		return new CKEDITOR.dom.text( text, this );\u000a	},\u000a\u000a	/**\u000a	 * Moves the selection focus to this document's window.\u000a	 */\u000a	focus: function() {\u000a		this.getWindow().focus();\u000a	},\u000a\u000a	/**\u000a	 * Returns the element that is currently designated as the active element in the document.\u000a	 *\u000a	 * **Note:** Only one element can be active at a time in a document.\u000a	 * An active element does not necessarily have focus,\u000a	 * but an element with focus is always the active element in a document.\u000a	 *\u000a	 * @returns {CKEDITOR.dom.element} Active element or `null` if an IE8-9 bug is encountered.\u000a	 * See [#10030](http://dev.ckeditor.com/ticket/10030).\u000a	 */\u000a	getActive: function() {\u000a		var $active;\u000a		try {\u000a			$active = this.$.activeElement;\u000a		} catch ( e ) {\u000a			return null;\u000a		}\u000a		return new CKEDITOR.dom.element( $active );\u000a	},\u000a\u000a	/**\u000a	 * Gets an element based on its ID.\u000a	 *\u000a	 *		var element = CKEDITOR.document.getById( 'myElement' );\u000a	 *		alert( element.getId() ); // 'myElement'\u000a	 *\u000a	 * @param {String} elementId The element ID.\u000a	 * @returns {CKEDITOR.dom.element} The element instance, or `null` if not found.\u000a	 */\u000a	getById: function( elementId ) {\u000a		var $ = this.$.getElementById( elementId );\u000a		return $ ? new CKEDITOR.dom.element( $ ) : null;\u000a	},\u000a\u000a	/**\u000a	 * Gets a node based on its address. See {@link CKEDITOR.dom.node#getAddress}.\u000a	 *\u000a	 * @param {Array} address\u000a	 * @param {Boolean} [normalized=false]\u000a	 */\u000a	getByAddress: function( address, normalized ) {\u000a		var $ = this.$.documentElement;\u000a\u000a		for ( var i = 0; $ && i < address.length; i++ ) {\u000a			var target = address[ i ];\u000a\u000a			if ( !normalized ) {\u000a				$ = $.childNodes[ target ];\u000a				continue;\u000a			}\u000a\u000a			var currentIndex = -1;\u000a\u000a			for ( var j = 0; j < $.childNodes.length; j++ ) {\u000a				var candidate = $.childNodes[ j ];\u000a\u000a				if ( normalized === true && candidate.nodeType == 3 && candidate.previousSibling && candidate.previousSibling.nodeType == 3 )\u000a					continue;\u000a\u000a				currentIndex++;\u000a\u000a				if ( currentIndex == target ) {\u000a					$ = candidate;\u000a					break;\u000a				}\u000a			}\u000a		}\u000a\u000a		return $ ? new CKEDITOR.dom.node( $ ) : null;\u000a	},\u000a\u000a	/**\u000a	 * Gets elements list based on a given tag name.\u000a	 *\u000a	 * @param {String} tagName The element tag name.\u000a	 * @returns {CKEDITOR.dom.nodeList} The nodes list.\u000a	 */\u000a	getElementsByTag: function( tagName, namespace ) {\u000a		if ( !( CKEDITOR.env.ie && ( document.documentMode <= 8 ) ) && namespace )\u000a			tagName = namespace + ':' + tagName;\u000a		return new CKEDITOR.dom.nodeList( this.$.getElementsByTagName( tagName ) );\u000a	},\u000a\u000a	/**\u000a	 * Gets the `<head>` element for this document.\u000a	 *\u000a	 *		var element = CKEDITOR.document.getHead();\u000a	 *		alert( element.getName() ); // 'head'\u000a	 *\u000a	 * @returns {CKEDITOR.dom.element} The `<head>` element.\u000a	 */\u000a	getHead: function() {\u000a		var head = this.$.getElementsByTagName( 'head' )[ 0 ];\u000a		if ( !head )\u000a			head = this.getDocumentElement().append( new CKEDITOR.dom.element( 'head' ), true );\u000a		else\u000a			head = new CKEDITOR.dom.element( head );\u000a\u000a		return head;\u000a	},\u000a\u000a	/**\u000a	 * Gets the `<body>` element for this document.\u000a	 *\u000a	 *		var element = CKEDITOR.document.getBody();\u000a	 *		alert( element.getName() ); // 'body'\u000a	 *\u000a	 * @returns {CKEDITOR.dom.element} The `<body>` element.\u000a	 */\u000a	getBody: function() {\u000a		return new CKEDITOR.dom.element( this.$.body );\u000a	},\u000a\u000a	/**\u000a	 * Gets the DOM document element for this document.\u000a	 *\u000a	 * @returns {CKEDITOR.dom.element} The DOM document element.\u000a	 */\u000a	getDocumentElement: function() {\u000a		return new CKEDITOR.dom.element( this.$.documentElement );\u000a	},\u000a\u000a	/**\u000a	 * Gets the window object that stores this document.\u000a	 *\u000a	 * @returns {CKEDITOR.dom.window} The window object.\u000a	 */\u000a	getWindow: function() {\u000a		return new CKEDITOR.dom.window( this.$.parentWindow || this.$.defaultView );\u000a	},\u000a\u000a	/**\u000a	 * Defines the document content through `document.write`. Note that the\u000a	 * previous document content will be lost (cleaned).\u000a	 *\u000a	 *		document.write(\u000a	 *			'<html>' +\u000a	 *				'<head><title>Sample Document</title></head>' +\u000a	 *				'<body>Document content created by code.</body>' +\u000a	 *			'</html>'\u000a	 *		);\u000a	 *\u000a	 * @since 3.5\u000a	 * @param {String} html The HTML defining the document content.\u000a	 */\u000a	write: function( html ) {\u000a		// Don't leave any history log in IE. (#5657)\u000a		this.$.open( 'text/html', 'replace' );\u000a\u000a		// Support for custom document.domain in IE.\u000a		//\u000a		// The script must be appended because if placed before the\u000a		// doctype, IE will go into quirks mode and mess with\u000a		// the editable, e.g. by changing its default height.\u000a		if ( CKEDITOR.env.ie )\u000a			html = html.replace( /(?:^\u005cs*<!DOCTYPE[^>]*?>)|^/i, '$&\u005cn<script data-cke-temp="1">(' + CKEDITOR.tools.fixDomain + ')();</script>' );\u000a\u000a		this.$.write( html );\u000a		this.$.close();\u000a	},\u000a\u000a	/**\u000a	 * Wrapper for `querySelectorAll`. Returns a list of elements within this document that match\u000a	 * the specified `selector`.\u000a	 *\u000a	 * **Note:** The returned list is not a live collection (like the result of native `querySelectorAll`).\u000a	 *\u000a	 * @since 4.3\u000a	 * @param {String} selector\u000a	 * @returns {CKEDITOR.dom.nodeList}\u000a	 */\u000a	find: function( selector ) {\u000a		return new CKEDITOR.dom.nodeList( this.$.querySelectorAll( selector ) );\u000a	},\u000a\u000a	/**\u000a	 * Wrapper for `querySelector`. Returns the first element within this document that matches\u000a	 * the specified `selector`.\u000a	 *\u000a	 * @since 4.3\u000a	 * @param {String} selector\u000a	 * @returns {CKEDITOR.dom.element}\u000a	 */\u000a	findOne: function( selector ) {\u000a		var el = this.$.querySelector( selector );\u000a\u000a		return el ? new CKEDITOR.dom.element( el ) : null;\u000a	},\u000a\u000a	/**\u000a	 * Internet Explorer 8 only method. It returns a document fragment which has all HTML5 elements enabled.\u000a	 *\u000a	 * @since 4.3\u000a	 * @private\u000a	 * @returns DocumentFragment\u000a	 */\u000a	_getHtml5ShivFrag: function() {\u000a		var $frag = this.getCustomData( 'html5ShivFrag' );\u000a\u000a		if ( !$frag ) {\u000a			$frag = this.$.createDocumentFragment();\u000a			CKEDITOR.tools.enableHtml5Elements( $frag, true );\u000a			this.setCustomData( 'html5ShivFrag', $frag );\u000a		}\u000a\u000a		return $frag;\u000a	}\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * Represents a list of {@link CKEDITOR.dom.node} objects.\u000a * It's a wrapper for native nodes list.\u000a *\u000a *		var nodeList = CKEDITOR.document.getBody().getChildren();\u000a *		alert( nodeList.count() ); // number [0;N]\u000a *\u000a * @class\u000a * @constructor Creates a document class instance.\u000a * @param {Object} nativeList\u000a */\u000aCKEDITOR.dom.nodeList = function( nativeList ) {\u000a	this.$ = nativeList;\u000a};\u000a\u000aCKEDITOR.dom.nodeList.prototype = {\u000a	/**\u000a	 * Get count of nodes in this list.\u000a	 *\u000a	 * @returns {Number}\u000a	 */\u000a	count: function() {\u000a		return this.$.length;\u000a	},\u000a\u000a	/**\u000a	 * Get node from the list.\u000a	 *\u000a	 * @returns {CKEDITOR.dom.node}\u000a	 */\u000a	getItem: function( index ) {\u000a		if ( index < 0 || index >= this.$.length )\u000a			return null;\u000a\u000a		var $node = this.$[ index ];\u000a		return $node ? new CKEDITOR.dom.node( $node ) : null;\u000a	}\u000a};\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.dom.element} class, which\u000a *		represents a DOM element.\u000a */\u000a\u000a/**\u000a * Represents a DOM element.\u000a *\u000a *		// Create a new <span> element.\u000a *		var element = new CKEDITOR.dom.element( 'span' );\u000a *\u000a *		// Create an element based on a native DOM element.\u000a *		var element = new CKEDITOR.dom.element( document.getElementById( 'myId' ) );\u000a *\u000a * @class\u000a * @extends CKEDITOR.dom.node\u000a * @constructor Creates an element class instance.\u000a * @param {Object/String} element A native DOM element or the element name for\u000a * new elements.\u000a * @param {CKEDITOR.dom.document} [ownerDocument] The document that will contain\u000a * the element in case of element creation.\u000a */\u000aCKEDITOR.dom.element = function( element, ownerDocument ) {\u000a	if ( typeof element == 'string' )\u000a		element = ( ownerDocument ? ownerDocument.$ : document ).createElement( element );\u000a\u000a	// Call the base constructor (we must not call CKEDITOR.dom.node).\u000a	CKEDITOR.dom.domObject.call( this, element );\u000a};\u000a\u000a// PACKAGER_RENAME( CKEDITOR.dom.element )\u000a/**\u000a * The the {@link CKEDITOR.dom.element} representing and element. If the\u000a * element is a native DOM element, it will be transformed into a valid\u000a * CKEDITOR.dom.element object.\u000a *\u000a *		var element = new CKEDITOR.dom.element( 'span' );\u000a *		alert( element == CKEDITOR.dom.element.get( element ) ); // true\u000a *\u000a *		var element = document.getElementById( 'myElement' );\u000a *		alert( CKEDITOR.dom.element.get( element ).getName() ); // (e.g.) 'p'\u000a *\u000a * @static\u000a * @param {String/Object} element Element's id or name or native DOM element.\u000a * @returns {CKEDITOR.dom.element} The transformed element.\u000a */\u000aCKEDITOR.dom.element.get = function( element ) {\u000a	var el = typeof element == 'string' ? document.getElementById( element ) || document.getElementsByName( element )[ 0 ] : element;\u000a\u000a	return el && ( el.$ ? el : new CKEDITOR.dom.element( el ) );\u000a};\u000a\u000aCKEDITOR.dom.element.prototype = new CKEDITOR.dom.node();\u000a\u000a/**\u000a * Creates an instance of the {@link CKEDITOR.dom.element} class based on the\u000a * HTML representation of an element.\u000a *\u000a *		var element = CKEDITOR.dom.element.createFromHtml( '<strong class="anyclass">My element</strong>' );\u000a *		alert( element.getName() ); // 'strong'\u000a *\u000a * @static\u000a * @param {String} html The element HTML. It should define only one element in\u000a * the "root" level. The "root" element can have child nodes, but not siblings.\u000a * @returns {CKEDITOR.dom.element} The element instance.\u000a */\u000aCKEDITOR.dom.element.createFromHtml = function( html, ownerDocument ) {\u000a	var temp = new CKEDITOR.dom.element( 'div', ownerDocument );\u000a	temp.setHtml( html );\u000a\u000a	// When returning the node, remove it from its parent to detach it.\u000a	return temp.getFirst().remove();\u000a};\u000a\u000a/**\u000a * @static\u000a * @todo\u000a */\u000aCKEDITOR.dom.element.setMarker = function( database, element, name, value ) {\u000a	var id = element.getCustomData( 'list_marker_id' ) || ( element.setCustomData( 'list_marker_id', CKEDITOR.tools.getNextNumber() ).getCustomData( 'list_marker_id' ) ),\u000a		markerNames = element.getCustomData( 'list_marker_names' ) || ( element.setCustomData( 'list_marker_names', {} ).getCustomData( 'list_marker_names' ) );\u000a	database[ id ] = element;\u000a	markerNames[ name ] = 1;\u000a\u000a	return element.setCustomData( name, value );\u000a};\u000a\u000a/**\u000a * @static\u000a * @todo\u000a */\u000aCKEDITOR.dom.element.clearAllMarkers = function( database ) {\u000a	for ( var i in database )\u000a		CKEDITOR.dom.element.clearMarkers( database, database[ i ], 1 );\u000a};\u000a\u000a/**\u000a * @static\u000a * @todo\u000a */\u000aCKEDITOR.dom.element.clearMarkers = function( database, element, removeFromDatabase ) {\u000a	var names = element.getCustomData( 'list_marker_names' ),\u000a		id = element.getCustomData( 'list_marker_id' );\u000a	for ( var i in names )\u000a		element.removeCustomData( i );\u000a	element.removeCustomData( 'list_marker_names' );\u000a	if ( removeFromDatabase ) {\u000a		element.removeCustomData( 'list_marker_id' );\u000a		delete database[ id ];\u000a	}\u000a};\u000a\u000a( function() {\u000a	CKEDITOR.tools.extend( CKEDITOR.dom.element.prototype, {\u000a		/**\u000a		 * The node type. This is a constant value set to {@link CKEDITOR#NODE_ELEMENT}.\u000a		 *\u000a		 * @readonly\u000a		 * @property {Number} [=CKEDITOR.NODE_ELEMENT]\u000a		 */\u000a		type: CKEDITOR.NODE_ELEMENT,\u000a\u000a		/**\u000a		 * Adds a CSS class to the element. It appends the class to the\u000a		 * already existing names.\u000a		 *\u000a		 *		var element = new CKEDITOR.dom.element( 'div' );\u000a		 *		element.addClass( 'classA' ); // <div class="classA">\u000a		 *		element.addClass( 'classB' ); // <div class="classA classB">\u000a		 *		element.addClass( 'classA' ); // <div class="classA classB">\u000a		 *\u000a		 * @chainable\u000a		 * @param {String} className The name of the class to be added.\u000a		 */\u000a		addClass: function( className ) {\u000a			var c = this.$.className;\u000a			if ( c ) {\u000a				var regex = new RegExp( '(?:^|\u005c\u005cs)' + className + '(?:\u005c\u005cs|$)', '' );\u000a				if ( !regex.test( c ) )\u000a					c += ' ' + className;\u000a			}\u000a			this.$.className = c || className;\u000a\u000a			return this;\u000a		},\u000a\u000a		/**\u000a		 * Removes a CSS class name from the elements classes. Other classes\u000a		 * remain untouched.\u000a		 *\u000a		 *		var element = new CKEDITOR.dom.element( 'div' );\u000a		 *		element.addClass( 'classA' );		// <div class="classA">\u000a		 *		element.addClass( 'classB' );		// <div class="classA classB">\u000a		 *		element.removeClass( 'classA' );	// <div class="classB">\u000a		 *		element.removeClass( 'classB' );	// <div>\u000a		 *\u000a		 * @chainable\u000a		 * @param {String} className The name of the class to remove.\u000a		 */\u000a		removeClass: function( className ) {\u000a			var c = this.getAttribute( 'class' );\u000a			if ( c ) {\u000a				var regex = new RegExp( '(?:^|\u005c\u005cs+)' + className + '(?=\u005c\u005cs|$)', 'i' );\u000a				if ( regex.test( c ) ) {\u000a					c = c.replace( regex, '' ).replace( /^\u005cs+/, '' );\u000a\u000a					if ( c )\u000a						this.setAttribute( 'class', c );\u000a					else\u000a						this.removeAttribute( 'class' );\u000a				}\u000a			}\u000a\u000a			return this;\u000a		},\u000a\u000a		/**\u000a		 * Checks if element has class name.\u000a		 *\u000a		 * @param {String} className\u000a		 * @returns {Boolean}\u000a		 */\u000a		hasClass: function( className ) {\u000a			var regex = new RegExp( '(?:^|\u005c\u005cs+)' + className + '(?=\u005c\u005cs|$)', '' );\u000a			return regex.test( this.getAttribute( 'class' ) );\u000a		},\u000a\u000a		/**\u000a		 * Append a node as a child of this element.\u000a		 *\u000a		 *		var p = new CKEDITOR.dom.element( 'p' );\u000a		 *\u000a		 *		var strong = new CKEDITOR.dom.element( 'strong' );\u000a		 *		p.append( strong );\u000a		 *\u000a		 *		var em = p.append( 'em' );\u000a		 *\u000a		 *		// Result: '<p><strong></strong><em></em></p>'\u000a		 *\u000a		 * @param {CKEDITOR.dom.node/String} node The node or element name to be appended.\u000a		 * @param {Boolean} [toStart=false] Indicates that the element is to be appended at the start.\u000a		 * @returns {CKEDITOR.dom.node} The appended node.\u000a		 */\u000a		append: function( node, toStart ) {\u000a			if ( typeof node == 'string' )\u000a				node = this.getDocument().createElement( node );\u000a\u000a			if ( toStart )\u000a				this.$.insertBefore( node.$, this.$.firstChild );\u000a			else\u000a				this.$.appendChild( node.$ );\u000a\u000a			return node;\u000a		},\u000a\u000a		/**\u000a		 * Append HTML as a child(ren) of this element.\u000a		 *\u000a		 * @param {String} html\u000a		 */\u000a		appendHtml: function( html ) {\u000a			if ( !this.$.childNodes.length )\u000a				this.setHtml( html );\u000a			else {\u000a				var temp = new CKEDITOR.dom.element( 'div', this.getDocument() );\u000a				temp.setHtml( html );\u000a				temp.moveChildren( this );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Append text to this element.\u000a		 *\u000a		 *		var p = new CKEDITOR.dom.element( 'p' );\u000a		 *		p.appendText( 'This is' );\u000a		 *		p.appendText( ' some text' );\u000a		 *\u000a		 *		// Result: '<p>This is some text</p>'\u000a		 *\u000a		 * @param {String} text The text to be appended.\u000a		 * @returns {CKEDITOR.dom.node} The appended node.\u000a		 */\u000a		appendText: function( text ) {\u000a			if ( this.$.text != null )\u000a				this.$.text += text;\u000a			else\u000a				this.append( new CKEDITOR.dom.text( text ) );\u000a		},\u000a\u000a		/**\u000a		 * Appends a `<br>` filler element to this element if the filler is not present already.\u000a		 * By default filler is appended only if {@link CKEDITOR.env#needsBrFiller} is `true`,\u000a		 * however when `force` is set to `true` filler will be appended regardless of the environment.\u000a		 *\u000a		 * @param {Boolean} [force] Append filler regardless of the environment.\u000a		 */\u000a		appendBogus: function( force ) {\u000a			if ( !force && !CKEDITOR.env.needsBrFiller )\u000a				return;\u000a\u000a			var lastChild = this.getLast();\u000a\u000a			// Ignore empty/spaces text.\u000a			while ( lastChild && lastChild.type == CKEDITOR.NODE_TEXT && !CKEDITOR.tools.rtrim( lastChild.getText() ) )\u000a				lastChild = lastChild.getPrevious();\u000a			if ( !lastChild || !lastChild.is || !lastChild.is( 'br' ) ) {\u000a				var bogus = this.getDocument().createElement( 'br' );\u000a\u000a				CKEDITOR.env.gecko && bogus.setAttribute( 'type', '_moz' );\u000a\u000a				this.append( bogus );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Breaks one of the ancestor element in the element position, moving\u000a		 * this element between the broken parts.\u000a		 *\u000a		 *		// Before breaking:\u000a		 *		//		<b>This <i>is some<span /> sample</i> test text</b>\u000a		 *		// If "element" is <span /> and "parent" is <i>:\u000a		 *		//		<b>This <i>is some</i><span /><i> sample</i> test text</b>\u000a		 *		element.breakParent( parent );\u000a		 *\u000a		 *		// Before breaking:\u000a		 *		//		<b>This <i>is some<span /> sample</i> test text</b>\u000a		 *		// If "element" is <span /> and "parent" is <b>:\u000a		 *		//		<b>This <i>is some</i></b><span /><b><i> sample</i> test text</b>\u000a		 *		element.breakParent( parent );\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} parent The anscestor element to get broken.\u000a		 */\u000a		breakParent: function( parent ) {\u000a			var range = new CKEDITOR.dom.range( this.getDocument() );\u000a\u000a			// We'll be extracting part of this element, so let's use our\u000a			// range to get the correct piece.\u000a			range.setStartAfter( this );\u000a			range.setEndAfter( parent );\u000a\u000a			// Extract it.\u000a			var docFrag = range.extractContents();\u000a\u000a			// Move the element outside the broken element.\u000a			range.insertNode( this.remove() );\u000a\u000a			// Re-insert the extracted piece after the element.\u000a			docFrag.insertAfterNode( this );\u000a		},\u000a\u000a		/**\u000a		 * Checks if this element contains given node.\u000a		 *\u000a		 * @method\u000a		 * @param {CKEDITOR.dom.node} node\u000a		 * @returns {Boolean}\u000a		 */\u000a		contains: CKEDITOR.env.ie || CKEDITOR.env.webkit ?\u000a			function( node ) {\u000a				var $ = this.$;\u000a\u000a				return node.type != CKEDITOR.NODE_ELEMENT ? $.contains( node.getParent().$ ) : $ != node.$ && $.contains( node.$ );\u000a			} : function( node ) {\u000a				return !!( this.$.compareDocumentPosition( node.$ ) & 16 );\u000a			},\u000a\u000a		/**\u000a		 * Moves the selection focus to this element.\u000a		 *\u000a		 *		var element = CKEDITOR.document.getById( 'myTextarea' );\u000a		 *		element.focus();\u000a		 *\u000a		 * @method\u000a		 * @param  {Boolean} defer Whether to asynchronously defer the\u000a		 * execution by 100 ms.\u000a		 */\u000a		focus: ( function() {\u000a			function exec() {\u000a				// IE throws error if the element is not visible.\u000a				try {\u000a					this.$.focus();\u000a				} catch ( e ) {}\u000a			}\u000a\u000a			return function( defer ) {\u000a				if ( defer )\u000a					CKEDITOR.tools.setTimeout( exec, 100, this );\u000a				else\u000a					exec.call( this );\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Gets the inner HTML of this element.\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<div><b>Example</b></div>' );\u000a		 *		alert( element.getHtml() ); // '<b>Example</b>'\u000a		 *\u000a		 * @returns {String} The inner HTML of this element.\u000a		 */\u000a		getHtml: function() {\u000a			var retval = this.$.innerHTML;\u000a			// Strip <?xml:namespace> tags in IE. (#3341).\u000a			return CKEDITOR.env.ie ? retval.replace( /<\u005c?[^>]*>/g, '' ) : retval;\u000a		},\u000a\u000a		/**\u000a		 * Gets the outer (inner plus tags) HTML of this element.\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<div class="bold"><b>Example</b></div>' );\u000a		 *		alert( element.getOuterHtml() ); // '<div class="bold"><b>Example</b></div>'\u000a		 *\u000a		 * @returns {String} The outer HTML of this element.\u000a		 */\u000a		getOuterHtml: function() {\u000a			if ( this.$.outerHTML ) {\u000a				// IE includes the <?xml:namespace> tag in the outerHTML of\u000a				// namespaced element. So, we must strip it here. (#3341)\u000a				return this.$.outerHTML.replace( /<\u005c?[^>]*>/, '' );\u000a			}\u000a\u000a			var tmpDiv = this.$.ownerDocument.createElement( 'div' );\u000a			tmpDiv.appendChild( this.$.cloneNode( true ) );\u000a			return tmpDiv.innerHTML;\u000a		},\u000a\u000a		/**\u000a		 * Retrieve the bounding rectangle of the current element, in pixels,\u000a		 * relative to the upper-left corner of the browser's client area.\u000a		 *\u000a		 * @returns {Object} The dimensions of the DOM element including\u000a		 * `left`, `top`, `right`, `bottom`, `width` and `height`.\u000a		 */\u000a		getClientRect: function() {\u000a			// http://help.dottoro.com/ljvmcrrn.php\u000a			var rect = CKEDITOR.tools.extend( {}, this.$.getBoundingClientRect() );\u000a\u000a			!rect.width && ( rect.width = rect.right - rect.left );\u000a			!rect.height && ( rect.height = rect.bottom - rect.top );\u000a\u000a			return rect;\u000a		},\u000a\u000a		/**\u000a		 * Sets the inner HTML of this element.\u000a		 *\u000a		 *		var p = new CKEDITOR.dom.element( 'p' );\u000a		 *		p.setHtml( '<b>Inner</b> HTML' );\u000a		 *\u000a		 *		// Result: '<p><b>Inner</b> HTML</p>'\u000a		 *\u000a		 * @method\u000a		 * @param {String} html The HTML to be set for this element.\u000a		 * @returns {String} The inserted HTML.\u000a		 */\u000a		setHtml: ( CKEDITOR.env.ie && CKEDITOR.env.version < 9 ) ?\u000a				// old IEs throws error on HTML manipulation (through the "innerHTML" property)\u000a				// on the element which resides in an DTD invalid position,  e.g. <span><div></div></span>\u000a				// fortunately it can be worked around with DOM manipulation.\u000a				function( html ) {\u000a					try {\u000a						var $ = this.$;\u000a\u000a						// Fix the case when setHtml is called on detached element.\u000a						// HTML5 shiv used for document in which this element was created\u000a						// won't affect that detached element. So get document fragment with\u000a						// all HTML5 elements enabled and set innerHTML while this element is appended to it.\u000a						if ( this.getParent() )\u000a							return ( $.innerHTML = html );\u000a						else {\u000a							var $frag = this.getDocument()._getHtml5ShivFrag();\u000a							$frag.appendChild( $ );\u000a							$.innerHTML = html;\u000a							$frag.removeChild( $ );\u000a\u000a							return html;\u000a						}\u000a					}\u000a					catch ( e ) {\u000a						this.$.innerHTML = '';\u000a\u000a						var temp = new CKEDITOR.dom.element( 'body', this.getDocument() );\u000a						temp.$.innerHTML = html;\u000a\u000a						var children = temp.getChildren();\u000a						while ( children.count() )\u000a							this.append( children.getItem( 0 ) );\u000a\u000a						return html;\u000a					}\u000a				}\u000a			:\u000a				function( html ) {\u000a					return ( this.$.innerHTML = html );\u000a				},\u000a\u000a		/**\u000a		 * Sets the element contents as plain text.\u000a		 *\u000a		 *		var element = new CKEDITOR.dom.element( 'div' );\u000a		 *		element.setText( 'A > B & C < D' );\u000a		 *		alert( element.innerHTML ); // 'A &gt; B &amp; C &lt; D'\u000a		 *\u000a		 * @param {String} text The text to be set.\u000a		 * @returns {String} The inserted text.\u000a		 */\u000a		setText: ( function() {\u000a			var supportsTextContent = document.createElement( 'p' );\u000a			supportsTextContent.innerHTML = 'x';\u000a			supportsTextContent = supportsTextContent.textContent;\u000a\u000a			return function( text ) {\u000a				this.$[ supportsTextContent ? 'textContent' : 'innerText' ] = text;\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Gets the value of an element attribute.\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<input type="text" />' );\u000a		 *		alert( element.getAttribute( 'type' ) ); // 'text'\u000a		 *\u000a		 * @method\u000a		 * @param {String} name The attribute name.\u000a		 * @returns {String} The attribute value or null if not defined.\u000a		 */\u000a		getAttribute: ( function() {\u000a			var standard = function( name ) {\u000a					return this.$.getAttribute( name, 2 );\u000a				};\u000a\u000a			if ( CKEDITOR.env.ie && ( CKEDITOR.env.ie7Compat || CKEDITOR.env.quirks ) ) {\u000a				return function( name ) {\u000a					switch ( name ) {\u000a						case 'class':\u000a							name = 'className';\u000a							break;\u000a\u000a						case 'http-equiv':\u000a							name = 'httpEquiv';\u000a							break;\u000a\u000a						case 'name':\u000a							return this.$.name;\u000a\u000a						case 'tabindex':\u000a							var tabIndex = standard.call( this, name );\u000a\u000a							// IE returns tabIndex=0 by default for all\u000a							// elements. For those elements,\u000a							// getAtrribute( 'tabindex', 2 ) returns 32768\u000a							// instead. So, we must make this check to give a\u000a							// uniform result among all browsers.\u000a							if ( tabIndex !== 0 && this.$.tabIndex === 0 )\u000a								tabIndex = null;\u000a\u000a							return tabIndex;\u000a\u000a						case 'checked':\u000a							var attr = this.$.attributes.getNamedItem( name ),\u000a								attrValue = attr.specified ? attr.nodeValue // For value given by parser.\u000a								: this.$.checked; // For value created via DOM interface.\u000a\u000a							return attrValue ? 'checked' : null;\u000a\u000a						case 'hspace':\u000a						case 'value':\u000a							return this.$[ name ];\u000a\u000a						case 'style':\u000a							// IE does not return inline styles via getAttribute(). See #2947.\u000a							return this.$.style.cssText;\u000a\u000a						case 'contenteditable':\u000a						case 'contentEditable':\u000a							return this.$.attributes.getNamedItem( 'contentEditable' ).specified ? this.$.getAttribute( 'contentEditable' ) : null;\u000a					}\u000a\u000a					return standard.call( this, name );\u000a				};\u000a			} else {\u000a				return standard;\u000a			}\u000a		} )(),\u000a\u000a		/**\u000a		 * Gets the nodes list containing all children of this element.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.nodeList}\u000a		 */\u000a		getChildren: function() {\u000a			return new CKEDITOR.dom.nodeList( this.$.childNodes );\u000a		},\u000a\u000a		/**\u000a		 * Gets the current computed value of one of the element CSS style\u000a		 * properties.\u000a		 *\u000a		 *		var element = new CKEDITOR.dom.element( 'span' );\u000a		 *		alert( element.getComputedStyle( 'display' ) ); // 'inline'\u000a		 *\u000a		 * @method\u000a		 * @param {String} propertyName The style property name.\u000a		 * @returns {String} The property value.\u000a		 */\u000a		getComputedStyle: CKEDITOR.env.ie ?\u000a			function( propertyName ) {\u000a				return this.$.currentStyle[ CKEDITOR.tools.cssStyleToDomStyle( propertyName ) ];\u000a			} : function( propertyName ) {\u000a				var style = this.getWindow().$.getComputedStyle( this.$, null );\u000a				// Firefox may return null if we call the above on a hidden iframe. (#9117)\u000a				return style ? style.getPropertyValue( propertyName ) : '';\u000a			},\u000a\u000a		/**\u000a		 * Gets the DTD entries for this element.\u000a		 *\u000a		 * @returns {Object} An object containing the list of elements accepted\u000a		 * by this element.\u000a		 */\u000a		getDtd: function() {\u000a			var dtd = CKEDITOR.dtd[ this.getName() ];\u000a\u000a			this.getDtd = function() {\u000a				return dtd;\u000a			};\u000a\u000a			return dtd;\u000a		},\u000a\u000a		/**\u000a		 * Gets all this element's descendants having given tag name.\u000a		 *\u000a		 * @method\u000a		 * @param {String} tagName\u000a		 */\u000a		getElementsByTag: CKEDITOR.dom.document.prototype.getElementsByTag,\u000a\u000a		/**\u000a		 * Gets the computed tabindex for this element.\u000a		 *\u000a		 *		var element = CKEDITOR.document.getById( 'myDiv' );\u000a		 *		alert( element.getTabIndex() ); // (e.g.) '-1'\u000a		 *\u000a		 * @method\u000a		 * @returns {Number} The tabindex value.\u000a		 */\u000a		getTabIndex: CKEDITOR.env.ie ?\u000a			function() {\u000a				var tabIndex = this.$.tabIndex;\u000a\u000a				// IE returns tabIndex=0 by default for all elements. In\u000a				// those cases we must check that the element really has\u000a				// the tabindex attribute set to zero, or it is one of\u000a				// those element that should have zero by default.\u000a				if ( tabIndex === 0 && !CKEDITOR.dtd.$tabIndex[ this.getName() ] && parseInt( this.getAttribute( 'tabindex' ), 10 ) !== 0 )\u000a					tabIndex = -1;\u000a\u000a				return tabIndex;\u000a			} : CKEDITOR.env.webkit ?\u000a			function() {\u000a				var tabIndex = this.$.tabIndex;\u000a\u000a				// Safari returns "undefined" for elements that should not\u000a				// have tabindex (like a div). So, we must try to get it\u000a				// from the attribute.\u000a				// https://bugs.webkit.org/show_bug.cgi?id=20596\u000a				if ( tabIndex === undefined ) {\u000a					tabIndex = parseInt( this.getAttribute( 'tabindex' ), 10 );\u000a\u000a					// If the element don't have the tabindex attribute,\u000a					// then we should return -1.\u000a					if ( isNaN( tabIndex ) )\u000a						tabIndex = -1;\u000a				}\u000a\u000a				return tabIndex;\u000a			} : function() {\u000a				return this.$.tabIndex;\u000a			},\u000a\u000a		/**\u000a		 * Gets the text value of this element.\u000a		 *\u000a		 * Only in IE (which uses innerText), `<br>` will cause linebreaks,\u000a		 * and sucessive whitespaces (including line breaks) will be reduced to\u000a		 * a single space. This behavior is ok for us, for now. It may change\u000a		 * in the future.\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<div>Sample <i>text</i>.</div>' );\u000a		 *		alert( <b>element.getText()</b> ); // 'Sample text.'\u000a		 *\u000a		 * @returns {String} The text value.\u000a		 */\u000a		getText: function() {\u000a			return this.$.textContent || this.$.innerText || '';\u000a		},\u000a\u000a		/**\u000a		 * Gets the window object that contains this element.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.window} The window object.\u000a		 */\u000a		getWindow: function() {\u000a			return this.getDocument().getWindow();\u000a		},\u000a\u000a		/**\u000a		 * Gets the value of the `id` attribute of this element.\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<p id="myId"></p>' );\u000a		 *		alert( element.getId() ); // 'myId'\u000a		 *\u000a		 * @returns {String} The element id, or null if not available.\u000a		 */\u000a		getId: function() {\u000a			return this.$.id || null;\u000a		},\u000a\u000a		/**\u000a		 * Gets the value of the `name` attribute of this element.\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<input name="myName"></input>' );\u000a		 *		alert( <b>element.getNameAtt()</b> ); // 'myName'\u000a		 *\u000a		 * @returns {String} The element name, or null if not available.\u000a		 */\u000a		getNameAtt: function() {\u000a			return this.$.name || null;\u000a		},\u000a\u000a		/**\u000a		 * Gets the element name (tag name). The returned name is guaranteed to\u000a		 * be always full lowercased.\u000a		 *\u000a		 *		var element = new CKEDITOR.dom.element( 'span' );\u000a		 *		alert( element.getName() ); // 'span'\u000a		 *\u000a		 * @returns {String} The element name.\u000a		 */\u000a		getName: function() {\u000a			// Cache the lowercased name inside a closure.\u000a			var nodeName = this.$.nodeName.toLowerCase();\u000a\u000a			if ( CKEDITOR.env.ie && ( document.documentMode <= 8 ) ) {\u000a				var scopeName = this.$.scopeName;\u000a				if ( scopeName != 'HTML' )\u000a					nodeName = scopeName.toLowerCase() + ':' + nodeName;\u000a			}\u000a\u000a			this.getName = function() {\u000a				return nodeName;\u000a			};\u000a\u000a			return this.getName();\u000a		},\u000a\u000a		/**\u000a		 * Gets the value set to this element. This value is usually available\u000a		 * for form field elements.\u000a		 *\u000a		 * @returns {String} The element value.\u000a		 */\u000a		getValue: function() {\u000a			return this.$.value;\u000a		},\u000a\u000a		/**\u000a		 * Gets the first child node of this element.\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<div><b>Example</b></div>' );\u000a		 *		var first = element.getFirst();\u000a		 *		alert( first.getName() ); // 'b'\u000a		 *\u000a		 * @param {Function} evaluator Filtering the result node.\u000a		 * @returns {CKEDITOR.dom.node} The first child node or null if not available.\u000a		 */\u000a		getFirst: function( evaluator ) {\u000a			var first = this.$.firstChild,\u000a				retval = first && new CKEDITOR.dom.node( first );\u000a			if ( retval && evaluator && !evaluator( retval ) )\u000a				retval = retval.getNext( evaluator );\u000a\u000a			return retval;\u000a		},\u000a\u000a		/**\u000a		 * See {@link #getFirst}.\u000a		 *\u000a		 * @param {Function} evaluator Filtering the result node.\u000a		 * @returns {CKEDITOR.dom.node}\u000a		 */\u000a		getLast: function( evaluator ) {\u000a			var last = this.$.lastChild,\u000a				retval = last && new CKEDITOR.dom.node( last );\u000a			if ( retval && evaluator && !evaluator( retval ) )\u000a				retval = retval.getPrevious( evaluator );\u000a\u000a			return retval;\u000a		},\u000a\u000a		/**\u000a		 * Gets CSS style value.\u000a		 *\u000a		 * @param {String} name The CSS property name.\u000a		 * @returns {String} Style value.\u000a		 */\u000a		getStyle: function( name ) {\u000a			return this.$.style[ CKEDITOR.tools.cssStyleToDomStyle( name ) ];\u000a		},\u000a\u000a		/**\u000a		 * Checks if the element name matches the specified criteria.\u000a		 *\u000a		 *		var element = new CKEDITOR.element( 'span' );\u000a		 *		alert( element.is( 'span' ) );			// true\u000a		 *		alert( element.is( 'p', 'span' ) );		// true\u000a		 *		alert( element.is( 'p' ) );				// false\u000a		 *		alert( element.is( 'p', 'div' ) );		// false\u000a		 *		alert( element.is( { p:1,span:1 } ) );	// true\u000a		 *\u000a		 * @param {String.../Object} name One or more names to be checked, or a {@link CKEDITOR.dtd} object.\u000a		 * @returns {Boolean} `true` if the element name matches any of the names.\u000a		 */\u000a		is: function() {\u000a			var name = this.getName();\u000a\u000a			// Check against the specified DTD liternal.\u000a			if ( typeof arguments[ 0 ] == 'object' )\u000a				return !!arguments[ 0 ][ name ];\u000a\u000a			// Check for tag names\u000a			for ( var i = 0; i < arguments.length; i++ ) {\u000a				if ( arguments[ i ] == name )\u000a					return true;\u000a			}\u000a			return false;\u000a		},\u000a\u000a		/**\u000a		 * Decide whether one element is able to receive cursor.\u000a		 *\u000a		 * @param {Boolean} [textCursor=true] Only consider element that could receive text child.\u000a		 */\u000a		isEditable: function( textCursor ) {\u000a			var name = this.getName();\u000a\u000a			if ( this.isReadOnly() || this.getComputedStyle( 'display' ) == 'none' ||\u000a				this.getComputedStyle( 'visibility' ) == 'hidden' ||\u000a				CKEDITOR.dtd.$nonEditable[ name ] ||\u000a				CKEDITOR.dtd.$empty[ name ] ||\u000a				( this.is( 'a' ) &&\u000a					( this.data( 'cke-saved-name' ) || this.hasAttribute( 'name' ) ) &&\u000a					!this.getChildCount()\u000a				) ) {\u000a				return false;\u000a			}\u000a\u000a			if ( textCursor !== false ) {\u000a				// Get the element DTD (defaults to span for unknown elements).\u000a				var dtd = CKEDITOR.dtd[ name ] || CKEDITOR.dtd.span;\u000a				// In the DTD # == text node.\u000a				return !!( dtd && dtd[ '#' ] );\u000a			}\u000a\u000a			return true;\u000a		},\u000a\u000a		/**\u000a		 * Compare this element's inner html, tag name, attributes, etc. with other one.\u000a		 *\u000a		 * See [W3C's DOM Level 3 spec - node#isEqualNode](http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-isEqualNode)\u000a		 * for more details.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} otherElement Element to compare.\u000a		 * @returns {Boolean}\u000a		 */\u000a		isIdentical: function( otherElement ) {\u000a			// do shallow clones, but with IDs\u000a			var thisEl = this.clone( 0, 1 ),\u000a				otherEl = otherElement.clone( 0, 1 );\u000a\u000a			// Remove distractions.\u000a			thisEl.removeAttributes( [ '_moz_dirty', 'data-cke-expando', 'data-cke-saved-href', 'data-cke-saved-name' ] );\u000a			otherEl.removeAttributes( [ '_moz_dirty', 'data-cke-expando', 'data-cke-saved-href', 'data-cke-saved-name' ] );\u000a\u000a			// Native comparison available.\u000a			if ( thisEl.$.isEqualNode ) {\u000a				// Styles order matters.\u000a				thisEl.$.style.cssText = CKEDITOR.tools.normalizeCssText( thisEl.$.style.cssText );\u000a				otherEl.$.style.cssText = CKEDITOR.tools.normalizeCssText( otherEl.$.style.cssText );\u000a				return thisEl.$.isEqualNode( otherEl.$ );\u000a			} else {\u000a				thisEl = thisEl.getOuterHtml();\u000a				otherEl = otherEl.getOuterHtml();\u000a\u000a				// Fix tiny difference between link href in older IEs.\u000a				if ( CKEDITOR.env.ie && CKEDITOR.env.version < 9 && this.is( 'a' ) ) {\u000a					var parent = this.getParent();\u000a					if ( parent.type == CKEDITOR.NODE_ELEMENT ) {\u000a						var el = parent.clone();\u000a						el.setHtml( thisEl ), thisEl = el.getHtml();\u000a						el.setHtml( otherEl ), otherEl = el.getHtml();\u000a					}\u000a				}\u000a\u000a				return thisEl == otherEl;\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Checks if this element is visible. May not work if the element is\u000a		 * child of an element with visibility set to `hidden`, but works well\u000a		 * on the great majority of cases.\u000a		 *\u000a		 * @returns {Boolean} True if the element is visible.\u000a		 */\u000a		isVisible: function() {\u000a			var isVisible = ( this.$.offsetHeight || this.$.offsetWidth ) && this.getComputedStyle( 'visibility' ) != 'hidden',\u000a				elementWindow, elementWindowFrame;\u000a\u000a			// Webkit and Opera report non-zero offsetHeight despite that\u000a			// element is inside an invisible iframe. (#4542)\u000a			if ( isVisible && CKEDITOR.env.webkit ) {\u000a				elementWindow = this.getWindow();\u000a\u000a				if ( !elementWindow.equals( CKEDITOR.document.getWindow() ) && ( elementWindowFrame = elementWindow.$.frameElement ) )\u000a					isVisible = new CKEDITOR.dom.element( elementWindowFrame ).isVisible();\u000a\u000a			}\u000a\u000a			return !!isVisible;\u000a		},\u000a\u000a		/**\u000a		 * Whether it's an empty inline elements which has no visual impact when removed.\u000a		 *\u000a		 * @returns {Boolean}\u000a		 */\u000a		isEmptyInlineRemoveable: function() {\u000a			if ( !CKEDITOR.dtd.$removeEmpty[ this.getName() ] )\u000a				return false;\u000a\u000a			var children = this.getChildren();\u000a			for ( var i = 0, count = children.count(); i < count; i++ ) {\u000a				var child = children.getItem( i );\u000a\u000a				if ( child.type == CKEDITOR.NODE_ELEMENT && child.data( 'cke-bookmark' ) )\u000a					continue;\u000a\u000a				if ( child.type == CKEDITOR.NODE_ELEMENT && !child.isEmptyInlineRemoveable() || child.type == CKEDITOR.NODE_TEXT && CKEDITOR.tools.trim( child.getText() ) )\u000a					return false;\u000a\u000a			}\u000a			return true;\u000a		},\u000a\u000a		/**\u000a		 * Checks if the element has any defined attributes.\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<div title="Test">Example</div>' );\u000a		 *		alert( element.hasAttributes() ); // true\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<div>Example</div>' );\u000a		 *		alert( element.hasAttributes() ); // false\u000a		 *\u000a		 * @method\u000a		 * @returns {Boolean} True if the element has attributes.\u000a		 */\u000a		hasAttributes: CKEDITOR.env.ie && ( CKEDITOR.env.ie7Compat || CKEDITOR.env.quirks ) ?\u000a			function() {\u000a				var attributes = this.$.attributes;\u000a\u000a				for ( var i = 0; i < attributes.length; i++ ) {\u000a					var attribute = attributes[ i ];\u000a\u000a					switch ( attribute.nodeName ) {\u000a						case 'class':\u000a							// IE has a strange bug. If calling removeAttribute('className'),\u000a							// the attributes collection will still contain the "class"\u000a							// attribute, which will be marked as "specified", even if the\u000a							// outerHTML of the element is not displaying the class attribute.\u000a							// Note : I was not able to reproduce it outside the editor,\u000a							// but I've faced it while working on the TC of #1391.\u000a							if ( this.getAttribute( 'class' ) ) {\u000a								return true;\u000a							}\u000a\u000a						// Attributes to be ignored.\u000a						/* falls through */\u000a						case 'data-cke-expando':\u000a							continue;\u000a\u000a\u000a						/* falls through */\u000a						default:\u000a							if ( attribute.specified ) {\u000a								return true;\u000a							}\u000a					}\u000a				}\u000a\u000a				return false;\u000a			} : function() {\u000a				var attrs = this.$.attributes,\u000a					attrsNum = attrs.length;\u000a\u000a				// The _moz_dirty attribute might get into the element after pasting (#5455)\u000a				var execludeAttrs = { 'data-cke-expando': 1, _moz_dirty: 1 };\u000a\u000a				return attrsNum > 0 && ( attrsNum > 2 || !execludeAttrs[ attrs[ 0 ].nodeName ] || ( attrsNum == 2 && !execludeAttrs[ attrs[ 1 ].nodeName ] ) );\u000a			},\u000a\u000a		/**\u000a		 * Checks if the specified attribute is defined for this element.\u000a		 *\u000a		 * @method\u000a		 * @param {String} name The attribute name.\u000a		 * @returns {Boolean} `true` if the specified attribute is defined.\u000a		 */\u000a		hasAttribute: ( function() {\u000a			function ieHasAttribute( name ) {\u000a				var $attr = this.$.attributes.getNamedItem( name );\u000a\u000a				if ( this.getName() == 'input' ) {\u000a					switch ( name ) {\u000a						case 'class':\u000a							return this.$.className.length > 0;\u000a						case 'checked':\u000a							return !!this.$.checked;\u000a						case 'value':\u000a							var type = this.getAttribute( 'type' );\u000a							return type == 'checkbox' || type == 'radio' ? this.$.value != 'on' : !!this.$.value;\u000a					}\u000a				}\u000a\u000a				if ( !$attr )\u000a					return false;\u000a\u000a				return $attr.specified;\u000a			}\u000a\u000a			if ( CKEDITOR.env.ie ) {\u000a				if ( CKEDITOR.env.version < 8 ) {\u000a					return function( name ) {\u000a						// On IE < 8 the name attribute cannot be retrieved\u000a						// right after the element creation and setting the\u000a						// name with setAttribute.\u000a						if ( name == 'name' )\u000a							return !!this.$.name;\u000a\u000a						return ieHasAttribute.call( this, name );\u000a					};\u000a				} else {\u000a					return ieHasAttribute;\u000a				}\u000a			} else {\u000a				return function( name ) {\u000a					// On other browsers specified property is deprecated and return always true,\u000a					// but fortunately $.attributes contains only specified attributes.\u000a					return !!this.$.attributes.getNamedItem( name );\u000a				};\u000a			}\u000a		} )(),\u000a\u000a		/**\u000a		 * Hides this element (sets `display: none`).\u000a		 *\u000a		 *		var element = CKEDITOR.document.getById( 'myElement' );\u000a		 *		element.hide();\u000a		 */\u000a		hide: function() {\u000a			this.setStyle( 'display', 'none' );\u000a		},\u000a\u000a		/**\u000a		 * Moves this element's children to the target element.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} target\u000a		 * @param {Boolean} [toStart=false] Insert moved children at the\u000a		 * beginning of the target element.\u000a		 */\u000a		moveChildren: function( target, toStart ) {\u000a			var $ = this.$;\u000a			target = target.$;\u000a\u000a			if ( $ == target )\u000a				return;\u000a\u000a			var child;\u000a\u000a			if ( toStart ) {\u000a				while ( ( child = $.lastChild ) )\u000a					target.insertBefore( $.removeChild( child ), target.firstChild );\u000a			} else {\u000a				while ( ( child = $.firstChild ) )\u000a					target.appendChild( $.removeChild( child ) );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Merges sibling elements that are identical to this one.\u000a		 *\u000a		 * Identical child elements are also merged. For example:\u000a		 *\u000a		 *		<b><i></i></b><b><i></i></b> => <b><i></i></b>\u000a		 *\u000a		 * @method\u000a		 * @param {Boolean} [inlineOnly=true] Allow only inline elements to be merged.\u000a		 */\u000a		mergeSiblings: ( function() {\u000a			function mergeElements( element, sibling, isNext ) {\u000a				if ( sibling && sibling.type == CKEDITOR.NODE_ELEMENT ) {\u000a					// Jumping over bookmark nodes and empty inline elements, e.g. <b><i></i></b>,\u000a					// queuing them to be moved later. (#5567)\u000a					var pendingNodes = [];\u000a\u000a					while ( sibling.data( 'cke-bookmark' ) || sibling.isEmptyInlineRemoveable() ) {\u000a						pendingNodes.push( sibling );\u000a						sibling = isNext ? sibling.getNext() : sibling.getPrevious();\u000a						if ( !sibling || sibling.type != CKEDITOR.NODE_ELEMENT )\u000a							return;\u000a					}\u000a\u000a					if ( element.isIdentical( sibling ) ) {\u000a						// Save the last child to be checked too, to merge things like\u000a						// <b><i></i></b><b><i></i></b> => <b><i></i></b>\u000a						var innerSibling = isNext ? element.getLast() : element.getFirst();\u000a\u000a						// Move pending nodes first into the target element.\u000a						while ( pendingNodes.length )\u000a							pendingNodes.shift().move( element, !isNext );\u000a\u000a						sibling.moveChildren( element, !isNext );\u000a						sibling.remove();\u000a\u000a						// Now check the last inner child (see two comments above).\u000a						if ( innerSibling && innerSibling.type == CKEDITOR.NODE_ELEMENT )\u000a							innerSibling.mergeSiblings();\u000a					}\u000a				}\u000a			}\u000a\u000a			return function( inlineOnly ) {\u000a				if ( !( inlineOnly === false || CKEDITOR.dtd.$removeEmpty[ this.getName() ] || this.is( 'a' ) ) ) // Merge empty links and anchors also. (#5567)\u000a				{\u000a					return;\u000a				}\u000a\u000a				mergeElements( this, this.getNext(), true );\u000a				mergeElements( this, this.getPrevious() );\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Shows this element (displays it).\u000a		 *\u000a		 *		var element = CKEDITOR.document.getById( 'myElement' );\u000a		 *		element.show();\u000a		 */\u000a		show: function() {\u000a			this.setStyles( {\u000a				display: '',\u000a				visibility: ''\u000a			} );\u000a		},\u000a\u000a		/**\u000a		 * Sets the value of an element attribute.\u000a		 *\u000a		 *		var element = CKEDITOR.document.getById( 'myElement' );\u000a		 *		element.setAttribute( 'class', 'myClass' );\u000a		 *		element.setAttribute( 'title', 'This is an example' );\u000a		 *\u000a		 * @method\u000a		 * @param {String} name The name of the attribute.\u000a		 * @param {String} value The value to be set to the attribute.\u000a		 * @returns {CKEDITOR.dom.element} This element instance.\u000a		 */\u000a		setAttribute: ( function() {\u000a			var standard = function( name, value ) {\u000a					this.$.setAttribute( name, value );\u000a					return this;\u000a				};\u000a\u000a			if ( CKEDITOR.env.ie && ( CKEDITOR.env.ie7Compat || CKEDITOR.env.quirks ) ) {\u000a				return function( name, value ) {\u000a					if ( name == 'class' )\u000a						this.$.className = value;\u000a					else if ( name == 'style' )\u000a						this.$.style.cssText = value;\u000a					else if ( name == 'tabindex' ) // Case sensitive.\u000a					this.$.tabIndex = value;\u000a					else if ( name == 'checked' )\u000a						this.$.checked = value;\u000a					else if ( name == 'contenteditable' )\u000a						standard.call( this, 'contentEditable', value );\u000a					else\u000a						standard.apply( this, arguments );\u000a					return this;\u000a				};\u000a			} else if ( CKEDITOR.env.ie8Compat && CKEDITOR.env.secure ) {\u000a				return function( name, value ) {\u000a					// IE8 throws error when setting src attribute to non-ssl value. (#7847)\u000a					if ( name == 'src' && value.match( /^http:\u005c/\u005c// ) ) {\u000a						try {\u000a							standard.apply( this, arguments );\u000a						} catch ( e ) {}\u000a					} else {\u000a						standard.apply( this, arguments );\u000a					}\u000a					return this;\u000a				};\u000a			} else {\u000a				return standard;\u000a			}\u000a		} )(),\u000a\u000a		/**\u000a		 * Sets the value of several element attributes.\u000a		 *\u000a		 *		var element = CKEDITOR.document.getById( 'myElement' );\u000a		 *		element.setAttributes( {\u000a		 *			'class':	'myClass',\u000a		 *			title:		'This is an example'\u000a		 *		} );\u000a		 *\u000a		 * @chainable\u000a		 * @param {Object} attributesPairs An object containing the names and\u000a		 * values of the attributes.\u000a		 * @returns {CKEDITOR.dom.element} This element instance.\u000a		 */\u000a		setAttributes: function( attributesPairs ) {\u000a			for ( var name in attributesPairs )\u000a				this.setAttribute( name, attributesPairs[ name ] );\u000a			return this;\u000a		},\u000a\u000a		/**\u000a		 * Sets the element value. This function is usually used with form\u000a		 * field element.\u000a		 *\u000a		 * @chainable\u000a		 * @param {String} value The element value.\u000a		 * @returns {CKEDITOR.dom.element} This element instance.\u000a		 */\u000a		setValue: function( value ) {\u000a			this.$.value = value;\u000a			return this;\u000a		},\u000a\u000a		/**\u000a		 * Removes an attribute from the element.\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<div class="classA"></div>' );\u000a		 *		element.removeAttribute( 'class' );\u000a		 *\u000a		 * @method\u000a		 * @param {String} name The attribute name.\u000a		 */\u000a		removeAttribute: ( function() {\u000a			var standard = function( name ) {\u000a					this.$.removeAttribute( name );\u000a				};\u000a\u000a			if ( CKEDITOR.env.ie && ( CKEDITOR.env.ie7Compat || CKEDITOR.env.quirks ) ) {\u000a				return function( name ) {\u000a					if ( name == 'class' )\u000a						name = 'className';\u000a					else if ( name == 'tabindex' )\u000a						name = 'tabIndex';\u000a					else if ( name == 'contenteditable' )\u000a						name = 'contentEditable';\u000a					standard.call( this, name );\u000a				};\u000a			} else {\u000a				return standard;\u000a			}\u000a		} )(),\u000a\u000a		/**\u000a		 * Removes all element's attributes or just given ones.\u000a		 *\u000a		 * @param {Array} [attributes] The array with attributes names.\u000a		 */\u000a		removeAttributes: function( attributes ) {\u000a			if ( CKEDITOR.tools.isArray( attributes ) ) {\u000a				for ( var i = 0; i < attributes.length; i++ )\u000a					this.removeAttribute( attributes[ i ] );\u000a			} else {\u000a				for ( var attr in attributes )\u000a					attributes.hasOwnProperty( attr ) && this.removeAttribute( attr );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Removes a style from the element.\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<div style="display:none"></div>' );\u000a		 *		element.removeStyle( 'display' );\u000a		 *\u000a		 * @method\u000a		 * @param {String} name The style name.\u000a		 */\u000a		removeStyle: function( name ) {\u000a			// Removes the specified property from the current style object.\u000a			var $ = this.$.style;\u000a\u000a			// "removeProperty" need to be specific on the following styles.\u000a			if ( !$.removeProperty && ( name == 'border' || name == 'margin' || name == 'padding' ) ) {\u000a				var names = expandedRules( name );\u000a				for ( var i = 0 ; i < names.length ; i++ )\u000a					this.removeStyle( names[ i ] );\u000a				return;\u000a			}\u000a\u000a			$.removeProperty ? $.removeProperty( name ) : $.removeAttribute( CKEDITOR.tools.cssStyleToDomStyle( name ) );\u000a\u000a			// Eventually remove empty style attribute.\u000a			if ( !this.$.style.cssText )\u000a				this.removeAttribute( 'style' );\u000a		},\u000a\u000a		/**\u000a		 * Sets the value of an element style.\u000a		 *\u000a		 *		var element = CKEDITOR.document.getById( 'myElement' );\u000a		 *		element.setStyle( 'background-color', '#ff0000' );\u000a		 *		element.setStyle( 'margin-top', '10px' );\u000a		 *		element.setStyle( 'float', 'right' );\u000a		 *\u000a		 * @param {String} name The name of the style. The CSS naming notation\u000a		 * must be used (e.g. `background-color`).\u000a		 * @param {String} value The value to be set to the style.\u000a		 * @returns {CKEDITOR.dom.element} This element instance.\u000a		 */\u000a		setStyle: function( name, value ) {\u000a			this.$.style[ CKEDITOR.tools.cssStyleToDomStyle( name ) ] = value;\u000a			return this;\u000a		},\u000a\u000a		/**\u000a		 * Sets the value of several element styles.\u000a		 *\u000a		 *		var element = CKEDITOR.document.getById( 'myElement' );\u000a		 *		element.setStyles( {\u000a		 *			position:	'absolute',\u000a		 *			float:		'right'\u000a		 *		} );\u000a		 *\u000a		 * @param {Object} stylesPairs An object containing the names and\u000a		 * values of the styles.\u000a		 * @returns {CKEDITOR.dom.element} This element instance.\u000a		 */\u000a		setStyles: function( stylesPairs ) {\u000a			for ( var name in stylesPairs )\u000a				this.setStyle( name, stylesPairs[ name ] );\u000a			return this;\u000a		},\u000a\u000a		/**\u000a		 * Sets the opacity of an element.\u000a		 *\u000a		 *		var element = CKEDITOR.document.getById( 'myElement' );\u000a		 *		element.setOpacity( 0.75 );\u000a		 *\u000a		 * @param {Number} opacity A number within the range `[0.0, 1.0]`.\u000a		 */\u000a		setOpacity: function( opacity ) {\u000a			if ( CKEDITOR.env.ie && CKEDITOR.env.version < 9 ) {\u000a				opacity = Math.round( opacity * 100 );\u000a				this.setStyle( 'filter', opacity >= 100 ? '' : 'progid:DXImageTransform.Microsoft.Alpha(opacity=' + opacity + ')' );\u000a			} else {\u000a				this.setStyle( 'opacity', opacity );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Makes the element and its children unselectable.\u000a		 *\u000a		 *		var element = CKEDITOR.document.getById( 'myElement' );\u000a		 *		element.unselectable();\u000a		 *\u000a		 * @method\u000a		 */\u000a		unselectable: function() {\u000a			// CSS unselectable.\u000a			this.setStyles( CKEDITOR.tools.cssVendorPrefix( 'user-select', 'none' ) );\u000a\u000a			// For IE/Opera which doesn't support for the above CSS style,\u000a			// the unselectable="on" attribute only specifies the selection\u000a			// process cannot start in the element itself, and it doesn't inherit.\u000a			if ( CKEDITOR.env.ie ) {\u000a				this.setAttribute( 'unselectable', 'on' );\u000a\u000a				var element,\u000a					elements = this.getElementsByTag( '*' );\u000a\u000a				for ( var i = 0, count = elements.count() ; i < count ; i++ ) {\u000a					element = elements.getItem( i );\u000a					element.setAttribute( 'unselectable', 'on' );\u000a				}\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Gets closest positioned (`position != static`) ancestor.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.element} Positioned ancestor or `null`.\u000a		 */\u000a		getPositionedAncestor: function() {\u000a			var current = this;\u000a			while ( current.getName() != 'html' ) {\u000a				if ( current.getComputedStyle( 'position' ) != 'static' )\u000a					return current;\u000a\u000a				current = current.getParent();\u000a			}\u000a			return null;\u000a		},\u000a\u000a		/**\u000a		 * Gets this element's position in document.\u000a		 *\u000a		 * @param {CKEDITOR.dom.document} [refDocument]\u000a		 * @returns {Object} Element's position.\u000a		 * @returns {Number} return.x\u000a		 * @returns {Number} return.y\u000a		 * @todo refDocument\u000a		 */\u000a		getDocumentPosition: function( refDocument ) {\u000a			var x = 0,\u000a				y = 0,\u000a				doc = this.getDocument(),\u000a				body = doc.getBody(),\u000a				quirks = doc.$.compatMode == 'BackCompat';\u000a\u000a			if ( document.documentElement.getBoundingClientRect ) {\u000a				var box = this.$.getBoundingClientRect(),\u000a					$doc = doc.$,\u000a					$docElem = $doc.documentElement;\u000a\u000a				var clientTop = $docElem.clientTop || body.$.clientTop || 0,\u000a					clientLeft = $docElem.clientLeft || body.$.clientLeft || 0,\u000a					needAdjustScrollAndBorders = true;\u000a\u000a				// #3804: getBoundingClientRect() works differently on IE and non-IE\u000a				// browsers, regarding scroll positions.\u000a				//\u000a				// On IE, the top position of the <html> element is always 0, no matter\u000a				// how much you scrolled down.\u000a				//\u000a				// On other browsers, the top position of the <html> element is negative\u000a				// scrollTop.\u000a				if ( CKEDITOR.env.ie ) {\u000a					var inDocElem = doc.getDocumentElement().contains( this ),\u000a						inBody = doc.getBody().contains( this );\u000a\u000a					needAdjustScrollAndBorders = ( quirks && inBody ) || ( !quirks && inDocElem );\u000a				}\u000a\u000a				if ( needAdjustScrollAndBorders ) {\u000a					x = box.left + ( !quirks && $docElem.scrollLeft || body.$.scrollLeft );\u000a					x -= clientLeft;\u000a					y = box.top + ( !quirks && $docElem.scrollTop || body.$.scrollTop );\u000a					y -= clientTop;\u000a				}\u000a			} else {\u000a				var current = this,\u000a					previous = null,\u000a					offsetParent;\u000a				while ( current && !( current.getName() == 'body' || current.getName() == 'html' ) ) {\u000a					x += current.$.offsetLeft - current.$.scrollLeft;\u000a					y += current.$.offsetTop - current.$.scrollTop;\u000a\u000a					// Opera includes clientTop|Left into offsetTop|Left.\u000a					if ( !current.equals( this ) ) {\u000a						x += ( current.$.clientLeft || 0 );\u000a						y += ( current.$.clientTop || 0 );\u000a					}\u000a\u000a					var scrollElement = previous;\u000a					while ( scrollElement && !scrollElement.equals( current ) ) {\u000a						x -= scrollElement.$.scrollLeft;\u000a						y -= scrollElement.$.scrollTop;\u000a						scrollElement = scrollElement.getParent();\u000a					}\u000a\u000a					previous = current;\u000a					current = ( offsetParent = current.$.offsetParent ) ? new CKEDITOR.dom.element( offsetParent ) : null;\u000a				}\u000a			}\u000a\u000a			if ( refDocument ) {\u000a				var currentWindow = this.getWindow(),\u000a					refWindow = refDocument.getWindow();\u000a\u000a				if ( !currentWindow.equals( refWindow ) && currentWindow.$.frameElement ) {\u000a					var iframePosition = ( new CKEDITOR.dom.element( currentWindow.$.frameElement ) ).getDocumentPosition( refDocument );\u000a\u000a					x += iframePosition.x;\u000a					y += iframePosition.y;\u000a				}\u000a			}\u000a\u000a			if ( !document.documentElement.getBoundingClientRect ) {\u000a				// In Firefox, we'll endup one pixel before the element positions,\u000a				// so we must add it here.\u000a				if ( CKEDITOR.env.gecko && !quirks ) {\u000a					x += this.$.clientLeft ? 1 : 0;\u000a					y += this.$.clientTop ? 1 : 0;\u000a				}\u000a			}\u000a\u000a			return { x: x, y: y };\u000a		},\u000a\u000a		/**\u000a		 * Make any page element visible inside the browser viewport.\u000a		 *\u000a		 * @param {Boolean} [alignToTop=false]\u000a		 */\u000a		scrollIntoView: function( alignToTop ) {\u000a			var parent = this.getParent();\u000a			if ( !parent )\u000a				return;\u000a\u000a			// Scroll the element into parent container from the inner out.\u000a			do {\u000a				// Check ancestors that overflows.\u000a				var overflowed =\u000a					parent.$.clientWidth && parent.$.clientWidth < parent.$.scrollWidth ||\u000a					parent.$.clientHeight && parent.$.clientHeight < parent.$.scrollHeight;\u000a\u000a				// Skip body element, which will report wrong clientHeight when containing\u000a				// floated content. (#9523)\u000a				if ( overflowed && !parent.is( 'body' ) )\u000a					this.scrollIntoParent( parent, alignToTop, 1 );\u000a\u000a				// Walk across the frame.\u000a				if ( parent.is( 'html' ) ) {\u000a					var win = parent.getWindow();\u000a\u000a					// Avoid security error.\u000a					try {\u000a						var iframe = win.$.frameElement;\u000a						iframe && ( parent = new CKEDITOR.dom.element( iframe ) );\u000a					} catch ( er ) {}\u000a				}\u000a			}\u000a			while ( ( parent = parent.getParent() ) );\u000a		},\u000a\u000a		/**\u000a		 * Make any page element visible inside one of the ancestors by scrolling the parent.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element/CKEDITOR.dom.window} parent The container to scroll into.\u000a		 * @param {Boolean} [alignToTop] Align the element's top side with the container's\u000a		 * when `true` is specified; align the bottom with viewport bottom when\u000a		 * `false` is specified. Otherwise scroll on either side with the minimum\u000a		 * amount to show the element.\u000a		 * @param {Boolean} [hscroll] Whether horizontal overflow should be considered.\u000a		 */\u000a		scrollIntoParent: function( parent, alignToTop, hscroll ) {\u000a			!parent && ( parent = this.getWindow() );\u000a\u000a			var doc = parent.getDocument();\u000a			var isQuirks = doc.$.compatMode == 'BackCompat';\u000a\u000a			// On window <html> is scrolled while quirks scrolls <body>.\u000a			if ( parent instanceof CKEDITOR.dom.window )\u000a				parent = isQuirks ? doc.getBody() : doc.getDocumentElement();\u000a\u000a			// Scroll the parent by the specified amount.\u000a			function scrollBy( x, y ) {\u000a				// Webkit doesn't support "scrollTop/scrollLeft"\u000a				// on documentElement/body element.\u000a				if ( /body|html/.test( parent.getName() ) )\u000a					parent.getWindow().$.scrollBy( x, y );\u000a				else {\u000a					parent.$.scrollLeft += x;\u000a					parent.$.scrollTop += y;\u000a				}\u000a			}\u000a\u000a			// Figure out the element position relative to the specified window.\u000a			function screenPos( element, refWin ) {\u000a				var pos = { x: 0, y: 0 };\u000a\u000a				if ( !( element.is( isQuirks ? 'body' : 'html' ) ) ) {\u000a					var box = element.$.getBoundingClientRect();\u000a					pos.x = box.left, pos.y = box.top;\u000a				}\u000a\u000a				var win = element.getWindow();\u000a				if ( !win.equals( refWin ) ) {\u000a					var outerPos = screenPos( CKEDITOR.dom.element.get( win.$.frameElement ), refWin );\u000a					pos.x += outerPos.x, pos.y += outerPos.y;\u000a				}\u000a\u000a				return pos;\u000a			}\u000a\u000a			// calculated margin size.\u000a			function margin( element, side ) {\u000a				return parseInt( element.getComputedStyle( 'margin-' + side ) || 0, 10 ) || 0;\u000a			}\u000a\u000a			var win = parent.getWindow();\u000a\u000a			var thisPos = screenPos( this, win ),\u000a				parentPos = screenPos( parent, win ),\u000a				eh = this.$.offsetHeight,\u000a				ew = this.$.offsetWidth,\u000a				ch = parent.$.clientHeight,\u000a				cw = parent.$.clientWidth,\u000a				lt, br;\u000a\u000a			// Left-top margins.\u000a			lt = {\u000a				x: thisPos.x - margin( this, 'left' ) - parentPos.x || 0,\u000a				y: thisPos.y - margin( this, 'top' ) - parentPos.y || 0\u000a			};\u000a\u000a			// Bottom-right margins.\u000a			br = {\u000a				x: thisPos.x + ew + margin( this, 'right' ) - ( ( parentPos.x ) + cw ) || 0,\u000a				y: thisPos.y + eh + margin( this, 'bottom' ) - ( ( parentPos.y ) + ch ) || 0\u000a			};\u000a\u000a			// 1. Do the specified alignment as much as possible;\u000a			// 2. Otherwise be smart to scroll only the minimum amount;\u000a			// 3. Never cut at the top;\u000a			// 4. DO NOT scroll when already visible.\u000a			if ( lt.y < 0 || br.y > 0 )\u000a				scrollBy( 0, alignToTop === true ? lt.y : alignToTop === false ? br.y : lt.y < 0 ? lt.y : br.y );\u000a\u000a			if ( hscroll && ( lt.x < 0 || br.x > 0 ) )\u000a				scrollBy( lt.x < 0 ? lt.x : br.x, 0 );\u000a		},\u000a\u000a		/**\u000a		 * Switch the `class` attribute to reflect one of the triple states of an\u000a		 * element in one of {@link CKEDITOR#TRISTATE_ON}, {@link CKEDITOR#TRISTATE_OFF}\u000a		 * or {@link CKEDITOR#TRISTATE_DISABLED}.\u000a		 *\u000a		 *		link.setState( CKEDITOR.TRISTATE_ON );\u000a		 *		// <a class="cke_on" aria-pressed="true">...</a>\u000a		 *		link.setState( CKEDITOR.TRISTATE_OFF );\u000a		 *		// <a class="cke_off">...</a>\u000a		 *		link.setState( CKEDITOR.TRISTATE_DISABLED );\u000a		 *		// <a class="cke_disabled" aria-disabled="true">...</a>\u000a		 *\u000a		 *		span.setState( CKEDITOR.TRISTATE_ON, 'cke_button' );\u000a		 *		// <span class="cke_button_on">...</span>\u000a		 *\u000a		 * @param {Number} state Indicate the element state. One of {@link CKEDITOR#TRISTATE_ON},\u000a		 * {@link CKEDITOR#TRISTATE_OFF}, {@link CKEDITOR#TRISTATE_DISABLED}.\u000a		 * @param [base='cke'] The prefix apply to each of the state class name.\u000a		 * @param [useAria=true] Whether toggle the ARIA state attributes besides of class name change.\u000a		 */\u000a		setState: function( state, base, useAria ) {\u000a			base = base || 'cke';\u000a\u000a			switch ( state ) {\u000a				case CKEDITOR.TRISTATE_ON:\u000a					this.addClass( base + '_on' );\u000a					this.removeClass( base + '_off' );\u000a					this.removeClass( base + '_disabled' );\u000a					useAria && this.setAttribute( 'aria-pressed', true );\u000a					useAria && this.removeAttribute( 'aria-disabled' );\u000a					break;\u000a\u000a				case CKEDITOR.TRISTATE_DISABLED:\u000a					this.addClass( base + '_disabled' );\u000a					this.removeClass( base + '_off' );\u000a					this.removeClass( base + '_on' );\u000a					useAria && this.setAttribute( 'aria-disabled', true );\u000a					useAria && this.removeAttribute( 'aria-pressed' );\u000a					break;\u000a\u000a				default:\u000a					this.addClass( base + '_off' );\u000a					this.removeClass( base + '_on' );\u000a					this.removeClass( base + '_disabled' );\u000a					useAria && this.removeAttribute( 'aria-pressed' );\u000a					useAria && this.removeAttribute( 'aria-disabled' );\u000a					break;\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Returns the inner document of this `<iframe>` element.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.document} The inner document.\u000a		 */\u000a		getFrameDocument: function() {\u000a			var $ = this.$;\u000a\u000a			try {\u000a				// In IE, with custom document.domain, it may happen that\u000a				// the iframe is not yet available, resulting in "Access\u000a				// Denied" for the following property access.\u000a				$.contentWindow.document;\u000a			} catch ( e ) {\u000a				// Trick to solve this issue, forcing the iframe to get ready\u000a				// by simply setting its "src" property.\u000a				$.src = $.src;\u000a			}\u000a\u000a			return $ && new CKEDITOR.dom.document( $.contentWindow.document );\u000a		},\u000a\u000a		/**\u000a		 * Copy all the attributes from one node to the other, kinda like a clone\u000a		 * skipAttributes is an object with the attributes that must **not** be copied.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} dest The destination element.\u000a		 * @param {Object} skipAttributes A dictionary of attributes to skip.\u000a		 */\u000a		copyAttributes: function( dest, skipAttributes ) {\u000a			var attributes = this.$.attributes;\u000a			skipAttributes = skipAttributes || {};\u000a\u000a			for ( var n = 0; n < attributes.length; n++ ) {\u000a				var attribute = attributes[ n ];\u000a\u000a				// Lowercase attribute name hard rule is broken for\u000a				// some attribute on IE, e.g. CHECKED.\u000a				var attrName = attribute.nodeName.toLowerCase(),\u000a					attrValue;\u000a\u000a				// We can set the type only once, so do it with the proper value, not copying it.\u000a				if ( attrName in skipAttributes )\u000a					continue;\u000a\u000a				if ( attrName == 'checked' && ( attrValue = this.getAttribute( attrName ) ) )\u000a					dest.setAttribute( attrName, attrValue );\u000a				// IE contains not specified attributes in $.attributes so we need to check\u000a				// if elements attribute is specified using hasAttribute.\u000a				else if ( !CKEDITOR.env.ie || this.hasAttribute( attrName ) ) {\u000a					attrValue = this.getAttribute( attrName );\u000a					if ( attrValue === null )\u000a						attrValue = attribute.nodeValue;\u000a\u000a					dest.setAttribute( attrName, attrValue );\u000a				}\u000a			}\u000a\u000a			// The style:\u000a			if ( this.$.style.cssText !== '' )\u000a				dest.$.style.cssText = this.$.style.cssText;\u000a		},\u000a\u000a		/**\u000a		 * Changes the tag name of the current element.\u000a		 *\u000a		 * @param {String} newTag The new tag for the element.\u000a		 */\u000a		renameNode: function( newTag ) {\u000a			// If it's already correct exit here.\u000a			if ( this.getName() == newTag )\u000a				return;\u000a\u000a			var doc = this.getDocument();\u000a\u000a			// Create the new node.\u000a			var newNode = new CKEDITOR.dom.element( newTag, doc );\u000a\u000a			// Copy all attributes.\u000a			this.copyAttributes( newNode );\u000a\u000a			// Move children to the new node.\u000a			this.moveChildren( newNode );\u000a\u000a			// Replace the node.\u000a			this.getParent() && this.$.parentNode.replaceChild( newNode.$, this.$ );\u000a			newNode.$[ 'data-cke-expando' ] = this.$[ 'data-cke-expando' ];\u000a			this.$ = newNode.$;\u000a			// Bust getName's cache. (#8663)\u000a			delete this.getName;\u000a		},\u000a\u000a		/**\u000a		 * Gets a DOM tree descendant under the current node.\u000a		 *\u000a		 *		var strong = p.getChild( 0 );\u000a		 *\u000a		 * @method\u000a		 * @param {Array/Number} indices The child index or array of child indices under the node.\u000a		 * @returns {CKEDITOR.dom.node} The specified DOM child under the current node. Null if child does not exist.\u000a		 */\u000a		getChild: ( function() {\u000a			function getChild( rawNode, index ) {\u000a				var childNodes = rawNode.childNodes;\u000a\u000a				if ( index >= 0 && index < childNodes.length )\u000a					return childNodes[ index ];\u000a			}\u000a\u000a			return function( indices ) {\u000a				var rawNode = this.$;\u000a\u000a				if ( !indices.slice )\u000a					rawNode = getChild( rawNode, indices );\u000a				else {\u000a					while ( indices.length > 0 && rawNode )\u000a						rawNode = getChild( rawNode, indices.shift() );\u000a				}\u000a\u000a				return rawNode ? new CKEDITOR.dom.node( rawNode ) : null;\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Gets number of element's children.\u000a		 *\u000a		 * @returns {Number}\u000a		 */\u000a		getChildCount: function() {\u000a			return this.$.childNodes.length;\u000a		},\u000a\u000a		/**\u000a		 * Disables browser's context menu in this element.\u000a		 */\u000a		disableContextMenu: function() {\u000a			this.on( 'contextmenu', function( event ) {\u000a				// Cancel the browser context menu.\u000a				if ( !event.data.getTarget().hasClass( 'cke_enable_context_menu' ) )\u000a					event.data.preventDefault();\u000a			} );\u000a		},\u000a\u000a		/**\u000a		 * Gets element's direction. Supports both CSS `direction` prop and `dir` attr.\u000a		 */\u000a		getDirection: function( useComputed ) {\u000a			if ( useComputed ) {\u000a				return this.getComputedStyle( 'direction' ) ||\u000a						this.getDirection() ||\u000a						this.getParent() && this.getParent().getDirection( 1 ) ||\u000a						this.getDocument().$.dir ||\u000a						'ltr';\u000a			}\u000a			else {\u000a				return this.getStyle( 'direction' ) || this.getAttribute( 'dir' );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Gets, sets and removes custom data to be stored as HTML5 data-* attributes.\u000a		 *\u000a		 *		element.data( 'extra-info', 'test' );	// Appended the attribute data-extra-info="test" to the element.\u000a		 *		alert( element.data( 'extra-info' ) );	// 'test'\u000a		 *		element.data( 'extra-info', false );	// Remove the data-extra-info attribute from the element.\u000a		 *\u000a		 * @param {String} name The name of the attribute, excluding the `data-` part.\u000a		 * @param {String} [value] The value to set. If set to false, the attribute will be removed.\u000a		 */\u000a		data: function( name, value ) {\u000a			name = 'data-' + name;\u000a			if ( value === undefined )\u000a				return this.getAttribute( name );\u000a			else if ( value === false )\u000a				this.removeAttribute( name );\u000a			else\u000a				this.setAttribute( name, value );\u000a\u000a			return null;\u000a		},\u000a\u000a		/**\u000a		 * Retrieves an editor instance which is based on this element (if any).\u000a		 * It basically loops over {@link CKEDITOR#instances} in search for an instance\u000a		 * that uses the element.\u000a		 *\u000a		 *		var element = new CKEDITOR.dom.element( 'div' );\u000a		 *		element.appendTo( CKEDITOR.document.getBody() );\u000a		 *		CKEDITOR.replace( element );\u000a		 *		alert( element.getEditor().name ); // 'editor1'\u000a		 *\u000a		 * @returns {CKEDITOR.editor} An editor instance or null if nothing has been found.\u000a		 */\u000a		getEditor: function() {\u000a			var instances = CKEDITOR.instances,\u000a				name, instance;\u000a\u000a			for ( name in instances ) {\u000a				instance = instances[ name ];\u000a\u000a				if ( instance.element.equals( this ) && instance.elementMode != CKEDITOR.ELEMENT_MODE_APPENDTO )\u000a					return instance;\u000a			}\u000a\u000a			return null;\u000a		},\u000a\u000a		/**\u000a		 * Returns list of elements within this element that match specified `selector`.\u000a		 *\u000a		 * **Notes:**\u000a		 *\u000a		 *	* Not available in IE7.\u000a		 *	* Returned list is not a live collection (like a result of native `querySelectorAll`).\u000a		 *	* Unlike native `querySelectorAll` this method ensures selector contextualization. This is:\u000a		 *\u000a		 *			HTML:		'<body><div><i>foo</i></div></body>'\u000a		 *			Native:		div.querySelectorAll( 'body i' ) // ->		[ <i>foo</i> ]\u000a		 *			Method:		div.find( 'body i' ) // ->					[]\u000a		 *						div.find( 'i' ) // ->						[ <i>foo</i> ]\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {String} selector\u000a		 * @returns {CKEDITOR.dom.nodeList}\u000a		 */\u000a		find: function( selector ) {\u000a			var removeTmpId = createTmpId( this ),\u000a				list = new CKEDITOR.dom.nodeList(\u000a					this.$.querySelectorAll( getContextualizedSelector( this, selector ) )\u000a				);\u000a\u000a			removeTmpId();\u000a\u000a			return list;\u000a		},\u000a\u000a		/**\u000a		 * Returns first element within this element that matches specified `selector`.\u000a		 *\u000a		 * **Notes:**\u000a		 *\u000a		 *	* Not available in IE7.\u000a		 *	* Unlike native `querySelectorAll` this method ensures selector contextualization. This is:\u000a		 *\u000a		 *			HTML:		'<body><div><i>foo</i></div></body>'\u000a		 *			Native:		div.querySelector( 'body i' ) // ->			<i>foo</i>\u000a		 *			Method:		div.findOne( 'body i' ) // ->				null\u000a		 *						div.findOne( 'i' ) // ->					<i>foo</i>\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {String} selector\u000a		 * @returns {CKEDITOR.dom.element}\u000a		 */\u000a		findOne: function( selector ) {\u000a			var removeTmpId = createTmpId( this ),\u000a				found = this.$.querySelector( getContextualizedSelector( this, selector ) );\u000a\u000a			removeTmpId();\u000a\u000a			return found ? new CKEDITOR.dom.element( found ) : null;\u000a		},\u000a\u000a		/**\u000a		 * Traverse the DOM of this element (inclusive), executing a callback for\u000a		 * each node.\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<div><p>foo<b>bar</b>bom</p></div>' );\u000a		 *		element.forEach( function( node ) {\u000a		 *			console.log( node );\u000a		 *		} );\u000a		 *		// Will log:\u000a		 *		// 1. <div> element,\u000a		 *		// 2. <p> element,\u000a		 *		// 3. "foo" text node,\u000a		 *		// 4. <b> element,\u000a		 *		// 5. "bar" text node,\u000a		 *		// 6. "bom" text node.\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {Function} callback Function to be executed on every node.\u000a		 * If `callback` returns `false` descendants of the node will be ignored.\u000a		 * @param {CKEDITOR.htmlParser.node} callback.node Node passed as argument.\u000a		 * @param {Number} [type] If specified `callback` will be executed only on\u000a		 * nodes of this type.\u000a		 * @param {Boolean} [skipRoot] Don't execute `callback` on this element.\u000a		 */\u000a		forEach: function( callback, type, skipRoot ) {\u000a			if ( !skipRoot && ( !type || this.type == type ) )\u000a					var ret = callback( this );\u000a\u000a			// Do not filter children if callback returned false.\u000a			if ( ret === false )\u000a				return;\u000a\u000a			var children = this.getChildren(),\u000a				node,\u000a				i = 0;\u000a\u000a			// We do not cache the size, because the live list of nodes may be changed by the callback.\u000a			for ( ; i < children.count(); i++ ) {\u000a				node = children.getItem( i );\u000a				if ( node.type == CKEDITOR.NODE_ELEMENT )\u000a					node.forEach( callback, type );\u000a				else if ( !type || node.type == type )\u000a					callback( node );\u000a			}\u000a		}\u000a	} );\u000a\u000a	function createTmpId( element ) {\u000a		var hadId = true;\u000a\u000a		if ( !element.$.id ) {\u000a			element.$.id = 'cke_tmp_' + CKEDITOR.tools.getNextNumber();\u000a			hadId = false;\u000a		}\u000a\u000a		return function() {\u000a			if ( !hadId )\u000a				element.removeAttribute( 'id' );\u000a		};\u000a	}\u000a\u000a	function getContextualizedSelector( element, selector ) {\u000a		return '#' + element.$.id + ' ' + selector.split( /,\u005cs*/ ).join( ', #' + element.$.id + ' ' );\u000a	}\u000a\u000a	var sides = {\u000a		width: [ 'border-left-width', 'border-right-width', 'padding-left', 'padding-right' ],\u000a		height: [ 'border-top-width', 'border-bottom-width', 'padding-top', 'padding-bottom' ]\u000a	};\u000a\u000a	// Generate list of specific style rules, applicable to margin/padding/border.\u000a	function expandedRules( style ) {\u000a		var sides = [ 'top', 'left', 'right', 'bottom' ], components;\u000a\u000a		if ( style == 'border' )\u000a				components = [ 'color', 'style', 'width' ];\u000a\u000a		var styles = [];\u000a		for ( var i = 0 ; i < sides.length ; i++ ) {\u000a\u000a			if ( components ) {\u000a				for ( var j = 0 ; j < components.length ; j++ )\u000a					styles.push( [ style, sides[ i ], components[ j ] ].join( '-' ) );\u000a			} else {\u000a				styles.push( [ style, sides[ i ] ].join( '-' ) );\u000a			}\u000a		}\u000a\u000a		return styles;\u000a	}\u000a\u000a	function marginAndPaddingSize( type ) {\u000a		var adjustment = 0;\u000a		for ( var i = 0, len = sides[ type ].length; i < len; i++ )\u000a			adjustment += parseInt( this.getComputedStyle( sides[ type ][ i ] ) || 0, 10 ) || 0;\u000a		return adjustment;\u000a	}\u000a\u000a	/**\u000a	 * Sets the element size considering the box model.\u000a	 *\u000a	 * @param {'width'/'height'} type The dimension to set.\u000a	 * @param {Number} size The length unit in px.\u000a	 * @param {Boolean} isBorderBox Apply the size based on the border box model.\u000a	 */\u000a	CKEDITOR.dom.element.prototype.setSize = function( type, size, isBorderBox ) {\u000a		if ( typeof size == 'number' ) {\u000a			if ( isBorderBox && !( CKEDITOR.env.ie && CKEDITOR.env.quirks ) )\u000a				size -= marginAndPaddingSize.call( this, type );\u000a\u000a			this.setStyle( type, size + 'px' );\u000a		}\u000a	};\u000a\u000a	/**\u000a	 * Gets the element size, possibly considering the box model.\u000a	 *\u000a	 * @param {'width'/'height'} type The dimension to get.\u000a	 * @param {Boolean} isBorderBox Get the size based on the border box model.\u000a	 */\u000a	CKEDITOR.dom.element.prototype.getSize = function( type, isBorderBox ) {\u000a		var size = Math.max( this.$[ 'offset' + CKEDITOR.tools.capitalize( type ) ], this.$[ 'client' + CKEDITOR.tools.capitalize( type ) ] ) || 0;\u000a\u000a		if ( isBorderBox )\u000a			size -= marginAndPaddingSize.call( this, type );\u000a\u000a		return size;\u000a	};\u000a} )();\u000a\u000a/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	// This function is to be called under a "walker" instance scope.\u000a	function iterate( rtl, breakOnFalse ) {\u000a		var range = this.range;\u000a\u000a		// Return null if we have reached the end.\u000a		if ( this._.end )\u000a			return null;\u000a\u000a		// This is the first call. Initialize it.\u000a		if ( !this._.start ) {\u000a			this._.start = 1;\u000a\u000a			// A collapsed range must return null at first call.\u000a			if ( range.collapsed ) {\u000a				this.end();\u000a				return null;\u000a			}\u000a\u000a			// Move outside of text node edges.\u000a			range.optimize();\u000a		}\u000a\u000a		var node,\u000a			startCt = range.startContainer,\u000a			endCt = range.endContainer,\u000a			startOffset = range.startOffset,\u000a			endOffset = range.endOffset,\u000a			guard,\u000a			userGuard = this.guard,\u000a			type = this.type,\u000a			getSourceNodeFn = ( rtl ? 'getPreviousSourceNode' : 'getNextSourceNode' );\u000a\u000a		// Create the LTR guard function, if necessary.\u000a		if ( !rtl && !this._.guardLTR ) {\u000a			// The node that stops walker from moving up.\u000a			var limitLTR = endCt.type == CKEDITOR.NODE_ELEMENT ? endCt : endCt.getParent();\u000a\u000a			// The node that stops the walker from going to next.\u000a			var blockerLTR = endCt.type == CKEDITOR.NODE_ELEMENT ? endCt.getChild( endOffset ) : endCt.getNext();\u000a\u000a			this._.guardLTR = function( node, movingOut ) {\u000a				return ( ( !movingOut || !limitLTR.equals( node ) ) && ( !blockerLTR || !node.equals( blockerLTR ) ) && ( node.type != CKEDITOR.NODE_ELEMENT || !movingOut || !node.equals( range.root ) ) );\u000a			};\u000a		}\u000a\u000a		// Create the RTL guard function, if necessary.\u000a		if ( rtl && !this._.guardRTL ) {\u000a			// The node that stops walker from moving up.\u000a			var limitRTL = startCt.type == CKEDITOR.NODE_ELEMENT ? startCt : startCt.getParent();\u000a\u000a			// The node that stops the walker from going to next.\u000a			var blockerRTL = startCt.type == CKEDITOR.NODE_ELEMENT ? startOffset ? startCt.getChild( startOffset - 1 ) : null : startCt.getPrevious();\u000a\u000a			this._.guardRTL = function( node, movingOut ) {\u000a				return ( ( !movingOut || !limitRTL.equals( node ) ) && ( !blockerRTL || !node.equals( blockerRTL ) ) && ( node.type != CKEDITOR.NODE_ELEMENT || !movingOut || !node.equals( range.root ) ) );\u000a			};\u000a		}\u000a\u000a		// Define which guard function to use.\u000a		var stopGuard = rtl ? this._.guardRTL : this._.guardLTR;\u000a\u000a		// Make the user defined guard function participate in the process,\u000a		// otherwise simply use the boundary guard.\u000a		if ( userGuard ) {\u000a			guard = function( node, movingOut ) {\u000a				if ( stopGuard( node, movingOut ) === false )\u000a					return false;\u000a\u000a				return userGuard( node, movingOut );\u000a			};\u000a		} else {\u000a			guard = stopGuard;\u000a		}\u000a\u000a		if ( this.current )\u000a			node = this.current[ getSourceNodeFn ]( false, type, guard );\u000a		else {\u000a			// Get the first node to be returned.\u000a			if ( rtl ) {\u000a				node = endCt;\u000a\u000a				if ( node.type == CKEDITOR.NODE_ELEMENT ) {\u000a					if ( endOffset > 0 )\u000a						node = node.getChild( endOffset - 1 );\u000a					else\u000a						node = ( guard( node, true ) === false ) ? null : node.getPreviousSourceNode( true, type, guard );\u000a				}\u000a			} else {\u000a				node = startCt;\u000a\u000a				if ( node.type == CKEDITOR.NODE_ELEMENT ) {\u000a					if ( !( node = node.getChild( startOffset ) ) )\u000a						node = ( guard( startCt, true ) === false ) ? null : startCt.getNextSourceNode( true, type, guard );\u000a				}\u000a			}\u000a\u000a			if ( node && guard( node ) === false )\u000a				node = null;\u000a		}\u000a\u000a		while ( node && !this._.end ) {\u000a			this.current = node;\u000a\u000a			if ( !this.evaluator || this.evaluator( node ) !== false ) {\u000a				if ( !breakOnFalse )\u000a					return node;\u000a			} else if ( breakOnFalse && this.evaluator ) {\u000a				return false;\u000a			}\u000a\u000a			node = node[ getSourceNodeFn ]( false, type, guard );\u000a		}\u000a\u000a		this.end();\u000a		return this.current = null;\u000a	}\u000a\u000a	function iterateToLast( rtl ) {\u000a		var node,\u000a			last = null;\u000a\u000a		while ( ( node = iterate.call( this, rtl ) ) )\u000a			last = node;\u000a\u000a		return last;\u000a	}\u000a\u000a	/**\u000a	 * Utility class to "walk" the DOM inside a range boundaries. If the\u000a	 * range starts or ends in the middle of the text node this node will\u000a	 * be included as a whole. Outside changes to the range may break the walker.\u000a	 *\u000a	 * The walker may return nodes that are not totaly included into the\u000a	 * range boundaires. Let's take the following range representation,\u000a	 * where the square brackets indicate the boundaries:\u000a	 *\u000a	 *		[<p>Some <b>sample] text</b>\u000a	 *\u000a	 * While walking forward into the above range, the following nodes are\u000a	 * returned: `<p>`, `"Some "`, `<b>` and `"sample"`. Going\u000a	 * backwards instead we have: `"sample"` and `"Some "`. So note that the\u000a	 * walker always returns nodes when "entering" them, but not when\u000a	 * "leaving" them. The guard function is instead called both when\u000a	 * entering and leaving nodes.\u000a	 *\u000a	 * @class\u000a	 */\u000a	CKEDITOR.dom.walker = CKEDITOR.tools.createClass( {\u000a		/**\u000a		 * Creates a walker class instance.\u000a		 *\u000a		 * @constructor\u000a		 * @param {CKEDITOR.dom.range} range The range within which walk.\u000a		 */\u000a		$: function( range ) {\u000a			this.range = range;\u000a\u000a			/**\u000a			 * A function executed for every matched node, to check whether\u000a			 * it's to be considered into the walk or not. If not provided, all\u000a			 * matched nodes are considered good.\u000a			 *\u000a			 * If the function returns `false` the node is ignored.\u000a			 *\u000a			 * @property {Function} evaluator\u000a			 */\u000a			// this.evaluator = null;\u000a\u000a			/**\u000a			 * A function executed for every node the walk pass by to check\u000a			 * whether the walk is to be finished. It's called when both\u000a			 * entering and exiting nodes, as well as for the matched nodes.\u000a			 *\u000a			 * If this function returns `false`, the walking ends and no more\u000a			 * nodes are evaluated.\u000a\u000a			 * @property {Function} guard\u000a			 */\u000a			// this.guard = null;\u000a\u000a			/** @private */\u000a			this._ = {};\u000a		},\u000a\u000a		//		statics :\u000a		//		{\u000a		//			/* Creates a CKEDITOR.dom.walker instance to walk inside DOM boundaries set by nodes.\u000a		//			 * @param {CKEDITOR.dom.node} startNode The node from wich the walk\u000a		//			 *		will start.\u000a		//			 * @param {CKEDITOR.dom.node} [endNode] The last node to be considered\u000a		//			 *		in the walk. No more nodes are retrieved after touching or\u000a		//			 *		passing it. If not provided, the walker stops at the\u000a		//			 *		&lt;body&gt; closing boundary.\u000a		//			 * @returns {CKEDITOR.dom.walker} A DOM walker for the nodes between the\u000a		//			 *		provided nodes.\u000a		//			 */\u000a		//			createOnNodes : function( startNode, endNode, startInclusive, endInclusive )\u000a		//			{\u000a		//				var range = new CKEDITOR.dom.range();\u000a		//				if ( startNode )\u000a		//					range.setStartAt( startNode, startInclusive ? CKEDITOR.POSITION_BEFORE_START : CKEDITOR.POSITION_AFTER_END ) ;\u000a		//				else\u000a		//					range.setStartAt( startNode.getDocument().getBody(), CKEDITOR.POSITION_AFTER_START ) ;\u000a		//\u000a		//				if ( endNode )\u000a		//					range.setEndAt( endNode, endInclusive ? CKEDITOR.POSITION_AFTER_END : CKEDITOR.POSITION_BEFORE_START ) ;\u000a		//				else\u000a		//					range.setEndAt( startNode.getDocument().getBody(), CKEDITOR.POSITION_BEFORE_END ) ;\u000a		//\u000a		//				return new CKEDITOR.dom.walker( range );\u000a		//			}\u000a		//		},\u000a		//\u000a		proto: {\u000a			/**\u000a			 * Stops walking. No more nodes are retrieved if this function gets called.\u000a			 */\u000a			end: function() {\u000a				this._.end = 1;\u000a			},\u000a\u000a			/**\u000a			 * Retrieves the next node (at right).\u000a			 *\u000a			 * @returns {CKEDITOR.dom.node} The next node or null if no more\u000a			 * nodes are available.\u000a			 */\u000a			next: function() {\u000a				return iterate.call( this );\u000a			},\u000a\u000a			/**\u000a			 * Retrieves the previous node (at left).\u000a			 *\u000a			 * @returns {CKEDITOR.dom.node} The previous node or null if no more\u000a			 * nodes are available.\u000a			 */\u000a			previous: function() {\u000a				return iterate.call( this, 1 );\u000a			},\u000a\u000a			/**\u000a			 * Check all nodes at right, executing the evaluation function.\u000a			 *\u000a			 * @returns {Boolean} `false` if the evaluator function returned\u000a			 * `false` for any of the matched nodes. Otherwise `true`.\u000a			 */\u000a			checkForward: function() {\u000a				return iterate.call( this, 0, 1 ) !== false;\u000a			},\u000a\u000a			/**\u000a			 * Check all nodes at left, executing the evaluation function.\u000a			 *\u000a			 * @returns {Boolean} `false` if the evaluator function returned\u000a			 * `false` for any of the matched nodes. Otherwise `true`.\u000a			 */\u000a			checkBackward: function() {\u000a				return iterate.call( this, 1, 1 ) !== false;\u000a			},\u000a\u000a			/**\u000a			 * Executes a full walk forward (to the right), until no more nodes\u000a			 * are available, returning the last valid node.\u000a			 *\u000a			 * @returns {CKEDITOR.dom.node} The last node at the right or null\u000a			 * if no valid nodes are available.\u000a			 */\u000a			lastForward: function() {\u000a				return iterateToLast.call( this );\u000a			},\u000a\u000a			/**\u000a			 * Executes a full walk backwards (to the left), until no more nodes\u000a			 * are available, returning the last valid node.\u000a			 *\u000a			 * @returns {CKEDITOR.dom.node} The last node at the left or null\u000a			 * if no valid nodes are available.\u000a			 */\u000a			lastBackward: function() {\u000a				return iterateToLast.call( this, 1 );\u000a			},\u000a\u000a			/**\u000a			 * Resets walker.\u000a			 */\u000a			reset: function() {\u000a				delete this.current;\u000a				this._ = {};\u000a			}\u000a\u000a		}\u000a	} );\u000a\u000a	// Anything whose display computed style is block, list-item, table,\u000a	// table-row-group, table-header-group, table-footer-group, table-row,\u000a	// table-column-group, table-column, table-cell, table-caption, or whose node\u000a	// name is hr, br (when enterMode is br only) is a block boundary.\u000a	var blockBoundaryDisplayMatch = {\u000a			block: 1, 'list-item': 1, table: 1, 'table-row-group': 1,\u000a			'table-header-group': 1, 'table-footer-group': 1, 'table-row': 1, 'table-column-group': 1,\u000a			'table-column': 1, 'table-cell': 1, 'table-caption': 1\u000a		},\u000a		outOfFlowPositions = { absolute: 1, fixed: 1 };\u000a\u000a	/**\u000a	 * Checks whether element is displayed as a block.\u000a	 *\u000a	 * @member CKEDITOR.dom.element\u000a	 * @param [customNodeNames] Custom list of nodes which will extend\u000a	 * default {@link CKEDITOR.dtd#$block} list.\u000a	 * @returns {Boolean}\u000a	 */\u000a	CKEDITOR.dom.element.prototype.isBlockBoundary = function( customNodeNames ) {\u000a		// Whether element is in normal page flow. Floated or positioned elements are out of page flow.\u000a		// Don't consider floated or positioned formatting as block boundary, fall back to dtd check in that case. (#6297)\u000a		var inPageFlow = this.getComputedStyle( 'float' ) == 'none' && !( this.getComputedStyle( 'position' ) in outOfFlowPositions );\u000a\u000a		if ( inPageFlow && blockBoundaryDisplayMatch[ this.getComputedStyle( 'display' ) ] )\u000a			return true;\u000a\u000a		// Either in $block or in customNodeNames if defined.\u000a		return !!( this.is( CKEDITOR.dtd.$block ) || customNodeNames && this.is( customNodeNames ) );\u000a	};\u000a\u000a	/**\u000a	 * Returns a function which checks whether the node is a block boundary.\u000a	 * See {@link CKEDITOR.dom.element#isBlockBoundary}.\u000a	 *\u000a	 * @static\u000a	 * @param customNodeNames\u000a	 * @returns {Function}\u000a	 */\u000a	CKEDITOR.dom.walker.blockBoundary = function( customNodeNames ) {\u000a		return function( node ) {\u000a			return !( node.type == CKEDITOR.NODE_ELEMENT && node.isBlockBoundary( customNodeNames ) );\u000a		};\u000a	};\u000a\u000a	/**\u000a	 * @static\u000a	 * @todo\u000a	 */\u000a	CKEDITOR.dom.walker.listItemBoundary = function() {\u000a		return this.blockBoundary( { br: 1 } );\u000a	};\u000a\u000a	/**\u000a	 * Returns a function which checks whether the node is a bookmark node OR bookmark node\u000a	 * inner contents.\u000a	 *\u000a	 * @static\u000a	 * @param {Boolean} [contentOnly=false] Whether only test against the text content of\u000a	 * bookmark node instead of the element itself (default).\u000a	 * @param {Boolean} [isReject=false] Whether should return `false` for the bookmark\u000a	 * node instead of `true` (default).\u000a	 * @returns {Function}\u000a	 */\u000a	CKEDITOR.dom.walker.bookmark = function( contentOnly, isReject ) {\u000a		function isBookmarkNode( node ) {\u000a			return ( node && node.getName && node.getName() == 'span' && node.data( 'cke-bookmark' ) );\u000a		}\u000a\u000a		return function( node ) {\u000a			var isBookmark, parent;\u000a			// Is bookmark inner text node?\u000a			isBookmark = ( node && node.type != CKEDITOR.NODE_ELEMENT && ( parent = node.getParent() ) && isBookmarkNode( parent ) );\u000a			// Is bookmark node?\u000a			isBookmark = contentOnly ? isBookmark : isBookmark || isBookmarkNode( node );\u000a			return !!( isReject ^ isBookmark );\u000a		};\u000a	};\u000a\u000a	/**\u000a	 * Returns a function which checks whether the node is a text node containing only whitespaces characters.\u000a	 *\u000a	 * @static\u000a	 * @param {Boolean} [isReject=false]\u000a	 * @returns {Function}\u000a	 */\u000a	CKEDITOR.dom.walker.whitespaces = function( isReject ) {\u000a		return function( node ) {\u000a			var isWhitespace;\u000a			if ( node && node.type == CKEDITOR.NODE_TEXT ) {\u000a				// whitespace, as well as the text cursor filler node we used in Webkit. (#9384)\u000a				isWhitespace = !CKEDITOR.tools.trim( node.getText() ) ||\u000a					CKEDITOR.env.webkit && node.getText() == '\u005cu200b';\u000a			}\u000a\u000a			return !!( isReject ^ isWhitespace );\u000a		};\u000a	};\u000a\u000a	/**\u000a	 * Returns a function which checks whether the node is invisible in the WYSIWYG mode.\u000a	 *\u000a	 * @static\u000a	 * @param {Boolean} [isReject=false]\u000a	 * @returns {Function}\u000a	 */\u000a	CKEDITOR.dom.walker.invisible = function( isReject ) {\u000a		var whitespace = CKEDITOR.dom.walker.whitespaces(),\u000a			// #12221 (Chrome) plus #11111 (Safari).\u000a			offsetWidth0 = CKEDITOR.env.webkit ? 1 : 0;\u000a\u000a		return function( node ) {\u000a			var invisible;\u000a\u000a			if ( whitespace( node ) )\u000a				invisible = 1;\u000a			else {\u000a				// Visibility should be checked on element.\u000a				if ( node.type == CKEDITOR.NODE_TEXT )\u000a					node = node.getParent();\u000a\u000a				// Nodes that take no spaces in wysiwyg:\u000a				// 1. White-spaces but not including NBSP.\u000a				// 2. Empty inline elements, e.g. <b></b>.\u000a				// 3. <br> elements (bogus, surrounded by text) (#12423).\u000a				invisible = node.$.offsetWidth <= offsetWidth0;\u000a			}\u000a\u000a			return !!( isReject ^ invisible );\u000a		};\u000a	};\u000a\u000a	/**\u000a	 * Returns a function which checks whether node's type is equal to passed one.\u000a	 *\u000a	 * @static\u000a	 * @param {Number} type\u000a	 * @param {Boolean} [isReject=false]\u000a	 * @returns {Function}\u000a	 */\u000a	CKEDITOR.dom.walker.nodeType = function( type, isReject ) {\u000a		return function( node ) {\u000a			return !!( isReject ^ ( node.type == type ) );\u000a		};\u000a	};\u000a\u000a	/**\u000a	 * Returns a function which checks whether node is a bogus (filler) node from\u000a	 * contenteditable element's point of view.\u000a	 *\u000a	 * @static\u000a	 * @param {Boolean} [isReject=false]\u000a	 * @returns {Function}\u000a	 */\u000a	CKEDITOR.dom.walker.bogus = function( isReject ) {\u000a		function nonEmpty( node ) {\u000a			return !isWhitespaces( node ) && !isBookmark( node );\u000a		}\u000a\u000a		return function( node ) {\u000a			var isBogus = CKEDITOR.env.needsBrFiller ? node.is && node.is( 'br' ) : node.getText && tailNbspRegex.test( node.getText() );\u000a\u000a			if ( isBogus ) {\u000a				var parent = node.getParent(),\u000a					next = node.getNext( nonEmpty );\u000a\u000a				isBogus = parent.isBlockBoundary() && ( !next || next.type == CKEDITOR.NODE_ELEMENT && next.isBlockBoundary() );\u000a			}\u000a\u000a			return !!( isReject ^ isBogus );\u000a		};\u000a	};\u000a\u000a	/**\u000a	 * Returns a function which checks whether node is a temporary element\u000a	 * (element with `data-cke-temp` attribute) or its child.\u000a	 *\u000a	 * @since 4.3\u000a	 * @static\u000a	 * @param {Boolean} [isReject=false] Whether should return `false` for the\u000a	 * temporary element instead of `true` (default).\u000a	 * @returns {Function}\u000a	 */\u000a	CKEDITOR.dom.walker.temp = function( isReject ) {\u000a		return function( node ) {\u000a			if ( node.type != CKEDITOR.NODE_ELEMENT )\u000a				node = node.getParent();\u000a\u000a			var isTemp = node && node.hasAttribute( 'data-cke-temp' );\u000a\u000a			return !!( isReject ^ isTemp );\u000a		};\u000a	};\u000a\u000a	var tailNbspRegex = /^[\u005ct\u005cr\u005cn ]*(?:&nbsp;|\u005cxa0)$/,\u000a		isWhitespaces = CKEDITOR.dom.walker.whitespaces(),\u000a		isBookmark = CKEDITOR.dom.walker.bookmark(),\u000a		isTemp = CKEDITOR.dom.walker.temp(),\u000a		toSkip = function( node ) {\u000a			return isBookmark( node ) ||\u000a				isWhitespaces( node ) ||\u000a				node.type == CKEDITOR.NODE_ELEMENT && node.is( CKEDITOR.dtd.$inline ) && !node.is( CKEDITOR.dtd.$empty );\u000a		};\u000a\u000a	/**\u000a	 * Returns a function which checks whether node should be ignored in terms of "editability".\u000a	 *\u000a	 * This includes:\u000a	 *\u000a	 * * whitespaces (see {@link CKEDITOR.dom.walker#whitespaces}),\u000a	 * * bookmarks (see {@link CKEDITOR.dom.walker#bookmark}),\u000a	 * * temporary elements (see {@link CKEDITOR.dom.walker#temp}).\u000a	 *\u000a	 * @since 4.3\u000a	 * @static\u000a	 * @param {Boolean} [isReject=false] Whether should return `false` for the\u000a	 * ignored element instead of `true` (default).\u000a	 * @returns {Function}\u000a	 */\u000a	CKEDITOR.dom.walker.ignored = function( isReject ) {\u000a		return function( node ) {\u000a			var isIgnored = isWhitespaces( node ) || isBookmark( node ) || isTemp( node );\u000a\u000a			return !!( isReject ^ isIgnored );\u000a		};\u000a	};\u000a\u000a	var isIgnored = CKEDITOR.dom.walker.ignored();\u000a\u000a	function isEmpty( node ) {\u000a		var i = 0,\u000a			l = node.getChildCount();\u000a\u000a		for ( ; i < l; ++i ) {\u000a			if ( !isIgnored( node.getChild( i ) ) )\u000a				return false;\u000a		}\u000a		return true;\u000a	}\u000a\u000a	function filterTextContainers( dtd ) {\u000a		var hash = {},\u000a			name;\u000a\u000a		for ( name in dtd ) {\u000a			if ( CKEDITOR.dtd[ name ][ '#' ] )\u000a				hash[ name ] = 1;\u000a		}\u000a		return hash;\u000a	}\u000a\u000a	// Block elements which can contain text nodes (without ul, ol, dl, etc.).\u000a	var dtdTextBlock = filterTextContainers( CKEDITOR.dtd.$block );\u000a\u000a	function isEditable( node ) {\u000a		// Skip temporary elements, bookmarks and whitespaces.\u000a		if ( isIgnored( node ) )\u000a			return false;\u000a\u000a		if ( node.type == CKEDITOR.NODE_TEXT )\u000a			return true;\u000a\u000a		if ( node.type == CKEDITOR.NODE_ELEMENT ) {\u000a			// All inline and non-editable elements are valid editable places.\u000a			// Note: the <hr> is currently the only element in CKEDITOR.dtd.$empty and CKEDITOR.dtd.$block,\u000a			// but generally speaking we need an intersection of these two sets.\u000a			// Note: non-editable block has to be treated differently (should be selected entirely).\u000a			if ( node.is( CKEDITOR.dtd.$inline ) || node.is( 'hr' ) || node.getAttribute( 'contenteditable' ) == 'false' )\u000a				return true;\u000a\u000a			// Empty blocks are editable on IE.\u000a			if ( !CKEDITOR.env.needsBrFiller && node.is( dtdTextBlock ) && isEmpty( node ) )\u000a				return true;\u000a		}\u000a\u000a		// Skip all other nodes.\u000a		return false;\u000a	}\u000a\u000a	/**\u000a	 * Returns a function which checks whether node can be a container or a sibling\u000a	 * of selection end.\u000a	 *\u000a	 * This includes:\u000a	 *\u000a	 * * text nodes (but not whitespaces),\u000a	 * * inline elements,\u000a	 * * intersection of {@link CKEDITOR.dtd#$empty} and {@link CKEDITOR.dtd#$block} (currenly\u000a	 * it's only `<hr>`),\u000a	 * * non-editable blocks (special case - such blocks cannot be containers nor\u000a	 * siblings, they need to be selected entirely),\u000a	 * * empty blocks which can contain text (IE only).\u000a	 *\u000a	 * @since 4.3\u000a	 * @static\u000a	 * @param {Boolean} [isReject=false] Whether should return `false` for the\u000a	 * ignored element instead of `true` (default).\u000a	 * @returns {Function}\u000a	 */\u000a	CKEDITOR.dom.walker.editable = function( isReject ) {\u000a		return function( node ) {\u000a			return !!( isReject ^ isEditable( node ) );\u000a		};\u000a	};\u000a\u000a	/**\u000a	 * Checks if there's a filler node at the end of an element, and returns it.\u000a	 *\u000a	 * @member CKEDITOR.dom.element\u000a	 * @returns {CKEDITOR.dom.node/Boolean} Bogus node or `false`.\u000a	 */\u000a	CKEDITOR.dom.element.prototype.getBogus = function() {\u000a		// Bogus are not always at the end, e.g. <p><a>text<br /></a></p> (#7070).\u000a		var tail = this;\u000a		do {\u000a			tail = tail.getPreviousSourceNode();\u000a		}\u000a		while ( toSkip( tail ) );\u000a\u000a		if ( tail && ( CKEDITOR.env.needsBrFiller ? tail.is && tail.is( 'br' ) : tail.getText && tailNbspRegex.test( tail.getText() ) ) )\u000a			return tail;\u000a\u000a		return false;\u000a	};\u000a\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * DocumentFragment is a "lightweight" or "minimal" Document object. It is\u000a * commonly used to extract a portion of a document's tree or to create a new\u000a * fragment of a document. Various operations may take DocumentFragment objects\u000a * as arguments and results in all the child nodes of the DocumentFragment being\u000a * moved to the child list of this node.\u000a *\u000a * @class\u000a * @constructor Creates a document fragment class instance.\u000a * @param {Object} nodeOrDoc\u000a * @todo example and param doc\u000a */\u000aCKEDITOR.dom.documentFragment = function( nodeOrDoc ) {\u000a	nodeOrDoc = nodeOrDoc || CKEDITOR.document;\u000a\u000a	if ( nodeOrDoc.type == CKEDITOR.NODE_DOCUMENT )\u000a		this.$ = nodeOrDoc.$.createDocumentFragment();\u000a	else\u000a		this.$ = nodeOrDoc;\u000a};\u000a\u000aCKEDITOR.tools.extend( CKEDITOR.dom.documentFragment.prototype, CKEDITOR.dom.element.prototype, {\u000a	/**\u000a	 * The node type. This is a constant value set to {@link CKEDITOR#NODE_DOCUMENT_FRAGMENT}.\u000a	 *\u000a	 * @readonly\u000a	 * @property {Number} [=CKEDITOR.NODE_DOCUMENT_FRAGMENT]\u000a	 */\u000a	type: CKEDITOR.NODE_DOCUMENT_FRAGMENT,\u000a\u000a	/**\u000a	 * Inserts document fragment's contents after specified node.\u000a	 *\u000a	 * @param {CKEDITOR.dom.node} node\u000a	 */\u000a	insertAfterNode: function( node ) {\u000a		node = node.$;\u000a		node.parentNode.insertBefore( this.$, node.nextSibling );\u000a	}\u000a}, true, {\u000a	'append': 1, 'appendBogus': 1, 'getFirst': 1, 'getLast': 1, 'getParent': 1, 'getNext': 1, 'getPrevious': 1,\u000a	'appendTo': 1, 'moveChildren': 1, 'insertBefore': 1, 'insertAfterNode': 1, 'replace': 1, 'trim': 1, 'type': 1,\u000a	'ltrim': 1, 'rtrim': 1, 'getDocument': 1, 'getChildCount': 1, 'getChild': 1, 'getChildren': 1\u000a} );\u000a\u000a/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * Represents a delimited piece of content in a DOM Document.\u000a * It is contiguous in the sense that it can be characterized as selecting all\u000a * of the content between a pair of boundary-points.\u000a *\u000a * This class shares much of the W3C\u000a * [Document Object Model Range](http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html)\u000a * ideas and features, adding several range manipulation tools to it, but it's\u000a * not intended to be compatible with it.\u000a *\u000a *		// Create a range for the entire contents of the editor document body.\u000a *		var range = new CKEDITOR.dom.range( editor.document );\u000a *		range.selectNodeContents( editor.document.getBody() );\u000a *		// Delete the contents.\u000a *		range.deleteContents();\u000a *\u000a * Usually you will want to work on a ranges rooted in the editor's {@link CKEDITOR.editable editable}\u000a * element. Such ranges can be created with a shorthand method &ndash; {@link CKEDITOR.editor#createRange editor.createRange}.\u000a *\u000a *		var range = editor.createRange();\u000a *		range.root.equals( editor.editable() ); // -> true\u000a *\u000a * Note that the {@link #root} of a range is an important property, which limits many\u000a * algorithms implemented in range's methods. Therefore it is crucial, especially\u000a * when using ranges inside inline editors, to specify correct root, so using\u000a * the {@link CKEDITOR.editor#createRange} method is highly recommended.\u000a *\u000a * ### Selection\u000a *\u000a * Range is only a logical representation of a piece of content in a DOM. It should not\u000a * be confused with a {@link CKEDITOR.dom.selection selection} which represents "physically\u000a * marked" content. It is possible to create unlimited number of various ranges, when\u000a * only one real selection may exist at a time in a document. Ranges are used to read position\u000a * of selection in the DOM and to move selection to new positions.\u000a *\u000a * The editor selection may be retrieved using the {@link CKEDITOR.editor#getSelection} method:\u000a *\u000a *		var sel = editor.getSelection(),\u000a *			ranges = sel.getRange(); // CKEDITOR.dom.rangeList instance.\u000a *\u000a *		var range = ranges[ 0 ];\u000a *		range.root; // -> editor's editable element.\u000a *\u000a * A range can also be selected:\u000a *\u000a *		var range = editor.createRange();\u000a *		range.selectNodeContents( editor.editable() );\u000a *		sel.selectRanges( [ range ] );\u000a *\u000a * @class\u000a * @constructor Creates a {@link CKEDITOR.dom.range} instance that can be used inside a specific DOM Document.\u000a * @param {CKEDITOR.dom.document/CKEDITOR.dom.element} root The document or element\u000a * within which the range will be scoped.\u000a * @todo global "TODO" - precise algorithms descriptions needed for the most complex methods like #enlarge.\u000a */\u000aCKEDITOR.dom.range = function( root ) {\u000a	/**\u000a	 * Node within which the range begins.\u000a	 *\u000a	 *		var range = new CKEDITOR.dom.range( editor.document );\u000a	 *		range.selectNodeContents( editor.document.getBody() );\u000a	 *		alert( range.startContainer.getName() ); // 'body'\u000a	 *\u000a	 * @readonly\u000a	 * @property {CKEDITOR.dom.element/CKEDITOR.dom.text}\u000a	 */\u000a	this.startContainer = null;\u000a\u000a	/**\u000a	 * Offset within the starting node of the range.\u000a	 *\u000a	 *		var range = new CKEDITOR.dom.range( editor.document );\u000a	 *		range.selectNodeContents( editor.document.getBody() );\u000a	 *		alert( range.startOffset ); // 0\u000a	 *\u000a	 * @readonly\u000a	 * @property {Number}\u000a	 */\u000a	this.startOffset = null;\u000a\u000a	/**\u000a	 * Node within which the range ends.\u000a	 *\u000a	 *		var range = new CKEDITOR.dom.range( editor.document );\u000a	 *		range.selectNodeContents( editor.document.getBody() );\u000a	 *		alert( range.endContainer.getName() ); // 'body'\u000a	 *\u000a	 * @readonly\u000a	 * @property {CKEDITOR.dom.element/CKEDITOR.dom.text}\u000a	 */\u000a	this.endContainer = null;\u000a\u000a	/**\u000a	 * Offset within the ending node of the range.\u000a	 *\u000a	 *		var range = new CKEDITOR.dom.range( editor.document );\u000a	 *		range.selectNodeContents( editor.document.getBody() );\u000a	 *		alert( range.endOffset ); // == editor.document.getBody().getChildCount()\u000a	 *\u000a	 * @readonly\u000a	 * @property {Number}\u000a	 */\u000a	this.endOffset = null;\u000a\u000a	/**\u000a	 * Indicates that this is a collapsed range. A collapsed range has its\u000a	 * start and end boundaries at the very same point so nothing is contained\u000a	 * in it.\u000a	 *\u000a	 *		var range = new CKEDITOR.dom.range( editor.document );\u000a	 *		range.selectNodeContents( editor.document.getBody() );\u000a	 *		alert( range.collapsed ); // false\u000a	 *		range.collapse();\u000a	 *		alert( range.collapsed ); // true\u000a	 *\u000a	 * @readonly\u000a	 */\u000a	this.collapsed = true;\u000a\u000a	var isDocRoot = root instanceof CKEDITOR.dom.document;\u000a	/**\u000a	 * The document within which the range can be used.\u000a	 *\u000a	 *		// Selects the body contents of the range document.\u000a	 *		range.selectNodeContents( range.document.getBody() );\u000a	 *\u000a	 * @readonly\u000a	 * @property {CKEDITOR.dom.document}\u000a	 */\u000a	this.document = isDocRoot ? root : root.getDocument();\u000a\u000a	/**\u000a	 * The ancestor DOM element within which the range manipulation are limited.\u000a	 *\u000a	 * @readonly\u000a	 * @property {CKEDITOR.dom.element}\u000a	 */\u000a	this.root = isDocRoot ? root.getBody() : root;\u000a};\u000a\u000a( function() {\u000a	// Updates the "collapsed" property for the given range object.\u000a	var updateCollapsed = function( range ) {\u000a			range.collapsed = ( range.startContainer && range.endContainer && range.startContainer.equals( range.endContainer ) && range.startOffset == range.endOffset );\u000a		};\u000a\u000a	// This is a shared function used to delete, extract and clone the range\u000a	// contents.\u000a	// V2\u000a	var execContentsAction = function( range, action, docFrag, mergeThen ) {\u000a			range.optimizeBookmark();\u000a\u000a			var startNode = range.startContainer;\u000a			var endNode = range.endContainer;\u000a\u000a			var startOffset = range.startOffset;\u000a			var endOffset = range.endOffset;\u000a\u000a			var removeStartNode;\u000a			var removeEndNode;\u000a\u000a			// For text containers, we must simply split the node and point to the\u000a			// second part. The removal will be handled by the rest of the code .\u000a			if ( endNode.type == CKEDITOR.NODE_TEXT )\u000a				endNode = endNode.split( endOffset );\u000a			else {\u000a				// If the end container has children and the offset is pointing\u000a				// to a child, then we should start from it.\u000a				if ( endNode.getChildCount() > 0 ) {\u000a					// If the offset points after the last node.\u000a					if ( endOffset >= endNode.getChildCount() ) {\u000a						// Let's create a temporary node and mark it for removal.\u000a						endNode = endNode.append( range.document.createText( '' ) );\u000a						removeEndNode = true;\u000a					} else {\u000a						endNode = endNode.getChild( endOffset );\u000a					}\u000a				}\u000a			}\u000a\u000a			// For text containers, we must simply split the node. The removal will\u000a			// be handled by the rest of the code .\u000a			if ( startNode.type == CKEDITOR.NODE_TEXT ) {\u000a				startNode.split( startOffset );\u000a\u000a				// In cases the end node is the same as the start node, the above\u000a				// splitting will also split the end, so me must move the end to\u000a				// the second part of the split.\u000a				if ( startNode.equals( endNode ) )\u000a					endNode = startNode.getNext();\u000a			} else {\u000a				// If the start container has children and the offset is pointing\u000a				// to a child, then we should start from its previous sibling.\u000a\u000a				// If the offset points to the first node, we don't have a\u000a				// sibling, so let's use the first one, but mark it for removal.\u000a				if ( !startOffset ) {\u000a					// Let's create a temporary node and mark it for removal.\u000a					startNode = startNode.append( range.document.createText( '' ), 1 );\u000a					removeStartNode = true;\u000a				} else if ( startOffset >= startNode.getChildCount() ) {\u000a					// Let's create a temporary node and mark it for removal.\u000a					startNode = startNode.append( range.document.createText( '' ) );\u000a					removeStartNode = true;\u000a				} else {\u000a					startNode = startNode.getChild( startOffset ).getPrevious();\u000a				}\u000a			}\u000a\u000a			// Get the parent nodes tree for the start and end boundaries.\u000a			var startParents = startNode.getParents();\u000a			var endParents = endNode.getParents();\u000a\u000a			// Compare them, to find the top most siblings.\u000a			var i, topStart, topEnd;\u000a\u000a			for ( i = 0; i < startParents.length; i++ ) {\u000a				topStart = startParents[ i ];\u000a				topEnd = endParents[ i ];\u000a\u000a				// The compared nodes will match until we find the top most\u000a				// siblings (different nodes that have the same parent).\u000a				// "i" will hold the index in the parents array for the top\u000a				// most element.\u000a				if ( !topStart.equals( topEnd ) )\u000a					break;\u000a			}\u000a\u000a			var clone = docFrag,\u000a				levelStartNode, levelClone, currentNode, currentSibling;\u000a\u000a			// Remove all successive sibling nodes for every node in the\u000a			// startParents tree.\u000a			for ( var j = i; j < startParents.length; j++ ) {\u000a				levelStartNode = startParents[ j ];\u000a\u000a				// For Extract and Clone, we must clone this level.\u000a				if ( clone && !levelStartNode.equals( startNode ) ) // action = 0 = Delete\u000a				levelClone = clone.append( levelStartNode.clone() );\u000a\u000a				currentNode = levelStartNode.getNext();\u000a\u000a				while ( currentNode ) {\u000a					// Stop processing when the current node matches a node in the\u000a					// endParents tree or if it is the endNode.\u000a					if ( currentNode.equals( endParents[ j ] ) || currentNode.equals( endNode ) )\u000a						break;\u000a\u000a					// Cache the next sibling.\u000a					currentSibling = currentNode.getNext();\u000a\u000a					// If cloning, just clone it.\u000a					if ( action == 2 ) // 2 = Clone\u000a					clone.append( currentNode.clone( true ) );\u000a					else {\u000a						// Both Delete and Extract will remove the node.\u000a						currentNode.remove();\u000a\u000a						// When Extracting, move the removed node to the docFrag.\u000a						if ( action == 1 ) // 1 = Extract\u000a						clone.append( currentNode );\u000a					}\u000a\u000a					currentNode = currentSibling;\u000a				}\u000a\u000a				if ( clone )\u000a					clone = levelClone;\u000a			}\u000a\u000a			clone = docFrag;\u000a\u000a			// Remove all previous sibling nodes for every node in the\u000a			// endParents tree.\u000a			for ( var k = i; k < endParents.length; k++ ) {\u000a				levelStartNode = endParents[ k ];\u000a\u000a				// For Extract and Clone, we must clone this level.\u000a				if ( action > 0 && !levelStartNode.equals( endNode ) ) // action = 0 = Delete\u000a				levelClone = clone.append( levelStartNode.clone() );\u000a\u000a				// The processing of siblings may have already been done by the parent.\u000a				if ( !startParents[ k ] || levelStartNode.$.parentNode != startParents[ k ].$.parentNode ) {\u000a					currentNode = levelStartNode.getPrevious();\u000a\u000a					while ( currentNode ) {\u000a						// Stop processing when the current node matches a node in the\u000a						// startParents tree or if it is the startNode.\u000a						if ( currentNode.equals( startParents[ k ] ) || currentNode.equals( startNode ) )\u000a							break;\u000a\u000a						// Cache the next sibling.\u000a						currentSibling = currentNode.getPrevious();\u000a\u000a						// If cloning, just clone it.\u000a						if ( action == 2 ) // 2 = Clone\u000a						clone.$.insertBefore( currentNode.$.cloneNode( true ), clone.$.firstChild );\u000a						else {\u000a							// Both Delete and Extract will remove the node.\u000a							currentNode.remove();\u000a\u000a							// When Extracting, mode the removed node to the docFrag.\u000a							if ( action == 1 ) // 1 = Extract\u000a							clone.$.insertBefore( currentNode.$, clone.$.firstChild );\u000a						}\u000a\u000a						currentNode = currentSibling;\u000a					}\u000a				}\u000a\u000a				if ( clone )\u000a					clone = levelClone;\u000a			}\u000a\u000a			if ( action == 2 ) // 2 = Clone.\u000a			{\u000a				// No changes in the DOM should be done, so fix the split text (if any).\u000a\u000a				var startTextNode = range.startContainer;\u000a				if ( startTextNode.type == CKEDITOR.NODE_TEXT ) {\u000a					startTextNode.$.data += startTextNode.$.nextSibling.data;\u000a					startTextNode.$.parentNode.removeChild( startTextNode.$.nextSibling );\u000a				}\u000a\u000a				var endTextNode = range.endContainer;\u000a				if ( endTextNode.type == CKEDITOR.NODE_TEXT && endTextNode.$.nextSibling ) {\u000a					endTextNode.$.data += endTextNode.$.nextSibling.data;\u000a					endTextNode.$.parentNode.removeChild( endTextNode.$.nextSibling );\u000a				}\u000a			} else {\u000a				// Collapse the range.\u000a\u000a				// If a node has been partially selected, collapse the range between\u000a				// topStart and topEnd. Otherwise, simply collapse it to the start. (W3C specs).\u000a				if ( topStart && topEnd && ( startNode.$.parentNode != topStart.$.parentNode || endNode.$.parentNode != topEnd.$.parentNode ) ) {\u000a					var endIndex = topEnd.getIndex();\u000a\u000a					// If the start node is to be removed, we must correct the\u000a					// index to reflect the removal.\u000a					if ( removeStartNode && topEnd.$.parentNode == startNode.$.parentNode )\u000a						endIndex--;\u000a\u000a					// Merge splitted parents.\u000a					if ( mergeThen && topStart.type == CKEDITOR.NODE_ELEMENT ) {\u000a						var span = CKEDITOR.dom.element.createFromHtml( '<span ' +\u000a							'data-cke-bookmark="1" style="display:none">&nbsp;</span>', range.document );\u000a						span.insertAfter( topStart );\u000a						topStart.mergeSiblings( false );\u000a						range.moveToBookmark( { startNode: span } );\u000a					} else {\u000a						range.setStart( topEnd.getParent(), endIndex );\u000a					}\u000a				}\u000a\u000a				// Collapse it to the start.\u000a				range.collapse( true );\u000a			}\u000a\u000a			// Cleanup any marked node.\u000a			if ( removeStartNode )\u000a				startNode.remove();\u000a\u000a			if ( removeEndNode && endNode.$.parentNode )\u000a				endNode.remove();\u000a		};\u000a\u000a	var inlineChildReqElements = {\u000a		abbr: 1, acronym: 1, b: 1, bdo: 1, big: 1, cite: 1, code: 1, del: 1,\u000a		dfn: 1, em: 1, font: 1, i: 1, ins: 1, label: 1, kbd: 1, q: 1, samp: 1, small: 1, span: 1, strike: 1,\u000a		strong: 1, sub: 1, sup: 1, tt: 1, u: 1, 'var': 1\u000a	};\u000a\u000a	// Creates the appropriate node evaluator for the dom walker used inside\u000a	// check(Start|End)OfBlock.\u000a	function getCheckStartEndBlockEvalFunction() {\u000a		var skipBogus = false,\u000a			whitespaces = CKEDITOR.dom.walker.whitespaces(),\u000a			bookmarkEvaluator = CKEDITOR.dom.walker.bookmark( true ),\u000a			isBogus = CKEDITOR.dom.walker.bogus();\u000a\u000a		return function( node ) {\u000a			// First skip empty nodes\u000a			if ( bookmarkEvaluator( node ) || whitespaces( node ) )\u000a				return true;\u000a\u000a			// Skip the bogus node at the end of block.\u000a			if ( isBogus( node ) && !skipBogus ) {\u000a				skipBogus = true;\u000a				return true;\u000a			}\u000a\u000a			// If there's any visible text, then we're not at the start.\u000a			if ( node.type == CKEDITOR.NODE_TEXT &&\u000a				( node.hasAscendant( 'pre' ) ||\u000a					CKEDITOR.tools.trim( node.getText() ).length ) ) {\u000a				return false;\u000a			}\u000a\u000a			// If there are non-empty inline elements (e.g. <img />), then we're not\u000a			// at the start.\u000a			if ( node.type == CKEDITOR.NODE_ELEMENT && !node.is( inlineChildReqElements ) )\u000a				return false;\u000a\u000a			return true;\u000a		};\u000a	}\u000a\u000a	var isBogus = CKEDITOR.dom.walker.bogus(),\u000a		nbspRegExp = /^[\u005ct\u005cr\u005cn ]*(?:&nbsp;|\u005cxa0)$/,\u000a		editableEval = CKEDITOR.dom.walker.editable(),\u000a		notIgnoredEval = CKEDITOR.dom.walker.ignored( true );\u000a\u000a	// Evaluator for CKEDITOR.dom.element::checkBoundaryOfElement, reject any\u000a	// text node and non-empty elements unless it's being bookmark text.\u000a	function elementBoundaryEval( checkStart ) {\u000a		var whitespaces = CKEDITOR.dom.walker.whitespaces(),\u000a			bookmark = CKEDITOR.dom.walker.bookmark( 1 );\u000a\u000a		return function( node ) {\u000a			// First skip empty nodes.\u000a			if ( bookmark( node ) || whitespaces( node ) )\u000a				return true;\u000a\u000a			// Tolerant bogus br when checking at the end of block.\u000a			// Reject any text node unless it's being bookmark\u000a			// OR it's spaces.\u000a			// Reject any element unless it's being invisible empty. (#3883)\u000a			return !checkStart && isBogus( node ) ||\u000a				node.type == CKEDITOR.NODE_ELEMENT &&\u000a				node.is( CKEDITOR.dtd.$removeEmpty );\u000a		};\u000a	}\u000a\u000a	function getNextEditableNode( isPrevious ) {\u000a		return function() {\u000a			var first;\u000a\u000a			return this[ isPrevious ? 'getPreviousNode' : 'getNextNode' ]( function( node ) {\u000a				// Cache first not ignorable node.\u000a				if ( !first && notIgnoredEval( node ) )\u000a					first = node;\u000a\u000a				// Return true if found editable node, but not a bogus next to start of our lookup (first != bogus).\u000a				return editableEval( node ) && !( isBogus( node ) && node.equals( first ) );\u000a			} );\u000a		};\u000a	}\u000a\u000a	CKEDITOR.dom.range.prototype = {\u000a		/**\u000a		 * Clones this range.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.range}\u000a		 */\u000a		clone: function() {\u000a			var clone = new CKEDITOR.dom.range( this.root );\u000a\u000a			clone.startContainer = this.startContainer;\u000a			clone.startOffset = this.startOffset;\u000a			clone.endContainer = this.endContainer;\u000a			clone.endOffset = this.endOffset;\u000a			clone.collapsed = this.collapsed;\u000a\u000a			return clone;\u000a		},\u000a\u000a		/**\u000a		 * Makes range collapsed by moving its start point (or end point if `toStart==true`)\u000a		 * to the second end.\u000a		 *\u000a		 * @param {Boolean} toStart Collapse range "to start".\u000a		 */\u000a		collapse: function( toStart ) {\u000a			if ( toStart ) {\u000a				this.endContainer = this.startContainer;\u000a				this.endOffset = this.startOffset;\u000a			} else {\u000a				this.startContainer = this.endContainer;\u000a				this.startOffset = this.endOffset;\u000a			}\u000a\u000a			this.collapsed = true;\u000a		},\u000a\u000a		/**\u000a		 * The content nodes of the range are cloned and added to a document fragment, which is returned.\u000a		 *\u000a		 * **Note:** Text selection may lost after invoking this method (caused by text node splitting).\u000a		 *\u000a		 * @returns {CKEDITOR.dom.documentFragment} Document fragment containing clone of range's content.\u000a		 */\u000a		cloneContents: function() {\u000a			var docFrag = new CKEDITOR.dom.documentFragment( this.document );\u000a\u000a			if ( !this.collapsed )\u000a				execContentsAction( this, 2, docFrag );\u000a\u000a			return docFrag;\u000a		},\u000a\u000a		/**\u000a		 * Deletes the content nodes of the range permanently from the DOM tree.\u000a		 *\u000a		 * @param {Boolean} [mergeThen] Merge any splitted elements result in DOM true due to partial selection.\u000a		 */\u000a		deleteContents: function( mergeThen ) {\u000a			if ( this.collapsed )\u000a				return;\u000a\u000a			execContentsAction( this, 0, null, mergeThen );\u000a		},\u000a\u000a		/**\u000a		 * The content nodes of the range are cloned and added to a document fragment,\u000a		 * meanwhile they are removed permanently from the DOM tree.\u000a		 *\u000a		 * @param {Boolean} [mergeThen] Merge any splitted elements result in DOM true due to partial selection.\u000a		 * @returns {CKEDITOR.dom.documentFragment} Document fragment containing extracted content.\u000a		 */\u000a		extractContents: function( mergeThen ) {\u000a			var docFrag = new CKEDITOR.dom.documentFragment( this.document );\u000a\u000a			if ( !this.collapsed )\u000a				execContentsAction( this, 1, docFrag, mergeThen );\u000a\u000a			return docFrag;\u000a		},\u000a\u000a		/**\u000a		 * Creates a bookmark object, which can be later used to restore the\u000a		 * range by using the {@link #moveToBookmark} function.\u000a		 *\u000a		 * This is an "intrusive" way to create a bookmark. It includes `<span>` tags\u000a		 * in the range boundaries. The advantage of it is that it is possible to\u000a		 * handle DOM mutations when moving back to the bookmark.\u000a		 *\u000a		 * **Note:** The inclusion of nodes in the DOM is a design choice and\u000a		 * should not be changed as there are other points in the code that may be\u000a		 * using those nodes to perform operations.\u000a		 *\u000a		 * @param {Boolean} [serializable] Indicates that the bookmark nodes\u000a		 * must contain IDs, which can be used to restore the range even\u000a		 * when these nodes suffer mutations (like cloning or `innerHTML` change).\u000a		 * @returns {Object} And object representing a bookmark.\u000a		 * @returns {CKEDITOR.dom.node/String} return.startNode Node or element ID.\u000a		 * @returns {CKEDITOR.dom.node/String} return.endNode Node or element ID.\u000a		 * @returns {Boolean} return.serializable\u000a		 * @returns {Boolean} return.collapsed\u000a		 */\u000a		createBookmark: function( serializable ) {\u000a			var startNode, endNode;\u000a			var baseId;\u000a			var clone;\u000a			var collapsed = this.collapsed;\u000a\u000a			startNode = this.document.createElement( 'span' );\u000a			startNode.data( 'cke-bookmark', 1 );\u000a			startNode.setStyle( 'display', 'none' );\u000a\u000a			// For IE, it must have something inside, otherwise it may be\u000a			// removed during DOM operations.\u000a			startNode.setHtml( '&nbsp;' );\u000a\u000a			if ( serializable ) {\u000a				baseId = 'cke_bm_' + CKEDITOR.tools.getNextNumber();\u000a				startNode.setAttribute( 'id', baseId + ( collapsed ? 'C' : 'S' ) );\u000a			}\u000a\u000a			// If collapsed, the endNode will not be created.\u000a			if ( !collapsed ) {\u000a				endNode = startNode.clone();\u000a				endNode.setHtml( '&nbsp;' );\u000a\u000a				if ( serializable )\u000a					endNode.setAttribute( 'id', baseId + 'E' );\u000a\u000a				clone = this.clone();\u000a				clone.collapse();\u000a				clone.insertNode( endNode );\u000a			}\u000a\u000a			clone = this.clone();\u000a			clone.collapse( true );\u000a			clone.insertNode( startNode );\u000a\u000a			// Update the range position.\u000a			if ( endNode ) {\u000a				this.setStartAfter( startNode );\u000a				this.setEndBefore( endNode );\u000a			} else {\u000a				this.moveToPosition( startNode, CKEDITOR.POSITION_AFTER_END );\u000a			}\u000a\u000a			return {\u000a				startNode: serializable ? baseId + ( collapsed ? 'C' : 'S' ) : startNode,\u000a				endNode: serializable ? baseId + 'E' : endNode,\u000a				serializable: serializable,\u000a				collapsed: collapsed\u000a			};\u000a		},\u000a\u000a		/**\u000a		 * Creates a "non intrusive" and "mutation sensible" bookmark. This\u000a		 * kind of bookmark should be used only when the DOM is supposed to\u000a		 * remain stable after its creation.\u000a		 *\u000a		 * @param {Boolean} [normalized] Indicates that the bookmark must\u000a		 * be normalized. When normalized, the successive text nodes are\u000a		 * considered a single node. To successfully load a normalized\u000a		 * bookmark, the DOM tree must also be normalized before calling\u000a		 * {@link #moveToBookmark}.\u000a		 * @returns {Object} An object representing the bookmark.\u000a		 * @returns {Array} return.start Start container's address (see {@link CKEDITOR.dom.node#getAddress}).\u000a		 * @returns {Array} return.end Start container's address.\u000a		 * @returns {Number} return.startOffset\u000a		 * @returns {Number} return.endOffset\u000a		 * @returns {Boolean} return.collapsed\u000a		 * @returns {Boolean} return.normalized\u000a		 * @returns {Boolean} return.is2 This is "bookmark2".\u000a		 */\u000a		createBookmark2: ( function() {\u000a			// Returns true for limit anchored in element and placed between text nodes.\u000a			//\u000a			//               v\u000a			// <p>[text node] [text node]</p> -> true\u000a			//\u000a			//    v\u000a			// <p> [text node]</p> -> false\u000a			//\u000a			//              v\u000a			// <p>[text node][text node]</p> -> false (limit is anchored in text node)\u000a			function betweenTextNodes( container, offset ) {\u000a				// Not anchored in element or limit is on the edge.\u000a				if ( container.type != CKEDITOR.NODE_ELEMENT || offset === 0 || offset == container.getChildCount() )\u000a					return 0;\u000a\u000a				return container.getChild( offset - 1 ).type == CKEDITOR.NODE_TEXT &&\u000a					container.getChild( offset ).type == CKEDITOR.NODE_TEXT;\u000a			}\u000a\u000a			// Sums lengths of all preceding text nodes.\u000a			function getLengthOfPrecedingTextNodes( node ) {\u000a				var sum = 0;\u000a\u000a				while ( ( node = node.getPrevious() ) && node.type == CKEDITOR.NODE_TEXT )\u000a					sum += node.getLength();\u000a\u000a				return sum;\u000a			}\u000a\u000a			function normalize( limit ) {\u000a				var container = limit.container,\u000a					offset = limit.offset;\u000a\u000a				// If limit is between text nodes move it to the end of preceding one,\u000a				// because they will be merged.\u000a				if ( betweenTextNodes( container, offset ) ) {\u000a					container = container.getChild( offset - 1 );\u000a					offset = container.getLength();\u000a				}\u000a\u000a				// Now, if limit is anchored in element and has at least two nodes before it,\u000a				// it may happen that some of them will be merged. Normalize the offset\u000a				// by setting it to normalized index of its preceding node.\u000a				if ( container.type == CKEDITOR.NODE_ELEMENT && offset > 1 )\u000a					offset = container.getChild( offset - 1 ).getIndex( true ) + 1;\u000a\u000a				// The last step - fix the offset inside text node by adding\u000a				// lengths of preceding text nodes which will be merged with container.\u000a				if ( container.type == CKEDITOR.NODE_TEXT )\u000a					offset += getLengthOfPrecedingTextNodes( container );\u000a\u000a				limit.container = container;\u000a				limit.offset = offset;\u000a			}\u000a\u000a			return function( normalized ) {\u000a				var collapsed = this.collapsed,\u000a					bmStart = {\u000a						container: this.startContainer,\u000a						offset: this.startOffset\u000a					},\u000a					bmEnd = {\u000a						container: this.endContainer,\u000a						offset: this.endOffset\u000a					};\u000a\u000a				if ( normalized ) {\u000a					normalize( bmStart );\u000a\u000a					if ( !collapsed )\u000a						normalize( bmEnd );\u000a				}\u000a\u000a				return {\u000a					start: bmStart.container.getAddress( normalized ),\u000a					end: collapsed ? null : bmEnd.container.getAddress( normalized ),\u000a					startOffset: bmStart.offset,\u000a					endOffset: bmEnd.offset,\u000a					normalized: normalized,\u000a					collapsed: collapsed,\u000a					is2: true // It's a createBookmark2 bookmark.\u000a				};\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Moves this range to the given bookmark. See {@link #createBookmark} and {@link #createBookmark2}.\u000a		 *\u000a		 * If serializable bookmark passed, then its `<span>` markers will be removed.\u000a		 *\u000a		 * @param {Object} bookmark\u000a		 */\u000a		moveToBookmark: function( bookmark ) {\u000a			if ( bookmark.is2 ) // Created with createBookmark2().\u000a			{\u000a				// Get the start information.\u000a				var startContainer = this.document.getByAddress( bookmark.start, bookmark.normalized ),\u000a					startOffset = bookmark.startOffset;\u000a\u000a				// Get the end information.\u000a				var endContainer = bookmark.end && this.document.getByAddress( bookmark.end, bookmark.normalized ),\u000a					endOffset = bookmark.endOffset;\u000a\u000a				// Set the start boundary.\u000a				this.setStart( startContainer, startOffset );\u000a\u000a				// Set the end boundary. If not available, collapse it.\u000a				if ( endContainer )\u000a					this.setEnd( endContainer, endOffset );\u000a				else\u000a					this.collapse( true );\u000a			} else // Created with createBookmark().\u000a			{\u000a				var serializable = bookmark.serializable,\u000a					startNode = serializable ? this.document.getById( bookmark.startNode ) : bookmark.startNode,\u000a					endNode = serializable ? this.document.getById( bookmark.endNode ) : bookmark.endNode;\u000a\u000a				// Set the range start at the bookmark start node position.\u000a				this.setStartBefore( startNode );\u000a\u000a				// Remove it, because it may interfere in the setEndBefore call.\u000a				startNode.remove();\u000a\u000a				// Set the range end at the bookmark end node position, or simply\u000a				// collapse it if it is not available.\u000a				if ( endNode ) {\u000a					this.setEndBefore( endNode );\u000a					endNode.remove();\u000a				} else {\u000a					this.collapse( true );\u000a				}\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Returns two nodes which are on the boundaries of this range.\u000a		 *\u000a		 * @returns {Object}\u000a		 * @returns {CKEDITOR.dom.node} return.startNode\u000a		 * @returns {CKEDITOR.dom.node} return.endNode\u000a		 * @todo precise desc/algorithm\u000a		 */\u000a		getBoundaryNodes: function() {\u000a			var startNode = this.startContainer,\u000a				endNode = this.endContainer,\u000a				startOffset = this.startOffset,\u000a				endOffset = this.endOffset,\u000a				childCount;\u000a\u000a			if ( startNode.type == CKEDITOR.NODE_ELEMENT ) {\u000a				childCount = startNode.getChildCount();\u000a				if ( childCount > startOffset )\u000a					startNode = startNode.getChild( startOffset );\u000a				else if ( childCount < 1 )\u000a					startNode = startNode.getPreviousSourceNode();\u000a				else // startOffset > childCount but childCount is not 0\u000a				{\u000a					// Try to take the node just after the current position.\u000a					startNode = startNode.$;\u000a					while ( startNode.lastChild )\u000a						startNode = startNode.lastChild;\u000a					startNode = new CKEDITOR.dom.node( startNode );\u000a\u000a					// Normally we should take the next node in DFS order. But it\u000a					// is also possible that we've already reached the end of\u000a					// document.\u000a					startNode = startNode.getNextSourceNode() || startNode;\u000a				}\u000a			}\u000a			if ( endNode.type == CKEDITOR.NODE_ELEMENT ) {\u000a				childCount = endNode.getChildCount();\u000a				if ( childCount > endOffset )\u000a					endNode = endNode.getChild( endOffset ).getPreviousSourceNode( true );\u000a				else if ( childCount < 1 )\u000a					endNode = endNode.getPreviousSourceNode();\u000a				else // endOffset > childCount but childCount is not 0\u000a				{\u000a					// Try to take the node just before the current position.\u000a					endNode = endNode.$;\u000a					while ( endNode.lastChild )\u000a						endNode = endNode.lastChild;\u000a					endNode = new CKEDITOR.dom.node( endNode );\u000a				}\u000a			}\u000a\u000a			// Sometimes the endNode will come right before startNode for collapsed\u000a			// ranges. Fix it. (#3780)\u000a			if ( startNode.getPosition( endNode ) & CKEDITOR.POSITION_FOLLOWING )\u000a				startNode = endNode;\u000a\u000a			return { startNode: startNode, endNode: endNode };\u000a		},\u000a\u000a		/**\u000a		 * Find the node which fully contains the range.\u000a		 *\u000a		 * @param {Boolean} [includeSelf=false]\u000a		 * @param {Boolean} [ignoreTextNode=false] Whether ignore {@link CKEDITOR#NODE_TEXT} type.\u000a		 * @returns {CKEDITOR.dom.element}\u000a		 */\u000a		getCommonAncestor: function( includeSelf, ignoreTextNode ) {\u000a			var start = this.startContainer,\u000a				end = this.endContainer,\u000a				ancestor;\u000a\u000a			if ( start.equals( end ) ) {\u000a				if ( includeSelf && start.type == CKEDITOR.NODE_ELEMENT && this.startOffset == this.endOffset - 1 )\u000a					ancestor = start.getChild( this.startOffset );\u000a				else\u000a					ancestor = start;\u000a			} else {\u000a				ancestor = start.getCommonAncestor( end );\u000a			}\u000a\u000a			return ignoreTextNode && !ancestor.is ? ancestor.getParent() : ancestor;\u000a		},\u000a\u000a		/**\u000a		 * Transforms the {@link #startContainer} and {@link #endContainer} properties from text\u000a		 * nodes to element nodes, whenever possible. This is actually possible\u000a		 * if either of the boundary containers point to a text node, and its\u000a		 * offset is set to zero, or after the last char in the node.\u000a		 */\u000a		optimize: function() {\u000a			var container = this.startContainer;\u000a			var offset = this.startOffset;\u000a\u000a			if ( container.type != CKEDITOR.NODE_ELEMENT ) {\u000a				if ( !offset )\u000a					this.setStartBefore( container );\u000a				else if ( offset >= container.getLength() )\u000a					this.setStartAfter( container );\u000a			}\u000a\u000a			container = this.endContainer;\u000a			offset = this.endOffset;\u000a\u000a			if ( container.type != CKEDITOR.NODE_ELEMENT ) {\u000a				if ( !offset )\u000a					this.setEndBefore( container );\u000a				else if ( offset >= container.getLength() )\u000a					this.setEndAfter( container );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Move the range out of bookmark nodes if they'd been the container.\u000a		 */\u000a		optimizeBookmark: function() {\u000a			var startNode = this.startContainer,\u000a				endNode = this.endContainer;\u000a\u000a			if ( startNode.is && startNode.is( 'span' ) && startNode.data( 'cke-bookmark' ) )\u000a				this.setStartAt( startNode, CKEDITOR.POSITION_BEFORE_START );\u000a			if ( endNode && endNode.is && endNode.is( 'span' ) && endNode.data( 'cke-bookmark' ) )\u000a				this.setEndAt( endNode, CKEDITOR.POSITION_AFTER_END );\u000a		},\u000a\u000a		/**\u000a		 * @param {Boolean} [ignoreStart=false]\u000a		 * @param {Boolean} [ignoreEnd=false]\u000a		 * @todo precise desc/algorithm\u000a		 */\u000a		trim: function( ignoreStart, ignoreEnd ) {\u000a			var startContainer = this.startContainer,\u000a				startOffset = this.startOffset,\u000a				collapsed = this.collapsed;\u000a			if ( ( !ignoreStart || collapsed ) && startContainer && startContainer.type == CKEDITOR.NODE_TEXT ) {\u000a				// If the offset is zero, we just insert the new node before\u000a				// the start.\u000a				if ( !startOffset ) {\u000a					startOffset = startContainer.getIndex();\u000a					startContainer = startContainer.getParent();\u000a				}\u000a				// If the offset is at the end, we'll insert it after the text\u000a				// node.\u000a				else if ( startOffset >= startContainer.getLength() ) {\u000a					startOffset = startContainer.getIndex() + 1;\u000a					startContainer = startContainer.getParent();\u000a				}\u000a				// In other case, we split the text node and insert the new\u000a				// node at the split point.\u000a				else {\u000a					var nextText = startContainer.split( startOffset );\u000a\u000a					startOffset = startContainer.getIndex() + 1;\u000a					startContainer = startContainer.getParent();\u000a\u000a					// Check all necessity of updating the end boundary.\u000a					if ( this.startContainer.equals( this.endContainer ) )\u000a						this.setEnd( nextText, this.endOffset - this.startOffset );\u000a					else if ( startContainer.equals( this.endContainer ) )\u000a						this.endOffset += 1;\u000a				}\u000a\u000a				this.setStart( startContainer, startOffset );\u000a\u000a				if ( collapsed ) {\u000a					this.collapse( true );\u000a					return;\u000a				}\u000a			}\u000a\u000a			var endContainer = this.endContainer;\u000a			var endOffset = this.endOffset;\u000a\u000a			if ( !( ignoreEnd || collapsed ) && endContainer && endContainer.type == CKEDITOR.NODE_TEXT ) {\u000a				// If the offset is zero, we just insert the new node before\u000a				// the start.\u000a				if ( !endOffset ) {\u000a					endOffset = endContainer.getIndex();\u000a					endContainer = endContainer.getParent();\u000a				}\u000a				// If the offset is at the end, we'll insert it after the text\u000a				// node.\u000a				else if ( endOffset >= endContainer.getLength() ) {\u000a					endOffset = endContainer.getIndex() + 1;\u000a					endContainer = endContainer.getParent();\u000a				}\u000a				// In other case, we split the text node and insert the new\u000a				// node at the split point.\u000a				else {\u000a					endContainer.split( endOffset );\u000a\u000a					endOffset = endContainer.getIndex() + 1;\u000a					endContainer = endContainer.getParent();\u000a				}\u000a\u000a				this.setEnd( endContainer, endOffset );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Expands the range so that partial units are completely contained.\u000a		 *\u000a		 * @param unit {Number} The unit type to expand with.\u000a		 * @param {Boolean} [excludeBrs=false] Whether include line-breaks when expanding.\u000a		 */\u000a		enlarge: function( unit, excludeBrs ) {\u000a			var leadingWhitespaceRegex = new RegExp( /[^\u005cs\u005cufeff]/ );\u000a\u000a			switch ( unit ) {\u000a				case CKEDITOR.ENLARGE_INLINE:\u000a					var enlargeInlineOnly = 1;\u000a\u000a				/* falls through */\u000a				case CKEDITOR.ENLARGE_ELEMENT:\u000a\u000a					if ( this.collapsed )\u000a						return;\u000a\u000a					// Get the common ancestor.\u000a					var commonAncestor = this.getCommonAncestor();\u000a\u000a					var boundary = this.root;\u000a\u000a					// For each boundary\u000a					//		a. Depending on its position, find out the first node to be checked (a sibling) or,\u000a					//			if not available, to be enlarge.\u000a					//		b. Go ahead checking siblings and enlarging the boundary as much as possible until the\u000a					//			common ancestor is not reached. After reaching the common ancestor, just save the\u000a					//			enlargeable node to be used later.\u000a\u000a					var startTop, endTop;\u000a\u000a					var enlargeable, sibling, commonReached;\u000a\u000a					// Indicates that the node can be added only if whitespace\u000a					// is available before it.\u000a					var needsWhiteSpace = false;\u000a					var isWhiteSpace;\u000a					var siblingText;\u000a\u000a					// Process the start boundary.\u000a\u000a					var container = this.startContainer;\u000a					var offset = this.startOffset;\u000a\u000a					if ( container.type == CKEDITOR.NODE_TEXT ) {\u000a						if ( offset ) {\u000a							// Check if there is any non-space text before the\u000a							// offset. Otherwise, container is null.\u000a							container = !CKEDITOR.tools.trim( container.substring( 0, offset ) ).length && container;\u000a\u000a							// If we found only whitespace in the node, it\u000a							// means that we'll need more whitespace to be able\u000a							// to expand. For example, <i> can be expanded in\u000a							// "A <i> [B]</i>", but not in "A<i> [B]</i>".\u000a							needsWhiteSpace = !!container;\u000a						}\u000a\u000a						if ( container ) {\u000a							if ( !( sibling = container.getPrevious() ) )\u000a								enlargeable = container.getParent();\u000a						}\u000a					} else {\u000a						// If we have offset, get the node preceeding it as the\u000a						// first sibling to be checked.\u000a						if ( offset )\u000a							sibling = container.getChild( offset - 1 ) || container.getLast();\u000a\u000a						// If there is no sibling, mark the container to be\u000a						// enlarged.\u000a						if ( !sibling )\u000a							enlargeable = container;\u000a					}\u000a\u000a					// Ensures that enlargeable can be indeed enlarged, if not it will be nulled.\u000a					enlargeable = getValidEnlargeable( enlargeable );\u000a\u000a					while ( enlargeable || sibling ) {\u000a						if ( enlargeable && !sibling ) {\u000a							// If we reached the common ancestor, mark the flag\u000a							// for it.\u000a							if ( !commonReached && enlargeable.equals( commonAncestor ) )\u000a								commonReached = true;\u000a\u000a							if ( enlargeInlineOnly ? enlargeable.isBlockBoundary() : !boundary.contains( enlargeable ) )\u000a								break;\u000a\u000a							// If we don't need space or this element breaks\u000a							// the line, then enlarge it.\u000a							if ( !needsWhiteSpace || enlargeable.getComputedStyle( 'display' ) != 'inline' ) {\u000a								needsWhiteSpace = false;\u000a\u000a								// If the common ancestor has been reached,\u000a								// we'll not enlarge it immediately, but just\u000a								// mark it to be enlarged later if the end\u000a								// boundary also enlarges it.\u000a								if ( commonReached )\u000a									startTop = enlargeable;\u000a								else\u000a									this.setStartBefore( enlargeable );\u000a							}\u000a\u000a							sibling = enlargeable.getPrevious();\u000a						}\u000a\u000a						// Check all sibling nodes preceeding the enlargeable\u000a						// node. The node wil lbe enlarged only if none of them\u000a						// blocks it.\u000a						while ( sibling ) {\u000a							// This flag indicates that this node has\u000a							// whitespaces at the end.\u000a							isWhiteSpace = false;\u000a\u000a							if ( sibling.type == CKEDITOR.NODE_COMMENT ) {\u000a								sibling = sibling.getPrevious();\u000a								continue;\u000a							} else if ( sibling.type == CKEDITOR.NODE_TEXT ) {\u000a								siblingText = sibling.getText();\u000a\u000a								if ( leadingWhitespaceRegex.test( siblingText ) )\u000a									sibling = null;\u000a\u000a								isWhiteSpace = /[\u005cs\u005cufeff]$/.test( siblingText );\u000a							} else {\u000a								// #12221 (Chrome) plus #11111 (Safari).\u000a								var offsetWidth0 = CKEDITOR.env.webkit ? 1 : 0;\u000a\u000a								// If this is a visible element.\u000a								// We need to check for the bookmark attribute because IE insists on\u000a								// rendering the display:none nodes we use for bookmarks. (#3363)\u000a								// Line-breaks (br) are rendered with zero width, which we don't want to include. (#7041)\u000a								if ( ( sibling.$.offsetWidth > offsetWidth0 || excludeBrs && sibling.is( 'br' ) ) && !sibling.data( 'cke-bookmark' ) ) {\u000a									// We'll accept it only if we need\u000a									// whitespace, and this is an inline\u000a									// element with whitespace only.\u000a									if ( needsWhiteSpace && CKEDITOR.dtd.$removeEmpty[ sibling.getName() ] ) {\u000a										// It must contains spaces and inline elements only.\u000a\u000a										siblingText = sibling.getText();\u000a\u000a										if ( leadingWhitespaceRegex.test( siblingText ) ) // Spaces + Zero Width No-Break Space (U+FEFF)\u000a										sibling = null;\u000a										else {\u000a											var allChildren = sibling.$.getElementsByTagName( '*' );\u000a											for ( var i = 0, child; child = allChildren[ i++ ]; ) {\u000a												if ( !CKEDITOR.dtd.$removeEmpty[ child.nodeName.toLowerCase() ] ) {\u000a													sibling = null;\u000a													break;\u000a												}\u000a											}\u000a										}\u000a\u000a										if ( sibling )\u000a											isWhiteSpace = !!siblingText.length;\u000a									} else {\u000a										sibling = null;\u000a									}\u000a								}\u000a							}\u000a\u000a							// A node with whitespaces has been found.\u000a							if ( isWhiteSpace ) {\u000a								// Enlarge the last enlargeable node, if we\u000a								// were waiting for spaces.\u000a								if ( needsWhiteSpace ) {\u000a									if ( commonReached )\u000a										startTop = enlargeable;\u000a									else if ( enlargeable )\u000a										this.setStartBefore( enlargeable );\u000a								} else {\u000a									needsWhiteSpace = true;\u000a								}\u000a							}\u000a\u000a							if ( sibling ) {\u000a								var next = sibling.getPrevious();\u000a\u000a								if ( !enlargeable && !next ) {\u000a									// Set the sibling as enlargeable, so it's\u000a									// parent will be get later outside this while.\u000a									enlargeable = sibling;\u000a									sibling = null;\u000a									break;\u000a								}\u000a\u000a								sibling = next;\u000a							} else {\u000a								// If sibling has been set to null, then we\u000a								// need to stop enlarging.\u000a								enlargeable = null;\u000a							}\u000a						}\u000a\u000a						if ( enlargeable )\u000a							enlargeable = getValidEnlargeable( enlargeable.getParent() );\u000a					}\u000a\u000a					// Process the end boundary. This is basically the same\u000a					// code used for the start boundary, with small changes to\u000a					// make it work in the oposite side (to the right). This\u000a					// makes it difficult to reuse the code here. So, fixes to\u000a					// the above code are likely to be replicated here.\u000a\u000a					container = this.endContainer;\u000a					offset = this.endOffset;\u000a\u000a					// Reset the common variables.\u000a					enlargeable = sibling = null;\u000a					commonReached = needsWhiteSpace = false;\u000a\u000a					// Function check if there are only whitespaces from the given starting point\u000a					// (startContainer and startOffset) till the end on block.\u000a					// Examples ("[" is the start point):\u000a					//  - <p>foo[ </p>           - will return true,\u000a					//  - <p><b>foo[ </b> </p>   - will return true,\u000a					//  - <p>foo[ bar</p>        - will return false,\u000a					//  - <p><b>foo[ </b>bar</p> - will return false,\u000a					//  - <p>foo[ <b></b></p>    - will return false.\u000a					function onlyWhiteSpaces( startContainer, startOffset ) {\u000a						// We need to enlarge range if there is white space at the end of the block,\u000a						// because it is not displayed in WYSIWYG mode and user can not select it. So\u000a						// "<p>foo[bar] </p>" should be changed to "<p>foo[bar ]</p>". On the other hand\u000a						// we should do nothing if we are not at the end of the block, so this should not\u000a						// be changed: "<p><i>[foo] </i>bar</p>".\u000a						var walkerRange = new CKEDITOR.dom.range( boundary );\u000a						walkerRange.setStart( startContainer, startOffset );\u000a						// The guard will find the end of range so I put boundary here.\u000a						walkerRange.setEndAt( boundary, CKEDITOR.POSITION_BEFORE_END );\u000a\u000a						var walker = new CKEDITOR.dom.walker( walkerRange ),\u000a							node;\u000a\u000a						walker.guard = function( node ) {\u000a							// Stop if you exit block.\u000a							return !( node.type == CKEDITOR.NODE_ELEMENT && node.isBlockBoundary() );\u000a						};\u000a\u000a						while ( ( node = walker.next() ) ) {\u000a							if ( node.type != CKEDITOR.NODE_TEXT ) {\u000a								// Stop if you enter to any node (walker.next() will return node only\u000a								// it goes out, not if it is go into node).\u000a								return false;\u000a							} else {\u000a								// Trim the first node to startOffset.\u000a								if ( node != startContainer )\u000a									siblingText = node.getText();\u000a								else\u000a									siblingText = node.substring( startOffset );\u000a\u000a								// Check if it is white space.\u000a								if ( leadingWhitespaceRegex.test( siblingText ) )\u000a									return false;\u000a							}\u000a						}\u000a\u000a						return true;\u000a					}\u000a\u000a					if ( container.type == CKEDITOR.NODE_TEXT ) {\u000a						// Check if there is only white space after the offset.\u000a						if ( CKEDITOR.tools.trim( container.substring( offset ) ).length ) {\u000a							// If we found only whitespace in the node, it\u000a							// means that we'll need more whitespace to be able\u000a							// to expand. For example, <i> can be expanded in\u000a							// "A <i> [B]</i>", but not in "A<i> [B]</i>".\u000a							needsWhiteSpace = true;\u000a						} else {\u000a							needsWhiteSpace = !container.getLength();\u000a\u000a							if ( offset == container.getLength() ) {\u000a								// If we are at the end of container and this is the last text node,\u000a								// we should enlarge end to the parent.\u000a								if ( !( sibling = container.getNext() ) )\u000a									enlargeable = container.getParent();\u000a							} else {\u000a								// If we are in the middle on text node and there are only whitespaces\u000a								// till the end of block, we should enlarge element.\u000a								if ( onlyWhiteSpaces( container, offset ) )\u000a									enlargeable = container.getParent();\u000a							}\u000a						}\u000a					} else {\u000a						// Get the node right after the boudary to be checked\u000a						// first.\u000a						sibling = container.getChild( offset );\u000a\u000a						if ( !sibling )\u000a							enlargeable = container;\u000a					}\u000a\u000a					while ( enlargeable || sibling ) {\u000a						if ( enlargeable && !sibling ) {\u000a							if ( !commonReached && enlargeable.equals( commonAncestor ) )\u000a								commonReached = true;\u000a\u000a							if ( enlargeInlineOnly ? enlargeable.isBlockBoundary() : !boundary.contains( enlargeable ) )\u000a								break;\u000a\u000a							if ( !needsWhiteSpace || enlargeable.getComputedStyle( 'display' ) != 'inline' ) {\u000a								needsWhiteSpace = false;\u000a\u000a								if ( commonReached )\u000a									endTop = enlargeable;\u000a								else if ( enlargeable )\u000a									this.setEndAfter( enlargeable );\u000a							}\u000a\u000a							sibling = enlargeable.getNext();\u000a						}\u000a\u000a						while ( sibling ) {\u000a							isWhiteSpace = false;\u000a\u000a							if ( sibling.type == CKEDITOR.NODE_TEXT ) {\u000a								siblingText = sibling.getText();\u000a\u000a								// Check if there are not whitespace characters till the end of editable.\u000a								// If so stop expanding.\u000a								if ( !onlyWhiteSpaces( sibling, 0 ) )\u000a									sibling = null;\u000a\u000a								isWhiteSpace = /^[\u005cs\u005cufeff]/.test( siblingText );\u000a							} else if ( sibling.type == CKEDITOR.NODE_ELEMENT ) {\u000a								// If this is a visible element.\u000a								// We need to check for the bookmark attribute because IE insists on\u000a								// rendering the display:none nodes we use for bookmarks. (#3363)\u000a								// Line-breaks (br) are rendered with zero width, which we don't want to include. (#7041)\u000a								if ( ( sibling.$.offsetWidth > 0 || excludeBrs && sibling.is( 'br' ) ) && !sibling.data( 'cke-bookmark' ) ) {\u000a									// We'll accept it only if we need\u000a									// whitespace, and this is an inline\u000a									// element with whitespace only.\u000a									if ( needsWhiteSpace && CKEDITOR.dtd.$removeEmpty[ sibling.getName() ] ) {\u000a										// It must contains spaces and inline elements only.\u000a\u000a										siblingText = sibling.getText();\u000a\u000a										if ( leadingWhitespaceRegex.test( siblingText ) )\u000a											sibling = null;\u000a										else {\u000a											allChildren = sibling.$.getElementsByTagName( '*' );\u000a											for ( i = 0; child = allChildren[ i++ ]; ) {\u000a												if ( !CKEDITOR.dtd.$removeEmpty[ child.nodeName.toLowerCase() ] ) {\u000a													sibling = null;\u000a													break;\u000a												}\u000a											}\u000a										}\u000a\u000a										if ( sibling )\u000a											isWhiteSpace = !!siblingText.length;\u000a									} else {\u000a										sibling = null;\u000a									}\u000a								}\u000a							} else {\u000a								isWhiteSpace = 1;\u000a							}\u000a\u000a							if ( isWhiteSpace ) {\u000a								if ( needsWhiteSpace ) {\u000a									if ( commonReached )\u000a										endTop = enlargeable;\u000a									else\u000a										this.setEndAfter( enlargeable );\u000a								}\u000a							}\u000a\u000a							if ( sibling ) {\u000a								next = sibling.getNext();\u000a\u000a								if ( !enlargeable && !next ) {\u000a									enlargeable = sibling;\u000a									sibling = null;\u000a									break;\u000a								}\u000a\u000a								sibling = next;\u000a							} else {\u000a								// If sibling has been set to null, then we\u000a								// need to stop enlarging.\u000a								enlargeable = null;\u000a							}\u000a						}\u000a\u000a						if ( enlargeable )\u000a							enlargeable = getValidEnlargeable( enlargeable.getParent() );\u000a					}\u000a\u000a					// If the common ancestor can be enlarged by both boundaries, then include it also.\u000a					if ( startTop && endTop ) {\u000a						commonAncestor = startTop.contains( endTop ) ? endTop : startTop;\u000a\u000a						this.setStartBefore( commonAncestor );\u000a						this.setEndAfter( commonAncestor );\u000a					}\u000a					break;\u000a\u000a				case CKEDITOR.ENLARGE_BLOCK_CONTENTS:\u000a				case CKEDITOR.ENLARGE_LIST_ITEM_CONTENTS:\u000a\u000a					// Enlarging the start boundary.\u000a					var walkerRange = new CKEDITOR.dom.range( this.root );\u000a\u000a					boundary = this.root;\u000a\u000a					walkerRange.setStartAt( boundary, CKEDITOR.POSITION_AFTER_START );\u000a					walkerRange.setEnd( this.startContainer, this.startOffset );\u000a\u000a					var walker = new CKEDITOR.dom.walker( walkerRange ),\u000a						blockBoundary, // The node on which the enlarging should stop.\u000a						tailBr, // In case BR as block boundary.\u000a						notBlockBoundary = CKEDITOR.dom.walker.blockBoundary( ( unit == CKEDITOR.ENLARGE_LIST_ITEM_CONTENTS ) ? { br: 1 } : null ),\u000a						inNonEditable = null,\u000a						// Record the encountered 'blockBoundary' for later use.\u000a						boundaryGuard = function( node ) {\u000a							// We should not check contents of non-editable elements. It may happen\u000a							// that inline widget has display:table child which should not block range#enlarge.\u000a							// When encoutered non-editable element...\u000a							if ( node.type == CKEDITOR.NODE_ELEMENT && node.getAttribute( 'contenteditable' ) == 'false' ) {\u000a								if ( inNonEditable ) {\u000a									// ... in which we already were, reset it (because we're leaving it) and return.\u000a									if ( inNonEditable.equals( node ) ) {\u000a										inNonEditable = null;\u000a										return;\u000a									}\u000a								// ... which we're entering, remember it but check it (no return).\u000a								} else {\u000a									inNonEditable = node;\u000a								}\u000a							// When we are in non-editable element, do not check if current node is a block boundary.\u000a							} else if ( inNonEditable ) {\u000a								return;\u000a							}\u000a\u000a							var retval = notBlockBoundary( node );\u000a							if ( !retval )\u000a								blockBoundary = node;\u000a							return retval;\u000a						},\u000a						// Record the encounted 'tailBr' for later use.\u000a						tailBrGuard = function( node ) {\u000a							var retval = boundaryGuard( node );\u000a							if ( !retval && node.is && node.is( 'br' ) )\u000a								tailBr = node;\u000a							return retval;\u000a						};\u000a\u000a					walker.guard = boundaryGuard;\u000a\u000a					enlargeable = walker.lastBackward();\u000a\u000a					// It's the body which stop the enlarging if no block boundary found.\u000a					blockBoundary = blockBoundary || boundary;\u000a\u000a					// Start the range either after the end of found block (<p>...</p>[text)\u000a					// or at the start of block (<p>[text...), by comparing the document position\u000a					// with 'enlargeable' node.\u000a					this.setStartAt( blockBoundary, !blockBoundary.is( 'br' ) && ( !enlargeable && this.checkStartOfBlock() ||\u000a						enlargeable && blockBoundary.contains( enlargeable ) ) ? CKEDITOR.POSITION_AFTER_START : CKEDITOR.POSITION_AFTER_END );\u000a\u000a					// Avoid enlarging the range further when end boundary spans right after the BR. (#7490)\u000a					if ( unit == CKEDITOR.ENLARGE_LIST_ITEM_CONTENTS ) {\u000a						var theRange = this.clone();\u000a						walker = new CKEDITOR.dom.walker( theRange );\u000a\u000a						var whitespaces = CKEDITOR.dom.walker.whitespaces(),\u000a							bookmark = CKEDITOR.dom.walker.bookmark();\u000a\u000a						walker.evaluator = function( node ) {\u000a							return !whitespaces( node ) && !bookmark( node );\u000a						};\u000a						var previous = walker.previous();\u000a						if ( previous && previous.type == CKEDITOR.NODE_ELEMENT && previous.is( 'br' ) )\u000a							return;\u000a					}\u000a\u000a					// Enlarging the end boundary.\u000a					// Set up new range and reset all flags (blockBoundary, inNonEditable, tailBr).\u000a\u000a					walkerRange = this.clone();\u000a					walkerRange.collapse();\u000a					walkerRange.setEndAt( boundary, CKEDITOR.POSITION_BEFORE_END );\u000a					walker = new CKEDITOR.dom.walker( walkerRange );\u000a\u000a					// tailBrGuard only used for on range end.\u000a					walker.guard = ( unit == CKEDITOR.ENLARGE_LIST_ITEM_CONTENTS ) ? tailBrGuard : boundaryGuard;\u000a					blockBoundary = inNonEditable = tailBr = null;\u000a\u000a					// End the range right before the block boundary node.\u000a					enlargeable = walker.lastForward();\u000a\u000a					// It's the body which stop the enlarging if no block boundary found.\u000a					blockBoundary = blockBoundary || boundary;\u000a\u000a					// Close the range either before the found block start (text]<p>...</p>) or at the block end (...text]</p>)\u000a					// by comparing the document position with 'enlargeable' node.\u000a					this.setEndAt( blockBoundary, ( !enlargeable && this.checkEndOfBlock() ||\u000a						enlargeable && blockBoundary.contains( enlargeable ) ) ? CKEDITOR.POSITION_BEFORE_END : CKEDITOR.POSITION_BEFORE_START );\u000a					// We must include the <br> at the end of range if there's\u000a					// one and we're expanding list item contents\u000a					if ( tailBr ) {\u000a						this.setEndAfter( tailBr );\u000a					}\u000a			}\u000a\u000a			// Ensures that returned element can be enlarged by selection, null otherwise.\u000a			// @param {CKEDITOR.dom.element} enlargeable\u000a			// @returns {CKEDITOR.dom.element/null}\u000a			function getValidEnlargeable( enlargeable ) {\u000a				return enlargeable && enlargeable.type == CKEDITOR.NODE_ELEMENT && enlargeable.hasAttribute( 'contenteditable' ) ?\u000a					null : enlargeable;\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Descrease the range to make sure that boundaries\u000a		 * always anchor beside text nodes or innermost element.\u000a		 *\u000a		 * @param {Number} mode The shrinking mode ({@link CKEDITOR#SHRINK_ELEMENT} or {@link CKEDITOR#SHRINK_TEXT}).\u000a		 *\u000a		 * * {@link CKEDITOR#SHRINK_ELEMENT} - Shrink the range boundaries to the edge of the innermost element.\u000a		 * * {@link CKEDITOR#SHRINK_TEXT} - Shrink the range boudaries to anchor by the side of enclosed text\u000a		 *     node, range remains if there's no text nodes on boundaries at all.\u000a		 *\u000a		 * @param {Boolean} selectContents Whether result range anchors at the inner OR outer boundary of the node.\u000a		 */\u000a		shrink: function( mode, selectContents, shrinkOnBlockBoundary ) {\u000a			// Unable to shrink a collapsed range.\u000a			if ( !this.collapsed ) {\u000a				mode = mode || CKEDITOR.SHRINK_TEXT;\u000a\u000a				var walkerRange = this.clone();\u000a\u000a				var startContainer = this.startContainer,\u000a					endContainer = this.endContainer,\u000a					startOffset = this.startOffset,\u000a					endOffset = this.endOffset;\u000a\u000a				// Whether the start/end boundary is moveable.\u000a				var moveStart = 1,\u000a					moveEnd = 1;\u000a\u000a				if ( startContainer && startContainer.type == CKEDITOR.NODE_TEXT ) {\u000a					if ( !startOffset )\u000a						walkerRange.setStartBefore( startContainer );\u000a					else if ( startOffset >= startContainer.getLength() )\u000a						walkerRange.setStartAfter( startContainer );\u000a					else {\u000a						// Enlarge the range properly to avoid walker making\u000a						// DOM changes caused by triming the text nodes later.\u000a						walkerRange.setStartBefore( startContainer );\u000a						moveStart = 0;\u000a					}\u000a				}\u000a\u000a				if ( endContainer && endContainer.type == CKEDITOR.NODE_TEXT ) {\u000a					if ( !endOffset )\u000a						walkerRange.setEndBefore( endContainer );\u000a					else if ( endOffset >= endContainer.getLength() )\u000a						walkerRange.setEndAfter( endContainer );\u000a					else {\u000a						walkerRange.setEndAfter( endContainer );\u000a						moveEnd = 0;\u000a					}\u000a				}\u000a\u000a				var walker = new CKEDITOR.dom.walker( walkerRange ),\u000a					isBookmark = CKEDITOR.dom.walker.bookmark();\u000a\u000a				walker.evaluator = function( node ) {\u000a					return node.type == ( mode == CKEDITOR.SHRINK_ELEMENT ? CKEDITOR.NODE_ELEMENT : CKEDITOR.NODE_TEXT );\u000a				};\u000a\u000a				var currentElement;\u000a				walker.guard = function( node, movingOut ) {\u000a					if ( isBookmark( node ) )\u000a						return true;\u000a\u000a					// Stop when we're shrink in element mode while encountering a text node.\u000a					if ( mode == CKEDITOR.SHRINK_ELEMENT && node.type == CKEDITOR.NODE_TEXT )\u000a						return false;\u000a\u000a					// Stop when we've already walked "through" an element.\u000a					if ( movingOut && node.equals( currentElement ) )\u000a						return false;\u000a\u000a					if ( shrinkOnBlockBoundary === false && node.type == CKEDITOR.NODE_ELEMENT && node.isBlockBoundary() )\u000a						return false;\u000a\u000a					// Stop shrinking when encountering an editable border.\u000a					if ( node.type == CKEDITOR.NODE_ELEMENT && node.hasAttribute( 'contenteditable' ) )\u000a						return false;\u000a\u000a					if ( !movingOut && node.type == CKEDITOR.NODE_ELEMENT )\u000a						currentElement = node;\u000a\u000a					return true;\u000a				};\u000a\u000a				if ( moveStart ) {\u000a					var textStart = walker[ mode == CKEDITOR.SHRINK_ELEMENT ? 'lastForward' : 'next' ]();\u000a					textStart && this.setStartAt( textStart, selectContents ? CKEDITOR.POSITION_AFTER_START : CKEDITOR.POSITION_BEFORE_START );\u000a				}\u000a\u000a				if ( moveEnd ) {\u000a					walker.reset();\u000a					var textEnd = walker[ mode == CKEDITOR.SHRINK_ELEMENT ? 'lastBackward' : 'previous' ]();\u000a					textEnd && this.setEndAt( textEnd, selectContents ? CKEDITOR.POSITION_BEFORE_END : CKEDITOR.POSITION_AFTER_END );\u000a				}\u000a\u000a				return !!( moveStart || moveEnd );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Inserts a node at the start of the range. The range will be expanded\u000a		 * the contain the node.\u000a		 *\u000a		 * @param {CKEDITOR.dom.node} node\u000a		 */\u000a		insertNode: function( node ) {\u000a			this.optimizeBookmark();\u000a			this.trim( false, true );\u000a\u000a			var startContainer = this.startContainer;\u000a			var startOffset = this.startOffset;\u000a\u000a			var nextNode = startContainer.getChild( startOffset );\u000a\u000a			if ( nextNode )\u000a				node.insertBefore( nextNode );\u000a			else\u000a				startContainer.append( node );\u000a\u000a			// Check if we need to update the end boundary.\u000a			if ( node.getParent() && node.getParent().equals( this.endContainer ) )\u000a				this.endOffset++;\u000a\u000a			// Expand the range to embrace the new node.\u000a			this.setStartBefore( node );\u000a		},\u000a\u000a		/**\u000a		 * Moves the range to given position according to specified node.\u000a		 *\u000a		 *		// HTML: <p>Foo <b>bar</b></p>\u000a		 *		range.moveToPosition( elB, CKEDITOR.POSITION_BEFORE_START );\u000a		 *		// Range will be moved to: <p>Foo ^<b>bar</b></p>\u000a		 *\u000a		 * See also {@link #setStartAt} and {@link #setEndAt}.\u000a		 *\u000a		 * @param {CKEDITOR.dom.node} node The node according to which position will be set.\u000a		 * @param {Number} position One of {@link CKEDITOR#POSITION_BEFORE_START},\u000a		 * {@link CKEDITOR#POSITION_AFTER_START}, {@link CKEDITOR#POSITION_BEFORE_END},\u000a		 * {@link CKEDITOR#POSITION_AFTER_END}.\u000a		 */\u000a		moveToPosition: function( node, position ) {\u000a			this.setStartAt( node, position );\u000a			this.collapse( true );\u000a		},\u000a\u000a		/**\u000a		 * Moves the range to the exact position of the specified range.\u000a		 *\u000a		 * @param {CKEDITOR.dom.range} range\u000a		 */\u000a		moveToRange: function( range ) {\u000a			this.setStart( range.startContainer, range.startOffset );\u000a			this.setEnd( range.endContainer, range.endOffset );\u000a		},\u000a\u000a		/**\u000a		 * Select nodes content. Range will start and end inside this node.\u000a		 *\u000a		 * @param {CKEDITOR.dom.node} node\u000a		 */\u000a		selectNodeContents: function( node ) {\u000a			this.setStart( node, 0 );\u000a			this.setEnd( node, node.type == CKEDITOR.NODE_TEXT ? node.getLength() : node.getChildCount() );\u000a		},\u000a\u000a		/**\u000a		 * Sets the start position of a range.\u000a		 *\u000a		 * @param {CKEDITOR.dom.node} startNode The node to start the range.\u000a		 * @param {Number} startOffset An integer greater than or equal to zero\u000a		 * representing the offset for the start of the range from the start\u000a		 * of `startNode`.\u000a		 */\u000a		setStart: function( startNode, startOffset ) {\u000a			// W3C requires a check for the new position. If it is after the end\u000a			// boundary, the range should be collapsed to the new start. It seams\u000a			// we will not need this check for our use of this class so we can\u000a			// ignore it for now.\u000a\u000a			// Fixing invalid range start inside dtd empty elements.\u000a			if ( startNode.type == CKEDITOR.NODE_ELEMENT && CKEDITOR.dtd.$empty[ startNode.getName() ] )\u000a				startOffset = startNode.getIndex(), startNode = startNode.getParent();\u000a\u000a			this.startContainer = startNode;\u000a			this.startOffset = startOffset;\u000a\u000a			if ( !this.endContainer ) {\u000a				this.endContainer = startNode;\u000a				this.endOffset = startOffset;\u000a			}\u000a\u000a			updateCollapsed( this );\u000a		},\u000a\u000a		/**\u000a		 * Sets the end position of a Range.\u000a		 *\u000a		 * @param {CKEDITOR.dom.node} endNode The node to end the range.\u000a		 * @param {Number} endOffset An integer greater than or equal to zero\u000a		 * representing the offset for the end of the range from the start\u000a		 * of `endNode`.\u000a		 */\u000a		setEnd: function( endNode, endOffset ) {\u000a			// W3C requires a check for the new position. If it is before the start\u000a			// boundary, the range should be collapsed to the new end. It seams we\u000a			// will not need this check for our use of this class so we can ignore\u000a			// it for now.\u000a\u000a			// Fixing invalid range end inside dtd empty elements.\u000a			if ( endNode.type == CKEDITOR.NODE_ELEMENT && CKEDITOR.dtd.$empty[ endNode.getName() ] )\u000a				endOffset = endNode.getIndex() + 1, endNode = endNode.getParent();\u000a\u000a			this.endContainer = endNode;\u000a			this.endOffset = endOffset;\u000a\u000a			if ( !this.startContainer ) {\u000a				this.startContainer = endNode;\u000a				this.startOffset = endOffset;\u000a			}\u000a\u000a			updateCollapsed( this );\u000a		},\u000a\u000a		/**\u000a		 * Sets start of this range after the specified node.\u000a		 *\u000a		 *		// Range: <p>foo<b>bar</b>^</p>\u000a		 *		range.setStartAfter( textFoo );\u000a		 *		// The range will be changed to:\u000a		 *		// <p>foo[<b>bar</b>]</p>\u000a		 *\u000a		 * @param {CKEDITOR.dom.node} node\u000a		 */\u000a		setStartAfter: function( node ) {\u000a			this.setStart( node.getParent(), node.getIndex() + 1 );\u000a		},\u000a\u000a		/**\u000a		 * Sets start of this range after the specified node.\u000a		 *\u000a		 *		// Range: <p>foo<b>bar</b>^</p>\u000a		 *		range.setStartBefore( elB );\u000a		 *		// The range will be changed to:\u000a		 *		// <p>foo[<b>bar</b>]</p>\u000a		 *\u000a		 * @param {CKEDITOR.dom.node} node\u000a		 */\u000a		setStartBefore: function( node ) {\u000a			this.setStart( node.getParent(), node.getIndex() );\u000a		},\u000a\u000a		/**\u000a		 * Sets end of this range after the specified node.\u000a		 *\u000a		 *		// Range: <p>foo^<b>bar</b></p>\u000a		 *		range.setEndAfter( elB );\u000a		 *		// The range will be changed to:\u000a		 *		// <p>foo[<b>bar</b>]</p>\u000a		 *\u000a		 * @param {CKEDITOR.dom.node} node\u000a		 */\u000a		setEndAfter: function( node ) {\u000a			this.setEnd( node.getParent(), node.getIndex() + 1 );\u000a		},\u000a\u000a		/**\u000a		 * Sets end of this range before the specified node.\u000a		 *\u000a		 *		// Range: <p>^foo<b>bar</b></p>\u000a		 *		range.setStartAfter( textBar );\u000a		 *		// The range will be changed to:\u000a		 *		// <p>[foo<b>]bar</b></p>\u000a		 *\u000a		 * @param {CKEDITOR.dom.node} node\u000a		 */\u000a		setEndBefore: function( node ) {\u000a			this.setEnd( node.getParent(), node.getIndex() );\u000a		},\u000a\u000a		/**\u000a		 * Moves the start of this range to given position according to specified node.\u000a		 *\u000a		 *		// HTML: <p>Foo <b>bar</b>^</p>\u000a		 *		range.setStartAt( elB, CKEDITOR.POSITION_AFTER_START );\u000a		 *		// The range will be changed to:\u000a		 *		// <p>Foo <b>[bar</b>]</p>\u000a		 *\u000a		 * See also {@link #setEndAt} and {@link #moveToPosition}.\u000a		 *\u000a		 * @param {CKEDITOR.dom.node} node The node according to which position will be set.\u000a		 * @param {Number} position One of {@link CKEDITOR#POSITION_BEFORE_START},\u000a		 * {@link CKEDITOR#POSITION_AFTER_START}, {@link CKEDITOR#POSITION_BEFORE_END},\u000a		 * {@link CKEDITOR#POSITION_AFTER_END}.\u000a		 */\u000a		setStartAt: function( node, position ) {\u000a			switch ( position ) {\u000a				case CKEDITOR.POSITION_AFTER_START:\u000a					this.setStart( node, 0 );\u000a					break;\u000a\u000a				case CKEDITOR.POSITION_BEFORE_END:\u000a					if ( node.type == CKEDITOR.NODE_TEXT )\u000a						this.setStart( node, node.getLength() );\u000a					else\u000a						this.setStart( node, node.getChildCount() );\u000a					break;\u000a\u000a				case CKEDITOR.POSITION_BEFORE_START:\u000a					this.setStartBefore( node );\u000a					break;\u000a\u000a				case CKEDITOR.POSITION_AFTER_END:\u000a					this.setStartAfter( node );\u000a			}\u000a\u000a			updateCollapsed( this );\u000a		},\u000a\u000a		/**\u000a		 * Moves the end of this range to given position according to specified node.\u000a		 *\u000a		 *		// HTML: <p>^Foo <b>bar</b></p>\u000a		 *		range.setEndAt( textBar, CKEDITOR.POSITION_BEFORE_START );\u000a		 *		// The range will be changed to:\u000a		 *		// <p>[Foo <b>]bar</b></p>\u000a		 *\u000a		 * See also {@link #setStartAt} and {@link #moveToPosition}.\u000a		 *\u000a		 * @param {CKEDITOR.dom.node} node The node according to which position will be set.\u000a		 * @param {Number} position One of {@link CKEDITOR#POSITION_BEFORE_START},\u000a		 * {@link CKEDITOR#POSITION_AFTER_START}, {@link CKEDITOR#POSITION_BEFORE_END},\u000a		 * {@link CKEDITOR#POSITION_AFTER_END}.\u000a		 */\u000a		setEndAt: function( node, position ) {\u000a			switch ( position ) {\u000a				case CKEDITOR.POSITION_AFTER_START:\u000a					this.setEnd( node, 0 );\u000a					break;\u000a\u000a				case CKEDITOR.POSITION_BEFORE_END:\u000a					if ( node.type == CKEDITOR.NODE_TEXT )\u000a						this.setEnd( node, node.getLength() );\u000a					else\u000a						this.setEnd( node, node.getChildCount() );\u000a					break;\u000a\u000a				case CKEDITOR.POSITION_BEFORE_START:\u000a					this.setEndBefore( node );\u000a					break;\u000a\u000a				case CKEDITOR.POSITION_AFTER_END:\u000a					this.setEndAfter( node );\u000a			}\u000a\u000a			updateCollapsed( this );\u000a		},\u000a\u000a		/**\u000a		 * Wraps inline content found around the range's start or end boundary\u000a		 * with a block element.\u000a		 *\u000a		 *		// Assuming the following range:\u000a		 *		// <h1>foo</h1>ba^r<br />bom<p>foo</p>\u000a		 *		// The result of executing:\u000a		 *		range.fixBlock( true, 'p' );\u000a		 *		// will be:\u000a		 *		// <h1>foo</h1><p>ba^r<br />bom</p><p>foo</p>\u000a		 *\u000a		 * Non-collapsed range:\u000a		 *\u000a		 *		// Assuming the following range:\u000a		 *		// ba[r<p>foo</p>bo]m\u000a		 *		// The result of executing:\u000a		 *		range.fixBlock( false, 'p' );\u000a		 *		// will be:\u000a		 *		// ba[r<p>foo</p><p>bo]m</p>\u000a		 *\u000a		 * @param {Boolean} [isStart=false] Whether the start or end boundary of a range should be checked.\u000a		 * @param {String} blockTag The name of a block element in which content will be wrapped.\u000a		 * For example: `'p'`.\u000a		 * @returns {CKEDITOR.dom.element} Created block wrapper.\u000a		 */\u000a		fixBlock: function( isStart, blockTag ) {\u000a			var bookmark = this.createBookmark(),\u000a				fixedBlock = this.document.createElement( blockTag );\u000a\u000a			this.collapse( isStart );\u000a\u000a			this.enlarge( CKEDITOR.ENLARGE_BLOCK_CONTENTS );\u000a\u000a			this.extractContents().appendTo( fixedBlock );\u000a			fixedBlock.trim();\u000a\u000a			fixedBlock.appendBogus();\u000a\u000a			this.insertNode( fixedBlock );\u000a\u000a			this.moveToBookmark( bookmark );\u000a\u000a			return fixedBlock;\u000a		},\u000a\u000a		/**\u000a		 * @todo\u000a		 */\u000a		splitBlock: function( blockTag ) {\u000a			var startPath = new CKEDITOR.dom.elementPath( this.startContainer, this.root ),\u000a				endPath = new CKEDITOR.dom.elementPath( this.endContainer, this.root );\u000a\u000a			var startBlockLimit = startPath.blockLimit,\u000a				endBlockLimit = endPath.blockLimit;\u000a\u000a			var startBlock = startPath.block,\u000a				endBlock = endPath.block;\u000a\u000a			var elementPath = null;\u000a			// Do nothing if the boundaries are in different block limits.\u000a			if ( !startBlockLimit.equals( endBlockLimit ) )\u000a				return null;\u000a\u000a			// Get or fix current blocks.\u000a			if ( blockTag != 'br' ) {\u000a				if ( !startBlock ) {\u000a					startBlock = this.fixBlock( true, blockTag );\u000a					endBlock = new CKEDITOR.dom.elementPath( this.endContainer, this.root ).block;\u000a				}\u000a\u000a				if ( !endBlock )\u000a					endBlock = this.fixBlock( false, blockTag );\u000a			}\u000a\u000a			// Get the range position.\u000a			var isStartOfBlock = startBlock && this.checkStartOfBlock(),\u000a				isEndOfBlock = endBlock && this.checkEndOfBlock();\u000a\u000a			// Delete the current contents.\u000a			// TODO: Why is 2.x doing CheckIsEmpty()?\u000a			this.deleteContents();\u000a\u000a			if ( startBlock && startBlock.equals( endBlock ) ) {\u000a				if ( isEndOfBlock ) {\u000a					elementPath = new CKEDITOR.dom.elementPath( this.startContainer, this.root );\u000a					this.moveToPosition( endBlock, CKEDITOR.POSITION_AFTER_END );\u000a					endBlock = null;\u000a				} else if ( isStartOfBlock ) {\u000a					elementPath = new CKEDITOR.dom.elementPath( this.startContainer, this.root );\u000a					this.moveToPosition( startBlock, CKEDITOR.POSITION_BEFORE_START );\u000a					startBlock = null;\u000a				} else {\u000a					endBlock = this.splitElement( startBlock );\u000a\u000a					// In Gecko, the last child node must be a bogus <br>.\u000a					// Note: bogus <br> added under <ul> or <ol> would cause\u000a					// lists to be incorrectly rendered.\u000a					if ( !startBlock.is( 'ul', 'ol' ) )\u000a						startBlock.appendBogus();\u000a				}\u000a			}\u000a\u000a			return {\u000a				previousBlock: startBlock,\u000a				nextBlock: endBlock,\u000a				wasStartOfBlock: isStartOfBlock,\u000a				wasEndOfBlock: isEndOfBlock,\u000a				elementPath: elementPath\u000a			};\u000a		},\u000a\u000a		/**\u000a		 * Branch the specified element from the collapsed range position and\u000a		 * place the caret between the two result branches.\u000a		 *\u000a		 * **Note:** The range must be collapsed and been enclosed by this element.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} element\u000a		 * @returns {CKEDITOR.dom.element} Root element of the new branch after the split.\u000a		 */\u000a		splitElement: function( toSplit ) {\u000a			if ( !this.collapsed )\u000a				return null;\u000a\u000a			// Extract the contents of the block from the selection point to the end\u000a			// of its contents.\u000a			this.setEndAt( toSplit, CKEDITOR.POSITION_BEFORE_END );\u000a			var documentFragment = this.extractContents();\u000a\u000a			// Duplicate the element after it.\u000a			var clone = toSplit.clone( false );\u000a\u000a			// Place the extracted contents into the duplicated element.\u000a			documentFragment.appendTo( clone );\u000a			clone.insertAfter( toSplit );\u000a			this.moveToPosition( toSplit, CKEDITOR.POSITION_AFTER_END );\u000a			return clone;\u000a		},\u000a\u000a		/**\u000a		 * Recursively remove any empty path blocks at the range boundary.\u000a		 *\u000a		 * @method\u000a		 * @param {Boolean} atEnd Removal to perform at the end boundary,\u000a		 * otherwise to perform at the start.\u000a		 */\u000a		removeEmptyBlocksAtEnd: ( function() {\u000a\u000a			var whitespace = CKEDITOR.dom.walker.whitespaces(),\u000a					bookmark = CKEDITOR.dom.walker.bookmark( false );\u000a\u000a			function childEval( parent ) {\u000a				return function( node ) {\u000a					// Whitespace, bookmarks, empty inlines.\u000a					if ( whitespace( node ) || bookmark( node ) ||\u000a							node.type == CKEDITOR.NODE_ELEMENT &&\u000a							node.isEmptyInlineRemoveable() ) {\u000a						return false;\u000a					} else if ( parent.is( 'table' ) && node.is( 'caption' ) ) {\u000a						return false;\u000a					}\u000a\u000a					return true;\u000a				};\u000a			}\u000a\u000a			return function( atEnd ) {\u000a\u000a				var bm = this.createBookmark();\u000a				var path = this[ atEnd ? 'endPath' : 'startPath' ]();\u000a				var block = path.block || path.blockLimit, parent;\u000a\u000a				// Remove any childless block, including list and table.\u000a				while ( block && !block.equals( path.root ) &&\u000a						!block.getFirst( childEval( block ) ) ) {\u000a					parent = block.getParent();\u000a					this[ atEnd ? 'setEndAt' : 'setStartAt' ]( block, CKEDITOR.POSITION_AFTER_END );\u000a					block.remove( 1 );\u000a					block = parent;\u000a				}\u000a\u000a				this.moveToBookmark( bm );\u000a			};\u000a\u000a		} )(),\u000a\u000a		/**\u000a		 * Gets {@link CKEDITOR.dom.elementPath} for the {@link #startContainer}.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.elementPath}\u000a		 */\u000a		startPath: function() {\u000a			return new CKEDITOR.dom.elementPath( this.startContainer, this.root );\u000a		},\u000a\u000a		/**\u000a		 * Gets {@link CKEDITOR.dom.elementPath} for the {@link #endContainer}.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.elementPath}\u000a		 */\u000a		endPath: function() {\u000a			return new CKEDITOR.dom.elementPath( this.endContainer, this.root );\u000a		},\u000a\u000a		/**\u000a		 * Check whether a range boundary is at the inner boundary of a given\u000a		 * element.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} element The target element to check.\u000a		 * @param {Number} checkType The boundary to check for both the range\u000a		 * and the element. It can be {@link CKEDITOR#START} or {@link CKEDITOR#END}.\u000a		 * @returns {Boolean} `true` if the range boundary is at the inner\u000a		 * boundary of the element.\u000a		 */\u000a		checkBoundaryOfElement: function( element, checkType ) {\u000a			var checkStart = ( checkType == CKEDITOR.START );\u000a\u000a			// Create a copy of this range, so we can manipulate it for our checks.\u000a			var walkerRange = this.clone();\u000a\u000a			// Collapse the range at the proper size.\u000a			walkerRange.collapse( checkStart );\u000a\u000a			// Expand the range to element boundary.\u000a			walkerRange[ checkStart ? 'setStartAt' : 'setEndAt' ]\u000a			( element, checkStart ? CKEDITOR.POSITION_AFTER_START : CKEDITOR.POSITION_BEFORE_END );\u000a\u000a			// Create the walker, which will check if we have anything useful\u000a			// in the range.\u000a			var walker = new CKEDITOR.dom.walker( walkerRange );\u000a			walker.evaluator = elementBoundaryEval( checkStart );\u000a\u000a			return walker[ checkStart ? 'checkBackward' : 'checkForward' ]();\u000a		},\u000a\u000a		/**\u000a		 * **Note:** Calls to this function may produce changes to the DOM. The range may\u000a		 * be updated to reflect such changes.\u000a		 *\u000a		 * @returns {Boolean}\u000a		 * @todo\u000a		 */\u000a		checkStartOfBlock: function() {\u000a			var startContainer = this.startContainer,\u000a				startOffset = this.startOffset;\u000a\u000a			// [IE] Special handling for range start in text with a leading NBSP,\u000a			// we it to be isolated, for bogus check.\u000a			if ( CKEDITOR.env.ie && startOffset && startContainer.type == CKEDITOR.NODE_TEXT )\u000a			{\u000a				var textBefore = CKEDITOR.tools.ltrim( startContainer.substring( 0, startOffset ) );\u000a				if ( nbspRegExp.test( textBefore ) )\u000a					this.trim( 0, 1 );\u000a			}\u000a\u000a			// Antecipate the trim() call here, so the walker will not make\u000a			// changes to the DOM, which would not get reflected into this\u000a			// range otherwise.\u000a			this.trim();\u000a\u000a			// We need to grab the block element holding the start boundary, so\u000a			// let's use an element path for it.\u000a			var path = new CKEDITOR.dom.elementPath( this.startContainer, this.root );\u000a\u000a			// Creates a range starting at the block start until the range start.\u000a			var walkerRange = this.clone();\u000a			walkerRange.collapse( true );\u000a			walkerRange.setStartAt( path.block || path.blockLimit, CKEDITOR.POSITION_AFTER_START );\u000a\u000a			var walker = new CKEDITOR.dom.walker( walkerRange );\u000a			walker.evaluator = getCheckStartEndBlockEvalFunction();\u000a\u000a			return walker.checkBackward();\u000a		},\u000a\u000a		/**\u000a		 * **Note:** Calls to this function may produce changes to the DOM. The range may\u000a		 * be updated to reflect such changes.\u000a		 *\u000a		 * @returns {Boolean}\u000a		 * @todo\u000a		 */\u000a		checkEndOfBlock: function() {\u000a			var endContainer = this.endContainer,\u000a				endOffset = this.endOffset;\u000a\u000a			// [IE] Special handling for range end in text with a following NBSP,\u000a			// we it to be isolated, for bogus check.\u000a			if ( CKEDITOR.env.ie && endContainer.type == CKEDITOR.NODE_TEXT )\u000a			{\u000a				var textAfter = CKEDITOR.tools.rtrim( endContainer.substring( endOffset ) );\u000a				if ( nbspRegExp.test( textAfter ) )\u000a					this.trim( 1, 0 );\u000a			}\u000a\u000a			// Antecipate the trim() call here, so the walker will not make\u000a			// changes to the DOM, which would not get reflected into this\u000a			// range otherwise.\u000a			this.trim();\u000a\u000a			// We need to grab the block element holding the start boundary, so\u000a			// let's use an element path for it.\u000a			var path = new CKEDITOR.dom.elementPath( this.endContainer, this.root );\u000a\u000a			// Creates a range starting at the block start until the range start.\u000a			var walkerRange = this.clone();\u000a			walkerRange.collapse( false );\u000a			walkerRange.setEndAt( path.block || path.blockLimit, CKEDITOR.POSITION_BEFORE_END );\u000a\u000a			var walker = new CKEDITOR.dom.walker( walkerRange );\u000a			walker.evaluator = getCheckStartEndBlockEvalFunction();\u000a\u000a			return walker.checkForward();\u000a		},\u000a\u000a		/**\u000a		 * Traverse with {@link CKEDITOR.dom.walker} to retrieve the previous element before the range start.\u000a		 *\u000a		 * @param {Function} evaluator Function used as the walker's evaluator.\u000a		 * @param {Function} [guard] Function used as the walker's guard.\u000a		 * @param {CKEDITOR.dom.element} [boundary] A range ancestor element in which the traversal is limited,\u000a		 * default to the root editable if not defined.\u000a		 * @returns {CKEDITOR.dom.element/null} The returned node from the traversal.\u000a		 */\u000a		getPreviousNode: function( evaluator, guard, boundary ) {\u000a			var walkerRange = this.clone();\u000a			walkerRange.collapse( 1 );\u000a			walkerRange.setStartAt( boundary || this.root, CKEDITOR.POSITION_AFTER_START );\u000a\u000a			var walker = new CKEDITOR.dom.walker( walkerRange );\u000a			walker.evaluator = evaluator;\u000a			walker.guard = guard;\u000a			return walker.previous();\u000a		},\u000a\u000a		/**\u000a		 * Traverse with {@link CKEDITOR.dom.walker} to retrieve the next element before the range start.\u000a		 *\u000a		 * @param {Function} evaluator Function used as the walker's evaluator.\u000a		 * @param {Function} [guard] Function used as the walker's guard.\u000a		 * @param {CKEDITOR.dom.element} [boundary] A range ancestor element in which the traversal is limited,\u000a		 * default to the root editable if not defined.\u000a		 * @returns {CKEDITOR.dom.element/null} The returned node from the traversal.\u000a		 */\u000a		getNextNode: function( evaluator, guard, boundary ) {\u000a			var walkerRange = this.clone();\u000a			walkerRange.collapse();\u000a			walkerRange.setEndAt( boundary || this.root, CKEDITOR.POSITION_BEFORE_END );\u000a\u000a			var walker = new CKEDITOR.dom.walker( walkerRange );\u000a			walker.evaluator = evaluator;\u000a			walker.guard = guard;\u000a			return walker.next();\u000a		},\u000a\u000a		/**\u000a		 * Check if elements at which the range boundaries anchor are read-only,\u000a		 * with respect to `contenteditable` attribute.\u000a		 *\u000a		 * @returns {Boolean}\u000a		 */\u000a		checkReadOnly: ( function() {\u000a			function checkNodesEditable( node, anotherEnd ) {\u000a				while ( node ) {\u000a					if ( node.type == CKEDITOR.NODE_ELEMENT ) {\u000a						if ( node.getAttribute( 'contentEditable' ) == 'false' && !node.data( 'cke-editable' ) )\u000a							return 0;\u000a\u000a						// Range enclosed entirely in an editable element.\u000a						else if ( node.is( 'html' ) || node.getAttribute( 'contentEditable' ) == 'true' && ( node.contains( anotherEnd ) || node.equals( anotherEnd ) ) )\u000a							break;\u000a\u000a					}\u000a					node = node.getParent();\u000a				}\u000a\u000a				return 1;\u000a			}\u000a\u000a			return function() {\u000a				var startNode = this.startContainer,\u000a					endNode = this.endContainer;\u000a\u000a				// Check if elements path at both boundaries are editable.\u000a				return !( checkNodesEditable( startNode, endNode ) && checkNodesEditable( endNode, startNode ) );\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Moves the range boundaries to the first/end editing point inside an\u000a		 * element.\u000a		 *\u000a		 * For example, in an element tree like\u000a		 * `<p><b><i></i></b> Text</p>`, the start editing point is\u000a		 * `<p><b><i>^</i></b> Text</p>` (inside `<i>`).\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} el The element into which look for the\u000a		 * editing spot.\u000a		 * @param {Boolean} isMoveToEnd Whether move to the end editable position.\u000a		 * @returns {Boolean} Whether range was moved.\u000a		 */\u000a		moveToElementEditablePosition: function( el, isMoveToEnd ) {\u000a\u000a			function nextDFS( node, childOnly ) {\u000a				var next;\u000a\u000a				if ( node.type == CKEDITOR.NODE_ELEMENT && node.isEditable( false ) )\u000a					next = node[ isMoveToEnd ? 'getLast' : 'getFirst' ]( notIgnoredEval );\u000a\u000a				if ( !childOnly && !next )\u000a					next = node[ isMoveToEnd ? 'getPrevious' : 'getNext' ]( notIgnoredEval );\u000a\u000a				return next;\u000a			}\u000a\u000a			// Handle non-editable element e.g. HR.\u000a			if ( el.type == CKEDITOR.NODE_ELEMENT && !el.isEditable( false ) ) {\u000a				this.moveToPosition( el, isMoveToEnd ? CKEDITOR.POSITION_AFTER_END : CKEDITOR.POSITION_BEFORE_START );\u000a				return true;\u000a			}\u000a\u000a			var found = 0;\u000a\u000a			while ( el ) {\u000a				// Stop immediately if we've found a text node.\u000a				if ( el.type == CKEDITOR.NODE_TEXT ) {\u000a					// Put cursor before block filler.\u000a					if ( isMoveToEnd && this.endContainer && this.checkEndOfBlock() && nbspRegExp.test( el.getText() ) )\u000a						this.moveToPosition( el, CKEDITOR.POSITION_BEFORE_START );\u000a					else\u000a						this.moveToPosition( el, isMoveToEnd ? CKEDITOR.POSITION_AFTER_END : CKEDITOR.POSITION_BEFORE_START );\u000a					found = 1;\u000a					break;\u000a				}\u000a\u000a				// If an editable element is found, move inside it, but not stop the searching.\u000a				if ( el.type == CKEDITOR.NODE_ELEMENT ) {\u000a					if ( el.isEditable() ) {\u000a						this.moveToPosition( el, isMoveToEnd ? CKEDITOR.POSITION_BEFORE_END : CKEDITOR.POSITION_AFTER_START );\u000a						found = 1;\u000a					}\u000a					// Put cursor before padding block br.\u000a					else if ( isMoveToEnd && el.is( 'br' ) && this.endContainer && this.checkEndOfBlock() )\u000a						this.moveToPosition( el, CKEDITOR.POSITION_BEFORE_START );\u000a					// Special case - non-editable block. Select entire element, because it does not make sense\u000a					// to place collapsed selection next to it, because browsers can't handle that.\u000a					else if ( el.getAttribute( 'contenteditable' ) == 'false' && el.is( CKEDITOR.dtd.$block ) ) {\u000a						this.setStartBefore( el );\u000a						this.setEndAfter( el );\u000a						return true;\u000a					}\u000a				}\u000a\u000a				el = nextDFS( el, found );\u000a			}\u000a\u000a			return !!found;\u000a		},\u000a\u000a		/**\u000a		 * Moves the range boundaries to the closest editing point after/before an\u000a		 * element.\u000a		 *\u000a		 * For example, if the start element has `id="start"`,\u000a		 * `<p><b>foo</b><span id="start">start</start></p>`, the closest previous editing point is\u000a		 * `<p><b>foo</b>^<span id="start">start</start></p>` (between `<b>` and `<span>`).\u000a		 *\u000a		 * See also: {@link #moveToElementEditablePosition}.\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {CKEDITOR.dom.element} element The starting element.\u000a		 * @param {Boolean} isMoveToEnd Whether move to the end of editable. Otherwise, look back.\u000a		 * @returns {Boolean} Whether the range was moved.\u000a		 */\u000a		moveToClosestEditablePosition: function( element, isMoveToEnd ) {\u000a			// We don't want to modify original range if there's no editable position.\u000a			var range = new CKEDITOR.dom.range( this.root ),\u000a				found = 0,\u000a				sibling,\u000a				positions = [ CKEDITOR.POSITION_AFTER_END, CKEDITOR.POSITION_BEFORE_START ];\u000a\u000a			// Set collapsed range at one of ends of element.\u000a			range.moveToPosition( element, positions[ isMoveToEnd ? 0 : 1 ] );\u000a\u000a			// Start element isn't a block, so we can automatically place range\u000a			// next to it.\u000a			if ( !element.is( CKEDITOR.dtd.$block ) )\u000a				found = 1;\u000a			else {\u000a				// Look for first node that fulfills eval function and place range next to it.\u000a				sibling = range[ isMoveToEnd ? 'getNextEditableNode' : 'getPreviousEditableNode' ]();\u000a				if ( sibling ) {\u000a					found = 1;\u000a\u000a					// Special case - eval accepts block element only if it's a non-editable block,\u000a					// which we want to select, not place collapsed selection next to it (which browsers\u000a					// can't handle).\u000a					if ( sibling.type == CKEDITOR.NODE_ELEMENT && sibling.is( CKEDITOR.dtd.$block ) && sibling.getAttribute( 'contenteditable' ) == 'false' ) {\u000a						range.setStartAt( sibling, CKEDITOR.POSITION_BEFORE_START );\u000a						range.setEndAt( sibling, CKEDITOR.POSITION_AFTER_END );\u000a					} else {\u000a						range.moveToPosition( sibling, positions[ isMoveToEnd ? 1 : 0 ] );\u000a					}\u000a				}\u000a			}\u000a\u000a			if ( found )\u000a				this.moveToRange( range );\u000a\u000a			return !!found;\u000a		},\u000a\u000a		/**\u000a		 * See {@link #moveToElementEditablePosition}.\u000a		 *\u000a		 * @returns {Boolean} Whether range was moved.\u000a		 */\u000a		moveToElementEditStart: function( target ) {\u000a			return this.moveToElementEditablePosition( target );\u000a		},\u000a\u000a		/**\u000a		 * See {@link #moveToElementEditablePosition}.\u000a		 *\u000a		 * @returns {Boolean} Whether range was moved.\u000a		 */\u000a		moveToElementEditEnd: function( target ) {\u000a			return this.moveToElementEditablePosition( target, true );\u000a		},\u000a\u000a		/**\u000a		 * Get the single node enclosed within the range if there's one.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.node}\u000a		 */\u000a		getEnclosedNode: function() {\u000a			var walkerRange = this.clone();\u000a\u000a			// Optimize and analyze the range to avoid DOM destructive nature of walker. (#5780)\u000a			walkerRange.optimize();\u000a			if ( walkerRange.startContainer.type != CKEDITOR.NODE_ELEMENT || walkerRange.endContainer.type != CKEDITOR.NODE_ELEMENT )\u000a				return null;\u000a\u000a			var walker = new CKEDITOR.dom.walker( walkerRange ),\u000a				isNotBookmarks = CKEDITOR.dom.walker.bookmark( false, true ),\u000a				isNotWhitespaces = CKEDITOR.dom.walker.whitespaces( true );\u000a\u000a			walker.evaluator = function( node ) {\u000a				return isNotWhitespaces( node ) && isNotBookmarks( node );\u000a			};\u000a			var node = walker.next();\u000a			walker.reset();\u000a			return node && node.equals( walker.previous() ) ? node : null;\u000a		},\u000a\u000a		/**\u000a		 * Get the node adjacent to the range start or {@link #startContainer}.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.node}\u000a		 */\u000a		getTouchedStartNode: function() {\u000a			var container = this.startContainer;\u000a\u000a			if ( this.collapsed || container.type != CKEDITOR.NODE_ELEMENT )\u000a				return container;\u000a\u000a			return container.getChild( this.startOffset ) || container;\u000a		},\u000a\u000a		/**\u000a		 * Get the node adjacent to the range end or {@link #endContainer}.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.node}\u000a		 */\u000a		getTouchedEndNode: function() {\u000a			var container = this.endContainer;\u000a\u000a			if ( this.collapsed || container.type != CKEDITOR.NODE_ELEMENT )\u000a				return container;\u000a\u000a			return container.getChild( this.endOffset - 1 ) || container;\u000a		},\u000a\u000a		/**\u000a		 * Gets next node which can be a container of a selection.\u000a		 * This methods mimics a behavior of right/left arrow keys in case of\u000a		 * collapsed selection. It does not return an exact position (with offset) though,\u000a		 * but just a selection's container.\u000a		 *\u000a		 * Note: use this method on a collapsed range.\u000a		 *\u000a		 * @since 4.3\u000a		 * @returns {CKEDITOR.dom.element/CKEDITOR.dom.text}\u000a		 */\u000a		getNextEditableNode: getNextEditableNode(),\u000a\u000a		/**\u000a		 * See {@link #getNextEditableNode}.\u000a		 *\u000a		 * @since 4.3\u000a		 * @returns {CKEDITOR.dom.element/CKEDITOR.dom.text}\u000a		 */\u000a		getPreviousEditableNode: getNextEditableNode( 1 ),\u000a\u000a		/**\u000a		 * Scrolls the start of current range into view.\u000a		 */\u000a		scrollIntoView: function() {\u000a\u000a			// The reference element contains a zero-width space to avoid\u000a			// a premature removal. The view is to be scrolled with respect\u000a			// to this element.\u000a			var reference = new CKEDITOR.dom.element.createFromHtml( '<span>&nbsp;</span>', this.document ),\u000a				afterCaretNode, startContainerText, isStartText;\u000a\u000a			var range = this.clone();\u000a\u000a			// Work with the range to obtain a proper caret position.\u000a			range.optimize();\u000a\u000a			// Currently in a text node, so we need to split it into two\u000a			// halves and put the reference between.\u000a			if ( isStartText = range.startContainer.type == CKEDITOR.NODE_TEXT ) {\u000a				// Keep the original content. It will be restored.\u000a				startContainerText = range.startContainer.getText();\u000a\u000a				// Split the startContainer at the this position.\u000a				afterCaretNode = range.startContainer.split( range.startOffset );\u000a\u000a				// Insert the reference between two text nodes.\u000a				reference.insertAfter( range.startContainer );\u000a			}\u000a\u000a			// If not in a text node, simply insert the reference into the range.\u000a			else {\u000a				range.insertNode( reference );\u000a			}\u000a\u000a			// Scroll with respect to the reference element.\u000a			reference.scrollIntoView();\u000a\u000a			// Get rid of split parts if "in a text node" case.\u000a			// Revert the original text of the startContainer.\u000a			if ( isStartText ) {\u000a				range.startContainer.setText( startContainerText );\u000a				afterCaretNode.remove();\u000a			}\u000a\u000a			// Get rid of the reference node. It is no longer necessary.\u000a			reference.remove();\u000a		}\u000a	};\u000a} )();\u000a\u000a/**\u000a * Indicates a position after start of a node.\u000a *\u000a *		// When used according to an element:\u000a *		// <element>^contents</element>\u000a *\u000a *		// When used according to a text node:\u000a *		// "^text" (range is anchored in the text node)\u000a *\u000a * It is used as a parameter of methods like: {@link CKEDITOR.dom.range#moveToPosition},\u000a * {@link CKEDITOR.dom.range#setStartAt} and {@link CKEDITOR.dom.range#setEndAt}.\u000a *\u000a * @readonly\u000a * @member CKEDITOR\u000a * @property {Number} [=1]\u000a */\u000aCKEDITOR.POSITION_AFTER_START = 1;\u000a\u000a/**\u000a * Indicates a position before end of a node.\u000a *\u000a *		// When used according to an element:\u000a *		// <element>contents^</element>\u000a *\u000a *		// When used according to a text node:\u000a *		// "text^" (range is anchored in the text node)\u000a *\u000a * It is used as a parameter of methods like: {@link CKEDITOR.dom.range#moveToPosition},\u000a * {@link CKEDITOR.dom.range#setStartAt} and {@link CKEDITOR.dom.range#setEndAt}.\u000a *\u000a * @readonly\u000a * @member CKEDITOR\u000a * @property {Number} [=2]\u000a */\u000aCKEDITOR.POSITION_BEFORE_END = 2;\u000a\u000a/**\u000a * Indicates a position before start of a node.\u000a *\u000a *		// When used according to an element:\u000a *		// ^<element>contents</element> (range is anchored in element's parent)\u000a *\u000a *		// When used according to a text node:\u000a *		// ^"text" (range is anchored in text node's parent)\u000a *\u000a * It is used as a parameter of methods like: {@link CKEDITOR.dom.range#moveToPosition},\u000a * {@link CKEDITOR.dom.range#setStartAt} and {@link CKEDITOR.dom.range#setEndAt}.\u000a *\u000a * @readonly\u000a * @member CKEDITOR\u000a * @property {Number} [=3]\u000a */\u000aCKEDITOR.POSITION_BEFORE_START = 3;\u000a\u000a/**\u000a * Indicates a position after end of a node.\u000a *\u000a *		// When used according to an element:\u000a *		// <element>contents</element>^ (range is anchored in element's parent)\u000a *\u000a *		// When used according to a text node:\u000a *		// "text"^ (range is anchored in text node's parent)\u000a *\u000a * It is used as a parameter of methods like: {@link CKEDITOR.dom.range#moveToPosition},\u000a * {@link CKEDITOR.dom.range#setStartAt} and {@link CKEDITOR.dom.range#setEndAt}.\u000a *\u000a * @readonly\u000a * @member CKEDITOR\u000a * @property {Number} [=4]\u000a */\u000aCKEDITOR.POSITION_AFTER_END = 4;\u000a\u000aCKEDITOR.ENLARGE_ELEMENT = 1;\u000aCKEDITOR.ENLARGE_BLOCK_CONTENTS = 2;\u000aCKEDITOR.ENLARGE_LIST_ITEM_CONTENTS = 3;\u000aCKEDITOR.ENLARGE_INLINE = 4;\u000a\u000a// Check boundary types.\u000a\u000a/**\u000a * See {@link CKEDITOR.dom.range#checkBoundaryOfElement}.\u000a *\u000a * @readonly\u000a * @member CKEDITOR\u000a * @property {Number} [=1]\u000a */\u000aCKEDITOR.START = 1;\u000a\u000a/**\u000a * See {@link CKEDITOR.dom.range#checkBoundaryOfElement}.\u000a *\u000a * @readonly\u000a * @member CKEDITOR\u000a * @property {Number} [=2]\u000a */\u000aCKEDITOR.END = 2;\u000a\u000a// Shrink range types.\u000a\u000a/**\u000a * See {@link CKEDITOR.dom.range#shrink}.\u000a *\u000a * @readonly\u000a * @member CKEDITOR\u000a * @property {Number} [=1]\u000a */\u000aCKEDITOR.SHRINK_ELEMENT = 1;\u000a\u000a/**\u000a * See {@link CKEDITOR.dom.range#shrink}.\u000a *\u000a * @readonly\u000a * @member CKEDITOR\u000a * @property {Number} [=2]\u000a */\u000aCKEDITOR.SHRINK_TEXT = 2;\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @ignore\u000a * File overview: DOM iterator, which iterates over list items, lines and paragraphs.\u000a */\u000a\u000a'use strict';\u000a\u000a( function() {\u000a	/**\u000a	 * Represents iterator class. It can be used to iterate\u000a	 * over all elements (or even text nodes in case of {@link #enlargeBr} set to `false`)\u000a	 * which establish "paragraph-like" spaces within passed range.\u000a	 *\u000a	 *		// <h1>[foo</h1><p>bar]</p>\u000a	 *		var iterator = range.createIterator();\u000a	 *		iterator.getNextParagraph(); // h1 element\u000a	 *		iterator.getNextParagraph(); // p element\u000a	 *\u000a	 *		// <ul><li>[foo</li><li>bar]</li>\u000a	 *		// With enforceRealBlocks set to false iterator will return two list item elements.\u000a	 *		// With enforceRealBlocks set to true iterator will return two paragraphs and the DOM will be changed to:\u000a	 *		// <ul><li><p>foo</p></li><li><p>bar</p></li>\u000a	 *\u000a	 * @class CKEDITOR.dom.iterator\u000a	 * @constructor Creates an iterator class instance.\u000a	 * @param {CKEDITOR.dom.range} range\u000a	 */\u000a	function iterator( range ) {\u000a		if ( arguments.length < 1 )\u000a			return;\u000a\u000a		this.range = range;\u000a		this.forceBrBreak = 0;\u000a\u000a		// (#3730).\u000a		/**\u000a		 * Whether include `<br>`s into the enlarged range. Should be\u000a		 * set to `false` when using iterator in {@link CKEDITOR#ENTER_BR} mode.\u000a		 *\u000a		 * @property {Boolean} [enlargeBr=true]\u000a		 */\u000a		this.enlargeBr = 1;\u000a\u000a		/**\u000a		 * Whether iterator should create transformable block\u000a		 * if the current one contains text and it cannot be transformed.\u000a		 * For example new blocks will be established in elements like\u000a		 * `<li>` or `<td>`.\u000a		 *\u000a		 * @property {Boolean} [enforceRealBlocks=false]\u000a		 */\u000a		this.enforceRealBlocks = 0;\u000a\u000a		this._ || ( this._ = {} );\u000a	}\u000a\u000a	/**\u000a	 * Default iterator's filter. It is set only for nested iterators.\u000a	 *\u000a	 * @since 4.3\u000a	 * @readonly\u000a	 * @property {CKEDITOR.filter} filter\u000a	 */\u000a\u000a	/**\u000a	 * Iterator's active filter. It is set by the {@link #getNextParagraph} method\u000a	 * when it enters nested editable.\u000a	 *\u000a	 * @since 4.3\u000a	 * @readonly\u000a	 * @property {CKEDITOR.filter} activeFilter\u000a	 */\u000a\u000a	var beginWhitespaceRegex = /^[\u005cr\u005cn\u005ct ]+$/,\u000a		// Ignore bookmark nodes.(#3783)\u000a		bookmarkGuard = CKEDITOR.dom.walker.bookmark( false, true ),\u000a		whitespacesGuard = CKEDITOR.dom.walker.whitespaces( true ),\u000a		skipGuard = function( node ) {\u000a			return bookmarkGuard( node ) && whitespacesGuard( node );\u000a		},\u000a		listItemNames = { dd: 1, dt: 1, li: 1 };\u000a\u000a	// Get a reference for the next element, bookmark nodes are skipped.\u000a	function getNextSourceNode( node, startFromSibling, lastNode ) {\u000a		var next = node.getNextSourceNode( startFromSibling, null, lastNode );\u000a		while ( !bookmarkGuard( next ) )\u000a			next = next.getNextSourceNode( startFromSibling, null, lastNode );\u000a		return next;\u000a	}\u000a\u000a	iterator.prototype = {\u000a		/**\u000a		 * Returns next paragraph-like element or `null` if reached the end of range.\u000a		 *\u000a		 * @param {String} [blockTag='p'] Name of a block element which will be established by\u000a		 * iterator in block-less elements (see {@link #enforceRealBlocks}).\u000a		 */\u000a		getNextParagraph: function( blockTag ) {\u000a			// The block element to be returned.\u000a			var block;\u000a\u000a			// The range object used to identify the paragraph contents.\u000a			var range;\u000a\u000a			// Indicats that the current element in the loop is the last one.\u000a			var isLast;\u000a\u000a			// Instructs to cleanup remaining BRs.\u000a			var removePreviousBr, removeLastBr;\u000a\u000a			blockTag = blockTag || 'p';\u000a\u000a			// We're iterating over nested editable.\u000a			if ( this._.nestedEditable ) {\u000a				// Get next block from nested iterator and returns it if was found.\u000a				block = this._.nestedEditable.iterator.getNextParagraph( blockTag );\u000a				if ( block ) {\u000a					// Inherit activeFilter from the nested iterator.\u000a					this.activeFilter = this._.nestedEditable.iterator.activeFilter;\u000a					return block;\u000a				}\u000a\u000a				// No block in nested iterator means that we reached the end of the nested editable.\u000a				// Reset the active filter to the default filter (or undefined if this iterator didn't have it).\u000a				this.activeFilter = this.filter;\u000a\u000a				// Try to find next nested editable or get back to parent (this) iterator.\u000a				if ( startNestedEditableIterator( this, blockTag, this._.nestedEditable.container, this._.nestedEditable.remaining ) ) {\u000a					// Inherit activeFilter from the nested iterator.\u000a					this.activeFilter = this._.nestedEditable.iterator.activeFilter;\u000a					return this._.nestedEditable.iterator.getNextParagraph( blockTag );\u000a				} else {\u000a					this._.nestedEditable = null;\u000a				}\u000a			}\u000a\u000a			// Block-less range should be checked first.\u000a			if ( !this.range.root.getDtd()[ blockTag ] )\u000a				return null;\u000a\u000a			// This is the first iteration. Let's initialize it.\u000a			if ( !this._.started )\u000a				range = startIterator.call( this );\u000a\u000a			var currentNode = this._.nextNode,\u000a				lastNode = this._.lastNode;\u000a\u000a			this._.nextNode = null;\u000a			while ( currentNode ) {\u000a				// closeRange indicates that a paragraph boundary has been found,\u000a				// so the range can be closed.\u000a				var closeRange = 0,\u000a					parentPre = currentNode.hasAscendant( 'pre' );\u000a\u000a				// includeNode indicates that the current node is good to be part\u000a				// of the range. By default, any non-element node is ok for it.\u000a				var includeNode = ( currentNode.type != CKEDITOR.NODE_ELEMENT ),\u000a					continueFromSibling = 0;\u000a\u000a				// If it is an element node, let's check if it can be part of the range.\u000a				if ( !includeNode ) {\u000a					var nodeName = currentNode.getName();\u000a\u000a					// Non-editable block was found - return it and move to processing\u000a					// its nested editables if they exist.\u000a					if ( CKEDITOR.dtd.$block[ nodeName ] && currentNode.getAttribute( 'contenteditable' ) == 'false' ) {\u000a						block = currentNode;\u000a\u000a						// Setup iterator for first of nested editables.\u000a						// If there's no editable, then algorithm will move to next element after current block.\u000a						startNestedEditableIterator( this, blockTag, block );\u000a\u000a						// Gets us straight to the end of getParagraph() because block variable is set.\u000a						break;\u000a					} else if ( currentNode.isBlockBoundary( this.forceBrBreak && !parentPre && { br: 1 } ) ) {\u000a						// <br> boundaries must be part of the range. It will\u000a						// happen only if ForceBrBreak.\u000a						if ( nodeName == 'br' )\u000a							includeNode = 1;\u000a						else if ( !range && !currentNode.getChildCount() && nodeName != 'hr' ) {\u000a							// If we have found an empty block, and haven't started\u000a							// the range yet, it means we must return this block.\u000a							block = currentNode;\u000a							isLast = currentNode.equals( lastNode );\u000a							break;\u000a						}\u000a\u000a						// The range must finish right before the boundary,\u000a						// including possibly skipped empty spaces. (#1603)\u000a						if ( range ) {\u000a							range.setEndAt( currentNode, CKEDITOR.POSITION_BEFORE_START );\u000a\u000a							// The found boundary must be set as the next one at this\u000a							// point. (#1717)\u000a							if ( nodeName != 'br' )\u000a								this._.nextNode = currentNode;\u000a						}\u000a\u000a						closeRange = 1;\u000a					} else {\u000a						// If we have child nodes, let's check them.\u000a						if ( currentNode.getFirst() ) {\u000a							// If we don't have a range yet, let's start it.\u000a							if ( !range ) {\u000a								range = this.range.clone();\u000a								range.setStartAt( currentNode, CKEDITOR.POSITION_BEFORE_START );\u000a							}\u000a\u000a							currentNode = currentNode.getFirst();\u000a							continue;\u000a						}\u000a						includeNode = 1;\u000a					}\u000a				} else if ( currentNode.type == CKEDITOR.NODE_TEXT ) {\u000a					// Ignore normal whitespaces (i.e. not including &nbsp; or\u000a					// other unicode whitespaces) before/after a block node.\u000a					if ( beginWhitespaceRegex.test( currentNode.getText() ) )\u000a						includeNode = 0;\u000a				}\u000a\u000a				// The current node is good to be part of the range and we are\u000a				// starting a new range, initialize it first.\u000a				if ( includeNode && !range ) {\u000a					range = this.range.clone();\u000a					range.setStartAt( currentNode, CKEDITOR.POSITION_BEFORE_START );\u000a				}\u000a\u000a				// The last node has been found.\u000a				isLast = ( ( !closeRange || includeNode ) && currentNode.equals( lastNode ) );\u000a\u000a				// If we are in an element boundary, let's check if it is time\u000a				// to close the range, otherwise we include the parent within it.\u000a				if ( range && !closeRange ) {\u000a					while ( !currentNode.getNext( skipGuard ) && !isLast ) {\u000a						var parentNode = currentNode.getParent();\u000a\u000a						if ( parentNode.isBlockBoundary( this.forceBrBreak && !parentPre && { br: 1 } ) ) {\u000a							closeRange = 1;\u000a							includeNode = 0;\u000a							isLast = isLast || ( parentNode.equals( lastNode ) );\u000a							// Make sure range includes bookmarks at the end of the block. (#7359)\u000a							range.setEndAt( parentNode, CKEDITOR.POSITION_BEFORE_END );\u000a							break;\u000a						}\u000a\u000a						currentNode = parentNode;\u000a						includeNode = 1;\u000a						isLast = ( currentNode.equals( lastNode ) );\u000a						continueFromSibling = 1;\u000a					}\u000a				}\u000a\u000a				// Now finally include the node.\u000a				if ( includeNode )\u000a					range.setEndAt( currentNode, CKEDITOR.POSITION_AFTER_END );\u000a\u000a				currentNode = getNextSourceNode( currentNode, continueFromSibling, lastNode );\u000a				isLast = !currentNode;\u000a\u000a				// We have found a block boundary. Let's close the range and move out of the\u000a				// loop.\u000a				if ( isLast || ( closeRange && range ) )\u000a					break;\u000a			}\u000a\u000a			// Now, based on the processed range, look for (or create) the block to be returned.\u000a			if ( !block ) {\u000a				// If no range has been found, this is the end.\u000a				if ( !range ) {\u000a					this._.docEndMarker && this._.docEndMarker.remove();\u000a					this._.nextNode = null;\u000a					return null;\u000a				}\u000a\u000a				var startPath = new CKEDITOR.dom.elementPath( range.startContainer, range.root );\u000a				var startBlockLimit = startPath.blockLimit,\u000a					checkLimits = { div: 1, th: 1, td: 1 };\u000a				block = startPath.block;\u000a\u000a				if ( !block && startBlockLimit && !this.enforceRealBlocks && checkLimits[ startBlockLimit.getName() ] &&\u000a					range.checkStartOfBlock() && range.checkEndOfBlock() && !startBlockLimit.equals( range.root ) ) {\u000a					block = startBlockLimit;\u000a				} else if ( !block || ( this.enforceRealBlocks && block.is( listItemNames ) ) ) {\u000a					// Create the fixed block.\u000a					block = this.range.document.createElement( blockTag );\u000a\u000a					// Move the contents of the temporary range to the fixed block.\u000a					range.extractContents().appendTo( block );\u000a					block.trim();\u000a\u000a					// Insert the fixed block into the DOM.\u000a					range.insertNode( block );\u000a\u000a					removePreviousBr = removeLastBr = true;\u000a				} else if ( block.getName() != 'li' ) {\u000a					// If the range doesn't includes the entire contents of the\u000a					// block, we must split it, isolating the range in a dedicated\u000a					// block.\u000a					if ( !range.checkStartOfBlock() || !range.checkEndOfBlock() ) {\u000a						// The resulting block will be a clone of the current one.\u000a						block = block.clone( false );\u000a\u000a						// Extract the range contents, moving it to the new block.\u000a						range.extractContents().appendTo( block );\u000a						block.trim();\u000a\u000a						// Split the block. At this point, the range will be in the\u000a						// right position for our intents.\u000a						var splitInfo = range.splitBlock();\u000a\u000a						removePreviousBr = !splitInfo.wasStartOfBlock;\u000a						removeLastBr = !splitInfo.wasEndOfBlock;\u000a\u000a						// Insert the new block into the DOM.\u000a						range.insertNode( block );\u000a					}\u000a				} else if ( !isLast ) {\u000a					// LIs are returned as is, with all their children (due to the\u000a					// nested lists). But, the next node is the node right after\u000a					// the current range, which could be an <li> child (nested\u000a					// lists) or the next sibling <li>.\u000a\u000a					this._.nextNode = ( block.equals( lastNode ) ? null : getNextSourceNode( range.getBoundaryNodes().endNode, 1, lastNode ) );\u000a				}\u000a			}\u000a\u000a			if ( removePreviousBr ) {\u000a				var previousSibling = block.getPrevious();\u000a				if ( previousSibling && previousSibling.type == CKEDITOR.NODE_ELEMENT ) {\u000a					if ( previousSibling.getName() == 'br' )\u000a						previousSibling.remove();\u000a					else if ( previousSibling.getLast() && previousSibling.getLast().$.nodeName.toLowerCase() == 'br' )\u000a						previousSibling.getLast().remove();\u000a				}\u000a			}\u000a\u000a			if ( removeLastBr ) {\u000a				var lastChild = block.getLast();\u000a				if ( lastChild && lastChild.type == CKEDITOR.NODE_ELEMENT && lastChild.getName() == 'br' ) {\u000a					// Remove br filler on browser which do not need it.\u000a					if ( !CKEDITOR.env.needsBrFiller || lastChild.getPrevious( bookmarkGuard ) || lastChild.getNext( bookmarkGuard ) )\u000a						lastChild.remove();\u000a				}\u000a			}\u000a\u000a			// Get a reference for the next element. This is important because the\u000a			// above block can be removed or changed, so we can rely on it for the\u000a			// next interation.\u000a			if ( !this._.nextNode )\u000a				this._.nextNode = ( isLast || block.equals( lastNode ) || !lastNode ) ? null : getNextSourceNode( block, 1, lastNode );\u000a\u000a			return block;\u000a		}\u000a	};\u000a\u000a	// @context CKEDITOR.dom.iterator\u000a	// @returns Collapsed range which will be reused when during furter processing.\u000a	function startIterator() {\u000a		var range = this.range.clone(),\u000a			// Indicate at least one of the range boundaries is inside a preformat block.\u000a			touchPre,\u000a\u000a			// (#12178)\u000a			// Remember if following situation takes place:\u000a			// * startAtInnerBoundary: <p>foo[</p>...\u000a			// * endAtInnerBoundary: ...<p>]bar</p>\u000a			// Because information about line break will be lost when shrinking range.\u000a			// Note that we test only if path block exist, because we must properly shrink\u000a			// range containing table and/or table cells.\u000a			// Note: When range is collapsed there's no way it can be shrinked.\u000a			// By checking if range is collapsed we also prevent #12308.\u000a			startPath = range.startPath(),\u000a			endPath = range.endPath(),\u000a			startAtInnerBoundary = !range.collapsed && rangeAtInnerBlockBoundary( range, startPath.block ),\u000a			endAtInnerBoundary = !range.collapsed && rangeAtInnerBlockBoundary( range, endPath.block, 1 );\u000a\u000a		// Shrink the range to exclude harmful "noises" (#4087, #4450, #5435).\u000a		range.shrink( CKEDITOR.SHRINK_ELEMENT, true );\u000a\u000a		if ( startAtInnerBoundary )\u000a			range.setStartAt( startPath.block, CKEDITOR.POSITION_BEFORE_END );\u000a		if ( endAtInnerBoundary )\u000a			range.setEndAt( endPath.block, CKEDITOR.POSITION_AFTER_START );\u000a\u000a		touchPre = range.endContainer.hasAscendant( 'pre', true ) || range.startContainer.hasAscendant( 'pre', true );\u000a\u000a		range.enlarge( this.forceBrBreak && !touchPre || !this.enlargeBr ? CKEDITOR.ENLARGE_LIST_ITEM_CONTENTS : CKEDITOR.ENLARGE_BLOCK_CONTENTS );\u000a\u000a		if ( !range.collapsed ) {\u000a			var walker = new CKEDITOR.dom.walker( range.clone() ),\u000a				ignoreBookmarkTextEvaluator = CKEDITOR.dom.walker.bookmark( true, true );\u000a			// Avoid anchor inside bookmark inner text.\u000a			walker.evaluator = ignoreBookmarkTextEvaluator;\u000a			this._.nextNode = walker.next();\u000a			// TODO: It's better to have walker.reset() used here.\u000a			walker = new CKEDITOR.dom.walker( range.clone() );\u000a			walker.evaluator = ignoreBookmarkTextEvaluator;\u000a			var lastNode = walker.previous();\u000a			this._.lastNode = lastNode.getNextSourceNode( true );\u000a\u000a			// We may have an empty text node at the end of block due to [3770].\u000a			// If that node is the lastNode, it would cause our logic to leak to the\u000a			// next block.(#3887)\u000a			if ( this._.lastNode && this._.lastNode.type == CKEDITOR.NODE_TEXT && !CKEDITOR.tools.trim( this._.lastNode.getText() ) && this._.lastNode.getParent().isBlockBoundary() ) {\u000a				var testRange = this.range.clone();\u000a				testRange.moveToPosition( this._.lastNode, CKEDITOR.POSITION_AFTER_END );\u000a				if ( testRange.checkEndOfBlock() ) {\u000a					var path = new CKEDITOR.dom.elementPath( testRange.endContainer, testRange.root ),\u000a						lastBlock = path.block || path.blockLimit;\u000a					this._.lastNode = lastBlock.getNextSourceNode( true );\u000a				}\u000a			}\u000a\u000a			// The end of document or range.root was reached, so we need a marker node inside.\u000a			if ( !this._.lastNode || !range.root.contains( this._.lastNode ) ) {\u000a				this._.lastNode = this._.docEndMarker = range.document.createText( '' );\u000a				this._.lastNode.insertAfter( lastNode );\u000a			}\u000a\u000a			// Let's reuse this variable.\u000a			range = null;\u000a		}\u000a\u000a		this._.started = 1;\u000a\u000a		return range;\u000a	}\u000a\u000a	// Does a nested editables lookup inside editablesContainer.\u000a	// If remainingEditables is set will lookup inside this array.\u000a	// @param {CKEDITOR.dom.element} editablesContainer\u000a	// @param {CKEDITOR.dom.element[]} [remainingEditables]\u000a	function getNestedEditableIn( editablesContainer, remainingEditables ) {\u000a		if ( remainingEditables == null )\u000a			remainingEditables = findNestedEditables( editablesContainer );\u000a\u000a		var editable;\u000a\u000a		while ( ( editable = remainingEditables.shift() ) ) {\u000a			if ( isIterableEditable( editable ) )\u000a				return { element: editable, remaining: remainingEditables };\u000a		}\u000a\u000a		return null;\u000a	}\u000a\u000a	// Checkes whether we can iterate over this editable.\u000a	function isIterableEditable( editable ) {\u000a		// Reject blockless editables.\u000a		return editable.getDtd().p;\u000a	}\u000a\u000a	// Finds nested editables within container. Does not return\u000a	// editables nested in another editable (twice).\u000a	function findNestedEditables( container ) {\u000a		var editables = [];\u000a\u000a		container.forEach( function( element ) {\u000a			if ( element.getAttribute( 'contenteditable' ) == 'true' ) {\u000a				editables.push( element );\u000a				return false; // Skip children.\u000a			}\u000a		}, CKEDITOR.NODE_ELEMENT, true );\u000a\u000a		return editables;\u000a	}\u000a\u000a	// Looks for a first nested editable after previousEditable (if passed) and creates\u000a	// nested iterator for it.\u000a	function startNestedEditableIterator( parentIterator, blockTag, editablesContainer, remainingEditables ) {\u000a		var editable = getNestedEditableIn( editablesContainer, remainingEditables );\u000a\u000a		if ( !editable )\u000a			return 0;\u000a\u000a		var filter = CKEDITOR.filter.instances[ editable.element.data( 'cke-filter' ) ];\u000a\u000a		// If current editable has a filter and this filter does not allow for block tag,\u000a		// search for next nested editable in remaining ones.\u000a		if ( filter && !filter.check( blockTag ) )\u000a			return startNestedEditableIterator( parentIterator, blockTag, editablesContainer, editable.remaining );\u000a\u000a		var range = new CKEDITOR.dom.range( editable.element );\u000a		range.selectNodeContents( editable.element );\u000a\u000a		var iterator = range.createIterator();\u000a		// This setting actually does not change anything in this case,\u000a		// because entire range contents is selected, so there're no <br>s to be included.\u000a		// But it seems right to copy it too.\u000a		iterator.enlargeBr = parentIterator.enlargeBr;\u000a		// Inherit configuration from parent iterator.\u000a		iterator.enforceRealBlocks = parentIterator.enforceRealBlocks;\u000a		// Set the activeFilter (which can be overriden when this iteator will start nested iterator)\u000a		// and the default filter, which will make it possible to reset to\u000a		// current iterator's activeFilter after leaving nested editable.\u000a		iterator.activeFilter = iterator.filter = filter;\u000a\u000a		parentIterator._.nestedEditable = {\u000a			element: editable.element,\u000a			container: editablesContainer,\u000a			remaining: editable.remaining,\u000a			iterator: iterator\u000a		};\u000a\u000a		return 1;\u000a	}\u000a\u000a	// Checks whether range starts or ends at inner block boundary.\u000a	// See usage comments to learn more.\u000a	function rangeAtInnerBlockBoundary( range, block, checkEnd ) {\u000a		if ( !block )\u000a			return false;\u000a\u000a		var testRange = range.clone();\u000a		testRange.collapse( !checkEnd );\u000a		return testRange.checkBoundaryOfElement( block, checkEnd ? CKEDITOR.START : CKEDITOR.END );\u000a	}\u000a\u000a	/**\u000a	 * Creates {CKEDITOR.dom.iterator} instance for this range.\u000a	 *\u000a	 * @member CKEDITOR.dom.range\u000a	 * @returns {CKEDITOR.dom.iterator}\u000a	 */\u000a	CKEDITOR.dom.range.prototype.createIterator = function() {\u000a		return new iterator( this );\u000a	};\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * Provides an "event like" system to parse strings of HTML data.\u000a *\u000a *		var parser = new CKEDITOR.htmlParser();\u000a *		parser.onTagOpen = function( tagName, attributes, selfClosing ) {\u000a *			alert( tagName );\u000a *		};\u000a *		parser.parse( '<p>Some <b>text</b>.</p>' ); // Alerts 'p', 'b'.\u000a *\u000a * @class\u000a * @constructor Creates a htmlParser class instance.\u000a */\u000aCKEDITOR.htmlParser = function() {\u000a	this._ = {\u000a		htmlPartsRegex: new RegExp( '<(?:(?:\u005c\u005c/([^>]+)>)|(?:!--([\u005c\u005cS|\u005c\u005cs]*?)-->)|(?:([^\u005c\u005cs>]+)\u005c\u005cs*((?:(?:"[^"]*")|(?:\u005c'[^\u005c']*\u005c')|[^"\u005c'>])*)\u005c\u005c/?>))', 'g' )\u000a	};\u000a};\u000a\u000a( function() {\u000a	var attribsRegex = /([\u005cw\u005c-:.]+)(?:(?:\u005cs*=\u005cs*(?:(?:"([^"]*)")|(?:'([^']*)')|([^\u005cs>]+)))|(?=\u005cs|$))/g,\u000a		emptyAttribs = { checked: 1, compact: 1, declare: 1, defer: 1, disabled: 1, ismap: 1, multiple: 1, nohref: 1, noresize: 1, noshade: 1, nowrap: 1, readonly: 1, selected: 1 };\u000a\u000a	CKEDITOR.htmlParser.prototype = {\u000a		/**\u000a		 * Function to be fired when a tag opener is found. This function\u000a		 * should be overriden when using this class.\u000a		 *\u000a		 *		var parser = new CKEDITOR.htmlParser();\u000a		 *		parser.onTagOpen = function( tagName, attributes, selfClosing ) {\u000a		 *			alert( tagName ); // e.g. 'b'\u000a		 *		} );\u000a		 *		parser.parse( '<!-- Example --><b>Hello</b>' );\u000a		 *\u000a		 * @param {String} tagName The tag name. The name is guarantted to be lowercased.\u000a		 * @param {Object} attributes An object containing all tag attributes. Each\u000a		 * property in this object represent and attribute name and its value is the attribute value.\u000a		 * @param {Boolean} selfClosing `true` if the tag closes itself, false if the tag doesn't.\u000a		 */\u000a		onTagOpen: function() {},\u000a\u000a		/**\u000a		 * Function to be fired when a tag closer is found. This function\u000a		 * should be overriden when using this class.\u000a		 *\u000a		 *		var parser = new CKEDITOR.htmlParser();\u000a		 *		parser.onTagClose = function( tagName ) {\u000a		 *			alert( tagName ); // 'b'\u000a		 *		} );\u000a		 *		parser.parse( '<!-- Example --><b>Hello</b>' );\u000a		 *\u000a		 * @param {String} tagName The tag name. The name is guarantted to be lowercased.\u000a		 */\u000a		onTagClose: function() {},\u000a\u000a		/**\u000a		 * Function to be fired when text is found. This function\u000a		 * should be overriden when using this class.\u000a		 *\u000a		 *		var parser = new CKEDITOR.htmlParser();\u000a		 *		parser.onText = function( text ) {\u000a		 *			alert( text ); // 'Hello'\u000a		 *		} );\u000a		 *		parser.parse( '<!-- Example --><b>Hello</b>' );\u000a		 *\u000a		 * @param {String} text The text found.\u000a		 */\u000a		onText: function() {},\u000a\u000a		/**\u000a		 * Function to be fired when CDATA section is found. This function\u000a		 * should be overriden when using this class.\u000a		 *\u000a		 *		var parser = new CKEDITOR.htmlParser();\u000a		 *		parser.onCDATA = function( cdata ) {\u000a		 *			alert( cdata ); // 'var hello;'\u000a		 *		} );\u000a		 *		parser.parse( '<script>var hello;</script>' );\u000a		 *\u000a		 * @param {String} cdata The CDATA been found.\u000a		 */\u000a		onCDATA: function() {},\u000a\u000a		/**\u000a		 * Function to be fired when a commend is found. This function\u000a		 * should be overriden when using this class.\u000a		 *\u000a		 *		var parser = new CKEDITOR.htmlParser();\u000a		 *		parser.onComment = function( comment ) {\u000a		 *			alert( comment ); // ' Example '\u000a		 *		} );\u000a		 *		parser.parse( '<!-- Example --><b>Hello</b>' );\u000a		 *\u000a		 * @param {String} comment The comment text.\u000a		 */\u000a		onComment: function() {},\u000a\u000a		/**\u000a		 * Parses text, looking for HTML tokens, like tag openers or closers,\u000a		 * or comments. This function fires the onTagOpen, onTagClose, onText\u000a		 * and onComment function during its execution.\u000a		 *\u000a		 *		var parser = new CKEDITOR.htmlParser();\u000a		 *		// The onTagOpen, onTagClose, onText and onComment should be overriden\u000a		 *		// at this point.\u000a		 *		parser.parse( '<!-- Example --><b>Hello</b>' );\u000a		 *\u000a		 * @param {String} html The HTML to be parsed.\u000a		 */\u000a		parse: function( html ) {\u000a			var parts, tagName,\u000a				nextIndex = 0,\u000a				cdata; // The collected data inside a CDATA section.\u000a\u000a			while ( ( parts = this._.htmlPartsRegex.exec( html ) ) ) {\u000a				var tagIndex = parts.index;\u000a				if ( tagIndex > nextIndex ) {\u000a					var text = html.substring( nextIndex, tagIndex );\u000a\u000a					if ( cdata )\u000a						cdata.push( text );\u000a					else\u000a						this.onText( text );\u000a				}\u000a\u000a				nextIndex = this._.htmlPartsRegex.lastIndex;\u000a\u000a				// "parts" is an array with the following items:\u000a				//		0 : The entire match for opening/closing tags and comments.\u000a				//		  : Group filled with the tag name for closing tags.\u000a				//		2 : Group filled with the comment text.\u000a				//		3 : Group filled with the tag name for opening tags.\u000a				//		4 : Group filled with the attributes part of opening tags.\u000a\u000a				// Closing tag\u000a				if ( ( tagName = parts[ 1 ] ) ) {\u000a					tagName = tagName.toLowerCase();\u000a\u000a					if ( cdata && CKEDITOR.dtd.$cdata[ tagName ] ) {\u000a						// Send the CDATA data.\u000a						this.onCDATA( cdata.join( '' ) );\u000a						cdata = null;\u000a					}\u000a\u000a					if ( !cdata ) {\u000a						this.onTagClose( tagName );\u000a						continue;\u000a					}\u000a				}\u000a\u000a				// If CDATA is enabled, just save the raw match.\u000a				if ( cdata ) {\u000a					cdata.push( parts[ 0 ] );\u000a					continue;\u000a				}\u000a\u000a				// Opening tag\u000a				if ( ( tagName = parts[ 3 ] ) ) {\u000a					tagName = tagName.toLowerCase();\u000a\u000a					// There are some tag names that can break things, so let's\u000a					// simply ignore them when parsing. (#5224)\u000a					if ( /="/.test( tagName ) )\u000a						continue;\u000a\u000a					var attribs = {},\u000a						attribMatch,\u000a						attribsPart = parts[ 4 ],\u000a						selfClosing = !!( attribsPart && attribsPart.charAt( attribsPart.length - 1 ) == '/' );\u000a\u000a					if ( attribsPart ) {\u000a						while ( ( attribMatch = attribsRegex.exec( attribsPart ) ) ) {\u000a							var attName = attribMatch[ 1 ].toLowerCase(),\u000a								attValue = attribMatch[ 2 ] || attribMatch[ 3 ] || attribMatch[ 4 ] || '';\u000a\u000a							if ( !attValue && emptyAttribs[ attName ] )\u000a								attribs[ attName ] = attName;\u000a							else\u000a								attribs[ attName ] = CKEDITOR.tools.htmlDecodeAttr( attValue );\u000a						}\u000a					}\u000a\u000a					this.onTagOpen( tagName, attribs, selfClosing );\u000a\u000a					// Open CDATA mode when finding the appropriate tags.\u000a					if ( !cdata && CKEDITOR.dtd.$cdata[ tagName ] )\u000a						cdata = [];\u000a\u000a					continue;\u000a				}\u000a\u000a				// Comment\u000a				if ( ( tagName = parts[ 2 ] ) )\u000a					this.onComment( tagName );\u000a			}\u000a\u000a			if ( html.length > nextIndex )\u000a				this.onText( html.substring( nextIndex, html.length ) );\u000a		}\u000a	};\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * TODO\u000a *\u000a * @class\u000a * @todo\u000a */\u000aCKEDITOR.htmlParser.basicWriter = CKEDITOR.tools.createClass( {\u000a	/**\u000a	 * Creates a basicWriter class instance.\u000a	 *\u000a	 * @constructor\u000a	 */\u000a	$: function() {\u000a		this._ = {\u000a			output: []\u000a		};\u000a	},\u000a\u000a	proto: {\u000a		/**\u000a		 * Writes the tag opening part for a opener tag.\u000a		 *\u000a		 *		// Writes '<p'.\u000a		 *		writer.openTag( 'p', { class : 'MyClass', id : 'MyId' } );\u000a		 *\u000a		 * @param {String} tagName The element name for this tag.\u000a		 * @param {Object} attributes The attributes defined for this tag. The\u000a		 * attributes could be used to inspect the tag.\u000a		 */\u000a		openTag: function( tagName ) {\u000a			this._.output.push( '<', tagName );\u000a		},\u000a\u000a		/**\u000a		 * Writes the tag closing part for a opener tag.\u000a		 *\u000a		 *		// Writes '>'.\u000a		 *		writer.openTagClose( 'p', false );\u000a		 *\u000a		 *		// Writes ' />'.\u000a		 *		writer.openTagClose( 'br', true );\u000a		 *\u000a		 * @param {String} tagName The element name for this tag.\u000a		 * @param {Boolean} isSelfClose Indicates that this is a self-closing tag,\u000a		 * like `<br>` or `<img>`.\u000a		 */\u000a		openTagClose: function( tagName, isSelfClose ) {\u000a			if ( isSelfClose )\u000a				this._.output.push( ' />' );\u000a			else\u000a				this._.output.push( '>' );\u000a		},\u000a\u000a		/**\u000a		 * Writes an attribute. This function should be called after opening the\u000a		 * tag with {@link #openTagClose}.\u000a		 *\u000a		 *		// Writes ' class="MyClass"'.\u000a		 *		writer.attribute( 'class', 'MyClass' );\u000a		 *\u000a		 * @param {String} attName The attribute name.\u000a		 * @param {String} attValue The attribute value.\u000a		 */\u000a		attribute: function( attName, attValue ) {\u000a			// Browsers don't always escape special character in attribute values. (#4683, #4719).\u000a			if ( typeof attValue == 'string' )\u000a				attValue = CKEDITOR.tools.htmlEncodeAttr( attValue );\u000a\u000a			this._.output.push( ' ', attName, '="', attValue, '"' );\u000a		},\u000a\u000a		/**\u000a		 * Writes a closer tag.\u000a		 *\u000a		 *		// Writes '</p>'.\u000a		 *		writer.closeTag( 'p' );\u000a		 *\u000a		 * @param {String} tagName The element name for this tag.\u000a		 */\u000a		closeTag: function( tagName ) {\u000a			this._.output.push( '</', tagName, '>' );\u000a		},\u000a\u000a		/**\u000a		 * Writes text.\u000a		 *\u000a		 *		// Writes 'Hello Word'.\u000a		 *		writer.text( 'Hello Word' );\u000a		 *\u000a		 * @param {String} text The text value.\u000a		 */\u000a		text: function( text ) {\u000a			this._.output.push( text );\u000a		},\u000a\u000a		/**\u000a		 * Writes a comment.\u000a		 *\u000a		 *		// Writes '<!-- My comment -->'.\u000a		 *		writer.comment( ' My comment ' );\u000a		 *\u000a		 * @param {String} comment The comment text.\u000a		 */\u000a		comment: function( comment ) {\u000a			this._.output.push( '<!--', comment, '-->' );\u000a		},\u000a\u000a		/**\u000a		 * Writes any kind of data to the ouput.\u000a		 *\u000a		 *		writer.write( 'This is an <b>example</b>.' );\u000a		 *\u000a		 * @param {String} data\u000a		 */\u000a		write: function( data ) {\u000a			this._.output.push( data );\u000a		},\u000a\u000a		/**\u000a		 * Empties the current output buffer.\u000a		 *\u000a		 *		writer.reset();\u000a		 */\u000a		reset: function() {\u000a			this._.output = [];\u000a			this._.indent = false;\u000a		},\u000a\u000a		/**\u000a		 * Empties the current output buffer.\u000a		 *\u000a		 *		var html = writer.getHtml();\u000a		 *\u000a		 * @param {Boolean} reset Indicates that the {@link #reset} method is to\u000a		 * be automatically called after retrieving the HTML.\u000a		 * @returns {String} The HTML written to the writer so far.\u000a		 */\u000a		getHtml: function( reset ) {\u000a			var html = this._.output.join( '' );\u000a\u000a			if ( reset )\u000a				this.reset();\u000a\u000a			return html;\u000a		}\u000a	}\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a'use strict';\u000a\u000a( function() {\u000a	/**\u000a	 * A lightweight representation of HTML node.\u000a	 *\u000a	 * @since 4.1\u000a	 * @class\u000a	 * @constructor Creates a node class instance.\u000a	 */\u000a	CKEDITOR.htmlParser.node = function() {};\u000a\u000a	CKEDITOR.htmlParser.node.prototype = {\u000a		/**\u000a		 * Remove this node from a tree.\u000a		 *\u000a		 * @since 4.1\u000a		 */\u000a		remove: function() {\u000a			var children = this.parent.children,\u000a				index = CKEDITOR.tools.indexOf( children, this ),\u000a				previous = this.previous,\u000a				next = this.next;\u000a\u000a			previous && ( previous.next = next );\u000a			next && ( next.previous = previous );\u000a			children.splice( index, 1 );\u000a			this.parent = null;\u000a		},\u000a\u000a		/**\u000a		 * Replace this node with given one.\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {CKEDITOR.htmlParser.node} node The node that will replace this one.\u000a		 */\u000a		replaceWith: function( node ) {\u000a			var children = this.parent.children,\u000a				index = CKEDITOR.tools.indexOf( children, this ),\u000a				previous = node.previous = this.previous,\u000a				next = node.next = this.next;\u000a\u000a			previous && ( previous.next = node );\u000a			next && ( next.previous = node );\u000a\u000a			children[ index ] = node;\u000a\u000a			node.parent = this.parent;\u000a			this.parent = null;\u000a		},\u000a\u000a		/**\u000a		 * Insert this node after given one.\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {CKEDITOR.htmlParser.node} node The node that will precede this element.\u000a		 */\u000a		insertAfter: function( node ) {\u000a			var children = node.parent.children,\u000a				index = CKEDITOR.tools.indexOf( children, node ),\u000a				next = node.next;\u000a\u000a			children.splice( index + 1, 0, this );\u000a\u000a			this.next = node.next;\u000a			this.previous = node;\u000a			node.next = this;\u000a			next && ( next.previous = this );\u000a\u000a			this.parent = node.parent;\u000a		},\u000a\u000a		/**\u000a		 * Insert this node before given one.\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {CKEDITOR.htmlParser.node} node The node that will follow this element.\u000a		 */\u000a		insertBefore: function( node ) {\u000a			var children = node.parent.children,\u000a				index = CKEDITOR.tools.indexOf( children, node );\u000a\u000a			children.splice( index, 0, this );\u000a\u000a			this.next = node;\u000a			this.previous = node.previous;\u000a			node.previous && ( node.previous.next = this );\u000a			node.previous = this;\u000a\u000a			this.parent = node.parent;\u000a		},\u000a\u000a		/**\u000a		 * Gets the closest ancestor element of this element which satisfies given condition\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {String/Object/Function} condition Name of an ancestor, hash of names or validator function.\u000a		 * @returns {CKEDITOR.htmlParser.element} The closest ancestor which satisfies given condition or `null`.\u000a		 */\u000a		getAscendant: function( condition ) {\u000a			var checkFn =\u000a				typeof condition == 'function' ?\u000a					condition :\u000a				typeof condition == 'string' ?\u000a					function( el ) {\u000a						return el.name == condition;\u000a					} :\u000a					function( el ) {\u000a						return el.name in condition;\u000a					};\u000a\u000a			var parent = this.parent;\u000a\u000a			// Parent has to be an element - don't check doc fragment.\u000a			while ( parent && parent.type == CKEDITOR.NODE_ELEMENT ) {\u000a				if ( checkFn( parent ) )\u000a					return parent;\u000a				parent = parent.parent;\u000a			}\u000a\u000a			return null;\u000a		},\u000a\u000a		/**\u000a		 * Wraps this element with given `wrapper`.\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {CKEDITOR.htmlParser.element} wrapper The element which will be this element's new parent.\u000a		 * @returns {CKEDITOR.htmlParser.element} Wrapper.\u000a		 */\u000a		wrapWith: function( wrapper ) {\u000a			this.replaceWith( wrapper );\u000a			wrapper.add( this );\u000a			return wrapper;\u000a		},\u000a\u000a		/**\u000a		 * Gets this node's index in its parent's children array.\u000a		 *\u000a		 * @since 4.3\u000a		 * @returns {Number}\u000a		 */\u000a		getIndex: function() {\u000a			return CKEDITOR.tools.indexOf( this.parent.children, this );\u000a		},\u000a\u000a		getFilterContext: function( context ) {\u000a			return context || {};\u000a		}\u000a	};\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a 'use strict';\u000a\u000a/**\u000a * A lightweight representation of an HTML comment.\u000a *\u000a * @class\u000a * @extends CKEDITOR.htmlParser.node\u000a * @constructor Creates a comment class instance.\u000a * @param {String} value The comment text value.\u000a */\u000aCKEDITOR.htmlParser.comment = function( value ) {\u000a	/**\u000a	 * The comment text.\u000a	 *\u000a	 * @property {String}\u000a	 */\u000a	this.value = value;\u000a\u000a	/** @private */\u000a	this._ = {\u000a		isBlockLike: false\u000a	};\u000a};\u000a\u000aCKEDITOR.htmlParser.comment.prototype = CKEDITOR.tools.extend( new CKEDITOR.htmlParser.node(), {\u000a	/**\u000a	 * The node type. This is a constant value set to {@link CKEDITOR#NODE_COMMENT}.\u000a	 *\u000a	 * @readonly\u000a	 * @property {Number} [=CKEDITOR.NODE_COMMENT]\u000a	 */\u000a	type: CKEDITOR.NODE_COMMENT,\u000a\u000a	/**\u000a	 * Filter this comment with given filter.\u000a	 *\u000a	 * @since 4.1\u000a	 * @param {CKEDITOR.htmlParser.filter} filter\u000a	 * @returns {Boolean} Method returns `false` when this comment has\u000a	 * been removed or replaced with other node. This is an information for\u000a	 * {@link CKEDITOR.htmlParser.element#filterChildren} that it has\u000a	 * to repeat filter on current position in parent's children array.\u000a	 */\u000a	filter: function( filter, context ) {\u000a		var comment = this.value;\u000a\u000a		if ( !( comment = filter.onComment( context, comment, this ) ) ) {\u000a			this.remove();\u000a			return false;\u000a		}\u000a\u000a		if ( typeof comment != 'string' ) {\u000a			this.replaceWith( comment );\u000a			return false;\u000a		}\u000a\u000a		this.value = comment;\u000a\u000a		return true;\u000a	},\u000a\u000a	/**\u000a	 * Writes the HTML representation of this comment to a CKEDITOR.htmlWriter.\u000a	 *\u000a	 * @param {CKEDITOR.htmlParser.basicWriter} writer The writer to which write the HTML.\u000a	 * @param {CKEDITOR.htmlParser.filter} [filter] The filter to be applied to this node.\u000a	 * **Note:** it's unsafe to filter offline (not appended) node.\u000a	 */\u000a	writeHtml: function( writer, filter ) {\u000a		if ( filter )\u000a			this.filter( filter );\u000a\u000a		writer.comment( this.value );\u000a	}\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a 'use strict';\u000a\u000a( function() {\u000a	/**\u000a	 * A lightweight representation of HTML text.\u000a	 *\u000a	 * @class\u000a	 * @extends CKEDITOR.htmlParser.node\u000a	 * @constructor Creates a text class instance.\u000a	 * @param {String} value The text node value.\u000a	 */\u000a	CKEDITOR.htmlParser.text = function( value ) {\u000a		/**\u000a		 * The text value.\u000a		 *\u000a		 * @property {String}\u000a		 */\u000a		this.value = value;\u000a\u000a		/** @private */\u000a		this._ = {\u000a			isBlockLike: false\u000a		};\u000a	};\u000a\u000a	CKEDITOR.htmlParser.text.prototype = CKEDITOR.tools.extend( new CKEDITOR.htmlParser.node(), {\u000a		/**\u000a		 * The node type. This is a constant value set to {@link CKEDITOR#NODE_TEXT}.\u000a		 *\u000a		 * @readonly\u000a		 * @property {Number} [=CKEDITOR.NODE_TEXT]\u000a		 */\u000a		type: CKEDITOR.NODE_TEXT,\u000a\u000a		/**\u000a		 * Filter this text node with given filter.\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {CKEDITOR.htmlParser.filter} filter\u000a		 * @returns {Boolean} Method returns `false` when this text node has\u000a		 * been removed. This is an information for {@link CKEDITOR.htmlParser.element#filterChildren}\u000a		 * that it has to repeat filter on current position in parent's children array.\u000a		 */\u000a		filter: function( filter, context ) {\u000a			if ( !( this.value = filter.onText( context, this.value, this ) ) ) {\u000a				this.remove();\u000a				return false;\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Writes the HTML representation of this text to a {CKEDITOR.htmlParser.basicWriter}.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.basicWriter} writer The writer to which write the HTML.\u000a		 * @param {CKEDITOR.htmlParser.filter} [filter] The filter to be applied to this node.\u000a		 * **Note:** it's unsafe to filter offline (not appended) node.\u000a		 */\u000a		writeHtml: function( writer, filter ) {\u000a			if ( filter )\u000a				this.filter( filter );\u000a\u000a			writer.text( this.value );\u000a		}\u000a	} );\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a 'use strict';\u000a\u000a( function() {\u000a\u000a	/**\u000a	 * A lightweight representation of HTML CDATA.\u000a	 *\u000a	 * @class\u000a	 * @extends CKEDITOR.htmlParser.node\u000a	 * @constructor Creates a cdata class instance.\u000a	 * @param {String} value The CDATA section value.\u000a	 */\u000a	CKEDITOR.htmlParser.cdata = function( value ) {\u000a		/**\u000a		 * The CDATA value.\u000a		 *\u000a		 * @property {String}\u000a		 */\u000a		this.value = value;\u000a	};\u000a\u000a	CKEDITOR.htmlParser.cdata.prototype = CKEDITOR.tools.extend( new CKEDITOR.htmlParser.node(), {\u000a		/**\u000a		 * CDATA has the same type as {@link CKEDITOR.htmlParser.text} This is\u000a		 * a constant value set to {@link CKEDITOR#NODE_TEXT}.\u000a		 *\u000a		 * @readonly\u000a		 * @property {Number} [=CKEDITOR.NODE_TEXT]\u000a		 */\u000a		type: CKEDITOR.NODE_TEXT,\u000a\u000a		filter: function() {},\u000a\u000a		/**\u000a		 * Writes the CDATA with no special manipulations.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.basicWriter} writer The writer to which write the HTML.\u000a		 */\u000a		writeHtml: function( writer ) {\u000a			writer.write( this.value );\u000a		}\u000a	} );\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a'use strict';\u000a\u000a/**\u000a * A lightweight representation of an HTML DOM structure.\u000a *\u000a * @class\u000a * @constructor Creates a fragment class instance.\u000a */\u000aCKEDITOR.htmlParser.fragment = function() {\u000a	/**\u000a	 * The nodes contained in the root of this fragment.\u000a	 *\u000a	 *		var fragment = CKEDITOR.htmlParser.fragment.fromHtml( '<b>Sample</b> Text' );\u000a	 *		alert( fragment.children.length ); // 2\u000a	 */\u000a	this.children = [];\u000a\u000a	/**\u000a	 * Get the fragment parent. Should always be null.\u000a	 *\u000a	 * @property {Object} [=null]\u000a	 */\u000a	this.parent = null;\u000a\u000a	/** @private */\u000a	this._ = {\u000a		isBlockLike: true,\u000a		hasInlineStarted: false\u000a	};\u000a};\u000a\u000a( function() {\u000a	// Block-level elements whose internal structure should be respected during\u000a	// parser fixing.\u000a	var nonBreakingBlocks = CKEDITOR.tools.extend( { table: 1, ul: 1, ol: 1, dl: 1 }, CKEDITOR.dtd.table, CKEDITOR.dtd.ul, CKEDITOR.dtd.ol, CKEDITOR.dtd.dl );\u000a\u000a	var listBlocks = { ol: 1, ul: 1 };\u000a\u000a	// Dtd of the fragment element, basically it accept anything except for intermediate structure, e.g. orphan <li>.\u000a	var rootDtd = CKEDITOR.tools.extend( {}, { html: 1 }, CKEDITOR.dtd.html, CKEDITOR.dtd.body, CKEDITOR.dtd.head, { style: 1, script: 1 } );\u000a\u000a	// Which element to create when encountered not allowed content.\u000a	var structureFixes = {\u000a		ul: 'li',\u000a		ol: 'li',\u000a		dl: 'dd',\u000a		table: 'tbody',\u000a		tbody: 'tr',\u000a		thead: 'tr',\u000a		tfoot: 'tr',\u000a		tr: 'td'\u000a	};\u000a\u000a	function isRemoveEmpty( node ) {\u000a		// Keep marked element event if it is empty.\u000a		if ( node.attributes[ 'data-cke-survive' ] )\u000a			return false;\u000a\u000a		// Empty link is to be removed when empty but not anchor. (#7894)\u000a		return node.name == 'a' && node.attributes.href || CKEDITOR.dtd.$removeEmpty[ node.name ];\u000a	}\u000a\u000a	/**\u000a	 * Creates a {@link CKEDITOR.htmlParser.fragment} from an HTML string.\u000a	 *\u000a	 *		var fragment = CKEDITOR.htmlParser.fragment.fromHtml( '<b>Sample</b> Text' );\u000a	 *		alert( fragment.children[ 0 ].name );		// 'b'\u000a	 *		alert( fragment.children[ 1 ].value );	// ' Text'\u000a	 *\u000a	 * @static\u000a	 * @param {String} fragmentHtml The HTML to be parsed, filling the fragment.\u000a	 * @param {CKEDITOR.htmlParser.element/String} [parent] Optional contextual\u000a	 * element which makes the content been parsed as the content of this element and fix\u000a	 * to match it.\u000a	 * If not provided, then {@link CKEDITOR.htmlParser.fragment} will be used\u000a	 * as the parent and it will be returned.\u000a	 * @param {String/Boolean} [fixingBlock] When `parent` is a block limit element,\u000a	 * and the param is a string value other than `false`, it is to\u000a	 * avoid having block-less content as the direct children of parent by wrapping\u000a	 * the content with a block element of the specified tag, e.g.\u000a	 * when `fixingBlock` specified as `p`, the content `<body><i>foo</i></body>`\u000a	 * will be fixed into `<body><p><i>foo</i></p></body>`.\u000a	 * @returns {CKEDITOR.htmlParser.fragment/CKEDITOR.htmlParser.element} The created fragment or passed `parent`.\u000a	 */\u000a	CKEDITOR.htmlParser.fragment.fromHtml = function( fragmentHtml, parent, fixingBlock ) {\u000a		var parser = new CKEDITOR.htmlParser();\u000a\u000a		var root = parent instanceof CKEDITOR.htmlParser.element ? parent : typeof parent == 'string' ? new CKEDITOR.htmlParser.element( parent ) : new CKEDITOR.htmlParser.fragment();\u000a\u000a		var pendingInline = [],\u000a			pendingBRs = [],\u000a			currentNode = root,\u000a			// Indicate we're inside a <textarea> element, spaces should be touched differently.\u000a			inTextarea = root.name == 'textarea',\u000a			// Indicate we're inside a <pre> element, spaces should be touched differently.\u000a			inPre = root.name == 'pre';\u000a\u000a		function checkPending( newTagName ) {\u000a			var pendingBRsSent;\u000a\u000a			if ( pendingInline.length > 0 ) {\u000a				for ( var i = 0; i < pendingInline.length; i++ ) {\u000a					var pendingElement = pendingInline[ i ],\u000a						pendingName = pendingElement.name,\u000a						pendingDtd = CKEDITOR.dtd[ pendingName ],\u000a						currentDtd = currentNode.name && CKEDITOR.dtd[ currentNode.name ];\u000a\u000a					if ( ( !currentDtd || currentDtd[ pendingName ] ) && ( !newTagName || !pendingDtd || pendingDtd[ newTagName ] || !CKEDITOR.dtd[ newTagName ] ) ) {\u000a						if ( !pendingBRsSent ) {\u000a							sendPendingBRs();\u000a							pendingBRsSent = 1;\u000a						}\u000a\u000a						// Get a clone for the pending element.\u000a						pendingElement = pendingElement.clone();\u000a\u000a						// Add it to the current node and make it the current,\u000a						// so the new element will be added inside of it.\u000a						pendingElement.parent = currentNode;\u000a						currentNode = pendingElement;\u000a\u000a						// Remove the pending element (back the index by one\u000a						// to properly process the next entry).\u000a						pendingInline.splice( i, 1 );\u000a						i--;\u000a					} else {\u000a						// Some element of the same type cannot be nested, flat them,\u000a						// e.g. <a href="#">foo<a href="#">bar</a></a>. (#7894)\u000a						if ( pendingName == currentNode.name )\u000a							addElement( currentNode, currentNode.parent, 1 ), i--;\u000a					}\u000a				}\u000a			}\u000a		}\u000a\u000a		function sendPendingBRs() {\u000a			while ( pendingBRs.length )\u000a				addElement( pendingBRs.shift(), currentNode );\u000a		}\u000a\u000a		// Rtrim empty spaces on block end boundary. (#3585)\u000a		function removeTailWhitespace( element ) {\u000a			if ( element._.isBlockLike && element.name != 'pre' && element.name != 'textarea' ) {\u000a\u000a				var length = element.children.length,\u000a					lastChild = element.children[ length - 1 ],\u000a					text;\u000a				if ( lastChild && lastChild.type == CKEDITOR.NODE_TEXT ) {\u000a					if ( !( text = CKEDITOR.tools.rtrim( lastChild.value ) ) )\u000a						element.children.length = length - 1;\u000a					else\u000a						lastChild.value = text;\u000a				}\u000a			}\u000a		}\u000a\u000a		// Beside of simply append specified element to target, this function also takes\u000a		// care of other dirty lifts like forcing block in body, trimming spaces at\u000a		// the block boundaries etc.\u000a		//\u000a		// @param {Element} element  The element to be added as the last child of {@link target}.\u000a		// @param {Element} target The parent element to relieve the new node.\u000a		// @param {Boolean} [moveCurrent=false] Don't change the "currentNode" global unless\u000a		// there's a return point node specified on the element, otherwise move current onto {@link target} node.\u000a		//\u000a		function addElement( element, target, moveCurrent ) {\u000a			target = target || currentNode || root;\u000a\u000a			// Current element might be mangled by fix body below,\u000a			// save it for restore later.\u000a			var savedCurrent = currentNode;\u000a\u000a			// Ignore any element that has already been added.\u000a			if ( element.previous === undefined ) {\u000a				if ( checkAutoParagraphing( target, element ) ) {\u000a					// Create a <p> in the fragment.\u000a					currentNode = target;\u000a					parser.onTagOpen( fixingBlock, {} );\u000a\u000a					// The new target now is the <p>.\u000a					element.returnPoint = target = currentNode;\u000a				}\u000a\u000a				removeTailWhitespace( element );\u000a\u000a				// Avoid adding empty inline.\u000a				if ( !( isRemoveEmpty( element ) && !element.children.length ) )\u000a					target.add( element );\u000a\u000a				if ( element.name == 'pre' )\u000a					inPre = false;\u000a\u000a				if ( element.name == 'textarea' )\u000a					inTextarea = false;\u000a			}\u000a\u000a			if ( element.returnPoint ) {\u000a				currentNode = element.returnPoint;\u000a				delete element.returnPoint;\u000a			} else {\u000a				currentNode = moveCurrent ? target : savedCurrent;\u000a			}\u000a		}\u000a\u000a		// Auto paragraphing should happen when inline content enters the root element.\u000a		function checkAutoParagraphing( parent, node ) {\u000a\u000a			// Check for parent that can contain block.\u000a			if ( ( parent == root || parent.name == 'body' ) && fixingBlock &&\u000a					( !parent.name || CKEDITOR.dtd[ parent.name ][ fixingBlock ] ) ) {\u000a				var name, realName;\u000a\u000a				if ( node.attributes && ( realName = node.attributes[ 'data-cke-real-element-type' ] ) )\u000a					name = realName;\u000a				else\u000a					name = node.name;\u000a\u000a				// Text node, inline elements are subjected, except for <script>/<style>.\u000a				return name && name in CKEDITOR.dtd.$inline &&\u000a					!( name in CKEDITOR.dtd.head ) &&\u000a					!node.isOrphan ||\u000a					node.type == CKEDITOR.NODE_TEXT;\u000a			}\u000a		}\u000a\u000a		// Judge whether two element tag names are likely the siblings from the same\u000a		// structural element.\u000a		function possiblySibling( tag1, tag2 ) {\u000a\u000a			if ( tag1 in CKEDITOR.dtd.$listItem || tag1 in CKEDITOR.dtd.$tableContent )\u000a				return tag1 == tag2 || tag1 == 'dt' && tag2 == 'dd' || tag1 == 'dd' && tag2 == 'dt';\u000a\u000a			return false;\u000a		}\u000a\u000a		parser.onTagOpen = function( tagName, attributes, selfClosing, optionalClose ) {\u000a			var element = new CKEDITOR.htmlParser.element( tagName, attributes );\u000a\u000a			// "isEmpty" will be always "false" for unknown elements, so we\u000a			// must force it if the parser has identified it as a selfClosing tag.\u000a			if ( element.isUnknown && selfClosing )\u000a				element.isEmpty = true;\u000a\u000a			// Check for optional closed elements, including browser quirks and manually opened blocks.\u000a			element.isOptionalClose = optionalClose;\u000a\u000a			// This is a tag to be removed if empty, so do not add it immediately.\u000a			if ( isRemoveEmpty( element ) ) {\u000a				pendingInline.push( element );\u000a				return;\u000a			} else if ( tagName == 'pre' )\u000a				inPre = true;\u000a			else if ( tagName == 'br' && inPre ) {\u000a				currentNode.add( new CKEDITOR.htmlParser.text( '\u005cn' ) );\u000a				return;\u000a			} else if ( tagName == 'textarea' ) {\u000a				inTextarea = true;\u000a			}\u000a\u000a			if ( tagName == 'br' ) {\u000a				pendingBRs.push( element );\u000a				return;\u000a			}\u000a\u000a			while ( 1 ) {\u000a				var currentName = currentNode.name;\u000a\u000a				var currentDtd = currentName ? ( CKEDITOR.dtd[ currentName ] || ( currentNode._.isBlockLike ? CKEDITOR.dtd.div : CKEDITOR.dtd.span ) ) : rootDtd;\u000a\u000a				// If the element cannot be child of the current element.\u000a				if ( !element.isUnknown && !currentNode.isUnknown && !currentDtd[ tagName ] ) {\u000a					// Current node doesn't have a close tag, time for a close\u000a					// as this element isn't fit in. (#7497)\u000a					if ( currentNode.isOptionalClose )\u000a						parser.onTagClose( currentName );\u000a					// Fixing malformed nested lists by moving it into a previous list item. (#3828)\u000a					else if ( tagName in listBlocks && currentName in listBlocks ) {\u000a						var children = currentNode.children,\u000a							lastChild = children[ children.length - 1 ];\u000a\u000a						// Establish the list item if it's not existed.\u000a						if ( !( lastChild && lastChild.name == 'li' ) )\u000a							addElement( ( lastChild = new CKEDITOR.htmlParser.element( 'li' ) ), currentNode );\u000a\u000a						!element.returnPoint && ( element.returnPoint = currentNode );\u000a						currentNode = lastChild;\u000a					}\u000a					// Establish new list root for orphan list items, but NOT to create\u000a					// new list for the following ones, fix them instead. (#6975)\u000a					// <dl><dt>foo<dd>bar</dl>\u000a					// <ul><li>foo<li>bar</ul>\u000a					else if ( tagName in CKEDITOR.dtd.$listItem &&\u000a							!possiblySibling( tagName, currentName ) ) {\u000a						parser.onTagOpen( tagName == 'li' ? 'ul' : 'dl', {}, 0, 1 );\u000a					}\u000a					// We're inside a structural block like table and list, AND the incoming element\u000a					// is not of the same type (e.g. <td>td1<td>td2</td>), we simply add this new one before it,\u000a					// and most importantly, return back to here once this element is added,\u000a					// e.g. <table><tr><td>td1</td><p>p1</p><td>td2</td></tr></table>\u000a					else if ( currentName in nonBreakingBlocks &&\u000a							!possiblySibling( tagName, currentName ) ) {\u000a						!element.returnPoint && ( element.returnPoint = currentNode );\u000a						currentNode = currentNode.parent;\u000a					} else {\u000a						// The current element is an inline element, which\u000a						// need to be continued even after the close, so put\u000a						// it in the pending list.\u000a						if ( currentName in CKEDITOR.dtd.$inline )\u000a							pendingInline.unshift( currentNode );\u000a\u000a						// The most common case where we just need to close the\u000a						// current one and append the new one to the parent.\u000a						if ( currentNode.parent )\u000a							addElement( currentNode, currentNode.parent, 1 );\u000a						// We've tried our best to fix the embarrassment here, while\u000a						// this element still doesn't find it's parent, mark it as\u000a						// orphan and show our tolerance to it.\u000a						else {\u000a							element.isOrphan = 1;\u000a							break;\u000a						}\u000a					}\u000a				} else {\u000a					break;\u000a				}\u000a			}\u000a\u000a			checkPending( tagName );\u000a			sendPendingBRs();\u000a\u000a			element.parent = currentNode;\u000a\u000a			if ( element.isEmpty )\u000a				addElement( element );\u000a			else\u000a				currentNode = element;\u000a		};\u000a\u000a		parser.onTagClose = function( tagName ) {\u000a			// Check if there is any pending tag to be closed.\u000a			for ( var i = pendingInline.length - 1; i >= 0; i-- ) {\u000a				// If found, just remove it from the list.\u000a				if ( tagName == pendingInline[ i ].name ) {\u000a					pendingInline.splice( i, 1 );\u000a					return;\u000a				}\u000a			}\u000a\u000a			var pendingAdd = [],\u000a				newPendingInline = [],\u000a				candidate = currentNode;\u000a\u000a			while ( candidate != root && candidate.name != tagName ) {\u000a				// If this is an inline element, add it to the pending list, if we're\u000a				// really closing one of the parents element later, they will continue\u000a				// after it.\u000a				if ( !candidate._.isBlockLike )\u000a					newPendingInline.unshift( candidate );\u000a\u000a				// This node should be added to it's parent at this point. But,\u000a				// it should happen only if the closing tag is really closing\u000a				// one of the nodes. So, for now, we just cache it.\u000a				pendingAdd.push( candidate );\u000a\u000a				// Make sure return point is properly restored.\u000a				candidate = candidate.returnPoint || candidate.parent;\u000a			}\u000a\u000a			if ( candidate != root ) {\u000a				// Add all elements that have been found in the above loop.\u000a				for ( i = 0; i < pendingAdd.length; i++ ) {\u000a					var node = pendingAdd[ i ];\u000a					addElement( node, node.parent );\u000a				}\u000a\u000a				currentNode = candidate;\u000a\u000a				if ( candidate._.isBlockLike )\u000a					sendPendingBRs();\u000a\u000a				addElement( candidate, candidate.parent );\u000a\u000a				// The parent should start receiving new nodes now, except if\u000a				// addElement changed the currentNode.\u000a				if ( candidate == currentNode )\u000a					currentNode = currentNode.parent;\u000a\u000a				pendingInline = pendingInline.concat( newPendingInline );\u000a			}\u000a\u000a			if ( tagName == 'body' )\u000a				fixingBlock = false;\u000a		};\u000a\u000a		parser.onText = function( text ) {\u000a			// Trim empty spaces at beginning of text contents except <pre> and <textarea>.\u000a			if ( ( !currentNode._.hasInlineStarted || pendingBRs.length ) && !inPre && !inTextarea ) {\u000a				text = CKEDITOR.tools.ltrim( text );\u000a\u000a				if ( text.length === 0 )\u000a					return;\u000a			}\u000a\u000a			var currentName = currentNode.name,\u000a				currentDtd = currentName ? ( CKEDITOR.dtd[ currentName ] || ( currentNode._.isBlockLike ? CKEDITOR.dtd.div : CKEDITOR.dtd.span ) ) : rootDtd;\u000a\u000a			// Fix orphan text in list/table. (#8540) (#8870)\u000a			if ( !inTextarea && !currentDtd[ '#' ] && currentName in nonBreakingBlocks ) {\u000a				parser.onTagOpen( structureFixes[ currentName ] || '' );\u000a				parser.onText( text );\u000a				return;\u000a			}\u000a\u000a			sendPendingBRs();\u000a			checkPending();\u000a\u000a			// Shrinking consequential spaces into one single for all elements\u000a			// text contents.\u000a			if ( !inPre && !inTextarea )\u000a				text = text.replace( /[\u005ct\u005cr\u005cn ]{2,}|[\u005ct\u005cr\u005cn]/g, ' ' );\u000a\u000a			text = new CKEDITOR.htmlParser.text( text );\u000a\u000a\u000a			if ( checkAutoParagraphing( currentNode, text ) )\u000a				this.onTagOpen( fixingBlock, {}, 0, 1 );\u000a\u000a			currentNode.add( text );\u000a		};\u000a\u000a		parser.onCDATA = function( cdata ) {\u000a			currentNode.add( new CKEDITOR.htmlParser.cdata( cdata ) );\u000a		};\u000a\u000a		parser.onComment = function( comment ) {\u000a			sendPendingBRs();\u000a			checkPending();\u000a			currentNode.add( new CKEDITOR.htmlParser.comment( comment ) );\u000a		};\u000a\u000a		// Parse it.\u000a		parser.parse( fragmentHtml );\u000a\u000a		sendPendingBRs();\u000a\u000a		// Close all pending nodes, make sure return point is properly restored.\u000a		while ( currentNode != root )\u000a			addElement( currentNode, currentNode.parent, 1 );\u000a\u000a		removeTailWhitespace( root );\u000a\u000a		return root;\u000a	};\u000a\u000a	CKEDITOR.htmlParser.fragment.prototype = {\u000a\u000a		/**\u000a		 * The node type. This is a constant value set to {@link CKEDITOR#NODE_DOCUMENT_FRAGMENT}.\u000a		 *\u000a		 * @readonly\u000a		 * @property {Number} [=CKEDITOR.NODE_DOCUMENT_FRAGMENT]\u000a		 */\u000a		type: CKEDITOR.NODE_DOCUMENT_FRAGMENT,\u000a\u000a		/**\u000a		 * Adds a node to this fragment.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.node} node The node to be added.\u000a		 * @param {Number} [index] From where the insertion happens.\u000a		 */\u000a		add: function( node, index ) {\u000a			isNaN( index ) && ( index = this.children.length );\u000a\u000a			var previous = index > 0 ? this.children[ index - 1 ] : null;\u000a			if ( previous ) {\u000a				// If the block to be appended is following text, trim spaces at\u000a				// the right of it.\u000a				if ( node._.isBlockLike && previous.type == CKEDITOR.NODE_TEXT ) {\u000a					previous.value = CKEDITOR.tools.rtrim( previous.value );\u000a\u000a					// If we have completely cleared the previous node.\u000a					if ( previous.value.length === 0 ) {\u000a						// Remove it from the list and add the node again.\u000a						this.children.pop();\u000a						this.add( node );\u000a						return;\u000a					}\u000a				}\u000a\u000a				previous.next = node;\u000a			}\u000a\u000a			node.previous = previous;\u000a			node.parent = this;\u000a\u000a			this.children.splice( index, 0, node );\u000a\u000a			if ( !this._.hasInlineStarted )\u000a				this._.hasInlineStarted = node.type == CKEDITOR.NODE_TEXT || ( node.type == CKEDITOR.NODE_ELEMENT && !node._.isBlockLike );\u000a		},\u000a\u000a		/**\u000a		 * Filter this fragment's content with given filter.\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {CKEDITOR.htmlParser.filter} filter\u000a		 */\u000a		filter: function( filter, context ) {\u000a			context = this.getFilterContext( context );\u000a\u000a			// Apply the root filter.\u000a			filter.onRoot( context, this );\u000a\u000a			this.filterChildren( filter, false, context );\u000a		},\u000a\u000a		/**\u000a		 * Filter this fragment's children with given filter.\u000a		 *\u000a		 * Element's children may only be filtered once by one\u000a		 * instance of filter.\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {CKEDITOR.htmlParser.filter} filter\u000a		 * @param {Boolean} [filterRoot] Whether to apply the "root" filter rule specified in the `filter`.\u000a		 */\u000a		filterChildren: function( filter, filterRoot, context ) {\u000a			// If this element's children were already filtered\u000a			// by current filter, don't filter them 2nd time.\u000a			// This situation may occur when filtering bottom-up\u000a			// (filterChildren() called manually in element's filter),\u000a			// or in unpredictable edge cases when filter\u000a			// is manipulating DOM structure.\u000a			if ( this.childrenFilteredBy == filter.id )\u000a				return;\u000a\u000a			context = this.getFilterContext( context );\u000a\u000a			// Filtering root if enforced.\u000a			if ( filterRoot && !this.parent )\u000a				filter.onRoot( context, this );\u000a\u000a			this.childrenFilteredBy = filter.id;\u000a\u000a			// Don't cache anything, children array may be modified by filter rule.\u000a			for ( var i = 0; i < this.children.length; i++ ) {\u000a				// Stay in place if filter returned false, what means\u000a				// that node has been removed.\u000a				if ( this.children[ i ].filter( filter, context ) === false )\u000a					i--;\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Writes the fragment HTML to a {@link CKEDITOR.htmlParser.basicWriter}.\u000a		 *\u000a		 *		var writer = new CKEDITOR.htmlWriter();\u000a		 *		var fragment = CKEDITOR.htmlParser.fragment.fromHtml( '<P><B>Example' );\u000a		 *		fragment.writeHtml( writer );\u000a		 *		alert( writer.getHtml() ); // '<p><b>Example</b></p>'\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.basicWriter} writer The writer to which write the HTML.\u000a		 * @param {CKEDITOR.htmlParser.filter} [filter] The filter to use when writing the HTML.\u000a		 */\u000a		writeHtml: function( writer, filter ) {\u000a			if ( filter )\u000a				this.filter( filter );\u000a\u000a			this.writeChildrenHtml( writer );\u000a		},\u000a\u000a		/**\u000a		 * Write and filtering the child nodes of this fragment.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.basicWriter} writer The writer to which write the HTML.\u000a		 * @param {CKEDITOR.htmlParser.filter} [filter] The filter to use when writing the HTML.\u000a		 * @param {Boolean} [filterRoot] Whether to apply the "root" filter rule specified in the `filter`.\u000a		 */\u000a		writeChildrenHtml: function( writer, filter, filterRoot ) {\u000a			var context = this.getFilterContext();\u000a\u000a			// Filtering root if enforced.\u000a			if ( filterRoot && !this.parent && filter )\u000a				filter.onRoot( context, this );\u000a\u000a			if ( filter )\u000a				this.filterChildren( filter, false, context );\u000a\u000a			for ( var i = 0, children = this.children, l = children.length; i < l; i++ )\u000a				children[ i ].writeHtml( writer );\u000a		},\u000a\u000a		/**\u000a		 * Execute callback on each node (of given type) in this document fragment.\u000a		 *\u000a		 *		var fragment = CKEDITOR.htmlParser.fragment.fromHtml( '<p>foo<b>bar</b>bom</p>' );\u000a		 *		fragment.forEach( function( node ) {\u000a		 *			console.log( node );\u000a		 *		} );\u000a		 *		// Will log:\u000a		 *		// 1. document fragment,\u000a		 *		// 2. <p> element,\u000a		 *		// 3. "foo" text node,\u000a		 *		// 4. <b> element,\u000a		 *		// 5. "bar" text node,\u000a		 *		// 6. "bom" text node.\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {Function} callback Function to be executed on every node.\u000a		 * **Since 4.3** if `callback` returned `false` descendants of current node will be ignored.\u000a		 * @param {CKEDITOR.htmlParser.node} callback.node Node passed as argument.\u000a		 * @param {Number} [type] If specified `callback` will be executed only on nodes of this type.\u000a		 * @param {Boolean} [skipRoot] Don't execute `callback` on this fragment.\u000a		 */\u000a		forEach: function( callback, type, skipRoot ) {\u000a			if ( !skipRoot && ( !type || this.type == type ) )\u000a				var ret = callback( this );\u000a\u000a			// Do not filter children if callback returned false.\u000a			if ( ret === false )\u000a				return;\u000a\u000a			var children = this.children,\u000a				node,\u000a				i = 0;\u000a\u000a			// We do not cache the size, because the list of nodes may be changed by the callback.\u000a			for ( ; i < children.length; i++ ) {\u000a				node = children[ i ];\u000a				if ( node.type == CKEDITOR.NODE_ELEMENT )\u000a					node.forEach( callback, type );\u000a				else if ( !type || node.type == type )\u000a					callback( node );\u000a			}\u000a		},\u000a\u000a		getFilterContext: function( context ) {\u000a			return context || {};\u000a		}\u000a	};\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a'use strict';\u000a\u000a( function() {\u000a	/**\u000a	 * Filter is a configurable tool for transforming and filtering {@link CKEDITOR.htmlParser.node nodes}.\u000a	 * It is mainly used during data processing phase which is done not on real DOM nodes,\u000a	 * but on their simplified form represented by {@link CKEDITOR.htmlParser.node} class and its subclasses.\u000a	 *\u000a	 *		var filter = new CKEDITOR.htmlParser.filter( {\u000a	 *			text: function( value ) {\u000a	 *				return '@' + value + '@';\u000a	 *			},\u000a	 *			elements: {\u000a	 *				p: function( element ) {\u000a	 *					element.attributes.foo = '1';\u000a	 *				}\u000a	 *			}\u000a	 *		} );\u000a	 *\u000a	 *		var fragment = CKEDITOR.htmlParser.fragment.fromHtml( '<p>Foo<b>bar!</b></p>' ),\u000a	 *			writer = new CKEDITOR.htmlParser.basicWriter();\u000a	 *		filter.applyTo( fragment );\u000a	 *		fragment.writeHtml( writer );\u000a	 *		writer.getHtml(); // '<p foo="1">@Foo@<b>@bar!@</b></p>'\u000a	 *\u000a	 * @class\u000a	 */\u000a	CKEDITOR.htmlParser.filter = CKEDITOR.tools.createClass( {\u000a		/**\u000a		 * @constructor Creates a filter class instance.\u000a		 * @param {CKEDITOR.htmlParser.filterRulesDefinition} [rules]\u000a		 */\u000a		$: function( rules ) {\u000a			/**\u000a			 * ID of filter instance, which is used to mark elements\u000a			 * to which this filter has been already applied.\u000a			 *\u000a			 * @property {Number} id\u000a			 * @readonly\u000a			 */\u000a			this.id = CKEDITOR.tools.getNextNumber();\u000a\u000a			/**\u000a			 * Rules for element names.\u000a			 *\u000a			 * @property {CKEDITOR.htmlParser.filterRulesGroup}\u000a			 * @readonly\u000a			 */\u000a			this.elementNameRules = new filterRulesGroup();\u000a\u000a			/**\u000a			 * Rules for attribute names.\u000a			 *\u000a			 * @property {CKEDITOR.htmlParser.filterRulesGroup}\u000a			 * @readonly\u000a			 */\u000a			this.attributeNameRules = new filterRulesGroup();\u000a\u000a			/**\u000a			 * Hash of elementName => {@link CKEDITOR.htmlParser.filterRulesGroup rules for elements}.\u000a			 *\u000a			 * @readonly\u000a			 */\u000a			this.elementsRules = {};\u000a\u000a			/**\u000a			 * Hash of attributeName => {@link CKEDITOR.htmlParser.filterRulesGroup rules for attributes}.\u000a			 *\u000a			 * @readonly\u000a			 */\u000a			this.attributesRules = {};\u000a\u000a			/**\u000a			 * Rules for text nodes.\u000a			 *\u000a			 * @property {CKEDITOR.htmlParser.filterRulesGroup}\u000a			 * @readonly\u000a			 */\u000a			this.textRules = new filterRulesGroup();\u000a\u000a			/**\u000a			 * Rules for comment nodes.\u000a			 *\u000a			 * @property {CKEDITOR.htmlParser.filterRulesGroup}\u000a			 * @readonly\u000a			 */\u000a			this.commentRules = new filterRulesGroup();\u000a\u000a			/**\u000a			 * Rules for a root node.\u000a			 *\u000a			 * @property {CKEDITOR.htmlParser.filterRulesGroup}\u000a			 * @readonly\u000a			 */\u000a			this.rootRules = new filterRulesGroup();\u000a\u000a			if ( rules )\u000a				this.addRules( rules, 10 );\u000a		},\u000a\u000a		proto: {\u000a			/**\u000a			 * Add rules to this filter.\u000a			 *\u000a			 * @param {CKEDITOR.htmlParser.filterRulesDefinition} rules Object containing filter rules.\u000a			 * @param {Object/Number} [options] Object containing rules' options or a priority\u000a			 * (for a backward compatibility with CKEditor versions up to 4.2.x).\u000a			 * @param {Number} [options.priority=10] The priority of a rule.\u000a			 * @param {Boolean} [options.applyToAll=false] Whether to apply rule to non-editable\u000a			 * elements and their descendants too.\u000a			 */\u000a			addRules: function( rules, options ) {\u000a				var priority;\u000a\u000a				// Backward compatibility.\u000a				if ( typeof options == 'number' )\u000a					priority = options;\u000a				// New version - try reading from options.\u000a				else if ( options && ( 'priority' in options ) )\u000a					priority = options.priority;\u000a\u000a				// Defaults.\u000a				if ( typeof priority != 'number' )\u000a					priority = 10;\u000a				if ( typeof options != 'object' )\u000a					options = {};\u000a\u000a				// Add the elementNames.\u000a				if ( rules.elementNames )\u000a					this.elementNameRules.addMany( rules.elementNames, priority, options );\u000a\u000a				// Add the attributeNames.\u000a				if ( rules.attributeNames )\u000a					this.attributeNameRules.addMany( rules.attributeNames, priority, options );\u000a\u000a				// Add the elements.\u000a				if ( rules.elements )\u000a					addNamedRules( this.elementsRules, rules.elements, priority, options );\u000a\u000a				// Add the attributes.\u000a				if ( rules.attributes )\u000a					addNamedRules( this.attributesRules, rules.attributes, priority, options );\u000a\u000a				// Add the text.\u000a				if ( rules.text )\u000a					this.textRules.add( rules.text, priority, options );\u000a\u000a				// Add the comment.\u000a				if ( rules.comment )\u000a					this.commentRules.add( rules.comment, priority, options );\u000a\u000a				// Add root node rules.\u000a				if ( rules.root )\u000a					this.rootRules.add( rules.root, priority, options );\u000a			},\u000a\u000a			/**\u000a			 * Apply this filter to given node.\u000a			 *\u000a			 * @param {CKEDITOR.htmlParser.node} node The node to be filtered.\u000a			 */\u000a			applyTo: function( node ) {\u000a				node.filter( this );\u000a			},\u000a\u000a			onElementName: function( context, name ) {\u000a				return this.elementNameRules.execOnName( context, name );\u000a			},\u000a\u000a			onAttributeName: function( context, name ) {\u000a				return this.attributeNameRules.execOnName( context, name );\u000a			},\u000a\u000a			onText: function( context, text, node ) {\u000a				return this.textRules.exec( context, text, node );\u000a			},\u000a\u000a			onComment: function( context, commentText, comment ) {\u000a				return this.commentRules.exec( context, commentText, comment );\u000a			},\u000a\u000a			onRoot: function( context, element ) {\u000a				return this.rootRules.exec( context, element );\u000a			},\u000a\u000a			onElement: function( context, element ) {\u000a				// We must apply filters set to the specific element name as\u000a				// well as those set to the generic ^/$ name. So, add both to an\u000a				// array and process them in a small loop.\u000a				var rulesGroups = [ this.elementsRules[ '^' ], this.elementsRules[ element.name ], this.elementsRules.$ ],\u000a					rulesGroup, ret;\u000a\u000a				for ( var i = 0; i < 3; i++ ) {\u000a					rulesGroup = rulesGroups[ i ];\u000a					if ( rulesGroup ) {\u000a						ret = rulesGroup.exec( context, element, this );\u000a\u000a						if ( ret === false )\u000a							return null;\u000a\u000a						if ( ret && ret != element )\u000a							return this.onNode( context, ret );\u000a\u000a						// The non-root element has been dismissed by one of the filters.\u000a						if ( element.parent && !element.name )\u000a							break;\u000a					}\u000a				}\u000a\u000a				return element;\u000a			},\u000a\u000a			onNode: function( context, node ) {\u000a				var type = node.type;\u000a\u000a				return type == CKEDITOR.NODE_ELEMENT ? this.onElement( context, node ) :\u000a					type == CKEDITOR.NODE_TEXT ? new CKEDITOR.htmlParser.text( this.onText( context, node.value ) ) :\u000a					type == CKEDITOR.NODE_COMMENT ? new CKEDITOR.htmlParser.comment( this.onComment( context, node.value ) ) : null;\u000a			},\u000a\u000a			onAttribute: function( context, element, name, value ) {\u000a				var rulesGroup = this.attributesRules[ name ];\u000a\u000a				if ( rulesGroup )\u000a					return rulesGroup.exec( context, value, element, this );\u000a				return value;\u000a			}\u000a		}\u000a	} );\u000a\u000a	/**\u000a	 * Class grouping filter rules for one subject (like element or attribute names).\u000a	 *\u000a	 * @class CKEDITOR.htmlParser.filterRulesGroup\u000a	 */\u000a	function filterRulesGroup() {\u000a		/**\u000a		 * Array of objects containing rule, priority and options.\u000a		 *\u000a		 * @property {Object[]}\u000a		 * @readonly\u000a		 */\u000a		this.rules = [];\u000a	}\u000a\u000a	CKEDITOR.htmlParser.filterRulesGroup = filterRulesGroup;\u000a\u000a	filterRulesGroup.prototype = {\u000a		/**\u000a		 * Adds specified rule to this group.\u000a		 *\u000a		 * @param {Function/Array} rule Function for function based rule or [ pattern, replacement ] array for\u000a		 * rule applicable to names.\u000a		 * @param {Number} priority\u000a		 * @param options\u000a		 */\u000a		add: function( rule, priority, options ) {\u000a			this.rules.splice( this.findIndex( priority ), 0, {\u000a				value: rule,\u000a				priority: priority,\u000a				options: options\u000a			} );\u000a		},\u000a\u000a		/**\u000a		 * Adds specified rules to this group.\u000a		 *\u000a		 * @param {Array} rules Array of rules - see {@link #add}.\u000a		 * @param {Number} priority\u000a		 * @param options\u000a		 */\u000a		addMany: function( rules, priority, options ) {\u000a			var args = [ this.findIndex( priority ), 0 ];\u000a\u000a			for ( var i = 0, len = rules.length; i < len; i++ ) {\u000a				args.push( {\u000a					value: rules[ i ],\u000a					priority: priority,\u000a					options: options\u000a				} );\u000a			}\u000a\u000a			this.rules.splice.apply( this.rules, args );\u000a		},\u000a\u000a		/**\u000a		 * Finds an index at which rule with given priority should be inserted.\u000a		 *\u000a		 * @param {Number} priority\u000a		 * @returns {Number} Index.\u000a		 */\u000a		findIndex: function( priority ) {\u000a			var rules = this.rules,\u000a				len = rules.length,\u000a				i = len - 1;\u000a\u000a			// Search from the end, because usually rules will be added with default priority, so\u000a			// we will be able to stop loop quickly.\u000a			while ( i >= 0 && priority < rules[ i ].priority )\u000a				i--;\u000a\u000a			return i + 1;\u000a		},\u000a\u000a		/**\u000a		 * Executes this rules group on given value. Applicable only if function based rules were added.\u000a		 *\u000a		 * All arguments passed to this function will be forwarded to rules' functions.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.node/CKEDITOR.htmlParser.fragment/String} currentValue The value to be filtered.\u000a		 * @returns {CKEDITOR.htmlParser.node/CKEDITOR.htmlParser.fragment/String} Filtered value.\u000a		 */\u000a		exec: function( context, currentValue ) {\u000a			var isNode = currentValue instanceof CKEDITOR.htmlParser.node || currentValue instanceof CKEDITOR.htmlParser.fragment,\u000a				// Splice '1' to remove context, which we don't want to pass to filter rules.\u000a				args = Array.prototype.slice.call( arguments, 1 ),\u000a				rules = this.rules,\u000a				len = rules.length,\u000a				orgType, orgName, ret, i, rule;\u000a\u000a			for ( i = 0; i < len; i++ ) {\u000a				// Backup the node info before filtering.\u000a				if ( isNode ) {\u000a					orgType = currentValue.type;\u000a					orgName = currentValue.name;\u000a				}\u000a\u000a				rule = rules[ i ];\u000a				if ( isRuleApplicable( context, rule ) ) {\u000a					ret = rule.value.apply( null, args );\u000a\u000a					if ( ret === false )\u000a						return ret;\u000a\u000a					// We're filtering node (element/fragment).\u000a					// No further filtering if it's not anymore fitable for the subsequent filters.\u000a					if ( isNode && ret && ( ret.name != orgName || ret.type != orgType ) )\u000a						return ret;\u000a\u000a					// Update currentValue and corresponding argument in args array.\u000a					// Updated values will be used in next for-loop step.\u000a					if ( ret != null )\u000a						args[ 0 ] = currentValue = ret;\u000a\u000a					// ret == undefined will continue loop as nothing has happened.\u000a				}\u000a			}\u000a\u000a			return currentValue;\u000a		},\u000a\u000a		/**\u000a		 * Executes this rules group on name. Applicable only if filter rules for names were added.\u000a		 *\u000a		 * @param {String} currentName The name to be filtered.\u000a		 * @returns {String} Filtered name.\u000a		 */\u000a		execOnName: function( context, currentName ) {\u000a			var i = 0,\u000a				rules = this.rules,\u000a				len = rules.length,\u000a				rule;\u000a\u000a			for ( ; currentName && i < len; i++ ) {\u000a				rule = rules[ i ];\u000a				if ( isRuleApplicable( context, rule ) )\u000a					currentName = currentName.replace( rule.value[ 0 ], rule.value[ 1 ] );\u000a			}\u000a\u000a			return currentName;\u000a		}\u000a	};\u000a\u000a	function addNamedRules( rulesGroups, newRules, priority, options ) {\u000a		var ruleName, rulesGroup;\u000a\u000a		for ( ruleName in newRules ) {\u000a			rulesGroup = rulesGroups[ ruleName ];\u000a\u000a			if ( !rulesGroup )\u000a				rulesGroup = rulesGroups[ ruleName ] = new filterRulesGroup();\u000a\u000a			rulesGroup.add( newRules[ ruleName ], priority, options );\u000a		}\u000a	}\u000a\u000a	function isRuleApplicable( context, rule ) {\u000a		if ( context.nonEditable && !rule.options.applyToAll )\u000a			return false;\u000a\u000a		if ( context.nestedEditable && rule.options.excludeNestedEditable )\u000a			return false;\u000a\u000a		return true;\u000a	}\u000a\u000a} )();\u000a\u000a/**\u000a * @class CKEDITOR.htmlParser.filterRulesDefinition\u000a * @abstract\u000a */\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a'use strict';\u000a\u000a/**\u000a * A lightweight representation of an HTML element.\u000a *\u000a * @class\u000a * @extends CKEDITOR.htmlParser.node\u000a * @constructor Creates an element class instance.\u000a * @param {String} name The element name.\u000a * @param {Object} attributes An object storing all attributes defined for\u000a * this element.\u000a */\u000aCKEDITOR.htmlParser.element = function( name, attributes ) {\u000a	/**\u000a	 * The element name.\u000a	 *\u000a	 * @property {String}\u000a	 */\u000a	this.name = name;\u000a\u000a	/**\u000a	 * Stores the attributes defined for this element.\u000a	 *\u000a	 * @property {Object}\u000a	 */\u000a	this.attributes = attributes || {};\u000a\u000a	/**\u000a	 * The nodes that are direct children of this element.\u000a	 */\u000a	this.children = [];\u000a\u000a	// Reveal the real semantic of our internal custom tag name (#6639),\u000a	// when resolving whether it's block like.\u000a	var realName = name || '',\u000a		prefixed = realName.match( /^cke:(.*)/ );\u000a	prefixed && ( realName = prefixed[ 1 ] );\u000a\u000a	var isBlockLike = !!( CKEDITOR.dtd.$nonBodyContent[ realName ] || CKEDITOR.dtd.$block[ realName ] ||\u000a		CKEDITOR.dtd.$listItem[ realName ] || CKEDITOR.dtd.$tableContent[ realName ] ||\u000a		CKEDITOR.dtd.$nonEditable[ realName ] || realName == 'br' );\u000a\u000a	this.isEmpty = !!CKEDITOR.dtd.$empty[ name ];\u000a	this.isUnknown = !CKEDITOR.dtd[ name ];\u000a\u000a	/** @private */\u000a	this._ = {\u000a		isBlockLike: isBlockLike,\u000a		hasInlineStarted: this.isEmpty || !isBlockLike\u000a	};\u000a};\u000a\u000a/**\u000a * Object presentation of CSS style declaration text.\u000a *\u000a * @class\u000a * @constructor Creates a `cssStyle` class instance.\u000a * @param {CKEDITOR.htmlParser.element/String} elementOrStyleText\u000a * An HTML parser element or the inline style text.\u000a */\u000aCKEDITOR.htmlParser.cssStyle = function() {\u000a	var styleText,\u000a		arg = arguments[ 0 ],\u000a		rules = {};\u000a\u000a	styleText = arg instanceof CKEDITOR.htmlParser.element ? arg.attributes.style : arg;\u000a\u000a	// html-encoded quote might be introduced by 'font-family'\u000a	// from MS-Word which confused the following regexp. e.g.\u000a	//'font-family: &quot;Lucida, Console&quot;'\u000a	// TODO reuse CSS methods from tools.\u000a	( styleText || '' ).replace( /&quot;/g, '"' ).replace( /\u005cs*([^ :;]+)\u005cs*:\u005cs*([^;]+)\u005cs*(?=;|$)/g, function( match, name, value ) {\u000a		name == 'font-family' && ( value = value.replace( /["']/g, '' ) );\u000a		rules[ name.toLowerCase() ] = value;\u000a	} );\u000a\u000a	return {\u000a\u000a		rules: rules,\u000a\u000a		/**\u000a		 * Applies the styles to the specified element or object.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.element/CKEDITOR.dom.element/Object} obj\u000a		 */\u000a		populate: function( obj ) {\u000a			var style = this.toString();\u000a			if ( style )\u000a				obj instanceof CKEDITOR.dom.element ? obj.setAttribute( 'style', style ) : obj instanceof CKEDITOR.htmlParser.element ? obj.attributes.style = style : obj.style = style;\u000a\u000a		},\u000a\u000a		/**\u000a		 * Serializes CSS style declaration to a string.\u000a		 *\u000a		 * @returns {String}\u000a		 */\u000a		toString: function() {\u000a			var output = [];\u000a			for ( var i in rules )\u000a				rules[ i ] && output.push( i, ':', rules[ i ], ';' );\u000a			return output.join( '' );\u000a		}\u000a	};\u000a};\u000a\u000a/** @class CKEDITOR.htmlParser.element */\u000a( function() {\u000a	// Used to sort attribute entries in an array, where the first element of\u000a	// each object is the attribute name.\u000a	var sortAttribs = function( a, b ) {\u000a			a = a[ 0 ];\u000a			b = b[ 0 ];\u000a			return a < b ? -1 : a > b ? 1 : 0;\u000a		},\u000a		fragProto = CKEDITOR.htmlParser.fragment.prototype;\u000a\u000a	CKEDITOR.htmlParser.element.prototype = CKEDITOR.tools.extend( new CKEDITOR.htmlParser.node(), {\u000a		/**\u000a		 * The node type. This is a constant value set to {@link CKEDITOR#NODE_ELEMENT}.\u000a		 *\u000a		 * @readonly\u000a		 * @property {Number} [=CKEDITOR.NODE_ELEMENT]\u000a		 */\u000a		type: CKEDITOR.NODE_ELEMENT,\u000a\u000a		/**\u000a		 * Adds a node to the element children list.\u000a		 *\u000a		 * @method\u000a		 * @param {CKEDITOR.htmlParser.node} node The node to be added.\u000a		 * @param {Number} [index] From where the insertion happens.\u000a		 */\u000a		add: fragProto.add,\u000a\u000a		/**\u000a		 * Clones this element.\u000a		 *\u000a		 * @returns {CKEDITOR.htmlParser.element} The element clone.\u000a		 */\u000a		clone: function() {\u000a			return new CKEDITOR.htmlParser.element( this.name, this.attributes );\u000a		},\u000a\u000a		/**\u000a		 * Filters this element and its children with the given filter.\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {CKEDITOR.htmlParser.filter} filter\u000a		 * @returns {Boolean} The method returns `false` when this element has\u000a		 * been removed or replaced with another. This information means that\u000a		 * {@link #filterChildren} has to repeat the filter on the current\u000a		 * position in parent's children array.\u000a		 */\u000a		filter: function( filter, context ) {\u000a			var element = this,\u000a				originalName, name;\u000a\u000a			context = element.getFilterContext( context );\u000a\u000a			// Do not process elements with data-cke-processor attribute set to off.\u000a			if ( context.off )\u000a				return true;\u000a\u000a			// Filtering if it's the root node.\u000a			if ( !element.parent )\u000a				filter.onRoot( context, element );\u000a\u000a			while ( true ) {\u000a				originalName = element.name;\u000a\u000a				if ( !( name = filter.onElementName( context, originalName ) ) ) {\u000a					this.remove();\u000a					return false;\u000a				}\u000a\u000a				element.name = name;\u000a\u000a				if ( !( element = filter.onElement( context, element ) ) ) {\u000a					this.remove();\u000a					return false;\u000a				}\u000a\u000a				// New element has been returned - replace current one\u000a				// and process it (stop processing this and return false, what\u000a				// means that element has been removed).\u000a				if ( element !== this ) {\u000a					this.replaceWith( element );\u000a					return false;\u000a				}\u000a\u000a				// If name has been changed - continue loop, so in next iteration\u000a				// filters for new name will be applied to this element.\u000a				// If name hasn't been changed - stop.\u000a				if ( element.name == originalName )\u000a					break;\u000a\u000a				// If element has been replaced with something of a\u000a				// different type, then make the replacement filter itself.\u000a				if ( element.type != CKEDITOR.NODE_ELEMENT ) {\u000a					this.replaceWith( element );\u000a					return false;\u000a				}\u000a\u000a				// This indicate that the element has been dropped by\u000a				// filter but not the children.\u000a				if ( !element.name ) {\u000a					this.replaceWithChildren();\u000a					return false;\u000a				}\u000a			}\u000a\u000a			var attributes = element.attributes,\u000a				a, value, newAttrName;\u000a\u000a			for ( a in attributes ) {\u000a				newAttrName = a;\u000a				value = attributes[ a ];\u000a\u000a				// Loop until name isn't modified.\u000a				// A little bit senseless, but IE would do that anyway\u000a				// because it iterates with for-in loop even over properties\u000a				// created during its run.\u000a				while ( true ) {\u000a					if ( !( newAttrName = filter.onAttributeName( context, a ) ) ) {\u000a						delete attributes[ a ];\u000a						break;\u000a					} else if ( newAttrName != a ) {\u000a						delete attributes[ a ];\u000a						a = newAttrName;\u000a						continue;\u000a					} else {\u000a						break;\u000a					}\u000a				}\u000a\u000a				if ( newAttrName ) {\u000a					if ( ( value = filter.onAttribute( context, element, newAttrName, value ) ) === false )\u000a						delete attributes[ newAttrName ];\u000a					else\u000a						attributes[ newAttrName ] = value;\u000a				}\u000a			}\u000a\u000a			if ( !element.isEmpty )\u000a				this.filterChildren( filter, false, context );\u000a\u000a			return true;\u000a		},\u000a\u000a		/**\u000a		 * Filters this element's children with the given filter.\u000a		 *\u000a		 * Element's children may only be filtered once by one\u000a		 * instance of the filter.\u000a		 *\u000a		 * @method filterChildren\u000a		 * @param {CKEDITOR.htmlParser.filter} filter\u000a		 */\u000a		filterChildren: fragProto.filterChildren,\u000a\u000a		/**\u000a		 * Writes the element HTML to the CKEDITOR.htmlWriter.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.basicWriter} writer The writer to which HTML will be written.\u000a		 * @param {CKEDITOR.htmlParser.filter} [filter] The filter to be applied to this node.\u000a		 * **Note:** It is unsafe to filter an offline (not appended) node.\u000a		 */\u000a		writeHtml: function( writer, filter ) {\u000a			if ( filter )\u000a				this.filter( filter );\u000a\u000a			var name = this.name,\u000a				attribsArray = [],\u000a				attributes = this.attributes,\u000a				attrName,\u000a				attr, i, l;\u000a\u000a			// Open element tag.\u000a			writer.openTag( name, attributes );\u000a\u000a			// Copy all attributes to an array.\u000a			for ( attrName in attributes )\u000a				attribsArray.push( [ attrName, attributes[ attrName ] ] );\u000a\u000a			// Sort the attributes by name.\u000a			if ( writer.sortAttributes )\u000a				attribsArray.sort( sortAttribs );\u000a\u000a			// Send the attributes.\u000a			for ( i = 0, l = attribsArray.length; i < l; i++ ) {\u000a				attr = attribsArray[ i ];\u000a				writer.attribute( attr[ 0 ], attr[ 1 ] );\u000a			}\u000a\u000a			// Close the tag.\u000a			writer.openTagClose( name, this.isEmpty );\u000a\u000a			this.writeChildrenHtml( writer );\u000a\u000a			// Close the element.\u000a			if ( !this.isEmpty )\u000a				writer.closeTag( name );\u000a		},\u000a\u000a		/**\u000a		 * Sends children of this element to the writer.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.basicWriter} writer The writer to which HTML will be written.\u000a		 * @param {CKEDITOR.htmlParser.filter} [filter]\u000a		 */\u000a		writeChildrenHtml: fragProto.writeChildrenHtml,\u000a\u000a		/**\u000a		 * Replaces this element with its children.\u000a		 *\u000a		 * @since 4.1\u000a		 */\u000a		replaceWithChildren: function() {\u000a			var children = this.children;\u000a\u000a			for ( var i = children.length; i; )\u000a				children[ --i ].insertAfter( this );\u000a\u000a			this.remove();\u000a		},\u000a\u000a		/**\u000a		 * Executes a callback on each node (of the given type) in this element.\u000a		 *\u000a		 *		// Create a <p> element with foo<b>bar</b>bom as its content.\u000a		 *		var elP = CKEDITOR.htmlParser.fragment.fromHtml( 'foo<b>bar</b>bom', 'p' );\u000a		 *		elP.forEach( function( node ) {\u000a		 *			console.log( node );\u000a		 *		} );\u000a		 *		// Will log:\u000a		 *		// 1. document fragment,\u000a		 *		// 2. <p> element,\u000a		 *		// 3. "foo" text node,\u000a		 *		// 4. <b> element,\u000a		 *		// 5. "bar" text node,\u000a		 *		// 6. "bom" text node.\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {Function} callback Function to be executed on every node.\u000a		 * **Since 4.3**: If `callback` returned `false`, the descendants of the current node will be ignored.\u000a		 * @param {CKEDITOR.htmlParser.node} callback.node Node passed as an argument.\u000a		 * @param {Number} [type] Whether the specified `callback` will be executed only on nodes of this type.\u000a		 * @param {Boolean} [skipRoot] Do not execute `callback` on this element.\u000a		 */\u000a		forEach: fragProto.forEach,\u000a\u000a		/**\u000a		 * Gets this element's first child. If `condition` is given, this method returns\u000a		 * the first child which satisfies that condition.\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {String/Object/Function} condition Name of a child, a hash of names, or a validator function.\u000a		 * @returns {CKEDITOR.htmlParser.node}\u000a		 */\u000a		getFirst: function( condition ) {\u000a			if ( !condition )\u000a				return this.children.length ? this.children[ 0 ] : null;\u000a\u000a			if ( typeof condition != 'function' )\u000a				condition = nameCondition( condition );\u000a\u000a			for ( var i = 0, l = this.children.length; i < l; ++i ) {\u000a				if ( condition( this.children[ i ] ) )\u000a					return this.children[ i ];\u000a			}\u000a			return null;\u000a		},\u000a\u000a		/**\u000a		 * Gets this element's inner HTML.\u000a		 *\u000a		 * @since 4.3\u000a		 * @returns {String}\u000a		 */\u000a		getHtml: function() {\u000a			var writer = new CKEDITOR.htmlParser.basicWriter();\u000a			this.writeChildrenHtml( writer );\u000a			return writer.getHtml();\u000a		},\u000a\u000a		/**\u000a		 * Sets this element's inner HTML.\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {String} html\u000a		 */\u000a		setHtml: function( html ) {\u000a			var children = this.children = CKEDITOR.htmlParser.fragment.fromHtml( html ).children;\u000a\u000a			for ( var i = 0, l = children.length; i < l; ++i )\u000a				children[ i ].parent = this;\u000a		},\u000a\u000a		/**\u000a		 * Gets this element's outer HTML.\u000a		 *\u000a		 * @since 4.3\u000a		 * @returns {String}\u000a		 */\u000a		getOuterHtml: function() {\u000a			var writer = new CKEDITOR.htmlParser.basicWriter();\u000a			this.writeHtml( writer );\u000a			return writer.getHtml();\u000a		},\u000a\u000a		/**\u000a		 * Splits this element at the given index.\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {Number} index Index at which the element will be split &mdash; `0` means the beginning,\u000a		 * `1` after first child node, etc.\u000a		 * @returns {CKEDITOR.htmlParser.element} The new element following this one.\u000a		 */\u000a		split: function( index ) {\u000a			var cloneChildren = this.children.splice( index, this.children.length - index ),\u000a				clone = this.clone();\u000a\u000a			for ( var i = 0; i < cloneChildren.length; ++i )\u000a				cloneChildren[ i ].parent = clone;\u000a\u000a			clone.children = cloneChildren;\u000a\u000a			if ( cloneChildren[ 0 ] )\u000a				cloneChildren[ 0 ].previous = null;\u000a\u000a			if ( index > 0 )\u000a				this.children[ index - 1 ].next = null;\u000a\u000a			this.parent.add( clone, this.getIndex() + 1 );\u000a\u000a			return clone;\u000a		},\u000a\u000a		/**\u000a		 * Adds a class name to the list of classes.\u000a		 *\u000a		 * @since 4.4\u000a		 * @param {String} className The class name to be added.\u000a		 */\u000a		addClass: function( className ) {\u000a			if ( this.hasClass( className ) )\u000a				return;\u000a\u000a			var c = this.attributes[ 'class' ] || '';\u000a\u000a			this.attributes[ 'class' ] = c + ( c ? ' ' : '' ) + className;\u000a		},\u000a\u000a		/**\u000a		 * Removes a class name from the list of classes.\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {String} className The class name to be removed.\u000a		 */\u000a		removeClass: function( className ) {\u000a			var classes = this.attributes[ 'class' ];\u000a\u000a			if ( !classes )\u000a				return;\u000a\u000a			// We can safely assume that className won't break regexp.\u000a			// http://stackoverflow.com/questions/448981/what-characters-are-valid-in-css-class-names\u000a			classes = CKEDITOR.tools.trim( classes.replace( new RegExp( '(?:\u005c\u005cs+|^)' + className + '(?:\u005c\u005cs+|$)' ), ' ' ) );\u000a\u000a			if ( classes )\u000a				this.attributes[ 'class' ] = classes;\u000a			else\u000a				delete this.attributes[ 'class' ];\u000a		},\u000a\u000a		/**\u000a		 * Checkes whether this element has a class name.\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {String} className The class name to be checked.\u000a		 * @returns {Boolean} Whether this element has a `className`.\u000a		 */\u000a		hasClass: function( className ) {\u000a			var classes = this.attributes[ 'class' ];\u000a\u000a			if ( !classes )\u000a				return false;\u000a\u000a			return ( new RegExp( '(?:^|\u005c\u005cs)' + className + '(?=\u005c\u005cs|$)' ) ).test( classes );\u000a		},\u000a\u000a		getFilterContext: function( ctx ) {\u000a			var changes = [];\u000a\u000a			if ( !ctx ) {\u000a				ctx = {\u000a					off: false,\u000a					nonEditable: false,\u000a					nestedEditable: false\u000a				};\u000a			}\u000a\u000a			if ( !ctx.off && this.attributes[ 'data-cke-processor' ] == 'off' )\u000a				changes.push( 'off', true );\u000a\u000a			if ( !ctx.nonEditable && this.attributes.contenteditable == 'false' )\u000a				changes.push( 'nonEditable', true );\u000a			// A context to be given nestedEditable must be nonEditable first (by inheritance) (#11372, #11698).\u000a			// Special case: #11504 - filter starts on <body contenteditable=true>,\u000a			// so ctx.nonEditable has not been yet set to true.\u000a			else if ( ctx.nonEditable && !ctx.nestedEditable && this.attributes.contenteditable == 'true' )\u000a				changes.push( 'nestedEditable', true );\u000a\u000a			if ( changes.length ) {\u000a				ctx = CKEDITOR.tools.copy( ctx );\u000a				for ( var i = 0; i < changes.length; i += 2 )\u000a					ctx[ changes[ i ] ] = changes[ i + 1 ];\u000a			}\u000a\u000a			return ctx;\u000a		}\u000a	}, true );\u000a\u000a	function nameCondition( condition ) {\u000a		return function( el ) {\u000a			return el.type == CKEDITOR.NODE_ELEMENT &&\u000a				( typeof condition == 'string' ? el.name == condition : el.name in condition );\u000a		};\u000a	}\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * Represents a command that can be executed on an editor instance.\u000a *\u000a *		var command = new CKEDITOR.command( editor, {\u000a *			exec: function( editor ) {\u000a *				alert( editor.document.getBody().getHtml() );\u000a *			}\u000a *		} );\u000a *\u000a * @class\u000a * @mixins CKEDITOR.event\u000a * @constructor Creates a command class instance.\u000a * @param {CKEDITOR.editor} editor The editor instance this command will be\u000a * related to.\u000a * @param {CKEDITOR.commandDefinition} commandDefinition The command\u000a * definition.\u000a */\u000aCKEDITOR.command = function( editor, commandDefinition ) {\u000a	/**\u000a	 * Lists UI items that are associated to this command. This list can be\u000a	 * used to interact with the UI on command execution (by the execution code\u000a	 * itself, for example).\u000a	 *\u000a	 *		alert( 'Number of UI items associated to this command: ' + command.uiItems.length );\u000a	 */\u000a	this.uiItems = [];\u000a\u000a	/**\u000a	 * Executes the command.\u000a	 *\u000a	 *		command.exec(); // The command gets executed.\u000a	 *\u000a	 * @param {Object} [data] Any data to pass to the command. Depends on the\u000a	 * command implementation and requirements.\u000a	 * @returns {Boolean} A boolean indicating that the command has been successfully executed.\u000a	 */\u000a	this.exec = function( data ) {\u000a		if ( this.state == CKEDITOR.TRISTATE_DISABLED || !this.checkAllowed() )\u000a			return false;\u000a\u000a		if ( this.editorFocus ) // Give editor focus if necessary (#4355).\u000a			editor.focus();\u000a\u000a		if ( this.fire( 'exec' ) === false )\u000a			return true;\u000a\u000a		return ( commandDefinition.exec.call( this, editor, data ) !== false );\u000a	};\u000a\u000a	/**\u000a	 * Explicitly update the status of the command, by firing the {@link CKEDITOR.command#event-refresh} event,\u000a	 * as well as invoke the {@link CKEDITOR.commandDefinition#refresh} method if defined, this method\u000a	 * is to allow different parts of the editor code to contribute in command status resolution.\u000a	 *\u000a	 * @param {CKEDITOR.editor} editor The editor instance.\u000a	 * @param {CKEDITOR.dom.elementPath} path\u000a	 */\u000a	this.refresh = function( editor, path ) {\u000a		// Do nothing is we're on read-only and this command doesn't support it.\u000a		// We don't need to disabled the command explicitely here, because this\u000a		// is already done by the "readOnly" event listener.\u000a		if ( !this.readOnly && editor.readOnly )\u000a			return true;\u000a\u000a		// Disable commands that are not allowed in the current selection path context.\u000a		if ( this.context && !path.isContextFor( this.context ) ) {\u000a			this.disable();\u000a			return true;\u000a		}\u000a\u000a		// Disable commands that are not allowed by the active filter.\u000a		if ( !this.checkAllowed( true ) ) {\u000a			this.disable();\u000a			return true;\u000a		}\u000a\u000a		// Make the "enabled" state a default for commands enabled from start.\u000a		if ( !this.startDisabled )\u000a			this.enable();\u000a\u000a		// Disable commands which shouldn't be enabled in this mode.\u000a		if ( this.modes && !this.modes[ editor.mode ] )\u000a			this.disable();\u000a\u000a		if ( this.fire( 'refresh', { editor: editor, path: path } ) === false )\u000a			return true;\u000a\u000a		return ( commandDefinition.refresh && commandDefinition.refresh.apply( this, arguments ) !== false );\u000a	};\u000a\u000a	var allowed;\u000a\u000a	/**\u000a	 * Checks whether this command is allowed by the active allowed\u000a	 * content filter ({@link CKEDITOR.editor#activeFilter}). This means\u000a	 * that if command implements {@link CKEDITOR.feature} interface it will be tested\u000a	 * by the {@link CKEDITOR.filter#checkFeature} method.\u000a	 *\u000a	 * @since 4.1\u000a	 * @param {Boolean} [noCache] Skip cache for example due to active filter change. Since CKEditor 4.2.\u000a	 * @returns {Boolean} Whether this command is allowed.\u000a	 */\u000a	this.checkAllowed = function( noCache ) {\u000a		if ( !noCache && typeof allowed == 'boolean' )\u000a			return allowed;\u000a\u000a		return allowed = editor.activeFilter.checkFeature( this );\u000a	};\u000a\u000a	CKEDITOR.tools.extend( this, commandDefinition, {\u000a		/**\u000a		 * The editor modes within which the command can be executed. The\u000a		 * execution will have no action if the current mode is not listed\u000a		 * in this property.\u000a		 *\u000a		 *		// Enable the command in both WYSIWYG and Source modes.\u000a		 *		command.modes = { wysiwyg:1,source:1 };\u000a		 *\u000a		 *		// Enable the command in Source mode only.\u000a		 *		command.modes = { source:1 };\u000a		 *\u000a		 * @see CKEDITOR.editor#mode\u000a		 */\u000a		modes: { wysiwyg: 1 },\u000a\u000a		/**\u000a		 * Indicates that the editor will get the focus before executing\u000a		 * the command.\u000a		 *\u000a		 *		// Do not force the editor to have focus when executing the command.\u000a		 *		command.editorFocus = false;\u000a		 *\u000a		 * @property {Boolean} [=true]\u000a		 */\u000a		editorFocus: 1,\u000a\u000a		/**\u000a		 * Indicates that this command is sensible to the selection context.\u000a		 * If `true`, the {@link CKEDITOR.command#method-refresh} method will be\u000a		 * called for this command on the {@link CKEDITOR.editor#event-selectionChange} event.\u000a		 *\u000a		 * @property {Boolean} [=false]\u000a		 */\u000a		contextSensitive: !!commandDefinition.context,\u000a\u000a		/**\u000a		 * Indicates the editor state. Possible values are:\u000a		 *\u000a		 * * {@link CKEDITOR#TRISTATE_DISABLED}: the command is\u000a		 *     disabled. It's execution will have no effect. Same as {@link #disable}.\u000a		 * * {@link CKEDITOR#TRISTATE_ON}: the command is enabled\u000a		 *     and currently active in the editor (for context sensitive commands,	for example).\u000a		 * * {@link CKEDITOR#TRISTATE_OFF}: the command is enabled\u000a		 *     and currently inactive in the editor (for context sensitive	commands, for example).\u000a		 *\u000a		 * Do not set this property directly, using the {@link #setState} method instead.\u000a		 *\u000a		 *		if ( command.state == CKEDITOR.TRISTATE_DISABLED )\u000a		 *			alert( 'This command is disabled' );\u000a		 *\u000a		 * @property {Number} [=CKEDITOR.TRISTATE_DISABLED]\u000a		 */\u000a		state: CKEDITOR.TRISTATE_DISABLED\u000a	} );\u000a\u000a	// Call the CKEDITOR.event constructor to initialize this instance.\u000a	CKEDITOR.event.call( this );\u000a};\u000a\u000aCKEDITOR.command.prototype = {\u000a	/**\u000a	 * Enables the command for execution. The command state (see\u000a	 * {@link CKEDITOR.command#property-state}) available before disabling it is restored.\u000a	 *\u000a	 *		command.enable();\u000a	 *		command.exec(); // Execute the command.\u000a	 */\u000a	enable: function() {\u000a		if ( this.state == CKEDITOR.TRISTATE_DISABLED && this.checkAllowed() )\u000a			this.setState( ( !this.preserveState || ( typeof this.previousState == 'undefined' ) ) ? CKEDITOR.TRISTATE_OFF : this.previousState );\u000a	},\u000a\u000a	/**\u000a	 * Disables the command for execution. The command state (see\u000a	 * {@link CKEDITOR.command#property-state}) will be set to {@link CKEDITOR#TRISTATE_DISABLED}.\u000a	 *\u000a	 *		command.disable();\u000a	 *		command.exec(); // "false" - Nothing happens.\u000a	 */\u000a	disable: function() {\u000a		this.setState( CKEDITOR.TRISTATE_DISABLED );\u000a	},\u000a\u000a	/**\u000a	 * Sets the command state.\u000a	 *\u000a	 *		command.setState( CKEDITOR.TRISTATE_ON );\u000a	 *		command.exec(); // Execute the command.\u000a	 *		command.setState( CKEDITOR.TRISTATE_DISABLED );\u000a	 *		command.exec(); // 'false' - Nothing happens.\u000a	 *		command.setState( CKEDITOR.TRISTATE_OFF );\u000a	 *		command.exec(); // Execute the command.\u000a	 *\u000a	 * @param {Number} newState The new state. See {@link #property-state}.\u000a	 * @returns {Boolean} Returns `true` if the command state changed.\u000a	 */\u000a	setState: function( newState ) {\u000a		// Do nothing if there is no state change.\u000a		if ( this.state == newState )\u000a			return false;\u000a\u000a		if ( newState != CKEDITOR.TRISTATE_DISABLED && !this.checkAllowed() )\u000a			return false;\u000a\u000a		this.previousState = this.state;\u000a\u000a		// Set the new state.\u000a		this.state = newState;\u000a\u000a		// Fire the "state" event, so other parts of the code can react to the\u000a		// change.\u000a		this.fire( 'state' );\u000a\u000a		return true;\u000a	},\u000a\u000a	/**\u000a	 * Toggles the on/off (active/inactive) state of the command. This is\u000a	 * mainly used internally by context sensitive commands.\u000a	 *\u000a	 *		command.toggleState();\u000a	 */\u000a	toggleState: function() {\u000a		if ( this.state == CKEDITOR.TRISTATE_OFF )\u000a			this.setState( CKEDITOR.TRISTATE_ON );\u000a		else if ( this.state == CKEDITOR.TRISTATE_ON )\u000a			this.setState( CKEDITOR.TRISTATE_OFF );\u000a	}\u000a};\u000a\u000aCKEDITOR.event.implementOn( CKEDITOR.command.prototype );\u000a\u000a/**\u000a * Indicates the previous command state.\u000a *\u000a *		alert( command.previousState );\u000a *\u000a * @property {Number} previousState\u000a * @see #state\u000a */\u000a\u000a/**\u000a * Fired when the command state changes.\u000a *\u000a *		command.on( 'state', function() {\u000a *			// Alerts the new state.\u000a *			alert( this.state );\u000a *		} );\u000a *\u000a * @event state\u000a */\u000a\u000a /**\u000a * @event refresh\u000a * @todo\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * Controls keystrokes typing in an editor instance.\u000a *\u000a * @class\u000a * @constructor Creates a keystrokeHandler class instance.\u000a * @param {CKEDITOR.editor} editor The editor instance.\u000a */\u000aCKEDITOR.keystrokeHandler = function( editor ) {\u000a	if ( editor.keystrokeHandler )\u000a		return editor.keystrokeHandler;\u000a\u000a	/**\u000a	 * A list of keystrokes associated with commands. Each entry points to the\u000a	 * command to be executed.\u000a	 *\u000a	 * Since CKEditor 4 there is no need to modify this property directly during the runtime.\u000a	 * Use {@link CKEDITOR.editor#setKeystroke} instead.\u000a	 */\u000a	this.keystrokes = {};\u000a\u000a	/**\u000a	 * A list of keystrokes that should be blocked if not defined in\u000a	 * {@link #keystrokes}. In this way it is possible to block the default\u000a	 * browser behavior for those keystrokes.\u000a	 */\u000a	this.blockedKeystrokes = {};\u000a\u000a	this._ = {\u000a		editor: editor\u000a	};\u000a\u000a	return this;\u000a};\u000a\u000a( function() {\u000a	var cancel;\u000a\u000a	var onKeyDown = function( event ) {\u000a			// The DOM event object is passed by the "data" property.\u000a			event = event.data;\u000a\u000a			var keyCombination = event.getKeystroke();\u000a			var command = this.keystrokes[ keyCombination ];\u000a			var editor = this._.editor;\u000a\u000a			cancel = ( editor.fire( 'key', { keyCode: keyCombination, domEvent: event } ) === false );\u000a\u000a			if ( !cancel ) {\u000a				if ( command ) {\u000a					var data = { from: 'keystrokeHandler' };\u000a					cancel = ( editor.execCommand( command, data ) !== false );\u000a				}\u000a\u000a				if ( !cancel )\u000a					cancel = !!this.blockedKeystrokes[ keyCombination ];\u000a			}\u000a\u000a			if ( cancel )\u000a				event.preventDefault( true );\u000a\u000a			return !cancel;\u000a		};\u000a\u000a	var onKeyPress = function( event ) {\u000a			if ( cancel ) {\u000a				cancel = false;\u000a				event.data.preventDefault( true );\u000a			}\u000a		};\u000a\u000a	CKEDITOR.keystrokeHandler.prototype = {\u000a		/**\u000a		 * Attaches this keystroke handle to a DOM object. Keystrokes typed\u000a		 * over this object will be handled by this keystrokeHandler.\u000a		 *\u000a		 * @param {CKEDITOR.dom.domObject} domObject The DOM object to attach to.\u000a		 */\u000a		attach: function( domObject ) {\u000a			// For most browsers, it is enough to listen to the keydown event\u000a			// only.\u000a			domObject.on( 'keydown', onKeyDown, this );\u000a\u000a			// Some browsers instead, don't cancel key events in the keydown, but in the\u000a			// keypress. So we must do a longer trip in those cases.\u000a			if ( CKEDITOR.env.gecko && CKEDITOR.env.mac )\u000a				domObject.on( 'keypress', onKeyPress, this );\u000a		}\u000a	};\u000a} )();\u000a\u000a/**\u000a * A list associating keystrokes with editor commands. Each element in the list\u000a * is an array where the first item is the keystroke, and the second is the\u000a * name of the command to be executed.\u000a *\u000a * This setting should be used to define (as well as to overwrite or remove) keystrokes\u000a * set by plugins (like `link` and `basicstyles`). If you want to set a keystroke\u000a * for your plugin or during the runtime, use {@link CKEDITOR.editor#setKeystroke} instead.\u000a *\u000a * Since default keystrokes are set by the {@link CKEDITOR.editor#setKeystroke}\u000a * method, by default `config.keystrokes` is an empty array.\u000a *\u000a * See {@link CKEDITOR.editor#setKeystroke} documentation for more details\u000a * regarding the start up order.\u000a *\u000a *		// Change default Ctrl+L keystroke for 'link' command to Ctrl+Shift+L.\u000a *		config.keystrokes = [\u000a *			...\u000a *			[ CKEDITOR.CTRL + CKEDITOR.SHIFT + 76, 'link' ],	// Ctrl+Shift+L\u000a *			...\u000a *		];\u000a *\u000a * To reset a particular keystroke, the following approach can be used:\u000a *\u000a *		// Disable default Ctrl+L keystroke which executes the 'link' command by default.\u000a *		config.keystrokes = [\u000a *			...\u000a *			[ CKEDITOR.CTRL + 76, null ],						// Ctrl+L\u000a *			...\u000a *		];\u000a *\u000a * In order to reset all default keystrokes, a {@link CKEDITOR#instanceReady} callback should be\u000a * used. This is since editor defaults are merged rather than overwritten by\u000a * user keystrokes.\u000a *\u000a * **Note**: This can be potentially harmful for the editor. Avoid this unless you are\u000a * aware of the consequences.\u000a *\u000a *		// Reset all default keystrokes.\u000a *		config.on.instanceReady = function() {\u000a *			this.keystrokeHandler.keystrokes = [];\u000a *		};\u000a *\u000a * @cfg {Array} [keystrokes=[]]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * Fired when any keyboard key (or a combination thereof) is pressed in the editing area.\u000a *\u000a *		editor.on( 'key', function( evt ) {\u000a *			if ( evt.data.keyCode == CKEDITOR.CTRL + 90 ) {\u000a *				// Do something...\u000a *\u000a *				// Cancel the event, so other listeners will not be executed and\u000a *				// the keydown's default behavior will be prevented.\u000a *				evt.cancel();\u000a *			}\u000a *		} );\u000a *\u000a * Usually you will want to use the {@link CKEDITOR.editor#setKeystroke} method or\u000a * the {@link CKEDITOR.config#keystrokes} option to attach a keystroke to some {@link CKEDITOR.command command}.\u000a * Key event listeners are usuful when some action should be executed conditionally, based\u000a * for example on precise selection location.\u000a *\u000a * @event key\u000a * @member CKEDITOR.editor\u000a * @param data\u000a * @param {Number} data.keyCode A number representing the key code (or a combination thereof).\u000a * It is the sum of the current key code and the {@link CKEDITOR#CTRL}, {@link CKEDITOR#SHIFT}\u000a * and {@link CKEDITOR#ALT} constants, if those are pressed.\u000a * @param {CKEDITOR.dom.event} data.domEvent A `keydown` DOM event instance. Available since CKEditor 4.4.1.\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	/**\u000a	 * Stores language-related functions.\u000a	 *\u000a	 * @class\u000a	 * @singleton\u000a	 */\u000a	CKEDITOR.lang = {\u000a		/**\u000a		 * The list of languages available in the editor core.\u000a		 *\u000a		 *		alert( CKEDITOR.lang.languages.en ); // 1\u000a		 */\u000a		languages: {\u000a			af: 1, ar: 1, bg: 1, bn: 1, bs: 1, ca: 1, cs: 1, cy: 1, da: 1, de: 1, el: 1,\u000a			'en-au': 1, 'en-ca': 1, 'en-gb': 1, en: 1, eo: 1, es: 1, et: 1, eu: 1, fa: 1, fi: 1, fo: 1,\u000a			'fr-ca': 1, fr: 1, gl: 1, gu: 1, he: 1, hi: 1, hr: 1, hu: 1, id: 1, is: 1, it: 1, ja: 1, ka: 1,\u000a			km: 1, ko: 1, ku: 1, lt: 1, lv: 1, mk: 1, mn: 1, ms: 1, nb: 1, nl: 1, no: 1, pl: 1, 'pt-br': 1,\u000a			pt: 1, ro: 1, ru: 1, si: 1, sk: 1, sl: 1, sq: 1, 'sr-latn': 1, sr: 1, sv: 1, th: 1, tr: 1, tt: 1, ug: 1,\u000a			uk: 1, vi: 1, 'zh-cn': 1, zh: 1\u000a		},\u000a\u000a		/**\u000a		 * The list of languages that are written Right-To-Left (RTL) and are supported by the editor.\u000a		 */\u000a		rtl: { ar: 1, fa: 1, he: 1, ku: 1, ug: 1 },\u000a\u000a		/**\u000a		 * Loads a specific language file, or auto detects it. A callback is\u000a		 * then called when the file gets loaded.\u000a		 *\u000a		 * @param {String} languageCode The code of the language file to be\u000a		 * loaded. If null or empty, autodetection will be performed. The\u000a		 * same happens if the language is not supported.\u000a		 * @param {String} defaultLanguage The language to be used if\u000a		 * `languageCode` is not supported or if the autodetection fails.\u000a		 * @param {Function} callback A function to be called once the\u000a		 * language file is loaded. Two parameters are passed to this\u000a		 * function: the language code and the loaded language entries.\u000a		 */\u000a		load: function( languageCode, defaultLanguage, callback ) {\u000a			// If no languageCode - fallback to browser or default.\u000a			// If languageCode - fallback to no-localized version or default.\u000a			if ( !languageCode || !CKEDITOR.lang.languages[ languageCode ] )\u000a				languageCode = this.detect( defaultLanguage, languageCode );\u000a\u000a			var that = this,\u000a				loadedCallback = function() {\u000a					that[ languageCode ].dir = that.rtl[ languageCode ] ? 'rtl' : 'ltr';\u000a					callback( languageCode, that[ languageCode ] );\u000a				};\u000a\u000a			if ( !this[ languageCode ] )\u000a				CKEDITOR.scriptLoader.load( CKEDITOR.getUrl( 'lang/' + languageCode + '.js' ), loadedCallback, this );\u000a			else\u000a				loadedCallback();\u000a		},\u000a\u000a		/**\u000a		 * Returns the language that best fits the user language. For example,\u000a		 * suppose that the user language is "pt-br". If this language is\u000a		 * supported by the editor, it is returned. Otherwise, if only "pt" is\u000a		 * supported, it is returned instead. If none of the previous are\u000a		 * supported, a default language is then returned.\u000a		 *\u000a		 *		alert( CKEDITOR.lang.detect( 'en' ) ); // e.g., in a German browser: 'de'\u000a		 *\u000a		 * @param {String} defaultLanguage The default language to be returned\u000a		 * if the user language is not supported.\u000a		 * @param {String} [probeLanguage] A language code to try to use,\u000a		 * instead of the browser-based autodetection.\u000a		 * @returns {String} The detected language code.\u000a		 */\u000a		detect: function( defaultLanguage, probeLanguage ) {\u000a			var languages = this.languages;\u000a			probeLanguage = probeLanguage || navigator.userLanguage || navigator.language || defaultLanguage;\u000a\u000a			var parts = probeLanguage.toLowerCase().match( /([a-z]+)(?:-([a-z]+))?/ ),\u000a				lang = parts[ 1 ],\u000a				locale = parts[ 2 ];\u000a\u000a			if ( languages[ lang + '-' + locale ] )\u000a				lang = lang + '-' + locale;\u000a			else if ( !languages[ lang ] )\u000a				lang = null;\u000a\u000a			CKEDITOR.lang.detect = lang ?\u000a			function() {\u000a				return lang;\u000a			} : function( defaultLanguage ) {\u000a				return defaultLanguage;\u000a			};\u000a\u000a			return lang || defaultLanguage;\u000a		}\u000a	};\u000a\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.lang} object for the English\u000a *		language. This is the base file for all translations.\u000a */\u000a\u000a/**#@+\u000a   @type String\u000a   @example\u000a*/\u000a\u000a/**\u000a * Contains the dictionary of language entries.\u000a * @namespace\u000a */\u000aCKEDITOR.lang[ 'en' ] = {\u000a	// ARIA description.\u000a	editor: 'Rich Text Editor',\u000a	editorPanel: 'Rich Text Editor panel',\u000a\u000a	// Common messages and labels.\u000a	common: {\u000a		// Screenreader titles. Please note that screenreaders are not always capable\u000a		// of reading non-English words. So be careful while translating it.\u000a		editorHelp: 'Press ALT 0 for help',\u000a\u000a		browseServer: 'Browse Server',\u000a		url: 'URL',\u000a		protocol: 'Protocol',\u000a		upload: 'Upload',\u000a		uploadSubmit: 'Send it to the Server',\u000a		image: 'Image',\u000a		flash: 'Flash',\u000a		form: 'Form',\u000a		checkbox: 'Checkbox',\u000a		radio: 'Radio Button',\u000a		textField: 'Text Field',\u000a		textarea: 'Textarea',\u000a		hiddenField: 'Hidden Field',\u000a		button: 'Button',\u000a		select: 'Selection Field',\u000a		imageButton: 'Image Button',\u000a		notSet: '<not set>',\u000a		id: 'Id',\u000a		name: 'Name',\u000a		langDir: 'Language Direction',\u000a		langDirLtr: 'Left to Right (LTR)',\u000a		langDirRtl: 'Right to Left (RTL)',\u000a		langCode: 'Language Code',\u000a		longDescr: 'Long Description URL',\u000a		cssClass: 'Stylesheet Classes',\u000a		advisoryTitle: 'Advisory Title',\u000a		cssStyle: 'Style',\u000a		ok: 'OK',\u000a		cancel: 'Cancel',\u000a		close: 'Close',\u000a		preview: 'Preview',\u000a		resize: 'Resize',\u000a		generalTab: 'General',\u000a		advancedTab: 'Advanced',\u000a		validateNumberFailed: 'This value is not a number.',\u000a		confirmNewPage: 'Any unsaved changes to this content will be lost. Are you sure you want to load new page?',\u000a		confirmCancel: 'You have changed some options. Are you sure you want to close the dialog window?',\u000a		options: 'Options',\u000a		target: 'Target',\u000a		targetNew: 'New Window (_blank)',\u000a		targetTop: 'Topmost Window (_top)',\u000a		targetSelf: 'Same Window (_self)',\u000a		targetParent: 'Parent Window (_parent)',\u000a		langDirLTR: 'Left to Right (LTR)',\u000a		langDirRTL: 'Right to Left (RTL)',\u000a		styles: 'Style',\u000a		cssClasses: 'Stylesheet Classes',\u000a		width: 'Width',\u000a		height: 'Height',\u000a		align: 'Alignment',\u000a		alignLeft: 'Left',\u000a		alignRight: 'Right',\u000a		alignCenter: 'Center',\u000a		alignJustify: 'Justify',\u000a		alignTop: 'Top',\u000a		alignMiddle: 'Middle',\u000a		alignBottom: 'Bottom',\u000a		alignNone: 'None',\u000a		invalidValue	: 'Invalid value.',\u000a		invalidHeight: 'Height must be a number.',\u000a		invalidWidth: 'Width must be a number.',\u000a		invalidCssLength: 'Value specified for the "%1" field must be a positive number with or without a valid CSS measurement unit (px, %, in, cm, mm, em, ex, pt, or pc).',\u000a		invalidHtmlLength: 'Value specified for the "%1" field must be a positive number with or without a valid HTML measurement unit (px or %).',\u000a		invalidInlineStyle: 'Value specified for the inline style must consist of one or more tuples with the format of "name : value", separated by semi-colons.',\u000a		cssLengthTooltip: 'Enter a number for a value in pixels or a number with a valid CSS unit (px, %, in, cm, mm, em, ex, pt, or pc).',\u000a\u000a		// Put the voice-only part of the label in the span.\u000a		unavailable: '%1<span class="cke_accessibility">, unavailable</span>'\u000a	}\u000a};\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.scriptLoader} object, used to load scripts\u000a *		asynchronously.\u000a */\u000a\u000a/**\u000a * Load scripts asynchronously.\u000a *\u000a * @class\u000a * @singleton\u000a */\u000aCKEDITOR.scriptLoader = ( function() {\u000a	var uniqueScripts = {},\u000a		waitingList = {};\u000a\u000a	return {\u000a		/**\u000a		 * Loads one or more external script checking if not already loaded\u000a		 * previously by this function.\u000a		 *\u000a		 *		CKEDITOR.scriptLoader.load( '/myscript.js' );\u000a		 *\u000a		 *		CKEDITOR.scriptLoader.load( '/myscript.js', function( success ) {\u000a		 *			// Alerts true if the script has been properly loaded.\u000a		 *			// HTTP error 404 should return false.\u000a		 *			alert( success );\u000a		 *		} );\u000a		 *\u000a		 *		CKEDITOR.scriptLoader.load( [ '/myscript1.js', '/myscript2.js' ], function( completed, failed ) {\u000a		 *			alert( 'Number of scripts loaded: ' + completed.length );\u000a		 *			alert( 'Number of failures: ' + failed.length );\u000a		 *		} );\u000a		 *\u000a		 * @param {String/Array} scriptUrl One or more URLs pointing to the\u000a		 * scripts to be loaded.\u000a		 * @param {Function} [callback] A function to be called when the script\u000a		 * is loaded and executed. If a string is passed to `scriptUrl`, a\u000a		 * boolean parameter is passed to the callback, indicating the\u000a		 * success of the load. If an array is passed instead, two arrays\u000a		 * parameters are passed to the callback - the first contains the\u000a		 * URLs that have been properly loaded and the second the failed ones.\u000a		 * @param {Object} [scope] The scope (`this` reference) to be used for\u000a		 * the callback call. Defaults to {@link CKEDITOR}.\u000a		 * @param {Boolean} [showBusy] Changes the cursor of the document while\u000a		 * the script is loaded.\u000a		 */\u000a		load: function( scriptUrl, callback, scope, showBusy ) {\u000a			var isString = ( typeof scriptUrl == 'string' );\u000a\u000a			if ( isString )\u000a				scriptUrl = [ scriptUrl ];\u000a\u000a			if ( !scope )\u000a				scope = CKEDITOR;\u000a\u000a			var scriptCount = scriptUrl.length,\u000a				completed = [],\u000a				failed = [];\u000a\u000a			var doCallback = function( success ) {\u000a					if ( callback ) {\u000a						if ( isString )\u000a							callback.call( scope, success );\u000a						else\u000a							callback.call( scope, completed, failed );\u000a					}\u000a				};\u000a\u000a			if ( scriptCount === 0 ) {\u000a				doCallback( true );\u000a				return;\u000a			}\u000a\u000a			var checkLoaded = function( url, success ) {\u000a					( success ? completed : failed ).push( url );\u000a\u000a					if ( --scriptCount <= 0 ) {\u000a						showBusy && CKEDITOR.document.getDocumentElement().removeStyle( 'cursor' );\u000a						doCallback( success );\u000a					}\u000a				};\u000a\u000a			var onLoad = function( url, success ) {\u000a					// Mark this script as loaded.\u000a					uniqueScripts[ url ] = 1;\u000a\u000a					// Get the list of callback checks waiting for this file.\u000a					var waitingInfo = waitingList[ url ];\u000a					delete waitingList[ url ];\u000a\u000a					// Check all callbacks waiting for this file.\u000a					for ( var i = 0; i < waitingInfo.length; i++ )\u000a						waitingInfo[ i ]( url, success );\u000a				};\u000a\u000a			var loadScript = function( url ) {\u000a					if ( uniqueScripts[ url ] ) {\u000a						checkLoaded( url, true );\u000a						return;\u000a					}\u000a\u000a					var waitingInfo = waitingList[ url ] || ( waitingList[ url ] = [] );\u000a					waitingInfo.push( checkLoaded );\u000a\u000a					// Load it only for the first request.\u000a					if ( waitingInfo.length > 1 )\u000a						return;\u000a\u000a					// Create the <script> element.\u000a					var script = new CKEDITOR.dom.element( 'script' );\u000a					script.setAttributes( {\u000a						type: 'text/javascript',\u000a						src: url\u000a					} );\u000a\u000a					if ( callback ) {\u000a						if ( CKEDITOR.env.ie && CKEDITOR.env.version < 11 ) {\u000a							// FIXME: For IE, we are not able to return false on error (like 404).\u000a							script.$.onreadystatechange = function() {\u000a								if ( script.$.readyState == 'loaded' || script.$.readyState == 'complete' ) {\u000a									script.$.onreadystatechange = null;\u000a									onLoad( url, true );\u000a								}\u000a							};\u000a						} else {\u000a							script.$.onload = function() {\u000a								// Some browsers, such as Safari, may call the onLoad function\u000a								// immediately. Which will break the loading sequence. (#3661)\u000a								setTimeout( function() {\u000a									onLoad( url, true );\u000a								}, 0 );\u000a							};\u000a\u000a							// FIXME: Opera and Safari will not fire onerror.\u000a							script.$.onerror = function() {\u000a								onLoad( url, false );\u000a							};\u000a						}\u000a					}\u000a\u000a					// Append it to <head>.\u000a					script.appendTo( CKEDITOR.document.getHead() );\u000a\u000a					CKEDITOR.fire( 'download', url ); // %REMOVE_LINE%\u000a				};\u000a\u000a			showBusy && CKEDITOR.document.getDocumentElement().setStyle( 'cursor', 'wait' );\u000a			for ( var i = 0; i < scriptCount; i++ ) {\u000a				loadScript( scriptUrl[ i ] );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Loads a script in a queue, so only one is loaded at the same time.\u000a		 *\u000a		 * @since 4.1.2\u000a		 * @param {String} scriptUrl URL pointing to the script to be loaded.\u000a		 * @param {Function} [callback] A function to be called when the script\u000a		 * is loaded and executed. A boolean parameter is passed to the callback,\u000a		 * indicating the success of the load.\u000a		 *\u000a		 * @see CKEDITOR.scriptLoader#load\u000a		 */\u000a		queue: ( function() {\u000a			var pending = [];\u000a\u000a			// Loads the very first script from queue and removes it.\u000a			function loadNext() {\u000a				var script;\u000a\u000a				if ( ( script = pending[ 0 ] ) )\u000a					this.load( script.scriptUrl, script.callback, CKEDITOR, 0 );\u000a			}\u000a\u000a			return function( scriptUrl, callback ) {\u000a				var that = this;\u000a\u000a				// This callback calls the standard callback for the script\u000a				// and loads the very next script from pending list.\u000a				function callbackWrapper() {\u000a					callback && callback.apply( this, arguments );\u000a\u000a					// Removed the just loaded script from the queue.\u000a					pending.shift();\u000a\u000a					loadNext.call( that );\u000a				}\u000a\u000a				// Let's add this script to the queue\u000a				pending.push( { scriptUrl: scriptUrl, callback: callbackWrapper } );\u000a\u000a				// If the queue was empty, then start loading.\u000a				if ( pending.length == 1 )\u000a					loadNext.call( this );\u000a			};\u000a		} )()\u000a	};\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.resourceManager} class, which is\u000a *		the base for resource managers, like plugins.\u000a */\u000a\u000a/**\u000a * Base class for resource managers, like plugins. This class is not\u000a * intended to be used out of the CKEditor core code.\u000a *\u000a * @class\u000a * @constructor Creates a resourceManager class instance.\u000a * @param {String} basePath The path for the resources folder.\u000a * @param {String} fileName The name used for resource files.\u000a */\u000aCKEDITOR.resourceManager = function( basePath, fileName ) {\u000a	/**\u000a	 * The base directory containing all resources.\u000a	 *\u000a	 * @property {String}\u000a	 */\u000a	this.basePath = basePath;\u000a\u000a	/**\u000a	 * The name used for resource files.\u000a	 *\u000a	 * @property {String}\u000a	 */\u000a	this.fileName = fileName;\u000a\u000a	/**\u000a	 * Contains references to all resources that have already been registered\u000a	 * with {@link #add}.\u000a	 */\u000a	this.registered = {};\u000a\u000a	/**\u000a	 * Contains references to all resources that have already been loaded\u000a	 * with {@link #load}.\u000a	 */\u000a	this.loaded = {};\u000a\u000a	/**\u000a	 * Contains references to all resources that have already been registered\u000a	 * with {@link #addExternal}.\u000a	 */\u000a	this.externals = {};\u000a\u000a	/**\u000a	 * @private\u000a	 */\u000a	this._ = {\u000a		// List of callbacks waiting for plugins to be loaded.\u000a		waitingList: {}\u000a	};\u000a};\u000a\u000aCKEDITOR.resourceManager.prototype = {\u000a	/**\u000a	 * Registers a resource.\u000a	 *\u000a	 *		CKEDITOR.plugins.add( 'sample', { ... plugin definition ... } );\u000a	 *\u000a	 * @param {String} name The resource name.\u000a	 * @param {Object} [definition] The resource definition.\u000a	 * @see CKEDITOR.pluginDefinition\u000a	 */\u000a	add: function( name, definition ) {\u000a		if ( this.registered[ name ] )\u000a			throw '[CKEDITOR.resourceManager.add] The resource name "' + name + '" is already registered.';\u000a\u000a		var resource = this.registered[ name ] = definition || {};\u000a		resource.name = name;\u000a		resource.path = this.getPath( name );\u000a\u000a		CKEDITOR.fire( name + CKEDITOR.tools.capitalize( this.fileName ) + 'Ready', resource );\u000a\u000a		return this.get( name );\u000a	},\u000a\u000a	/**\u000a	 * Gets the definition of a specific resource.\u000a	 *\u000a	 *		var definition = CKEDITOR.plugins.get( 'sample' );\u000a	 *\u000a	 * @param {String} name The resource name.\u000a	 * @returns {Object} The registered object.\u000a	 */\u000a	get: function( name ) {\u000a		return this.registered[ name ] || null;\u000a	},\u000a\u000a	/**\u000a	 * Get the folder path for a specific loaded resource.\u000a	 *\u000a	 *		alert( CKEDITOR.plugins.getPath( 'sample' ) ); // '<editor path>/plugins/sample/'\u000a	 *\u000a	 * @param {String} name The resource name.\u000a	 * @returns {String}\u000a	 */\u000a	getPath: function( name ) {\u000a		var external = this.externals[ name ];\u000a		return CKEDITOR.getUrl( ( external && external.dir ) || this.basePath + name + '/' );\u000a	},\u000a\u000a	/**\u000a	 * Get the file path for a specific loaded resource.\u000a	 *\u000a	 *		alert( CKEDITOR.plugins.getFilePath( 'sample' ) ); // '<editor path>/plugins/sample/plugin.js'\u000a	 *\u000a	 * @param {String} name The resource name.\u000a	 * @returns {String}\u000a	 */\u000a	getFilePath: function( name ) {\u000a		var external = this.externals[ name ];\u000a		return CKEDITOR.getUrl( this.getPath( name ) + ( external ? external.file : this.fileName + '.js' ) );\u000a	},\u000a\u000a	/**\u000a	 * Registers one or more resources to be loaded from an external path\u000a	 * instead of the core base path.\u000a	 *\u000a	 *		// Loads a plugin from '/myplugin/samples/plugin.js'.\u000a	 *		CKEDITOR.plugins.addExternal( 'sample', '/myplugins/sample/' );\u000a	 *\u000a	 *		// Loads a plugin from '/myplugin/samples/my_plugin.js'.\u000a	 *		CKEDITOR.plugins.addExternal( 'sample', '/myplugins/sample/', 'my_plugin.js' );\u000a	 *\u000a	 *		// Loads a plugin from '/myplugin/samples/my_plugin.js'.\u000a	 *		CKEDITOR.plugins.addExternal( 'sample', '/myplugins/sample/my_plugin.js', '' );\u000a	 *\u000a	 * @param {String} names The resource names, separated by commas.\u000a	 * @param {String} path The path of the folder containing the resource.\u000a	 * @param {String} [fileName] The resource file name. If not provided, the\u000a	 * default name is used. If provided with a empty string, will implicitly indicates that `path` argument\u000a	 * is already the full path.\u000a	 */\u000a	addExternal: function( names, path, fileName ) {\u000a		names = names.split( ',' );\u000a		for ( var i = 0; i < names.length; i++ ) {\u000a			var name = names[ i ];\u000a\u000a			// If "fileName" is not provided, we assume that it may be available\u000a			// in "path". Try to extract it in this case.\u000a			if ( !fileName ) {\u000a				path = path.replace( /[^\u005c/]+$/, function( match ) {\u000a					fileName = match;\u000a					return '';\u000a				} );\u000a			}\u000a\u000a			this.externals[ name ] = {\u000a				dir: path,\u000a\u000a				// Use the default file name if there is no "fileName" and it\u000a				// was not found in "path".\u000a				file: fileName || ( this.fileName + '.js' )\u000a			};\u000a		}\u000a	},\u000a\u000a	/**\u000a	 * Loads one or more resources.\u000a	 *\u000a	 *		CKEDITOR.plugins.load( 'myplugin', function( plugins ) {\u000a	 *			alert( plugins[ 'myplugin' ] ); // object\u000a	 *		} );\u000a	 *\u000a	 * @param {String/Array} name The name of the resource to load. It may be a\u000a	 * string with a single resource name, or an array with several names.\u000a	 * @param {Function} callback A function to be called when all resources\u000a	 * are loaded. The callback will receive an array containing all loaded names.\u000a	 * @param {Object} [scope] The scope object to be used for the callback call.\u000a	 */\u000a	load: function( names, callback, scope ) {\u000a		// Ensure that we have an array of names.\u000a		if ( !CKEDITOR.tools.isArray( names ) )\u000a			names = names ? [ names ] : [];\u000a\u000a		var loaded = this.loaded,\u000a			registered = this.registered,\u000a			urls = [],\u000a			urlsNames = {},\u000a			resources = {};\u000a\u000a		// Loop through all names.\u000a		for ( var i = 0; i < names.length; i++ ) {\u000a			var name = names[ i ];\u000a\u000a			if ( !name )\u000a				continue;\u000a\u000a			// If not available yet.\u000a			if ( !loaded[ name ] && !registered[ name ] ) {\u000a				var url = this.getFilePath( name );\u000a				urls.push( url );\u000a				if ( !( url in urlsNames ) )\u000a					urlsNames[ url ] = [];\u000a				urlsNames[ url ].push( name );\u000a			} else {\u000a				resources[ name ] = this.get( name );\u000a			}\u000a		}\u000a\u000a		CKEDITOR.scriptLoader.load( urls, function( completed, failed ) {\u000a			if ( failed.length ) {\u000a				throw '[CKEDITOR.resourceManager.load] Resource name "' + urlsNames[ failed[ 0 ] ].join( ',' ) +\u000a					'" was not found at "' + failed[ 0 ] + '".';\u000a			}\u000a\u000a			for ( var i = 0; i < completed.length; i++ ) {\u000a				var nameList = urlsNames[ completed[ i ] ];\u000a				for ( var j = 0; j < nameList.length; j++ ) {\u000a					var name = nameList[ j ];\u000a					resources[ name ] = this.get( name );\u000a\u000a					loaded[ name ] = 1;\u000a				}\u000a			}\u000a\u000a			callback.call( scope, resources );\u000a		}, this );\u000a	}\u000a};\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.plugins} object, which is used to\u000a *		manage plugins registration and loading.\u000a */\u000a\u000a/**\u000a * Manages plugins registration and loading.\u000a *\u000a * @class\u000a * @extends CKEDITOR.resourceManager\u000a * @singleton\u000a */\u000aCKEDITOR.plugins = new CKEDITOR.resourceManager( 'plugins/', 'plugin' );\u000a\u000a// PACKAGER_RENAME( CKEDITOR.plugins )\u000a\u000aCKEDITOR.plugins.load = CKEDITOR.tools.override( CKEDITOR.plugins.load, function( originalLoad ) {\u000a	var initialized = {};\u000a\u000a	return function( name, callback, scope ) {\u000a		var allPlugins = {};\u000a\u000a		var loadPlugins = function( names ) {\u000a				originalLoad.call( this, names, function( plugins ) {\u000a					CKEDITOR.tools.extend( allPlugins, plugins );\u000a\u000a					var requiredPlugins = [];\u000a					for ( var pluginName in plugins ) {\u000a						var plugin = plugins[ pluginName ],\u000a							requires = plugin && plugin.requires;\u000a\u000a						if ( !initialized[ pluginName ] ) {\u000a							// Register all icons eventually defined by this plugin.\u000a							if ( plugin.icons ) {\u000a								var icons = plugin.icons.split( ',' );\u000a								for ( var ic = icons.length; ic--; ) {\u000a									CKEDITOR.skin.addIcon( icons[ ic ],\u000a										plugin.path +\u000a										'icons/' +\u000a										( CKEDITOR.env.hidpi && plugin.hidpi ? 'hidpi/' : '' ) +\u000a										icons[ ic ] +\u000a										'.png' );\u000a								}\u000a							}\u000a							initialized[ pluginName ] = 1;\u000a						}\u000a\u000a						if ( requires ) {\u000a							// Trasnform it into an array, if it's not one.\u000a							if ( requires.split )\u000a								requires = requires.split( ',' );\u000a\u000a							for ( var i = 0; i < requires.length; i++ ) {\u000a								if ( !allPlugins[ requires[ i ] ] )\u000a									requiredPlugins.push( requires[ i ] );\u000a							}\u000a						}\u000a					}\u000a\u000a					if ( requiredPlugins.length )\u000a						loadPlugins.call( this, requiredPlugins );\u000a					else {\u000a						// Call the "onLoad" function for all plugins.\u000a						for ( pluginName in allPlugins ) {\u000a							plugin = allPlugins[ pluginName ];\u000a							if ( plugin.onLoad && !plugin.onLoad._called ) {\u000a								// Make it possible to return false from plugin::onLoad to disable it.\u000a								if ( plugin.onLoad() === false )\u000a									delete allPlugins[ pluginName ];\u000a\u000a								plugin.onLoad._called = 1;\u000a							}\u000a						}\u000a\u000a						// Call the callback.\u000a						if ( callback )\u000a							callback.call( scope || window, allPlugins );\u000a					}\u000a				}, this );\u000a\u000a			};\u000a\u000a		loadPlugins.call( this, name );\u000a	};\u000a} );\u000a\u000a/**\u000a * Loads a specific language file, or auto detect it. A callback is\u000a * then called when the file gets loaded.\u000a *\u000a *		CKEDITOR.plugins.setLang( 'myPlugin', 'en', {\u000a *			title: 'My plugin',\u000a *			selectOption: 'Please select an option'\u000a *		} );\u000a *\u000a * @param {String} pluginName The name of the plugin to which the provided translation\u000a * should be attached.\u000a * @param {String} languageCode The code of the language translation provided.\u000a * @param {Object} languageEntries An object that contains pairs of label and\u000a * the respective translation.\u000a */\u000aCKEDITOR.plugins.setLang = function( pluginName, languageCode, languageEntries ) {\u000a	var plugin = this.get( pluginName ),\u000a		pluginLangEntries = plugin.langEntries || ( plugin.langEntries = {} ),\u000a		pluginLang = plugin.lang || ( plugin.lang = [] );\u000a\u000a	if ( pluginLang.split )\u000a		pluginLang = pluginLang.split( ',' );\u000a\u000a	if ( CKEDITOR.tools.indexOf( pluginLang, languageCode ) == -1 )\u000a		pluginLang.push( languageCode );\u000a\u000a	pluginLangEntries[ languageCode ] = languageEntries;\u000a};\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * Contains UI features related to an editor instance.\u000a *\u000a * @class\u000a * @mixins CKEDITOR.event\u000a * @constructor Creates an ui class instance.\u000a * @param {CKEDITOR.editor} editor The editor instance.\u000a */\u000aCKEDITOR.ui = function( editor ) {\u000a	if ( editor.ui )\u000a		return editor.ui;\u000a\u000a	this.items = {};\u000a	this.instances = {};\u000a	this.editor = editor;\u000a\u000a	/**\u000a	 * Object used to hold private stuff.\u000a	 *\u000a	 * @private\u000a	 */\u000a	this._ = {\u000a		handlers: {}\u000a	};\u000a\u000a	return this;\u000a};\u000a\u000a// PACKAGER_RENAME( CKEDITOR.ui )\u000a\u000aCKEDITOR.ui.prototype = {\u000a	/**\u000a	 * Adds a UI item to the items collection. These items can be later used in\u000a	 * the interface.\u000a	 *\u000a	 *		// Add a new button named 'MyBold'.\u000a	 *		editorInstance.ui.add( 'MyBold', CKEDITOR.UI_BUTTON, {\u000a	 *			label: 'My Bold',\u000a	 *			command: 'bold'\u000a	 *		} );\u000a	 *\u000a	 * @param {String} name The UI item name.\u000a	 * @param {Object} type The item type.\u000a	 * @param {Object} definition The item definition. The properties of this\u000a	 * object depend on the item type.\u000a	 */\u000a	add: function( name, type, definition ) {\u000a		// Compensate the unique name of this ui item to definition.\u000a		definition.name = name.toLowerCase();\u000a\u000a		var item = this.items[ name ] = {\u000a			type: type,\u000a			// The name of {@link CKEDITOR.command} which associate with this UI.\u000a			command: definition.command || null,\u000a			args: Array.prototype.slice.call( arguments, 2 )\u000a		};\u000a\u000a		CKEDITOR.tools.extend( item, definition );\u000a	},\u000a\u000a	/**\u000a	 * Retrieve the created ui objects by name.\u000a	 *\u000a	 * @param {String} name The name of the UI definition.\u000a	 */\u000a	get: function( name ) {\u000a		return this.instances[ name ];\u000a	},\u000a\u000a	/**\u000a	 * Gets a UI object.\u000a	 *\u000a	 * @param {String} name The UI item hame.\u000a	 * @returns {Object} The UI element.\u000a	 */\u000a	create: function( name ) {\u000a		var item = this.items[ name ],\u000a			handler = item && this._.handlers[ item.type ],\u000a			command = item && item.command && this.editor.getCommand( item.command );\u000a\u000a		var result = handler && handler.create.apply( this, item.args );\u000a\u000a		this.instances[ name ] = result;\u000a\u000a		// Add reference inside command object.\u000a		if ( command )\u000a			command.uiItems.push( result );\u000a\u000a		if ( result && !result.type )\u000a			result.type = item.type;\u000a\u000a		return result;\u000a	},\u000a\u000a	/**\u000a	 * Adds a handler for a UI item type. The handler is responsible for\u000a	 * transforming UI item definitions in UI objects.\u000a	 *\u000a	 * @param {Object} type The item type.\u000a	 * @param {Object} handler The handler definition.\u000a	 */\u000a	addHandler: function( type, handler ) {\u000a		this._.handlers[ type ] = handler;\u000a	},\u000a\u000a	/**\u000a	 * Returns the unique DOM element that represents one editor's UI part, as\u000a	 * the editor UI is made completely decoupled from DOM (no DOM reference hold),\u000a	 * this method is mainly used to retrieve the rendered DOM part by name.\u000a	 *\u000a	 *		// Hide the bottom space in the UI.\u000a	 *		var bottom = editor.ui.getSpace( 'bottom' );\u000a	 *		bottom.setStyle( 'display', 'none' );\u000a	 *\u000a	 * @param {String} name The space name.\u000a	 * @returns {CKEDITOR.dom.element} The element that represents the space.\u000a	 */\u000a	space: function( name ) {\u000a		return CKEDITOR.document.getById( this.spaceId( name ) );\u000a	},\u000a\u000a	/**\u000a	 * Generate the HTML ID from a specific UI space name.\u000a	 *\u000a	 * @param name\u000a	 * @todo param and return types?\u000a	 */\u000a	spaceId: function( name ) {\u000a		return this.editor.id + '_' + name;\u000a	}\u000a};\u000a\u000aCKEDITOR.event.implementOn( CKEDITOR.ui );\u000a\u000a/**\u000a * Internal event fired when a new UI element is ready.\u000a *\u000a * @event ready\u000a * @param {Object} data The new element.\u000a */\u000a\u000a/**\u000a * Virtual class which just illustrates the features of handler objects to be\u000a * passed to the {@link CKEDITOR.ui#addHandler} function.\u000a * This class is not really part of the API, so don't call its constructor.\u000a *\u000a * @class CKEDITOR.ui.handlerDefinition\u000a */\u000a\u000a/**\u000a * Transforms an item definition into an UI item object.\u000a *\u000a *		editorInstance.ui.addHandler( CKEDITOR.UI_BUTTON, {\u000a *			create: function( definition ) {\u000a *				return new CKEDITOR.ui.button( definition );\u000a *			}\u000a *		} );\u000a *\u000a * @method create\u000a * @param {Object} definition The item definition.\u000a * @returns {Object} The UI element.\u000a * @todo We lack the "UI element" abstract super class.\u000a */\u000a\u000a/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	'use strict';\u000a\u000a	var DTD = CKEDITOR.dtd,\u000a		// processElement flag - means that element has been somehow modified.\u000a		FILTER_ELEMENT_MODIFIED = 1,\u000a		// processElement flag - meaning explained in CKEDITOR.FILTER_SKIP_TREE doc.\u000a		FILTER_SKIP_TREE = 2,\u000a		copy = CKEDITOR.tools.copy,\u000a		trim = CKEDITOR.tools.trim,\u000a		TEST_VALUE = 'cke-test',\u000a		enterModeTags = [ '', 'p', 'br', 'div' ];\u000a\u000a	/**\u000a	 * A flag indicating that the current element and all its ancestors\u000a	 * should not be filtered.\u000a	 *\u000a	 * See {@link CKEDITOR.filter#addElementCallback} for more details.\u000a	 *\u000a	 * @since 4.4\u000a	 * @readonly\u000a	 * @property {Number} [=2]\u000a	 * @member CKEDITOR\u000a	 */\u000a	CKEDITOR.FILTER_SKIP_TREE = FILTER_SKIP_TREE;\u000a\u000a	/**\u000a	 * Highly configurable class which implements input data filtering mechanisms\u000a	 * and core functions used for the activation of editor features.\u000a	 *\u000a	 * A filter instance is always available under the {@link CKEDITOR.editor#filter}\u000a	 * property and is used by the editor in its core features like filtering input data,\u000a	 * applying data transformations, validating whether a feature may be enabled for\u000a	 * the current setup. It may be configured in two ways:\u000a	 *\u000a	 *	* By the user, with the {@link CKEDITOR.config#allowedContent} setting.\u000a	 *	* Automatically, by loaded features (toolbar items, commands, etc.).\u000a	 *\u000a	 * In both cases additional allowed content rules may be added by\u000a	 * setting the {@link CKEDITOR.config#extraAllowedContent}\u000a	 * configuration option.\u000a	 *\u000a	 * **Note**: Filter rules will be extended with the following elements\u000a	 * depending on the {@link CKEDITOR.config#enterMode} and\u000a	 * {@link CKEDITOR.config#shiftEnterMode} settings:\u000a	 *\u000a	 *	* `'p'` &ndash; for {@link CKEDITOR#ENTER_P},\u000a	 *	* `'div'` &ndash; for {@link CKEDITOR#ENTER_DIV},\u000a	 *	* `'br'` &ndash; for {@link CKEDITOR#ENTER_BR}.\u000a	 *\u000a	 * **Read more** about the Advanced Content Filter in [guides](#!/guide/dev_advanced_content_filter).\u000a	 *\u000a	 * Filter may also be used as a standalone instance by passing\u000a	 * {@link CKEDITOR.filter.allowedContentRules} instead of {@link CKEDITOR.editor}\u000a	 * to the constructor:\u000a	 *\u000a	 *		var filter = new CKEDITOR.filter( 'b' );\u000a	 *\u000a	 *		filter.check( 'b' ); // -> true\u000a	 *		filter.check( 'i' ); // -> false\u000a	 *		filter.allow( 'i' );\u000a	 *		filter.check( 'i' ); // -> true\u000a	 *\u000a	 * @since 4.1\u000a	 * @class\u000a	 * @constructor Creates a filter class instance.\u000a	 * @param {CKEDITOR.editor/CKEDITOR.filter.allowedContentRules} editorOrRules\u000a	 */\u000a	CKEDITOR.filter = function( editorOrRules ) {\u000a		/**\u000a		 * Whether custom {@link CKEDITOR.config#allowedContent} was set.\u000a		 *\u000a		 * This property does not apply to the standalone filter.\u000a		 *\u000a		 * @readonly\u000a		 * @property {Boolean} customConfig\u000a		 */\u000a\u000a		/**\u000a		 * Array of rules added by the {@link #allow} method (including those\u000a		 * loaded from {@link CKEDITOR.config#allowedContent} and\u000a		 * {@link CKEDITOR.config#extraAllowedContent}).\u000a		 *\u000a		 * Rules in this array are in unified allowed content rules format.\u000a		 *\u000a		 * This property is useful for debugging issues with rules string parsing\u000a		 * or for checking which rules were automatically added by editor features.\u000a		 *\u000a		 * @readonly\u000a		 */\u000a		this.allowedContent = [];\u000a\u000a		/**\u000a		 * Array of rules added by the {@link #disallow} method (including those\u000a		 * loaded from {@link CKEDITOR.config#disallowedContent}).\u000a		 *\u000a		 * Rules in this array are in unified disallowed content rules format.\u000a		 *\u000a		 * This property is useful for debugging issues with rules string parsing\u000a		 * or for checking which rules were automatically added by editor features.\u000a		 *\u000a		 * @since 4.4\u000a		 * @readonly\u000a		 */\u000a		this.disallowedContent = [];\u000a\u000a		/**\u000a		 * Array of element callbacks. See {@link #addElementCallback}.\u000a		 *\u000a		 * @readonly\u000a		 * @property {Function[]} [=null]\u000a		 */\u000a		this.elementCallbacks = null;\u000a\u000a		/**\u000a		 * Whether the filter is disabled.\u000a		 *\u000a		 * To disable the filter, set {@link CKEDITOR.config#allowedContent} to `true`\u000a		 * or use the {@link #disable} method.\u000a		 *\u000a		 * @readonly\u000a		 */\u000a		this.disabled = false;\u000a\u000a		/**\u000a		 * Editor instance if not a standalone filter.\u000a		 *\u000a		 * @readonly\u000a		 * @property {CKEDITOR.editor} [=null]\u000a		 */\u000a		this.editor = null;\u000a\u000a		/**\u000a		 * Filter's unique id. It can be used to find filter instance in\u000a		 * {@link CKEDITOR.filter#instances CKEDITOR.filter.instance} object.\u000a		 *\u000a		 * @since 4.3\u000a		 * @readonly\u000a		 * @property {Number} id\u000a		 */\u000a		this.id = CKEDITOR.tools.getNextNumber();\u000a\u000a		this._ = {\u000a			// Optimized allowed content rules.\u000a			allowedRules: {\u000a				elements: {},\u000a				generic: []\u000a			},\u000a			// Optimized disallowed content rules.\u000a			disallowedRules: {\u000a				elements: {},\u000a				generic: []\u000a			},\u000a			// Object: element name => array of transformations groups.\u000a			transformations: {},\u000a			cachedTests: {}\u000a		};\u000a\u000a		// Register filter instance.\u000a		CKEDITOR.filter.instances[ this.id ] = this;\u000a\u000a		if ( editorOrRules instanceof CKEDITOR.editor ) {\u000a			var editor = this.editor = editorOrRules;\u000a			this.customConfig = true;\u000a\u000a			var allowedContent = editor.config.allowedContent;\u000a\u000a			// Disable filter completely by setting config.allowedContent = true.\u000a			if ( allowedContent === true ) {\u000a				this.disabled = true;\u000a				return;\u000a			}\u000a\u000a			if ( !allowedContent )\u000a				this.customConfig = false;\u000a\u000a			this.allow( allowedContent, 'config', 1 );\u000a			this.allow( editor.config.extraAllowedContent, 'extra', 1 );\u000a\u000a			// Enter modes should extend filter rules (ENTER_P adds 'p' rule, etc.).\u000a			this.allow( enterModeTags[ editor.enterMode ] + ' ' + enterModeTags[ editor.shiftEnterMode ], 'default', 1 );\u000a\u000a			this.disallow( editor.config.disallowedContent );\u000a		}\u000a		// Rules object passed in editorOrRules argument - initialize standalone filter.\u000a		else {\u000a			this.customConfig = false;\u000a			this.allow( editorOrRules, 'default', 1 );\u000a		}\u000a	};\u000a\u000a	/**\u000a	 * Object containing all filter instances stored under their\u000a	 * {@link #id} properties.\u000a	 *\u000a	 *		var filter = new CKEDITOR.filter( 'p' );\u000a	 *		filter === CKEDITOR.filter.instances[ filter.id ];\u000a	 *\u000a	 * @since 4.3\u000a	 * @static\u000a	 * @property instances\u000a	 */\u000a	CKEDITOR.filter.instances = {};\u000a\u000a	CKEDITOR.filter.prototype = {\u000a		/**\u000a		 * Adds allowed content rules to the filter.\u000a		 *\u000a		 * Read about rules formats in [Allowed Content Rules guide](#!/guide/dev_allowed_content_rules).\u000a		 *\u000a		 *		// Add a basic rule for custom image feature (e.g. 'MyImage' button).\u000a		 *		editor.filter.allow( 'img[!src,alt]', 'MyImage' );\u000a		 *\u000a		 *		// Add rules for two header styles allowed by 'HeadersCombo'.\u000a		 *		var header1Style = new CKEDITOR.style( { element: 'h1' } ),\u000a		 *			header2Style = new CKEDITOR.style( { element: 'h2' } );\u000a		 *		editor.filter.allow( [ header1Style, header2Style ], 'HeadersCombo' );\u000a		 *\u000a		 * @param {CKEDITOR.filter.allowedContentRules} newRules Rule(s) to be added.\u000a		 * @param {String} [featureName] Name of a feature that allows this content (most often plugin/button/command name).\u000a		 * @param {Boolean} [overrideCustom] By default this method will reject any rules\u000a		 * if {@link CKEDITOR.config#allowedContent} is defined to avoid overriding it.\u000a		 * Pass `true` to force rules addition.\u000a		 * @returns {Boolean} Whether the rules were accepted.\u000a		 */\u000a		allow: function( newRules, featureName, overrideCustom ) {\u000a			// Check arguments and constraints. Clear cache.\u000a			if ( !beforeAddingRule( this, newRules, overrideCustom ) )\u000a				return false;\u000a\u000a			var i, ret;\u000a\u000a			if ( typeof newRules == 'string' )\u000a				newRules = parseRulesString( newRules );\u000a			else if ( newRules instanceof CKEDITOR.style ) {\u000a				// If style has the cast method defined, use it and abort.\u000a				if ( newRules.toAllowedContentRules )\u000a					return this.allow( newRules.toAllowedContentRules( this.editor ), featureName, overrideCustom );\u000a\u000a				newRules = convertStyleToRules( newRules );\u000a			} else if ( CKEDITOR.tools.isArray( newRules ) ) {\u000a				for ( i = 0; i < newRules.length; ++i )\u000a					ret = this.allow( newRules[ i ], featureName, overrideCustom );\u000a				return ret; // Return last status.\u000a			}\u000a\u000a			addAndOptimizeRules( this, newRules, featureName, this.allowedContent, this._.allowedRules );\u000a\u000a			return true;\u000a		},\u000a\u000a		/**\u000a		 * Applies this filter to passed {@link CKEDITOR.htmlParser.fragment} or {@link CKEDITOR.htmlParser.element}.\u000a		 * The result of filtering is a DOM tree without disallowed content.\u000a		 *\u000a		 *			// Create standalone filter passing 'p' and 'b' elements.\u000a		 *		var filter = new CKEDITOR.filter( 'p b' ),\u000a		 *			// Parse HTML string to pseudo DOM structure.\u000a		 *			fragment = CKEDITOR.htmlParser.fragment.fromHtml( '<p><b>foo</b> <i>bar</i></p>' ),\u000a		 *			writer = new CKEDITOR.htmlParser.basicWriter();\u000a		 *\u000a		 *		filter.applyTo( fragment );\u000a		 *		fragment.writeHtml( writer );\u000a		 *		writer.getHtml(); // -> '<p><b>foo</b> bar</p>'\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.fragment/CKEDITOR.htmlParser.element} fragment Node to be filtered.\u000a		 * @param {Boolean} [toHtml] Set to `true` if the filter is used together with {@link CKEDITOR.htmlDataProcessor#toHtml}.\u000a		 * @param {Boolean} [transformOnly] If set to `true` only transformations will be applied. Content\u000a		 * will not be filtered with allowed content rules.\u000a		 * @param {Number} [enterMode] Enter mode used by the filter when deciding how to strip disallowed element.\u000a		 * Defaults to {@link CKEDITOR.editor#activeEnterMode} for a editor's filter or to {@link CKEDITOR#ENTER_P} for standalone filter.\u000a		 * @returns {Boolean} Whether some part of the `fragment` was removed by the filter.\u000a		 */\u000a		applyTo: function( fragment, toHtml, transformOnly, enterMode ) {\u000a			if ( this.disabled )\u000a				return false;\u000a\u000a			var that = this,\u000a				toBeRemoved = [],\u000a				protectedRegexs = this.editor && this.editor.config.protectedSource,\u000a				processRetVal,\u000a				isModified = false,\u000a				filterOpts = {\u000a					doFilter: !transformOnly,\u000a					doTransform: true,\u000a					doCallbacks: true,\u000a					toHtml: toHtml\u000a				};\u000a\u000a			// Filter all children, skip root (fragment or editable-like wrapper used by data processor).\u000a			fragment.forEach( function( el ) {\u000a				if ( el.type == CKEDITOR.NODE_ELEMENT ) {\u000a					// Do not filter element with data-cke-filter="off" and all their descendants.\u000a					if ( el.attributes[ 'data-cke-filter' ] == 'off' )\u000a						return false;\u000a\u000a					// (#10260) Don't touch elements like spans with data-cke-* attribute since they're\u000a					// responsible e.g. for placing markers, bookmarks, odds and stuff.\u000a					// We love 'em and we don't wanna lose anything during the filtering.\u000a					// '|' is to avoid tricky joints like data-="foo" + cke-="bar". Yes, they're possible.\u000a					//\u000a					// NOTE: data-cke-* assigned elements are preserved only when filter is used with\u000a					//       htmlDataProcessor.toHtml because we don't want to protect them when outputting data\u000a					//       (toDataFormat).\u000a					if ( toHtml && el.name == 'span' && ~CKEDITOR.tools.objectKeys( el.attributes ).join( '|' ).indexOf( 'data-cke-' ) )\u000a						return;\u000a\u000a					processRetVal = processElement( that, el, toBeRemoved, filterOpts );\u000a					if ( processRetVal & FILTER_ELEMENT_MODIFIED )\u000a						isModified = true;\u000a					else if ( processRetVal & FILTER_SKIP_TREE )\u000a						return false;\u000a				}\u000a				else if ( el.type == CKEDITOR.NODE_COMMENT && el.value.match( /^\u005c{cke_protected\u005c}(?!\u005c{C\u005c})/ ) ) {\u000a					if ( !processProtectedElement( that, el, protectedRegexs, filterOpts ) )\u000a						toBeRemoved.push( el );\u000a				}\u000a			}, null, true );\u000a\u000a			if ( toBeRemoved.length )\u000a				isModified = true;\u000a\u000a			var node, element, check,\u000a				toBeChecked = [],\u000a				enterTag = enterModeTags[ enterMode || ( this.editor ? this.editor.enterMode : CKEDITOR.ENTER_P ) ];\u000a\u000a			// Remove elements in reverse order - from leaves to root, to avoid conflicts.\u000a			while ( ( node = toBeRemoved.pop() ) ) {\u000a				if ( node.type == CKEDITOR.NODE_ELEMENT )\u000a					removeElement( node, enterTag, toBeChecked );\u000a				// This is a comment securing rejected element - remove it completely.\u000a				else\u000a					node.remove();\u000a			}\u000a\u000a			// Check elements that have been marked as possibly invalid.\u000a			while ( ( check = toBeChecked.pop() ) ) {\u000a				element = check.el;\u000a				// Element has been already removed.\u000a				if ( !element.parent )\u000a					continue;\u000a\u000a				switch ( check.check ) {\u000a					// Check if element itself is correct.\u000a					case 'it':\u000a						// Check if element included in $removeEmpty has no children.\u000a						if ( DTD.$removeEmpty[ element.name ] && !element.children.length )\u000a							removeElement( element, enterTag, toBeChecked );\u000a						// Check if that is invalid element.\u000a						else if ( !validateElement( element ) )\u000a							removeElement( element, enterTag, toBeChecked );\u000a						break;\u000a\u000a					// Check if element is in correct context. If not - remove element.\u000a					case 'el-up':\u000a						// Check if e.g. li is a child of body after ul has been removed.\u000a						if ( element.parent.type != CKEDITOR.NODE_DOCUMENT_FRAGMENT &&\u000a							!DTD[ element.parent.name ][ element.name ]\u000a						)\u000a							removeElement( element, enterTag, toBeChecked );\u000a						break;\u000a\u000a					// Check if element is in correct context. If not - remove parent.\u000a					case 'parent-down':\u000a						if ( element.parent.type != CKEDITOR.NODE_DOCUMENT_FRAGMENT &&\u000a							!DTD[ element.parent.name ][ element.name ]\u000a						)\u000a							removeElement( element.parent, enterTag, toBeChecked );\u000a						break;\u000a				}\u000a			}\u000a\u000a			return isModified;\u000a		},\u000a\u000a		/**\u000a		 * Checks whether a {@link CKEDITOR.feature} can be enabled. Unlike {@link #addFeature},\u000a		 * this method always checks the feature, even when the default configuration\u000a		 * for {@link CKEDITOR.config#allowedContent} is used.\u000a		 *\u000a		 *		// TODO example\u000a		 *\u000a		 * @param {CKEDITOR.feature} feature The feature to be tested.\u000a		 * @returns {Boolean} Whether this feature can be enabled.\u000a		 */\u000a		checkFeature: function( feature ) {\u000a			if ( this.disabled )\u000a				return true;\u000a\u000a			if ( !feature )\u000a				return true;\u000a\u000a			// Some features may want to register other features.\u000a			// E.g. a button may return a command bound to it.\u000a			if ( feature.toFeature )\u000a				feature = feature.toFeature( this.editor );\u000a\u000a			return !feature.requiredContent || this.check( feature.requiredContent );\u000a		},\u000a\u000a		/**\u000a		 * Disables Advanced Content Filter.\u000a		 *\u000a		 * This method is meant to be used by plugins which are not\u000a		 * compatible with the filter and in other cases in which the filter\u000a		 * has to be disabled during the initialization phase or runtime.\u000a		 *\u000a		 * In other cases the filter can be disabled by setting\u000a		 * {@link CKEDITOR.config#allowedContent} to `true`.\u000a		 */\u000a		disable: function() {\u000a			this.disabled = true;\u000a		},\u000a\u000a		/**\u000a		 * Adds disallowed content rules to the filter.\u000a		 *\u000a		 * Read about rules formats in the [Allowed Content Rules guide](#!/guide/dev_allowed_content_rules).\u000a		 *\u000a		 *		// Disallow all styles on the image elements.\u000a		 *		editor.filter.disallow( 'img{*}' );\u000a		 *\u000a		 *		// Disallow all span and div elements.\u000a		 *		editor.filter.disallow( 'span div' );\u000a		 *\u000a		 * @since 4.4\u000a		 * @param {CKEDITOR.filter.disallowedContentRules} newRules Rule(s) to be added.\u000a		 */\u000a		disallow: function( newRules ) {\u000a			// Check arguments and constraints. Clear cache.\u000a			// Note: we pass true in the 3rd argument, because disallow() should never\u000a			// be blocked by custom configuration.\u000a			if ( !beforeAddingRule( this, newRules, true ) )\u000a				return false;\u000a\u000a			if ( typeof newRules == 'string' )\u000a				newRules = parseRulesString( newRules );\u000a\u000a			addAndOptimizeRules( this, newRules, null, this.disallowedContent, this._.disallowedRules );\u000a\u000a			return true;\u000a		},\u000a\u000a		/**\u000a		 * Adds an array of {@link CKEDITOR.feature} content forms. All forms\u000a		 * will then be transformed to the first form which is allowed by the filter.\u000a		 *\u000a		 *		editor.filter.allow( 'i; span{!font-style}' );\u000a		 *		editor.filter.addContentForms( [\u000a		 *			'em',\u000a		 *			'i',\u000a		 *			[ 'span', function( el ) {\u000a		 *				return el.styles[ 'font-style' ] == 'italic';\u000a		 *			} ]\u000a		 *		] );\u000a		 *		// Now <em> and <span style="font-style:italic"> will be replaced with <i>\u000a		 *		// because this is the first allowed form.\u000a		 *		// <span> is allowed too, but it is the last form and\u000a		 *		// additionaly, the editor cannot transform an element based on\u000a		 *		// the array+function form).\u000a		 *\u000a		 * This method is used by the editor to register {@link CKEDITOR.feature#contentForms}\u000a		 * when adding a feature with {@link #addFeature} or {@link CKEDITOR.editor#addFeature}.\u000a		 *\u000a		 * @param {Array} forms The content forms of a feature.\u000a		 */\u000a		addContentForms: function( forms ) {\u000a			if ( this.disabled )\u000a				return;\u000a\u000a			if ( !forms )\u000a				return;\u000a\u000a			var i, form,\u000a				transfGroups = [],\u000a				preferredForm;\u000a\u000a			// First, find preferred form - this is, first allowed.\u000a			for ( i = 0; i < forms.length && !preferredForm; ++i ) {\u000a				form = forms[ i ];\u000a\u000a				// Check only strings and styles - array format isn't supported by #check().\u000a				if ( ( typeof form == 'string' || form instanceof CKEDITOR.style ) && this.check( form ) )\u000a					preferredForm = form;\u000a			}\u000a\u000a			// This feature doesn't have preferredForm, so ignore it.\u000a			if ( !preferredForm )\u000a				return;\u000a\u000a			for ( i = 0; i < forms.length; ++i )\u000a				transfGroups.push( getContentFormTransformationGroup( forms[ i ], preferredForm ) );\u000a\u000a			this.addTransformations( transfGroups );\u000a		},\u000a\u000a		/**\u000a		 * Adds a callback which will be executed on every element\u000a		 * that the filter reaches when filtering, before the element is filtered.\u000a		 *\u000a		 * By returning {@link CKEDITOR#FILTER_SKIP_TREE} it is possible to\u000a		 * skip filtering of the current element and all its ancestors.\u000a		 *\u000a		 *		editor.filter.addElementCallback( function( el ) {\u000a		 *			if ( el.hasClass( 'protected' ) )\u000a		 *				return CKEDITOR.FILTER_SKIP_TREE;\u000a		 *		} );\u000a		 *\u000a		 * **Note:** At this stage the element passed to the callback does not\u000a		 * contain `attributes`, `classes`, and `styles` properties which are available\u000a		 * temporarily on later stages of the filtering process. Therefore you need to\u000a		 *  use the pure {@link CKEDITOR.htmlParser.element} interface.\u000a		 *\u000a		 * @since 4.4\u000a		 * @param {Function} callback The callback to be executed.\u000a		 */\u000a		addElementCallback: function( callback ) {\u000a			// We want to keep it a falsy value, to speed up finding whether there are any callbacks.\u000a			if ( !this.elementCallbacks )\u000a				this.elementCallbacks = [];\u000a\u000a			this.elementCallbacks.push( callback );\u000a		},\u000a\u000a		/**\u000a		 * Checks whether a feature can be enabled for the HTML restrictions in place\u000a		 * for the current CKEditor instance, based on the HTML code the feature might\u000a		 * generate and the minimal HTML code the feature needs to be able to generate.\u000a		 *\u000a		 *		// TODO example\u000a		 *\u000a		 * @param {CKEDITOR.feature} feature\u000a		 * @returns {Boolean} Whether this feature can be enabled.\u000a		 */\u000a		addFeature: function( feature ) {\u000a			if ( this.disabled )\u000a				return true;\u000a\u000a			if ( !feature )\u000a				return true;\u000a\u000a			// Some features may want to register other features.\u000a			// E.g. a button may return a command bound to it.\u000a			if ( feature.toFeature )\u000a				feature = feature.toFeature( this.editor );\u000a\u000a			// If default configuration (will be checked inside #allow()),\u000a			// then add allowed content rules.\u000a			this.allow( feature.allowedContent, feature.name );\u000a\u000a			this.addTransformations( feature.contentTransformations );\u000a			this.addContentForms( feature.contentForms );\u000a\u000a			// If custom configuration or any DACRs, then check if required content is allowed.\u000a			if ( feature.requiredContent && ( this.customConfig || this.disallowedContent.length ) )\u000a				return this.check( feature.requiredContent );\u000a\u000a			return true;\u000a		},\u000a\u000a		/**\u000a		 * Adds an array of content transformation groups. One group\u000a		 * may contain many transformation rules, but only the first\u000a		 * matching rule in a group is executed.\u000a		 *\u000a		 * A single transformation rule is an object with four properties:\u000a		 *\u000a		 *	* `check` (optional) &ndash; if set and {@link CKEDITOR.filter} does\u000a		 *		not accept this {@link CKEDITOR.filter.contentRule}, this transformation rule\u000a		 *		will not be executed (it does not *match*). This value is passed\u000a		 *		to {@link #check}.\u000a		 *	* `element` (optional) &ndash; this string property tells the filter on which\u000a		 *		element this transformation can be run. It is optional, because\u000a		 *		the element name can be obtained from `check` (if it is a String format)\u000a		 *		or `left` (if it is a {@link CKEDITOR.style} instance).\u000a		 *	* `left` (optional) &ndash; a function accepting an element or a {@link CKEDITOR.style}\u000a		 *		instance verifying whether the transformation should be\u000a		 *		executed on this specific element. If it returns `false` or if an element\u000a		 *		does not match this style, this transformation rule does not *match*.\u000a		 *	* `right` &ndash; a function accepting an element and {@link CKEDITOR.filter.transformationsTools}\u000a		 *		or a string containing the name of the {@link CKEDITOR.filter.transformationsTools} method\u000a		 *		that should be called on an element.\u000a		 *\u000a		 * A shorthand format is also available. A transformation rule can be defined by\u000a		 * a single string `'check:right'`. The string before `':'` will be used as\u000a		 * the `check` property and the second part as the `right` property.\u000a		 *\u000a		 * Transformation rules can be grouped. The filter will try to apply\u000a		 * the first rule in a group. If it *matches*, the filter will ignore subsequent rules and\u000a		 * will move to the next group. If it does not *match*, the next rule will be checked.\u000a		 *\u000a		 * Examples:\u000a		 *\u000a		 *		editor.filter.addTransformations( [\u000a		 *			// First group.\u000a		 *			[\u000a		 *				// First rule. If table{width} is allowed, it\u000a		 *				// executes {@link CKEDITOR.filter.transformationsTools#sizeToStyle} on a table element.\u000a		 *				'table{width}: sizeToStyle',\u000a		 *				// Second rule should not be executed if the first was.\u000a		 *				'table[width]: sizeToAttribute'\u000a		 *			],\u000a		 *			// Second group.\u000a		 *			[\u000a		 *				// This rule will add the foo="1" attribute to all images that\u000a		 *				// do not have it.\u000a		 *				{\u000a		 *					element: 'img',\u000a		 *					left: function( el ) {\u000a		 *						return !el.attributes.foo;\u000a		 *					},\u000a		 *					right: function( el, tools ) {\u000a		 *						el.attributes.foo = '1';\u000a		 *					}\u000a		 *				}\u000a		 *			]\u000a		 *		] );\u000a		 *\u000a		 *		// Case 1:\u000a		 *		// config.allowedContent = 'table{height,width}; tr td'.\u000a		 *		//\u000a		 *		// '<table style="height:100px; width:200px">...</table>'		-> '<table style="height:100px; width:200px">...</table>'\u000a		 *		// '<table height="100" width="200">...</table>'				-> '<table style="height:100px; width:200px">...</table>'\u000a		 *\u000a		 *		// Case 2:\u000a		 *		// config.allowedContent = 'table[height,width]; tr td'.\u000a		 *		//\u000a		 *		// '<table style="height:100px; width:200px">...</table>'		-> '<table height="100" width="200">...</table>'\u000a		 *		// '<table height="100" width="200">...</table>'				-> '<table height="100" width="200"">...</table>'\u000a		 *\u000a		 *		// Case 3:\u000a		 *		// config.allowedContent = 'table{width,height}[height,width]; tr td'.\u000a		 *		//\u000a		 *		// '<table style="height:100px; width:200px">...</table>'		-> '<table style="height:100px; width:200px">...</table>'\u000a		 *		// '<table height="100" width="200">...</table>'				-> '<table style="height:100px; width:200px">...</table>'\u000a		 *		//\u000a		 *		// Note: Both forms are allowed (size set by style and by attributes), but only\u000a		 *		// the first transformation is applied &mdash; the size is always transformed to a style.\u000a		 *		// This is because only the first transformation matching allowed content rules is applied.\u000a		 *\u000a		 * This method is used by the editor to add {@link CKEDITOR.feature#contentTransformations}\u000a		 * when adding a feature by {@link #addFeature} or {@link CKEDITOR.editor#addFeature}.\u000a		 *\u000a		 * @param {Array} transformations\u000a		 */\u000a		addTransformations: function( transformations ) {\u000a			if ( this.disabled )\u000a				return;\u000a\u000a			if ( !transformations )\u000a				return;\u000a\u000a			var optimized = this._.transformations,\u000a				group, i;\u000a\u000a			for ( i = 0; i < transformations.length; ++i ) {\u000a				group = optimizeTransformationsGroup( transformations[ i ] );\u000a\u000a				if ( !optimized[ group.name ] )\u000a					optimized[ group.name ] = [];\u000a\u000a				optimized[ group.name ].push( group.rules );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Checks whether the content defined in the `test` argument is allowed\u000a		 * by this filter.\u000a		 *\u000a		 * If `strictCheck` is set to `false` (default value), this method checks\u000a		 * if all parts of the `test` (styles, attributes, and classes) are\u000a		 * accepted by the filter. If `strictCheck` is set to `true`, the test\u000a		 * must also contain the required attributes, styles, and classes.\u000a		 *\u000a		 * For example:\u000a		 *\u000a		 *		// Rule: 'img[!src,alt]'.\u000a		 *		filter.check( 'img[alt]' ); // -> true\u000a		 *		filter.check( 'img[alt]', true, true ); // -> false\u000a		 *\u000a		 * Second `check()` call returned `false` because `src` is required.\u000a		 *\u000a		 * **Note:** The `test` argument is of {@link CKEDITOR.filter.contentRule} type, which is\u000a		 * a limited version of {@link CKEDITOR.filter.allowedContentRules}. Read more about it\u000a		 * in the {@link CKEDITOR.filter.contentRule}'s documentation.\u000a		 *\u000a		 * @param {CKEDITOR.filter.contentRule} test\u000a		 * @param {Boolean} [applyTransformations=true] Whether to use registered transformations.\u000a		 * @param {Boolean} [strictCheck] Whether the filter should check if an element with exactly\u000a		 * these properties is allowed.\u000a		 * @returns {Boolean} Returns `true` if the content is allowed.\u000a		 */\u000a		check: function( test, applyTransformations, strictCheck ) {\u000a			if ( this.disabled )\u000a				return true;\u000a\u000a			// If rules are an array, expand it and return the logical OR value of\u000a			// the rules.\u000a			if ( CKEDITOR.tools.isArray( test ) ) {\u000a				for ( var i = test.length ; i-- ; ) {\u000a					if ( this.check( test[ i ], applyTransformations, strictCheck ) )\u000a						return true;\u000a				}\u000a				return false;\u000a			}\u000a\u000a			var element, result, cacheKey;\u000a\u000a			if ( typeof test == 'string' ) {\u000a				cacheKey = test + '<' + ( applyTransformations === false ? '0' : '1' ) + ( strictCheck ? '1' : '0' ) + '>';\u000a\u000a				// Check if result of this check hasn't been already cached.\u000a				if ( cacheKey in this._.cachedChecks )\u000a					return this._.cachedChecks[ cacheKey ];\u000a\u000a				// Create test element from string.\u000a				element = mockElementFromString( test );\u000a			} else {\u000a				// Create test element from CKEDITOR.style.\u000a				element = mockElementFromStyle( test );\u000a			}\u000a\u000a			// Make a deep copy.\u000a			var clone = CKEDITOR.tools.clone( element ),\u000a				toBeRemoved = [],\u000a				transformations;\u000a\u000a			// Apply transformations to original element.\u000a			// Transformations will be applied to clone by the filter function.\u000a			if ( applyTransformations !== false && ( transformations = this._.transformations[ element.name ] ) ) {\u000a				for ( i = 0; i < transformations.length; ++i )\u000a					applyTransformationsGroup( this, element, transformations[ i ] );\u000a\u000a				// Transformations could modify styles or classes, so they need to be copied\u000a				// to attributes object.\u000a				updateAttributes( element );\u000a			}\u000a\u000a			// Filter clone of mocked element.\u000a			processElement( this, clone, toBeRemoved, {\u000a				doFilter: true,\u000a				doTransform: applyTransformations !== false,\u000a				skipRequired: !strictCheck,\u000a				skipFinalValidation: !strictCheck\u000a			} );\u000a\u000a			// Element has been marked for removal.\u000a			if ( toBeRemoved.length > 0 ) {\u000a				result = false;\u000a			// Compare only left to right, because clone may be only trimmed version of original element.\u000a			} else if ( !CKEDITOR.tools.objectCompare( element.attributes, clone.attributes, true ) ) {\u000a				result = false;\u000a			} else {\u000a				result = true;\u000a			}\u000a\u000a			// Cache result of this test - we can build cache only for string tests.\u000a			if ( typeof test == 'string' )\u000a				this._.cachedChecks[ cacheKey ] = result;\u000a\u000a			return result;\u000a		},\u000a\u000a		/**\u000a		 * Returns first enter mode allowed by this filter rules. Modes are checked in `p`, `div`, `br` order.\u000a		 * If none of tags is allowed this method will return {@link CKEDITOR#ENTER_BR}.\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {Number} defaultMode The default mode which will be checked as the first one.\u000a		 * @param {Boolean} [reverse] Whether to check modes in reverse order (used for shift enter mode).\u000a		 * @returns {Number} Allowed enter mode.\u000a		 */\u000a		getAllowedEnterMode: ( function() {\u000a			var tagsToCheck = [ 'p', 'div', 'br' ],\u000a				enterModes = {\u000a					p: CKEDITOR.ENTER_P,\u000a					div: CKEDITOR.ENTER_DIV,\u000a					br: CKEDITOR.ENTER_BR\u000a				};\u000a\u000a			return function( defaultMode, reverse ) {\u000a				// Clone the array first.\u000a				var tags = tagsToCheck.slice(),\u000a					tag;\u000a\u000a				// Check the default mode first.\u000a				if ( this.check( enterModeTags[ defaultMode ] ) )\u000a					return defaultMode;\u000a\u000a				// If not reverse order, reverse array so we can pop() from it.\u000a				if ( !reverse )\u000a					tags = tags.reverse();\u000a\u000a				while ( ( tag = tags.pop() ) ) {\u000a					if ( this.check( tag ) )\u000a						return enterModes[ tag ];\u000a				}\u000a\u000a				return CKEDITOR.ENTER_BR;\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Destroys the filter instance and removes it from the global {@link CKEDITOR.filter#instances} object.\u000a		 *\u000a		 * @since 4.4.5\u000a		 */\u000a		destroy: function() {\u000a			delete CKEDITOR.filter.instances[ this.id ];\u000a			// Deleting reference to filter instance should be enough,\u000a			// but since these are big objects it's safe to clean them up too.\u000a			delete this._;\u000a			delete this.allowedContent;\u000a			delete this.disallowedContent;\u000a		}\u000a	};\u000a\u000a	function addAndOptimizeRules( that, newRules, featureName, standardizedRules, optimizedRules ) {\u000a		var groupName, rule,\u000a			rulesToOptimize = [];\u000a\u000a		for ( groupName in newRules ) {\u000a			rule = newRules[ groupName ];\u000a\u000a			// { 'p h1': true } => { 'p h1': {} }.\u000a			if ( typeof rule == 'boolean' )\u000a				rule = {};\u000a			// { 'p h1': func } => { 'p h1': { match: func } }.\u000a			else if ( typeof rule == 'function' )\u000a				rule = { match: rule };\u000a			// Clone (shallow) rule, because we'll modify it later.\u000a			else\u000a				rule = copy( rule );\u000a\u000a			// If this is not an unnamed rule ({ '$1' => { ... } })\u000a			// move elements list to property.\u000a			if ( groupName.charAt( 0 ) != '$' )\u000a				rule.elements = groupName;\u000a\u000a			if ( featureName )\u000a				rule.featureName = featureName.toLowerCase();\u000a\u000a			standardizeRule( rule );\u000a\u000a			// Save rule and remember to optimize it.\u000a			standardizedRules.push( rule );\u000a			rulesToOptimize.push( rule );\u000a		}\u000a\u000a		optimizeRules( optimizedRules, rulesToOptimize );\u000a	}\u000a\u000a	// Apply ACR to an element.\u000a	// @param rule\u000a	// @param element\u000a	// @param status Object containing status of element's filtering.\u000a	// @param {Boolean} skipRequired If true don't check if element has all required properties.\u000a	function applyAllowedRule( rule, element, status, skipRequired ) {\u000a		// This rule doesn't match this element - skip it.\u000a		if ( rule.match && !rule.match( element ) )\u000a			return;\u000a\u000a		// If element doesn't have all required styles/attrs/classes\u000a		// this rule doesn't match it.\u000a		if ( !skipRequired && !hasAllRequired( rule, element ) )\u000a			return;\u000a\u000a		// If this rule doesn't validate properties only mark element as valid.\u000a		if ( !rule.propertiesOnly )\u000a			status.valid = true;\u000a\u000a		// Apply rule only when all attrs/styles/classes haven't been marked as valid.\u000a		if ( !status.allAttributes )\u000a			status.allAttributes = applyAllowedRuleToHash( rule.attributes, element.attributes, status.validAttributes );\u000a\u000a		if ( !status.allStyles )\u000a			status.allStyles = applyAllowedRuleToHash( rule.styles, element.styles, status.validStyles );\u000a\u000a		if ( !status.allClasses )\u000a			status.allClasses = applyAllowedRuleToArray( rule.classes, element.classes, status.validClasses );\u000a	}\u000a\u000a	// Apply itemsRule to items (only classes are kept in array).\u000a	// Push accepted items to validItems array.\u000a	// Return true when all items are valid.\u000a	function applyAllowedRuleToArray( itemsRule, items, validItems ) {\u000a		if ( !itemsRule )\u000a			return false;\u000a\u000a		// True means that all elements of array are accepted (the asterix was used for classes).\u000a		if ( itemsRule === true )\u000a			return true;\u000a\u000a		for ( var i = 0, l = items.length, item; i < l; ++i ) {\u000a			item = items[ i ];\u000a			if ( !validItems[ item ] )\u000a				validItems[ item ] = itemsRule( item );\u000a		}\u000a\u000a		return false;\u000a	}\u000a\u000a	function applyAllowedRuleToHash( itemsRule, items, validItems ) {\u000a		if ( !itemsRule )\u000a			return false;\u000a\u000a		if ( itemsRule === true )\u000a			return true;\u000a\u000a		for ( var name in items ) {\u000a			if ( !validItems[ name ] )\u000a				validItems[ name ] = itemsRule( name );\u000a		}\u000a\u000a		return false;\u000a	}\u000a\u000a	// Apply DACR rule to an element.\u000a	function applyDisallowedRule( rule, element, status ) {\u000a		// This rule doesn't match this element - skip it.\u000a		if ( rule.match && !rule.match( element ) )\u000a			return;\u000a\u000a		// No properties - it's an element only rule so it disallows entire element.\u000a		// Early return is handled in filterElement.\u000a		if ( rule.noProperties )\u000a			return false;\u000a\u000a		// Apply rule to attributes, styles and classes. Switch hadInvalid* to true if method returned true.\u000a		status.hadInvalidAttribute = applyDisallowedRuleToHash( rule.attributes, element.attributes ) || status.hadInvalidAttribute;\u000a		status.hadInvalidStyle = applyDisallowedRuleToHash( rule.styles, element.styles ) || status.hadInvalidStyle;\u000a		status.hadInvalidClass = applyDisallowedRuleToArray( rule.classes, element.classes ) || status.hadInvalidClass;\u000a	}\u000a\u000a	// Apply DACR to items (only classes are kept in array).\u000a	// @returns {Boolean} True if at least one of items was invalid (disallowed).\u000a	function applyDisallowedRuleToArray( itemsRule, items ) {\u000a		if ( !itemsRule )\u000a			return false;\u000a\u000a		var hadInvalid = false,\u000a			allDisallowed = itemsRule === true;\u000a\u000a		for ( var i = items.length; i--; ) {\u000a			if ( allDisallowed || itemsRule( items[ i ] ) ) {\u000a				items.splice( i, 1 );\u000a				hadInvalid = true;\u000a			}\u000a		}\u000a\u000a		return hadInvalid;\u000a	}\u000a\u000a	// Apply DACR to items (styles and attributes).\u000a	// @returns {Boolean} True if at least one of items was invalid (disallowed).\u000a	function applyDisallowedRuleToHash( itemsRule, items ) {\u000a		if ( !itemsRule )\u000a			return false;\u000a\u000a		var hadInvalid = false,\u000a			allDisallowed = itemsRule === true;\u000a\u000a		for ( var name in items ) {\u000a			if ( allDisallowed || itemsRule( name ) ) {\u000a				delete items[ name ];\u000a				hadInvalid = true;\u000a			}\u000a		}\u000a\u000a		return hadInvalid;\u000a	}\u000a\u000a	function beforeAddingRule( that, newRules, overrideCustom ) {\u000a		if ( that.disabled )\u000a			return false;\u000a\u000a		// Don't override custom user's configuration if not explicitly requested.\u000a		if ( that.customConfig && !overrideCustom )\u000a			return false;\u000a\u000a		if ( !newRules )\u000a			return false;\u000a\u000a		// Clear cache, because new rules could change results of checks.\u000a		that._.cachedChecks = {};\u000a\u000a		return true;\u000a	}\u000a\u000a	// Convert CKEDITOR.style to filter's rule.\u000a	function convertStyleToRules( style ) {\u000a		var styleDef = style.getDefinition(),\u000a			rules = {},\u000a			rule,\u000a			attrs = styleDef.attributes;\u000a\u000a		rules[ styleDef.element ] = rule = {\u000a			styles: styleDef.styles,\u000a			requiredStyles: styleDef.styles && CKEDITOR.tools.objectKeys( styleDef.styles )\u000a		};\u000a\u000a		if ( attrs ) {\u000a			attrs = copy( attrs );\u000a			rule.classes = attrs[ 'class' ] ? attrs[ 'class' ].split( /\u005cs+/ ) : null;\u000a			rule.requiredClasses = rule.classes;\u000a			delete attrs[ 'class' ];\u000a			rule.attributes = attrs;\u000a			rule.requiredAttributes = attrs && CKEDITOR.tools.objectKeys( attrs );\u000a		}\u000a\u000a		return rules;\u000a	}\u000a\u000a	// Convert all validator formats (string, array, object, boolean) to hash or boolean:\u000a	// * true is returned for '*'/true validator,\u000a	// * false is returned for empty validator (no validator at all (false/null) or e.g. empty array),\u000a	// * object is returned in other cases.\u000a	function convertValidatorToHash( validator, delimiter ) {\u000a		if ( !validator )\u000a			return false;\u000a\u000a		if ( validator === true )\u000a			return validator;\u000a\u000a		if ( typeof validator == 'string' ) {\u000a			validator = trim( validator );\u000a			if ( validator == '*' )\u000a				return true;\u000a			else\u000a				return CKEDITOR.tools.convertArrayToObject( validator.split( delimiter ) );\u000a		}\u000a		else if ( CKEDITOR.tools.isArray( validator ) ) {\u000a			if ( validator.length )\u000a				return CKEDITOR.tools.convertArrayToObject( validator );\u000a			else\u000a				return false;\u000a		}\u000a		// If object.\u000a		else {\u000a			var obj = {},\u000a				len = 0;\u000a\u000a			for ( var i in validator ) {\u000a				obj[ i ] = validator[ i ];\u000a				len++;\u000a			}\u000a\u000a			return len ? obj : false;\u000a		}\u000a	}\u000a\u000a	function executeElementCallbacks( element, callbacks ) {\u000a		for ( var i = 0, l = callbacks.length, retVal; i < l; ++i ) {\u000a			if ( ( retVal = callbacks[ i ]( element ) ) )\u000a				return retVal;\u000a		}\u000a	}\u000a\u000a	// Extract required properties from "required" validator and "all" properties.\u000a	// Remove exclamation marks from "all" properties.\u000a	//\u000a	// E.g.:\u000a	// requiredClasses = { cl1: true }\u000a	// (all) classes = { cl1: true, cl2: true, '!cl3': true }\u000a	//\u000a	// result:\u000a	// returned = { cl1: true, cl3: true }\u000a	// all = { cl1: true, cl2: true, cl3: true }\u000a	//\u000a	// This function returns false if nothing is required.\u000a	function extractRequired( required, all ) {\u000a		var unbang = [],\u000a			empty = true,\u000a			i;\u000a\u000a		if ( required )\u000a			empty = false;\u000a		else\u000a			required = {};\u000a\u000a		for ( i in all ) {\u000a			if ( i.charAt( 0 ) == '!' ) {\u000a				i = i.slice( 1 );\u000a				unbang.push( i );\u000a				required[ i ] = true;\u000a				empty = false;\u000a			}\u000a		}\u000a\u000a		while ( ( i = unbang.pop() ) ) {\u000a			all[ i ] = all[ '!' + i ];\u000a			delete all[ '!' + i ];\u000a		}\u000a\u000a		return empty ? false : required;\u000a	}\u000a\u000a	// Does the actual filtering by appling allowed content rules\u000a	// to the element.\u000a	//\u000a	// @param {CKEDITOR.filter} that The context.\u000a	// @param {CKEDITOR.htmlParser.element} element\u000a	// @param {Object} opts The same as in processElement.\u000a	function filterElement( that, element, opts ) {\u000a		var name = element.name,\u000a			privObj = that._,\u000a			allowedRules = privObj.allowedRules.elements[ name ],\u000a			genericAllowedRules = privObj.allowedRules.generic,\u000a			disallowedRules = privObj.disallowedRules.elements[ name ],\u000a			genericDisallowedRules = privObj.disallowedRules.generic,\u000a			skipRequired = opts.skipRequired,\u000a			status = {\u000a				// Whether any of rules accepted element.\u000a				// If not - it will be stripped.\u000a				valid: false,\u000a				// Objects containing accepted attributes, classes and styles.\u000a				validAttributes: {},\u000a				validClasses: {},\u000a				validStyles: {},\u000a				// Whether all are valid.\u000a				// If we know that all element's attrs/classes/styles are valid\u000a				// we can skip their validation, to improve performance.\u000a				allAttributes: false,\u000a				allClasses: false,\u000a				allStyles: false,\u000a				// Whether element had (before applying DACRs) at least one invalid attribute/class/style.\u000a				hadInvalidAttribute: false,\u000a				hadInvalidClass: false,\u000a				hadInvalidStyle: false\u000a			},\u000a			i, l;\u000a\u000a		// Early return - if there are no rules for this element (specific or generic), remove it.\u000a		if ( !allowedRules && !genericAllowedRules )\u000a			return null;\u000a\u000a		// Could not be done yet if there were no transformations and if this\u000a		// is real (not mocked) object.\u000a		populateProperties( element );\u000a\u000a		// Note - this step modifies element's styles, classes and attributes.\u000a		if ( disallowedRules ) {\u000a			for ( i = 0, l = disallowedRules.length; i < l; ++i ) {\u000a				// Apply rule and make an early return if false is returned what means\u000a				// that element is completely disallowed.\u000a				if ( applyDisallowedRule( disallowedRules[ i ], element, status ) === false )\u000a					return null;\u000a			}\u000a		}\u000a\u000a		// Note - this step modifies element's styles, classes and attributes.\u000a		if ( genericDisallowedRules ) {\u000a			for ( i = 0, l = genericDisallowedRules.length; i < l; ++i )\u000a				applyDisallowedRule( genericDisallowedRules[ i ], element, status );\u000a		}\u000a\u000a		if ( allowedRules ) {\u000a			for ( i = 0, l = allowedRules.length; i < l; ++i )\u000a				applyAllowedRule( allowedRules[ i ], element, status, skipRequired );\u000a		}\u000a\u000a		if ( genericAllowedRules ) {\u000a			for ( i = 0, l = genericAllowedRules.length; i < l; ++i )\u000a				applyAllowedRule( genericAllowedRules[ i ], element, status, skipRequired );\u000a		}\u000a\u000a		return status;\u000a	}\u000a\u000a	// Check whether element has all properties (styles,classes,attrs) required by a rule.\u000a	function hasAllRequired( rule, element ) {\u000a		if ( rule.nothingRequired )\u000a			return true;\u000a\u000a		var i, req, reqs, existing;\u000a\u000a		if ( ( reqs = rule.requiredClasses ) ) {\u000a			existing = element.classes;\u000a			for ( i = 0; i < reqs.length; ++i ) {\u000a				req = reqs[ i ];\u000a				if ( typeof req == 'string' ) {\u000a					if ( CKEDITOR.tools.indexOf( existing, req ) == -1 )\u000a						return false;\u000a				}\u000a				// This means regexp.\u000a				else {\u000a					if ( !CKEDITOR.tools.checkIfAnyArrayItemMatches( existing, req ) )\u000a						return false;\u000a				}\u000a			}\u000a		}\u000a\u000a		return hasAllRequiredInHash( element.styles, rule.requiredStyles ) &&\u000a			hasAllRequiredInHash( element.attributes, rule.requiredAttributes );\u000a	}\u000a\u000a	// Check whether all items in required (array) exist in existing (object).\u000a	function hasAllRequiredInHash( existing, required ) {\u000a		if ( !required )\u000a			return true;\u000a\u000a		for ( var i = 0, req; i < required.length; ++i ) {\u000a			req = required[ i ];\u000a			if ( typeof req == 'string' ) {\u000a				if ( !( req in existing ) )\u000a					return false;\u000a			}\u000a			// This means regexp.\u000a			else {\u000a				if ( !CKEDITOR.tools.checkIfAnyObjectPropertyMatches( existing, req ) )\u000a					return false;\u000a			}\u000a		}\u000a\u000a		return true;\u000a	}\u000a\u000a	// Create pseudo element that will be passed through filter\u000a	// to check if tested string is allowed.\u000a	function mockElementFromString( str ) {\u000a		var element = parseRulesString( str ).$1,\u000a			styles = element.styles,\u000a			classes = element.classes;\u000a\u000a		element.name = element.elements;\u000a		element.classes = classes = ( classes ? classes.split( /\u005cs*,\u005cs*/ ) : [] );\u000a		element.styles = mockHash( styles );\u000a		element.attributes = mockHash( element.attributes );\u000a		element.children = [];\u000a\u000a		if ( classes.length )\u000a			element.attributes[ 'class' ] = classes.join( ' ' );\u000a		if ( styles )\u000a			element.attributes.style = CKEDITOR.tools.writeCssText( element.styles );\u000a\u000a		return element;\u000a	}\u000a\u000a	// Create pseudo element that will be passed through filter\u000a	// to check if tested style is allowed.\u000a	function mockElementFromStyle( style ) {\u000a		var styleDef = style.getDefinition(),\u000a			styles = styleDef.styles,\u000a			attrs = styleDef.attributes || {};\u000a\u000a		if ( styles ) {\u000a			styles = copy( styles );\u000a			attrs.style = CKEDITOR.tools.writeCssText( styles, true );\u000a		} else {\u000a			styles = {};\u000a		}\u000a\u000a		var el = {\u000a			name: styleDef.element,\u000a			attributes: attrs,\u000a			classes: attrs[ 'class' ] ? attrs[ 'class' ].split( /\u005cs+/ ) : [],\u000a			styles: styles,\u000a			children: []\u000a		};\u000a\u000a		return el;\u000a	}\u000a\u000a	// Mock hash based on string.\u000a	// 'a,b,c' => { a: 'cke-test', b: 'cke-test', c: 'cke-test' }\u000a	// Used to mock styles and attributes objects.\u000a	function mockHash( str ) {\u000a		// It may be a null or empty string.\u000a		if ( !str )\u000a			return {};\u000a\u000a		var keys = str.split( /\u005cs*,\u005cs*/ ).sort(),\u000a			obj = {};\u000a\u000a		while ( keys.length )\u000a			obj[ keys.shift() ] = TEST_VALUE;\u000a\u000a		return obj;\u000a	}\u000a\u000a	// Extract properties names from the object\u000a	// and replace those containing wildcards with regexps.\u000a	// Note: there's a room for performance improvement. Array of mixed types\u000a	// breaks JIT-compiler optiomization what may invalidate compilation of pretty a lot of code.\u000a	//\u000a	// @returns An array of strings and regexps.\u000a	function optimizeRequiredProperties( requiredProperties ) {\u000a		var arr = [];\u000a		for ( var propertyName in requiredProperties ) {\u000a			if ( propertyName.indexOf( '*' ) > -1 )\u000a				arr.push( new RegExp( '^' + propertyName.replace( /\u005c*/g, '.*' ) + '$' ) );\u000a			else\u000a				arr.push( propertyName );\u000a		}\u000a		return arr;\u000a	}\u000a\u000a	var validators = { styles: 1, attributes: 1, classes: 1 },\u000a		validatorsRequired = {\u000a			styles: 'requiredStyles',\u000a			attributes: 'requiredAttributes',\u000a			classes: 'requiredClasses'\u000a		};\u000a\u000a	// Optimize a rule by replacing validators with functions\u000a	// and rewriting requiredXXX validators to arrays.\u000a	function optimizeRule( rule ) {\u000a		var validatorName,\u000a			requiredProperties,\u000a			i;\u000a\u000a		for ( validatorName in validators )\u000a			rule[ validatorName ] = validatorFunction( rule[ validatorName ] );\u000a\u000a		var nothingRequired = true;\u000a		for ( i in validatorsRequired ) {\u000a			validatorName = validatorsRequired[ i ];\u000a			requiredProperties = optimizeRequiredProperties( rule[ validatorName ] );\u000a			// Don't set anything if there are no required properties. This will allow to\u000a			// save some memory by GCing all empty arrays (requiredProperties).\u000a			if ( requiredProperties.length ) {\u000a				rule[ validatorName ] = requiredProperties;\u000a				nothingRequired = false;\u000a			}\u000a		}\u000a\u000a		rule.nothingRequired = nothingRequired;\u000a		rule.noProperties = !( rule.attributes || rule.classes || rule.styles );\u000a	}\u000a\u000a	// Add optimized version of rule to optimizedRules object.\u000a	function optimizeRules( optimizedRules, rules ) {\u000a		var elementsRules = optimizedRules.elements,\u000a			genericRules = optimizedRules.generic,\u000a			i, l, rule, element, priority;\u000a\u000a		for ( i = 0, l = rules.length; i < l; ++i ) {\u000a			// Shallow copy. Do not modify original rule.\u000a			rule = copy( rules[ i ] );\u000a			priority = rule.classes === true || rule.styles === true || rule.attributes === true;\u000a			optimizeRule( rule );\u000a\u000a			// E.g. "*(xxx)[xxx]" - it's a generic rule that\u000a			// validates properties only.\u000a			// Or '$1': { match: function() {...} }\u000a			if ( rule.elements === true || rule.elements === null ) {\u000a				// Add priority rules at the beginning.\u000a				genericRules[ priority ? 'unshift' : 'push' ]( rule );\u000a			}\u000a			// If elements list was explicitly defined,\u000a			// add this rule for every defined element.\u000a			else {\u000a				// We don't need elements validator for this kind of rule.\u000a				var elements = rule.elements;\u000a				delete rule.elements;\u000a\u000a				for ( element in elements ) {\u000a					if ( !elementsRules[ element ] )\u000a						elementsRules[ element ] = [ rule ];\u000a					else\u000a						elementsRules[ element ][ priority ? 'unshift' : 'push' ]( rule );\u000a				}\u000a			}\u000a		}\u000a	}\u000a\u000a	//                  <   elements   ><                       styles, attributes and classes                        >< separator >\u000a	var rulePattern = /^([a-z0-9\u005c-*\u005cs]+)((?:\u005cs*\u005c{[!\u005cw\u005c-,\u005cs\u005c*]+\u005c}\u005cs*|\u005cs*\u005c[[!\u005cw\u005c-,\u005cs\u005c*]+\u005c]\u005cs*|\u005cs*\u005c([!\u005cw\u005c-,\u005cs\u005c*]+\u005c)\u005cs*){0,3})(?:;\u005cs*|$)/i,\u000a		groupsPatterns = {\u000a			styles: /{([^}]+)}/,\u000a			attrs: /\u005c[([^\u005c]]+)\u005c]/,\u000a			classes: /\u005c(([^\u005c)]+)\u005c)/\u000a		};\u000a\u000a	function parseRulesString( input ) {\u000a		var match,\u000a			props, styles, attrs, classes,\u000a			rules = {},\u000a			groupNum = 1;\u000a\u000a		input = trim( input );\u000a\u000a		while ( ( match = input.match( rulePattern ) ) ) {\u000a			if ( ( props = match[ 2 ] ) ) {\u000a				styles = parseProperties( props, 'styles' );\u000a				attrs = parseProperties( props, 'attrs' );\u000a				classes = parseProperties( props, 'classes' );\u000a			} else {\u000a				styles = attrs = classes = null;\u000a			}\u000a\u000a			// Add as an unnamed rule, because there can be two rules\u000a			// for one elements set defined in string format.\u000a			rules[ '$' + groupNum++ ] = {\u000a				elements: match[ 1 ],\u000a				classes: classes,\u000a				styles: styles,\u000a				attributes: attrs\u000a			};\u000a\u000a			// Move to the next group.\u000a			input = input.slice( match[ 0 ].length );\u000a		}\u000a\u000a		return rules;\u000a	}\u000a\u000a	// Extract specified properties group (styles, attrs, classes) from\u000a	// what stands after the elements list in string format of allowedContent.\u000a	function parseProperties( properties, groupName ) {\u000a		var group = properties.match( groupsPatterns[ groupName ] );\u000a		return group ? trim( group[ 1 ] ) : null;\u000a	}\u000a\u000a	function populateProperties( element ) {\u000a			// Backup styles and classes, because they may be removed by DACRs.\u000a			// We'll need them in updateElement().\u000a		var styles = element.styleBackup = element.attributes.style,\u000a			classes = element.classBackup = element.attributes[ 'class' ];\u000a\u000a		// Parse classes and styles if that hasn't been done before.\u000a		if ( !element.styles )\u000a			element.styles = CKEDITOR.tools.parseCssText( styles || '', 1 );\u000a		if ( !element.classes )\u000a			element.classes = classes ? classes.split( /\u005cs+/ ) : [];\u000a	}\u000a\u000a	// Filter element protected with a comment.\u000a	// Returns true if protected content is ok, false otherwise.\u000a	function processProtectedElement( that, comment, protectedRegexs, filterOpts ) {\u000a		var source = decodeURIComponent( comment.value.replace( /^\u005c{cke_protected\u005c}/, '' ) ),\u000a			protectedFrag,\u000a			toBeRemoved = [],\u000a			node, i, match;\u000a\u000a		// Protected element's and protected source's comments look exactly the same.\u000a		// Check if what we have isn't a protected source instead of protected script/noscript.\u000a		if ( protectedRegexs ) {\u000a			for ( i = 0; i < protectedRegexs.length; ++i ) {\u000a				if ( ( match = source.match( protectedRegexs[ i ] ) ) &&\u000a					match[ 0 ].length == source.length	// Check whether this pattern matches entire source\u000a														// to avoid '<script>alert("<? 1 ?>")</script>' matching\u000a														// the PHP's protectedSource regexp.\u000a				)\u000a					return true;\u000a			}\u000a		}\u000a\u000a		protectedFrag = CKEDITOR.htmlParser.fragment.fromHtml( source );\u000a\u000a		if ( protectedFrag.children.length == 1 && ( node = protectedFrag.children[ 0 ] ).type == CKEDITOR.NODE_ELEMENT )\u000a			processElement( that, node, toBeRemoved, filterOpts );\u000a\u000a		// If protected element has been marked to be removed, return 'false' - comment was rejected.\u000a		return !toBeRemoved.length;\u000a	}\u000a\u000a	var unprotectElementsNamesRegexp = /^cke:(object|embed|param)$/,\u000a		protectElementsNamesRegexp = /^(object|embed|param)$/;\u000a\u000a	// The actual function which filters, transforms and does other funny things with an element.\u000a	//\u000a	// @param {CKEDITOR.filter} that Context.\u000a	// @param {CKEDITOR.htmlParser.element} element The element to be processed.\u000a	// @param {Array} toBeRemoved Array into which elements rejected by the filter will be pushed.\u000a	// @param {Boolean} [opts.doFilter] Whether element should be filtered.\u000a	// @param {Boolean} [opts.doTransform] Whether transformations should be applied.\u000a	// @param {Boolean} [opts.doCallbacks] Whether to execute element callbacks.\u000a	// @param {Boolean} [opts.toHtml] Set to true if filter used together with htmlDP#toHtml\u000a	// @param {Boolean} [opts.skipRequired] Whether element's required properties shouldn't be verified.\u000a	// @param {Boolean} [opts.skipFinalValidation] Whether to not perform final element validation (a,img).\u000a	// @returns {Number} Possible flags:\u000a	//  * FILTER_ELEMENT_MODIFIED,\u000a	//  * FILTER_SKIP_TREE.\u000a	function processElement( that, element, toBeRemoved, opts ) {\u000a		var status,\u000a			retVal = 0,\u000a			callbacksRetVal;\u000a\u000a		// Unprotect elements names previously protected by htmlDataProcessor\u000a		// (see protectElementNames and protectSelfClosingElements functions).\u000a		// Note: body, title, etc. are not protected by htmlDataP (or are protected and then unprotected).\u000a		if ( opts.toHtml )\u000a			element.name = element.name.replace( unprotectElementsNamesRegexp, '$1' );\u000a\u000a		// Execute element callbacks and return if one of them returned any value.\u000a		if ( opts.doCallbacks && that.elementCallbacks ) {\u000a			// For now we only support here FILTER_SKIP_TREE, so we can early return if retVal is truly value.\u000a			if ( ( callbacksRetVal = executeElementCallbacks( element, that.elementCallbacks ) ) )\u000a				return callbacksRetVal;\u000a		}\u000a\u000a		// If transformations are set apply all groups.\u000a		if ( opts.doTransform )\u000a			transformElement( that, element );\u000a\u000a		if ( opts.doFilter ) {\u000a			// Apply all filters.\u000a			status = filterElement( that, element, opts );\u000a\u000a			// Handle early return from filterElement.\u000a			if ( !status ) {\u000a				toBeRemoved.push( element );\u000a				return FILTER_ELEMENT_MODIFIED;\u000a			}\u000a\u000a			// Finally, if after running all filter rules it still hasn't been allowed - remove it.\u000a			if ( !status.valid ) {\u000a				toBeRemoved.push( element );\u000a				return FILTER_ELEMENT_MODIFIED;\u000a			}\u000a\u000a			// Update element's attributes based on status of filtering.\u000a			if ( updateElement( element, status ) )\u000a				retVal = FILTER_ELEMENT_MODIFIED;\u000a\u000a			if ( !opts.skipFinalValidation && !validateElement( element ) ) {\u000a				toBeRemoved.push( element );\u000a				return FILTER_ELEMENT_MODIFIED;\u000a			}\u000a		}\u000a\u000a		// Protect previously unprotected elements.\u000a		if ( opts.toHtml )\u000a			element.name = element.name.replace( protectElementsNamesRegexp, 'cke:$1' );\u000a\u000a		return retVal;\u000a	}\u000a\u000a	// Returns a regexp object which can be used to test if a property\u000a	// matches one of wildcard validators.\u000a	function regexifyPropertiesWithWildcards( validators ) {\u000a		var patterns = [],\u000a			i;\u000a\u000a		for ( i in validators ) {\u000a			if ( i.indexOf( '*' ) > -1 )\u000a				patterns.push( i.replace( /\u005c*/g, '.*' ) );\u000a		}\u000a\u000a		if ( patterns.length )\u000a			return new RegExp( '^(?:' + patterns.join( '|' ) + ')$' );\u000a		else\u000a			return null;\u000a	}\u000a\u000a	// Standardize a rule by converting all validators to hashes.\u000a	function standardizeRule( rule ) {\u000a		rule.elements = convertValidatorToHash( rule.elements, /\u005cs+/ ) || null;\u000a		rule.propertiesOnly = rule.propertiesOnly || ( rule.elements === true );\u000a\u000a		var delim = /\u005cs*,\u005cs*/,\u000a			i;\u000a\u000a		for ( i in validators ) {\u000a			rule[ i ] = convertValidatorToHash( rule[ i ], delim ) || null;\u000a			rule[ validatorsRequired[ i ] ] = extractRequired( convertValidatorToHash(\u000a				rule[ validatorsRequired[ i ] ], delim ), rule[ i ] ) || null;\u000a		}\u000a\u000a		rule.match = rule.match || null;\u000a	}\u000a\u000a	// Does the element transformation by applying registered\u000a	// transformation rules.\u000a	function transformElement( that, element ) {\u000a		var transformations = that._.transformations[ element.name ],\u000a			i;\u000a\u000a		if ( !transformations )\u000a			return;\u000a\u000a		populateProperties( element );\u000a\u000a		for ( i = 0; i < transformations.length; ++i )\u000a			applyTransformationsGroup( that, element, transformations[ i ] );\u000a\u000a		// Do not count on updateElement() which is called in processElement, because it:\u000a		// * may not be called,\u000a		// * may skip some properties when all are marked as valid.\u000a		updateAttributes( element );\u000a	}\u000a\u000a	// Copy element's styles and classes back to attributes array.\u000a	function updateAttributes( element ) {\u000a		var attrs = element.attributes,\u000a			styles;\u000a\u000a		// Will be recreated later if any of styles/classes exists.\u000a		delete attrs.style;\u000a		delete attrs[ 'class' ];\u000a\u000a		if ( ( styles = CKEDITOR.tools.writeCssText( element.styles, true ) ) )\u000a			attrs.style = styles;\u000a\u000a		if ( element.classes.length )\u000a			attrs[ 'class' ] = element.classes.sort().join( ' ' );\u000a	}\u000a\u000a	// Update element object based on status of filtering.\u000a	// @returns Whether element was modified.\u000a	function updateElement( element, status ) {\u000a		var validAttrs = status.validAttributes,\u000a			validStyles = status.validStyles,\u000a			validClasses = status.validClasses,\u000a			attrs = element.attributes,\u000a			styles = element.styles,\u000a			classes = element.classes,\u000a			origClasses = element.classBackup,\u000a			origStyles = element.styleBackup,\u000a			name, origName, i,\u000a			stylesArr = [],\u000a			classesArr = [],\u000a			internalAttr = /^data-cke-/,\u000a			isModified = false;\u000a\u000a		// Will be recreated later if any of styles/classes were passed.\u000a		delete attrs.style;\u000a		delete attrs[ 'class' ];\u000a		// Clean up.\u000a		delete element.classBackup;\u000a		delete element.styleBackup;\u000a\u000a		if ( !status.allAttributes ) {\u000a			for ( name in attrs ) {\u000a				// If not valid and not internal attribute delete it.\u000a				if ( !validAttrs[ name ] ) {\u000a					// Allow all internal attibutes...\u000a					if ( internalAttr.test( name ) ) {\u000a						// ... unless this is a saved attribute and the original one isn't allowed.\u000a						if ( name != ( origName = name.replace( /^data-cke-saved-/, '' ) ) &&\u000a							!validAttrs[ origName ]\u000a						) {\u000a							delete attrs[ name ];\u000a							isModified = true;\u000a						}\u000a					} else {\u000a						delete attrs[ name ];\u000a						isModified = true;\u000a					}\u000a				}\u000a\u000a			}\u000a		}\u000a\u000a		if ( !status.allStyles || status.hadInvalidStyle ) {\u000a			for ( name in styles ) {\u000a				// We check status.allStyles because when there was a '*' ACR and some\u000a				// DACR we have now both properties true - status.allStyles and status.hadInvalidStyle.\u000a				// However unlike in the case when we only have '*' ACR, in which we can just copy original\u000a				// styles, in this case we must copy only those styles which were not removed by DACRs.\u000a				if ( status.allStyles || validStyles[ name ] )\u000a					stylesArr.push( name + ':' + styles[ name ] );\u000a				else\u000a					isModified = true;\u000a			}\u000a			if ( stylesArr.length )\u000a				attrs.style = stylesArr.sort().join( '; ' );\u000a		}\u000a		else if ( origStyles ) {\u000a			attrs.style = origStyles;\u000a		}\u000a\u000a		if ( !status.allClasses || status.hadInvalidClass ) {\u000a			for ( i = 0; i < classes.length; ++i ) {\u000a				// See comment for styles.\u000a				if ( status.allClasses || validClasses[ classes[ i ] ] )\u000a					classesArr.push( classes[ i ] );\u000a			}\u000a			if ( classesArr.length )\u000a				attrs[ 'class' ] = classesArr.sort().join( ' ' );\u000a\u000a			if ( origClasses && classesArr.length < origClasses.split( /\u005cs+/ ).length )\u000a				isModified = true;\u000a		}\u000a		else if ( origClasses ) {\u000a			attrs[ 'class' ] = origClasses;\u000a		}\u000a\u000a		return isModified;\u000a	}\u000a\u000a	function validateElement( element ) {\u000a		switch ( element.name ) {\u000a			case 'a':\u000a				// Code borrowed from htmlDataProcessor, so ACF does the same clean up.\u000a				if ( !( element.children.length || element.attributes.name ) )\u000a					return false;\u000a				break;\u000a			case 'img':\u000a				if ( !element.attributes.src )\u000a					return false;\u000a				break;\u000a		}\u000a\u000a		return true;\u000a	}\u000a\u000a	function validatorFunction( validator ) {\u000a		if ( !validator )\u000a			return false;\u000a		if ( validator === true )\u000a			return true;\u000a\u000a		// Note: We don't need to remove properties with wildcards from the validator object.\u000a		// E.g. data-* is actually an edge case of /^data-.*$/, so when it's accepted\u000a		// by `value in validator` it's ok.\u000a		var regexp = regexifyPropertiesWithWildcards( validator );\u000a\u000a		return function( value ) {\u000a			return value in validator || ( regexp && value.match( regexp ) );\u000a		};\u000a	}\u000a\u000a	//\u000a	// REMOVE ELEMENT ---------------------------------------------------------\u000a	//\u000a\u000a	// Check whether all children will be valid in new context.\u000a	// Note: it doesn't verify if text node is valid, because\u000a	// new parent should accept them.\u000a	function checkChildren( children, newParentName ) {\u000a		var allowed = DTD[ newParentName ];\u000a\u000a		for ( var i = 0, l = children.length, child; i < l; ++i ) {\u000a			child = children[ i ];\u000a			if ( child.type == CKEDITOR.NODE_ELEMENT && !allowed[ child.name ] )\u000a				return false;\u000a		}\u000a\u000a		return true;\u000a	}\u000a\u000a	function createBr() {\u000a		return new CKEDITOR.htmlParser.element( 'br' );\u000a	}\u000a\u000a	// Whether this is an inline element or text.\u000a	function inlineNode( node ) {\u000a		return node.type == CKEDITOR.NODE_TEXT ||\u000a			node.type == CKEDITOR.NODE_ELEMENT && DTD.$inline[ node.name ];\u000a	}\u000a\u000a	function isBrOrBlock( node ) {\u000a		return node.type == CKEDITOR.NODE_ELEMENT &&\u000a			( node.name == 'br' || DTD.$block[ node.name ] );\u000a	}\u000a\u000a	// Try to remove element in the best possible way.\u000a	//\u000a	// @param {Array} toBeChecked After executing this function\u000a	// this array will contain elements that should be checked\u000a	// because they were marked as potentially:\u000a	// * in wrong context (e.g. li in body),\u000a	// * empty elements from $removeEmpty,\u000a	// * incorrect img/a/other element validated by validateElement().\u000a	function removeElement( element, enterTag, toBeChecked ) {\u000a		var name = element.name;\u000a\u000a		if ( DTD.$empty[ name ] || !element.children.length ) {\u000a			// Special case - hr in br mode should be replaced with br, not removed.\u000a			if ( name == 'hr' && enterTag == 'br' )\u000a				element.replaceWith( createBr() );\u000a			else {\u000a				// Parent might become an empty inline specified in $removeEmpty or empty a[href].\u000a				if ( element.parent )\u000a					toBeChecked.push( { check: 'it', el: element.parent } );\u000a\u000a				element.remove();\u000a			}\u000a		} else if ( DTD.$block[ name ] || name == 'tr' ) {\u000a			if ( enterTag == 'br' )\u000a				stripBlockBr( element, toBeChecked );\u000a			else\u000a				stripBlock( element, enterTag, toBeChecked );\u000a		}\u000a		// Special case - elements that may contain CDATA\u000a		// should be removed completely. <script> is handled\u000a		// by processProtectedElement().\u000a		else if ( name == 'style' )\u000a			element.remove();\u000a		// The rest of inline elements. May also be the last resort\u000a		// for some special elements.\u000a		else {\u000a			// Parent might become an empty inline specified in $removeEmpty or empty a[href].\u000a			if ( element.parent )\u000a				toBeChecked.push( { check: 'it', el: element.parent } );\u000a			element.replaceWithChildren();\u000a		}\u000a	}\u000a\u000a	// Strip element block, but leave its content.\u000a	// Works in 'div' and 'p' enter modes.\u000a	function stripBlock( element, enterTag, toBeChecked ) {\u000a		var children = element.children;\u000a\u000a		// First, check if element's children may be wrapped with <p/div>.\u000a		// Ignore that <p/div> may not be allowed in element.parent.\u000a		// This will be fixed when removing parent or by toBeChecked rule.\u000a		if ( checkChildren( children, enterTag ) ) {\u000a			element.name = enterTag;\u000a			element.attributes = {};\u000a			// Check if this p/div was put in correct context.\u000a			// If not - strip parent.\u000a			toBeChecked.push( { check: 'parent-down', el: element } );\u000a			return;\u000a		}\u000a\u000a		var parent = element.parent,\u000a			shouldAutoP = parent.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT || parent.name == 'body',\u000a			i, child, p;\u000a\u000a		for ( i = children.length; i > 0; ) {\u000a			child = children[ --i ];\u000a\u000a			// If parent requires auto paragraphing and child is inline node,\u000a			// insert this child into newly created paragraph.\u000a			if ( shouldAutoP && inlineNode( child )  ) {\u000a				if ( !p ) {\u000a					p = new CKEDITOR.htmlParser.element( enterTag );\u000a					p.insertAfter( element );\u000a\u000a					// Check if this p/div was put in correct context.\u000a					// If not - strip parent.\u000a					toBeChecked.push( { check: 'parent-down', el: p } );\u000a				}\u000a				p.add( child, 0 );\u000a			}\u000a			// Child which doesn't need to be auto paragraphed.\u000a			else {\u000a				p = null;\u000a				child.insertAfter( element );\u000a				// If inserted into invalid context, mark it and check\u000a				// after removing all elements.\u000a				if ( parent.type != CKEDITOR.NODE_DOCUMENT_FRAGMENT &&\u000a					child.type == CKEDITOR.NODE_ELEMENT &&\u000a					!DTD[ parent.name ][ child.name ]\u000a				)\u000a					toBeChecked.push( { check: 'el-up', el: child } );\u000a			}\u000a		}\u000a\u000a		// All children have been moved to element's parent, so remove it.\u000a		element.remove();\u000a	}\u000a\u000a	// Prepend/append block with <br> if isn't\u000a	// already prepended/appended with <br> or block and\u000a	// isn't first/last child of its parent.\u000a	// Then replace element with its children.\u000a	// <p>a</p><p>b</p> => <p>a</p><br>b => a<br>b\u000a	function stripBlockBr( element ) {\u000a		var br;\u000a\u000a		if ( element.previous && !isBrOrBlock( element.previous ) ) {\u000a			br = createBr();\u000a			br.insertBefore( element );\u000a		}\u000a\u000a		if ( element.next && !isBrOrBlock( element.next ) ) {\u000a			br = createBr();\u000a			br.insertAfter( element );\u000a		}\u000a\u000a		element.replaceWithChildren();\u000a	}\u000a\u000a	//\u000a	// TRANSFORMATIONS --------------------------------------------------------\u000a	//\u000a\u000a	// Apply given transformations group to the element.\u000a	function applyTransformationsGroup( filter, element, group ) {\u000a		var i, rule;\u000a\u000a		for ( i = 0; i < group.length; ++i ) {\u000a			rule = group[ i ];\u000a\u000a			// Test with #check or #left only if it's set.\u000a			// Do not apply transformations because that creates infinite loop.\u000a			if ( ( !rule.check || filter.check( rule.check, false ) ) &&\u000a				( !rule.left || rule.left( element ) ) ) {\u000a				rule.right( element, transformationsTools );\u000a				return; // Only first matching rule in a group is executed.\u000a			}\u000a		}\u000a	}\u000a\u000a	// Check whether element matches CKEDITOR.style.\u000a	// The element can be a "superset" of style,\u000a	// e.g. it may have more classes, but need to have\u000a	// at least those defined in style.\u000a	function elementMatchesStyle( element, style ) {\u000a		var def = style.getDefinition(),\u000a			defAttrs = def.attributes,\u000a			defStyles = def.styles,\u000a			attrName, styleName,\u000a			classes, classPattern, cl;\u000a\u000a		if ( element.name != def.element )\u000a			return false;\u000a\u000a		for ( attrName in defAttrs ) {\u000a			if ( attrName == 'class' ) {\u000a				classes = defAttrs[ attrName ].split( /\u005cs+/ );\u000a				classPattern = element.classes.join( '|' );\u000a				while ( ( cl = classes.pop() ) ) {\u000a					if ( classPattern.indexOf( cl ) == -1 )\u000a						return false;\u000a				}\u000a			} else {\u000a				if ( element.attributes[ attrName ] != defAttrs[ attrName ] )\u000a					return false;\u000a			}\u000a		}\u000a\u000a		for ( styleName in defStyles ) {\u000a			if ( element.styles[ styleName ] != defStyles[ styleName ] )\u000a				return false;\u000a		}\u000a\u000a		return true;\u000a	}\u000a\u000a	// Return transformation group for content form.\u000a	// One content form makes one transformation rule in one group.\u000a	function getContentFormTransformationGroup( form, preferredForm ) {\u000a		var element, left;\u000a\u000a		if ( typeof form == 'string' )\u000a			element = form;\u000a		else if ( form instanceof CKEDITOR.style )\u000a			left = form;\u000a		else {\u000a			element = form[ 0 ];\u000a			left = form[ 1 ];\u000a		}\u000a\u000a		return [ {\u000a			element: element,\u000a			left: left,\u000a			right: function( el, tools ) {\u000a				tools.transform( el, preferredForm );\u000a			}\u000a		} ];\u000a	}\u000a\u000a	// Obtain element's name from transformation rule.\u000a	// It will be defined by #element, or #check or #left (styleDef.element).\u000a	function getElementNameForTransformation( rule, check ) {\u000a		if ( rule.element )\u000a			return rule.element;\u000a		if ( check )\u000a			return check.match( /^([a-z0-9]+)/i )[ 0 ];\u000a		return rule.left.getDefinition().element;\u000a	}\u000a\u000a	function getMatchStyleFn( style ) {\u000a		return function( el ) {\u000a			return elementMatchesStyle( el, style );\u000a		};\u000a	}\u000a\u000a	function getTransformationFn( toolName ) {\u000a		return function( el, tools ) {\u000a			tools[ toolName ]( el );\u000a		};\u000a	}\u000a\u000a	function optimizeTransformationsGroup( rules ) {\u000a		var groupName, i, rule,\u000a			check, left, right,\u000a			optimizedRules = [];\u000a\u000a		for ( i = 0; i < rules.length; ++i ) {\u000a			rule = rules[ i ];\u000a\u000a			if ( typeof rule == 'string' ) {\u000a				rule = rule.split( /\u005cs*:\u005cs*/ );\u000a				check = rule[ 0 ];\u000a				left = null;\u000a				right = rule[ 1 ];\u000a			} else {\u000a				check = rule.check;\u000a				left = rule.left;\u000a				right = rule.right;\u000a			}\u000a\u000a			// Extract element name.\u000a			if ( !groupName )\u000a				groupName = getElementNameForTransformation( rule, check );\u000a\u000a			if ( left instanceof CKEDITOR.style )\u000a				left = getMatchStyleFn( left );\u000a\u000a			optimizedRules.push( {\u000a				// It doesn't make sense to test against name rule (e.g. 'table'), so don't save it.\u000a				check: check == groupName ? null : check,\u000a\u000a				left: left,\u000a\u000a				// Handle shorthand format. E.g.: 'table[width]:sizeToAttribute'.\u000a				right: typeof right == 'string' ? getTransformationFn( right ) : right\u000a			} );\u000a		}\u000a\u000a		return {\u000a			name: groupName,\u000a			rules: optimizedRules\u000a		};\u000a	}\u000a\u000a	/**\u000a	 * Singleton containing tools useful for transformation rules.\u000a	 *\u000a	 * @class CKEDITOR.filter.transformationsTools\u000a	 * @singleton\u000a	 */\u000a	var transformationsTools = CKEDITOR.filter.transformationsTools = {\u000a		/**\u000a		 * Converts `width` and `height` attributes to styles.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.element} element\u000a		 */\u000a		sizeToStyle: function( element ) {\u000a			this.lengthToStyle( element, 'width' );\u000a			this.lengthToStyle( element, 'height' );\u000a		},\u000a\u000a		/**\u000a		 * Converts `width` and `height` styles to attributes.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.element} element\u000a		 */\u000a		sizeToAttribute: function( element ) {\u000a			this.lengthToAttribute( element, 'width' );\u000a			this.lengthToAttribute( element, 'height' );\u000a		},\u000a\u000a		/**\u000a		 * Converts length in the `attrName` attribute to a valid CSS length (like `width` or `height`).\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.element} element\u000a		 * @param {String} attrName Name of the attribute that will be converted.\u000a		 * @param {String} [styleName=attrName] Name of the style into which the attribute will be converted.\u000a		 */\u000a		lengthToStyle: function( element, attrName, styleName ) {\u000a			styleName = styleName || attrName;\u000a\u000a			if ( !( styleName in element.styles ) ) {\u000a				var value = element.attributes[ attrName ];\u000a\u000a				if ( value ) {\u000a					if ( ( /^\u005cd+$/ ).test( value ) )\u000a						value += 'px';\u000a\u000a					element.styles[ styleName ] = value;\u000a				}\u000a			}\u000a\u000a			delete element.attributes[ attrName ];\u000a		},\u000a\u000a		/**\u000a		 * Converts length in the `styleName` style to a valid length attribute (like `width` or `height`).\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.element} element\u000a		 * @param {String} styleName Name of the style that will be converted.\u000a		 * @param {String} [attrName=styleName] Name of the attribute into which the style will be converted.\u000a		 */\u000a		lengthToAttribute: function( element, styleName, attrName ) {\u000a			attrName = attrName || styleName;\u000a\u000a			if ( !( attrName in element.attributes ) ) {\u000a				var value = element.styles[ styleName ],\u000a					match = value && value.match( /^(\u005cd+)(?:\u005c.\u005cd*)?px$/ );\u000a\u000a				if ( match )\u000a					element.attributes[ attrName ] = match[ 1 ];\u000a				// Pass the TEST_VALUE used by filter#check when mocking element.\u000a				else if ( value == TEST_VALUE )\u000a					element.attributes[ attrName ] = TEST_VALUE;\u000a			}\u000a\u000a			delete element.styles[ styleName ];\u000a		},\u000a\u000a		/**\u000a		 * Converts the `align` attribute to the `float` style if not set. Attribute\u000a		 * is always removed.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.element} element\u000a		 */\u000a		alignmentToStyle: function( element ) {\u000a			if ( !( 'float' in element.styles ) ) {\u000a				var value = element.attributes.align;\u000a\u000a				if ( value == 'left' || value == 'right' )\u000a					element.styles[ 'float' ] = value; // Uh... GCC doesn't like the 'float' prop name.\u000a			}\u000a\u000a			delete element.attributes.align;\u000a		},\u000a\u000a		/**\u000a		 * Converts the `float` style to the `align` attribute if not set.\u000a		 * Style is always removed.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.element} element\u000a		 */\u000a		alignmentToAttribute: function( element ) {\u000a			if ( !( 'align' in element.attributes ) ) {\u000a				var value = element.styles[ 'float' ];\u000a\u000a				if ( value == 'left' || value == 'right' )\u000a					element.attributes.align = value;\u000a			}\u000a\u000a			delete element.styles[ 'float' ]; // Uh... GCC doesn't like the 'float' prop name.\u000a		},\u000a\u000a		/**\u000a		 * Checks whether an element matches a given {@link CKEDITOR.style}.\u000a		 * The element can be a "superset" of a style, e.g. it may have\u000a		 * more classes, but needs to have at least those defined in the style.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.element} element\u000a		 * @param {CKEDITOR.style} style\u000a		 */\u000a		matchesStyle: elementMatchesStyle,\u000a\u000a		/**\u000a		 * Transforms element to given form.\u000a		 *\u000a		 * Form may be a:\u000a		 *\u000a		 *	* {@link CKEDITOR.style},\u000a		 *	* string &ndash; the new name of an element.\u000a		 *\u000a		 * @param {CKEDITOR.htmlParser.element} el\u000a		 * @param {CKEDITOR.style/String} form\u000a		 */\u000a		transform: function( el, form ) {\u000a			if ( typeof form == 'string' )\u000a				el.name = form;\u000a			// Form is an instance of CKEDITOR.style.\u000a			else {\u000a				var def = form.getDefinition(),\u000a					defStyles = def.styles,\u000a					defAttrs = def.attributes,\u000a					attrName, styleName,\u000a					existingClassesPattern, defClasses, cl;\u000a\u000a				el.name = def.element;\u000a\u000a				for ( attrName in defAttrs ) {\u000a					if ( attrName == 'class' ) {\u000a						existingClassesPattern = el.classes.join( '|' );\u000a						defClasses = defAttrs[ attrName ].split( /\u005cs+/ );\u000a\u000a						while ( ( cl = defClasses.pop() ) ) {\u000a							if ( existingClassesPattern.indexOf( cl ) == -1 )\u000a								el.classes.push( cl );\u000a						}\u000a					} else {\u000a						el.attributes[ attrName ] = defAttrs[ attrName ];\u000a					}\u000a\u000a				}\u000a\u000a				for ( styleName in defStyles ) {\u000a					el.styles[ styleName ] = defStyles[ styleName ];\u000a				}\u000a			}\u000a		}\u000a	};\u000a\u000a} )();\u000a\u000a/**\u000a * Allowed content rules. This setting is used when\u000a * instantiating {@link CKEDITOR.editor#filter}.\u000a *\u000a * The following values are accepted:\u000a *\u000a *	* {@link CKEDITOR.filter.allowedContentRules} &ndash; defined rules will be added\u000a *	to the {@link CKEDITOR.editor#filter}.\u000a *	* `true` &ndash; will disable the filter (data will not be filtered,\u000a *	all features will be activated).\u000a *	* default &ndash; the filter will be configured by loaded features\u000a *	(toolbar items, commands, etc.).\u000a *\u000a * In all cases filter configuration may be extended by\u000a * {@link CKEDITOR.config#extraAllowedContent}. This option may be especially\u000a * useful when you want to use the default `allowedContent` value\u000a * along with some additional rules.\u000a *\u000a *		CKEDITOR.replace( 'textarea_id', {\u000a *			allowedContent: 'p b i; a[!href]',\u000a *			on: {\u000a *				instanceReady: function( evt ) {\u000a *					var editor = evt.editor;\u000a *\u000a *					editor.filter.check( 'h1' ); // -> false\u000a *					editor.setData( '<h1><i>Foo</i></h1><p class="left"><span>Bar</span> <a href="http://foo.bar">foo</a></p>' );\u000a *					// Editor contents will be:\u000a *					'<p><i>Foo</i></p><p>Bar <a href="http://foo.bar">foo</a></p>'\u000a *				}\u000a *			}\u000a *		} );\u000a *\u000a * It is also possible to disallow some already allowed content. It is especially\u000a * useful when you want to "trim down" the content allowed by default by\u000a * editor features. To do that, use the {@link #disallowedContent} option.\u000a *\u000a * @since 4.1\u000a * @cfg {CKEDITOR.filter.allowedContentRules/Boolean} [allowedContent=null]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * This option makes it possible to set additional allowed\u000a * content rules for {@link CKEDITOR.editor#filter}.\u000a *\u000a * It is especially useful in combination with the default\u000a * {@link CKEDITOR.config#allowedContent} value:\u000a *\u000a *		CKEDITOR.replace( 'textarea_id', {\u000a *			plugins: 'wysiwygarea,toolbar,format',\u000a *			extraAllowedContent: 'b i',\u000a *			on: {\u000a *				instanceReady: function( evt ) {\u000a *					var editor = evt.editor;\u000a *\u000a *					editor.filter.check( 'h1' ); // -> true (thanks to Format combo)\u000a *					editor.filter.check( 'b' ); // -> true (thanks to extraAllowedContent)\u000a *					editor.setData( '<h1><i>Foo</i></h1><p class="left"><b>Bar</b> <a href="http://foo.bar">foo</a></p>' );\u000a *					// Editor contents will be:\u000a *					'<h1><i>Foo</i></h1><p><b>Bar</b> foo</p>'\u000a *				}\u000a *			}\u000a *		} );\u000a *\u000a * See {@link CKEDITOR.config#allowedContent} for more details.\u000a *\u000a * @since 4.1\u000a * @cfg {Object/String} extraAllowedContent\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * Disallowed content rules. They have precedence over {@link #allowedContent allowed content rules}.\u000a * Read more in the [Disallowed Content guide](#!/guide/dev_disallowed_content).\u000a *\u000a * See also {@link CKEDITOR.config#allowedContent} and {@link CKEDITOR.config#extraAllowedContent}.\u000a *\u000a * @since 4.4\u000a * @cfg {CKEDITOR.filter.disallowedContentRules} disallowedContent\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * This event is fired when {@link CKEDITOR.filter} has stripped some\u000a * content from the data that was loaded (e.g. by {@link CKEDITOR.editor#method-setData}\u000a * method or in the source mode) or inserted (e.g. when pasting or using the\u000a * {@link CKEDITOR.editor#method-insertHtml} method).\u000a *\u000a * This event is useful when testing whether the {@link CKEDITOR.config#allowedContent}\u000a * setting is sufficient and correct for a system that is migrating to CKEditor 4.1\u000a * (where the [Advanced Content Filter](#!/guide/dev_advanced_content_filter) was introduced).\u000a *\u000a * @since 4.1\u000a * @event dataFiltered\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Virtual class which is the [Allowed Content Rules](#!/guide/dev_allowed_content_rules) formats type.\u000a *\u000a * Possible formats are:\u000a *\u000a *	* the [string format](#!/guide/dev_allowed_content_rules-section-2),\u000a *	* the [object format](#!/guide/dev_allowed_content_rules-section-3),\u000a *	* a {@link CKEDITOR.style} instance &ndash; used mainly for integrating plugins with Advanced Content Filter,\u000a *	* an array of the above formats.\u000a *\u000a * @since 4.1\u000a * @class CKEDITOR.filter.allowedContentRules\u000a * @abstract\u000a */\u000a\u000a/**\u000a * Virtual class representing the {@link CKEDITOR.filter#disallow} argument and a type of\u000a * the {@link CKEDITOR.config#disallowedContent} option.\u000a *\u000a * This is a simplified version of the {@link CKEDITOR.filter.allowedContentRules} type.\u000a * Only the string format and object format are accepted. Required properties\u000a * are not allowed in this format.\u000a *\u000a * Read more in the [Disallowed Content guide](#!/guide/dev_disallowed_content).\u000a *\u000a * @since 4.4\u000a * @class CKEDITOR.filter.disallowedContentRules\u000a * @abstract\u000a */\u000a\u000a/**\u000a * Virtual class representing {@link CKEDITOR.filter#check} argument.\u000a *\u000a * This is a simplified version of the {@link CKEDITOR.filter.allowedContentRules} type.\u000a * It may contain only one element and its styles, classes, and attributes. Only the\u000a * string format and a {@link CKEDITOR.style} instances are accepted. Required properties\u000a * are not allowed in this format.\u000a *\u000a * Example:\u000a *\u000a *		'img[src,alt](foo)'	// Correct rule.\u000a *		'ol, ul(!foo)'		// Incorrect rule. Multiple elements and required\u000a *							// properties are not supported.\u000a *\u000a * @since 4.1\u000a * @class CKEDITOR.filter.contentRule\u000a * @abstract\u000a */\u000a\u000a/**\u000a * Interface that may be automatically implemented by any\u000a * instance of any class which has at least the `name` property and\u000a * can be meant as an editor feature.\u000a *\u000a * For example:\u000a *\u000a *	* "Bold" command, button, and keystroke &ndash; it does not mean exactly\u000a * `<strong>` or `<b>` but just the ability to create bold text.\u000a *	* "Format" drop-down list &ndash; it also does not imply any HTML tag.\u000a *	* "Link" command, button, and keystroke.\u000a *	* "Image" command, button, and dialog window.\u000a *\u000a * Thus most often a feature is an instance of one of the following classes:\u000a *\u000a *	* {@link CKEDITOR.command}\u000a *	* {@link CKEDITOR.ui.button}\u000a *	* {@link CKEDITOR.ui.richCombo}\u000a *\u000a * None of them have a `name` property explicitly defined, but\u000a * it is set by {@link CKEDITOR.editor#addCommand} and {@link CKEDITOR.ui#add}.\u000a *\u000a * During editor initialization all features that the editor should activate\u000a * should be passed to {@link CKEDITOR.editor#addFeature} (shorthand for {@link CKEDITOR.filter#addFeature}).\u000a *\u000a * This method checks if a feature can be activated (see {@link #requiredContent}) and if yes,\u000a * then it registers allowed content rules required by this feature (see {@link #allowedContent}) along\u000a * with two kinds of transformations: {@link #contentForms} and {@link #contentTransformations}.\u000a *\u000a * By default all buttons that are included in [toolbar layout configuration](#!/guide/dev_toolbar)\u000a * are checked and registered with {@link CKEDITOR.editor#addFeature}, all styles available in the\u000a * 'Format' and 'Styles' drop-down lists are checked and registered too and so on.\u000a *\u000a * @since 4.1\u000a * @class CKEDITOR.feature\u000a * @abstract\u000a */\u000a\u000a/**\u000a * HTML code that can be generated by this feature.\u000a *\u000a * For example a basic image feature (image button displaying the image dialog window)\u000a * may allow `'img[!src,alt,width,height]'`.\u000a *\u000a * During the feature activation this value is passed to {@link CKEDITOR.filter#allow}.\u000a *\u000a * @property {CKEDITOR.filter.allowedContentRules} [allowedContent=null]\u000a */\u000a\u000a/**\u000a * Minimal HTML code that this feature must be allowed to\u000a * generate in order to work.\u000a *\u000a * For example a basic image feature (image button displaying the image dialog window)\u000a * needs `'img[src,alt]'` in order to be activated.\u000a *\u000a * During the feature validation this value is passed to {@link CKEDITOR.filter#check}.\u000a *\u000a * If this value is not provided, a feature will be always activated.\u000a *\u000a * @property {CKEDITOR.filter.contentRule} [requiredContent=null]\u000a */\u000a\u000a/**\u000a * The name of the feature.\u000a *\u000a * It is used for example to identify which {@link CKEDITOR.filter#allowedContent}\u000a * rule was added for which feature.\u000a *\u000a * @property {String} name\u000a */\u000a\u000a/**\u000a * Feature content forms to be registered in the {@link CKEDITOR.editor#filter}\u000a * during the feature activation.\u000a *\u000a * See {@link CKEDITOR.filter#addContentForms} for more details.\u000a *\u000a * @property [contentForms=null]\u000a */\u000a\u000a/**\u000a * Transformations (usually for content generated by this feature, but not necessarily)\u000a * that will be registered in the {@link CKEDITOR.editor#filter} during the feature activation.\u000a *\u000a * See {@link CKEDITOR.filter#addTransformations} for more details.\u000a *\u000a * @property [contentTransformations=null]\u000a */\u000a\u000a/**\u000a * Returns a feature that this feature needs to register.\u000a *\u000a * In some cases, during activation, one feature may need to register\u000a * another feature. For example a {@link CKEDITOR.ui.button} often registers\u000a * a related command. See {@link CKEDITOR.ui.button#toFeature}.\u000a *\u000a * This method is executed when a feature is passed to the {@link CKEDITOR.editor#addFeature}.\u000a *\u000a * @method toFeature\u000a * @returns {CKEDITOR.feature}\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.focusManager} class, which is used\u000a *		to handle the focus in editor instances.\u000a */\u000a\u000a( function() {\u000a	/**\u000a	 * Manages the focus activity in an editor instance. This class is to be\u000a	 * used mainly by UI element coders when adding interface elements that need\u000a	 * to set the focus state of the editor.\u000a	 *\u000a	 *		var focusManager = new CKEDITOR.focusManager( editor );\u000a	 *		focusManager.focus();\u000a	 *\u000a	 * @class\u000a	 * @constructor Creates a focusManager class instance.\u000a	 * @param {CKEDITOR.editor} editor The editor instance.\u000a	 */\u000a	CKEDITOR.focusManager = function( editor ) {\u000a		if ( editor.focusManager )\u000a			return editor.focusManager;\u000a\u000a		/**\u000a		 * Indicates that the editor instance has focus.\u000a		 *\u000a		 *		alert( CKEDITOR.instances.editor1.focusManager.hasFocus ); // e.g. true\u000a		 */\u000a		this.hasFocus = false;\u000a\u000a		/**\u000a		 * Indicates the currently focused DOM element that makes the editor activated.\u000a		 *\u000a		 * @property {CKEDITOR.dom.domObject}\u000a		 */\u000a		this.currentActive = null;\u000a\u000a		/**\u000a		 * Object used to store private stuff.\u000a		 *\u000a		 * @private\u000a		 */\u000a		this._ = {\u000a			editor: editor\u000a		};\u000a\u000a		return this;\u000a	};\u000a\u000a	var SLOT_NAME = 'focusmanager',\u000a		SLOT_NAME_LISTENERS = 'focusmanager_handlers';\u000a\u000a	/**\u000a	 * Object used to store private stuff.\u000a	 *\u000a	 * @private\u000a	 * @class\u000a	 * @singleton\u000a	 */\u000a	CKEDITOR.focusManager._ = {\u000a		/**\u000a		 * The delay (in milliseconds) to deactivate the editor when a UI DOM element has lost focus.\u000a		 *\u000a		 * @private\u000a		 * @property {Number} [blurDelay=200]\u000a		 * @member CKEDITOR.focusManager._\u000a		 */\u000a		blurDelay: 200\u000a	};\u000a\u000a	CKEDITOR.focusManager.prototype = {\u000a\u000a		/**\u000a		 * Indicates that this editor instance is activated (due to a DOM focus change).\u000a		 * The `activated` state is a symbolic indicator of an active user\u000a		 * interaction session.\u000a		 *\u000a		 * **Note:** This method will not introduce UI focus\u000a		 * impact on DOM, it is here to record the editor UI focus state internally.\u000a		 * If you want to make the cursor blink inside the editable, use\u000a		 * {@link CKEDITOR.editor#method-focus} instead.\u000a		 *\u000a		 *		var editor = CKEDITOR.instances.editor1;\u000a		 *		editor.focusManage.focus( editor.editable() );\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} [currentActive] The new value of the {@link #currentActive} property.\u000a		 * @member CKEDITOR.focusManager\u000a		 */\u000a		focus: function( currentActive ) {\u000a			if ( this._.timer )\u000a				clearTimeout( this._.timer );\u000a\u000a			if ( currentActive )\u000a				this.currentActive = currentActive;\u000a\u000a			if ( !( this.hasFocus || this._.locked ) ) {\u000a				// If another editor has the current focus, we first "blur" it. In\u000a				// this way the events happen in a more logical sequence, like:\u000a				//		"focus 1" > "blur 1" > "focus 2"\u000a				// ... instead of:\u000a				//		"focus 1" > "focus 2" > "blur 1"\u000a				var current = CKEDITOR.currentInstance;\u000a				current && current.focusManager.blur( 1 );\u000a\u000a				this.hasFocus = true;\u000a\u000a				var ct = this._.editor.container;\u000a				ct && ct.addClass( 'cke_focus' );\u000a				this._.editor.fire( 'focus' );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Prevents from changing the focus manager state until the next {@link #unlock} is called.\u000a		 *\u000a		 * @member CKEDITOR.focusManager\u000a		 */\u000a		lock: function() {\u000a			this._.locked = 1;\u000a		},\u000a\u000a		/**\u000a		 * Restores the automatic focus management if {@link #lock} is called.\u000a		 *\u000a		 * @member CKEDITOR.focusManager\u000a		 */\u000a		unlock: function() {\u000a			delete this._.locked;\u000a		},\u000a\u000a		/**\u000a		 * Used to indicate that the editor instance has been deactivated by the specified\u000a		 * element which has just lost focus.\u000a		 *\u000a		 * **Note:** This function acts asynchronously with a delay of 100ms to\u000a		 * avoid temporary deactivation. Use the `noDelay` parameter instead\u000a		 * to deactivate immediately.\u000a		 *\u000a		 *		var editor = CKEDITOR.instances.editor1;\u000a		 *		editor.focusManager.blur();\u000a		 *\u000a		 * @param {Boolean} [noDelay=false] Immediately deactivate the editor instance synchronously.\u000a		 * @member CKEDITOR.focusManager\u000a		 */\u000a		blur: function( noDelay ) {\u000a			if ( this._.locked )\u000a				return;\u000a\u000a			function doBlur() {\u000a				if ( this.hasFocus ) {\u000a					this.hasFocus = false;\u000a\u000a					var ct = this._.editor.container;\u000a					ct && ct.removeClass( 'cke_focus' );\u000a					this._.editor.fire( 'blur' );\u000a				}\u000a			}\u000a\u000a			if ( this._.timer )\u000a				clearTimeout( this._.timer );\u000a\u000a			var delay = CKEDITOR.focusManager._.blurDelay;\u000a			if ( noDelay || !delay )\u000a				doBlur.call( this );\u000a			else {\u000a				this._.timer = CKEDITOR.tools.setTimeout( function() {\u000a					delete this._.timer;\u000a					doBlur.call( this );\u000a				}, delay, this );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Registers a UI DOM element to the focus manager, which will make the focus manager "hasFocus"\u000a		 * once the input focus is relieved on the element.\u000a		 * This method is designed to be used by plugins to expand the jurisdiction of the editor focus.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} element The container (topmost) element of one UI part.\u000a		 * @param {Boolean} isCapture If specified, {@link CKEDITOR.event#useCapture} will be used when listening to the focus event.\u000a		 * @member CKEDITOR.focusManager\u000a		 */\u000a		add: function( element, isCapture ) {\u000a			var fm = element.getCustomData( SLOT_NAME );\u000a			if ( !fm || fm != this ) {\u000a				// If this element is already taken by another instance, dismiss it first.\u000a				fm && fm.remove( element );\u000a\u000a				var focusEvent = 'focus',\u000a					blurEvent = 'blur';\u000a\u000a				// Bypass the element's internal DOM focus change.\u000a				if ( isCapture ) {\u000a\u000a					// Use "focusin/focusout" events instead of capture phase in IEs,\u000a					// which fires synchronously.\u000a					if ( CKEDITOR.env.ie ) {\u000a						focusEvent = 'focusin';\u000a						blurEvent = 'focusout';\u000a					} else {\u000a						CKEDITOR.event.useCapture = 1;\u000a					}\u000a				}\u000a\u000a				var listeners = {\u000a					blur: function() {\u000a						if ( element.equals( this.currentActive ) )\u000a							this.blur();\u000a					},\u000a					focus: function() {\u000a						this.focus( element );\u000a					}\u000a				};\u000a\u000a				element.on( focusEvent, listeners.focus, this );\u000a				element.on( blurEvent, listeners.blur, this );\u000a\u000a				if ( isCapture )\u000a					CKEDITOR.event.useCapture = 0;\u000a\u000a				element.setCustomData( SLOT_NAME, this );\u000a				element.setCustomData( SLOT_NAME_LISTENERS, listeners );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Dismisses an element from the focus manager delegations added by {@link #add}.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} element The element to be removed from the focus manager.\u000a		 * @member CKEDITOR.focusManager\u000a		 */\u000a		remove: function( element ) {\u000a			element.removeCustomData( SLOT_NAME );\u000a			var listeners = element.removeCustomData( SLOT_NAME_LISTENERS );\u000a			element.removeListener( 'blur', listeners.blur );\u000a			element.removeListener( 'focus', listeners.focus );\u000a		}\u000a\u000a	};\u000a\u000a} )();\u000a\u000a/**\u000a * Fired when the editor instance receives the input focus.\u000a *\u000a *		editor.on( 'focus', function( e ) {\u000a *			alert( 'The editor named ' + e.editor.name + ' is now focused' );\u000a *		} );\u000a *\u000a * @event focus\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor The editor instance.\u000a */\u000a\u000a/**\u000a * Fired when the editor instance loses the input focus.\u000a *\u000a * **Note:** This event will **NOT** be triggered when focus is moved internally, e.g. from\u000a * an editable to another part of the editor UI like a dialog window.\u000a * If you are interested only in the focus state of the editable, listen to the `focus`\u000a * and `blur` events of the {@link CKEDITOR.editable} instead.\u000a *\u000a *		editor.on( 'blur', function( e ) {\u000a *			alert( 'The editor named ' + e.editor.name + ' lost the focus' );\u000a *		} );\u000a *\u000a * @event blur\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor The editor instance.\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.config} object that stores the\u000a * default configuration settings.\u000a */\u000a\u000a/**\u000a * Used in conjunction with {@link CKEDITOR.config#enterMode}\u000a * and {@link CKEDITOR.config#shiftEnterMode} configuration\u000a * settings to make the editor produce `<p>` tags when\u000a * using the *Enter* key.\u000a *\u000a * @readonly\u000a * @property {Number} [=1]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.ENTER_P = 1;\u000a\u000a/**\u000a * Used in conjunction with {@link CKEDITOR.config#enterMode}\u000a * and {@link CKEDITOR.config#shiftEnterMode} configuration\u000a * settings to make the editor produce `<br>` tags when\u000a * using the *Enter* key.\u000a *\u000a * @readonly\u000a * @property {Number} [=2]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.ENTER_BR = 2;\u000a\u000a/**\u000a * Used in conjunction with {@link CKEDITOR.config#enterMode}\u000a * and {@link CKEDITOR.config#shiftEnterMode} configuration\u000a * settings to make the editor produce `<div>` tags when\u000a * using the *Enter* key.\u000a *\u000a * @readonly\u000a * @property {Number} [=3]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.ENTER_DIV = 3;\u000a\u000a/**\u000a * Stores default configuration settings. Changes to this object are\u000a * reflected in all editor instances, if not specified otherwise for a particular\u000a * instance.\u000a *\u000a * Read more about setting CKEditor configuration in the\u000a * [Developer's Guide](#!/guide/dev_configuration).\u000a *\u000a * @class\u000a * @singleton\u000a */\u000aCKEDITOR.config = {\u000a	/**\u000a	 * The URL path for the custom configuration file to be loaded. If not\u000a	 * overloaded with inline configuration, it defaults to the `config.js`\u000a	 * file present in the root of the CKEditor installation directory.\u000a	 *\u000a	 * CKEditor will recursively load custom configuration files defined inside\u000a	 * other custom configuration files.\u000a	 *\u000a	 *		// Load a specific configuration file.\u000a	 *		CKEDITOR.replace( 'myfield', { customConfig: '/myconfig.js' } );\u000a	 *\u000a	 *		// Do not load any custom configuration file.\u000a	 *		CKEDITOR.replace( 'myfield', { customConfig: '' } );\u000a	 *\u000a	 * @cfg {String} [="<CKEditor folder>/config.js"]\u000a	 */\u000a	customConfig: 'config.js',\u000a\u000a	/**\u000a	 * Whether the replaced element (usually a `<textarea>`)\u000a	 * is to be updated automatically when posting the form containing the editor.\u000a	 *\u000a	 * @cfg\u000a	 */\u000a	autoUpdateElement: true,\u000a\u000a	/**\u000a	 * The user interface language localization to use. If left empty, the editor\u000a	 * will automatically be localized to the user language. If the user language is not supported,\u000a	 * the language specified in the {@link CKEDITOR.config#defaultLanguage}\u000a	 * configuration setting is used.\u000a	 *\u000a	 *		// Load the German interface.\u000a	 *		config.language = 'de';\u000a	 *\u000a	 * @cfg\u000a	 */\u000a	language: '',\u000a\u000a	/**\u000a	 * The language to be used if the {@link CKEDITOR.config#language}\u000a	 * setting is left empty and it is not possible to localize the editor to the user language.\u000a	 *\u000a	 *		config.defaultLanguage = 'it';\u000a	 *\u000a	 * @cfg\u000a	 */\u000a	defaultLanguage: 'en',\u000a\u000a	/**\u000a	 * The writing direction of the language which is used to create editor contents.\u000a	 * Allowed values are:\u000a	 *\u000a	 * * `''` (an empty string) &ndash; Indicates that content direction will be the same as either\u000a	 *      the editor UI direction or the page element direction depending on the editor type:\u000a	 *     * Classic editor &ndash; The same as the user interface language direction.\u000a	 *     * Inline editor &ndash; The same as the editable element text direction.\u000a	 * * `'ltr'` &ndash; Indicates a Left-To-Right text direction (like in English).\u000a	 * * `'rtl'` &ndash; Indicates a Right-To-Left text direction (like in Arabic).\u000a	 *\u000a	 * Example:\u000a	 *\u000a	 *		config.contentsLangDirection = 'rtl';\u000a	 *\u000a	 * @cfg\u000a	 */\u000a	contentsLangDirection: '',\u000a\u000a	/**\u000a	 * Sets the behavior of the *Enter* key. It also determines other behavior\u000a	 * rules of the editor, like whether the `<br>` element is to be used\u000a	 * as a paragraph separator when indenting text.\u000a	 * The allowed values are the following constants that cause the behavior outlined below:\u000a	 *\u000a	 * * {@link CKEDITOR#ENTER_P} (1) &ndash; new `<p>` paragraphs are created;\u000a	 * * {@link CKEDITOR#ENTER_BR} (2) &ndash; lines are broken with `<br>` elements;\u000a	 * * {@link CKEDITOR#ENTER_DIV} (3) &ndash; new `<div>` blocks are created.\u000a	 *\u000a	 * **Note**: It is recommended to use the {@link CKEDITOR#ENTER_P} setting because of\u000a	 * its semantic value and correctness. The editor is optimized for this setting.\u000a	 *\u000a	 *		// Not recommended.\u000a	 *		config.enterMode = CKEDITOR.ENTER_BR;\u000a	 *\u000a	 * @cfg {Number} [=CKEDITOR.ENTER_P]\u000a	 */\u000a	enterMode: CKEDITOR.ENTER_P,\u000a\u000a	/**\u000a	 * Force the use of {@link CKEDITOR.config#enterMode} as line break regardless\u000a	 * of the context. If, for example, {@link CKEDITOR.config#enterMode} is set\u000a	 * to {@link CKEDITOR#ENTER_P}, pressing the *Enter* key inside a\u000a	 * `<div>` element will create a new paragraph with `<p>`\u000a	 * instead of a `<div>`.\u000a	 *\u000a	 *		// Not recommended.\u000a	 *		config.forceEnterMode = true;\u000a	 *\u000a	 * @since 3.2.1\u000a	 * @cfg\u000a	 */\u000a	forceEnterMode: false,\u000a\u000a	/**\u000a	 * Similarly to the {@link CKEDITOR.config#enterMode} setting, it defines the behavior\u000a	 * of the *Shift+Enter* key combination.\u000a	 *\u000a	 * The allowed values are the following constants the behavior outlined below:\u000a	 *\u000a	 * * {@link CKEDITOR#ENTER_P} (1) &ndash; new `<p>` paragraphs are created;\u000a	 * * {@link CKEDITOR#ENTER_BR} (2) &ndash; lines are broken with `<br>` elements;\u000a	 * * {@link CKEDITOR#ENTER_DIV} (3) &ndash; new `<div>` blocks are created.\u000a	 *\u000a	 * Example:\u000a	 *\u000a	 *		config.shiftEnterMode = CKEDITOR.ENTER_P;\u000a	 *\u000a	 * @cfg {Number} [=CKEDITOR.ENTER_BR]\u000a	 */\u000a	shiftEnterMode: CKEDITOR.ENTER_BR,\u000a\u000a	/**\u000a	 * Sets the `DOCTYPE` to be used when loading the editor content as HTML.\u000a	 *\u000a	 *		// Set the DOCTYPE to the HTML 4 (Quirks) mode.\u000a	 *		config.docType = '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">';\u000a	 *\u000a	 * @cfg\u000a	 */\u000a	docType: '<!DOCTYPE html>',\u000a\u000a	/**\u000a	 * Sets the `id` attribute to be used on the `body` element\u000a	 * of the editing area. This can be useful when you intend to reuse the original CSS\u000a	 * file you are using on your live website and want to assign the editor the same ID\u000a	 * as the section that will include the contents. In this way ID-specific CSS rules will\u000a	 * be enabled.\u000a	 *\u000a	 *		config.bodyId = 'contents_id';\u000a	 *\u000a	 * @since 3.1\u000a	 * @cfg\u000a	 */\u000a	bodyId: '',\u000a\u000a	/**\u000a	 * Sets the `class` attribute to be used on the `body` element\u000a	 * of the editing area. This can be useful when you intend to reuse the original CSS\u000a	 * file you are using on your live website and want to assign the editor the same class\u000a	 * as the section that will include the contents. In this way class-specific CSS rules will\u000a	 * be enabled.\u000a	 *\u000a	 *		config.bodyClass = 'contents';\u000a	 *\u000a	 * **Note:** Editor needs to load stylesheets containing contents styles. You can either\u000a	 * copy them to the `contents.css` file that editor loads by default or set the {@link #contentsCss}\u000a	 * option.\u000a	 *\u000a	 * **Note:** This setting applies only to the classic editor (the one that uses `iframe`).\u000a	 *\u000a	 * @since 3.1\u000a	 * @cfg\u000a	 */\u000a	bodyClass: '',\u000a\u000a	/**\u000a	 * Indicates whether the contents to be edited are being input as a full HTML page.\u000a	 * A full page includes the `<html>`, `<head>`, and `<body>` elements.\u000a	 * The final output will also reflect this setting, including the\u000a	 * `<body>` contents only if this setting is disabled.\u000a	 *\u000a	 *		config.fullPage = true;\u000a	 *\u000a	 * @since 3.1\u000a	 * @cfg\u000a	 */\u000a	fullPage: false,\u000a\u000a	/**\u000a	 * The height of the editing area that includes the editor content. This configuration\u000a	 * option accepts an integer (to denote a value in pixels) or any CSS-defined length unit\u000a	 * except percent (`%`) values  which are not supported.\u000a	 *\u000a	 * **Note:** This configuration option is ignored by [inline editor](#!/guide/dev_inline).\u000a	 *\u000a	 *		config.height = 500;		// 500 pixels.\u000a	 *		config.height = '25em';		// CSS length.\u000a	 *		config.height = '300px';	// CSS length.\u000a	 *\u000a	 * @cfg {Number/String}\u000a	 */\u000a	height: 200,\u000a\u000a	/**\u000a	 * Comma-separated list of plugins to be used in an editor instance. Note that\u000a	 * the actual plugins that are to be loaded could still be affected by two other settings:\u000a	 * {@link CKEDITOR.config#extraPlugins} and {@link CKEDITOR.config#removePlugins}.\u000a	 *\u000a	 * @cfg {String} [="<default list of plugins>"]\u000a	 */\u000a	plugins: '', // %REMOVE_LINE%\u000a\u000a	/**\u000a	 * A list of additional plugins to be loaded. This setting makes it easier\u000a	 * to add new plugins without having to touch the {@link CKEDITOR.config#plugins} setting.\u000a	 *\u000a	 * **Note:** The most recommended way to\u000a	 * [add CKEditor plugins](http://docs.ckeditor.com/#!/guide/dev_plugins) is through\u000a	 * [CKEditor Builder](http://ckeditor.com/builder).\u000a	 *\u000a	 *		config.extraPlugins = 'myplugin,anotherplugin';\u000a	 *\u000a	 * @cfg\u000a	 */\u000a	extraPlugins: '',\u000a\u000a	/**\u000a	 * A list of plugins that must not be loaded. This setting makes it possible\u000a	 * to avoid loading some plugins defined in the {@link CKEDITOR.config#plugins}\u000a	 * setting, without having to touch it.\u000a	 *\u000a	 * **Note:** A plugin required by another plugin cannot be removed and will cause\u000a	 * an error to be thrown. So for example if `contextmenu` is required by `tabletools`,\u000a	 * it can only be removed if `tabletools` is not loaded.\u000a	 *\u000a	 *		config.removePlugins = 'elementspath,save,font';\u000a	 *\u000a	 * @cfg\u000a	 */\u000a	removePlugins: '',\u000a\u000a	/**\u000a	 * A list of regular expressions to be executed on input HTML,\u000a	 * indicating HTML source code that when matched, must **not** be available in the WYSIWYG\u000a	 * mode for editing.\u000a	 *\u000a	 *		config.protectedSource.push( /<\u005c?[\u005cs\u005cS]*?\u005c?>/g );											// PHP code\u000a	 *		config.protectedSource.push( /<%[\u005cs\u005cS]*?%>/g );												// ASP code\u000a	 *		config.protectedSource.push( /(<asp:[^\u005c>]+>[\u005cs|\u005cS]*?<\u005c/asp:[^\u005c>]+>)|(<asp:[^\u005c>]+\u005c/>)/gi );	// ASP.Net code\u000a	 *\u000a	 * @cfg\u000a	 */\u000a	protectedSource: [],\u000a\u000a	/**\u000a	 * The editor `tabindex` value.\u000a	 *\u000a	 *		config.tabIndex = 1;\u000a	 *\u000a	 * @cfg\u000a	 */\u000a	tabIndex: 0,\u000a\u000a	/**\u000a	 * The editor UI outer width. This configuration option accepts an integer\u000a	 * (to denote a value in pixels) or any CSS-defined length unit.\u000a	 *\u000a	 * Unlike the {@link CKEDITOR.config#height} setting, this\u000a	 * one will set the outer width of the entire editor UI, not for the\u000a	 * editing area only.\u000a	 *\u000a	 * **Note:** This configuration option is ignored by [inline editor](#!/guide/dev_inline).\u000a	 *\u000a	 *		config.width = 850;		// 850 pixels wide.\u000a	 *		config.width = '75%';	// CSS unit.\u000a	 *\u000a	 * @cfg {String/Number}\u000a	 */\u000a	width: '',\u000a\u000a	/**\u000a	 * The base Z-index for floating dialog windows and popups.\u000a	 *\u000a	 *		config.baseFloatZIndex = 2000;\u000a	 *\u000a	 * @cfg\u000a	 */\u000a	baseFloatZIndex: 10000,\u000a\u000a	/**\u000a	 * The keystrokes that are blocked by default as the browser implementation\u000a	 * is buggy. These default keystrokes are handled by the editor.\u000a	 *\u000a	 *		// Default setting.\u000a	 *		config.blockedKeystrokes = [\u000a	 *			CKEDITOR.CTRL + 66, // CTRL+B\u000a	 *			CKEDITOR.CTRL + 73, // CTRL+I\u000a	 *			CKEDITOR.CTRL + 85 // CTRL+U\u000a	 *		];\u000a	 *\u000a	 * @cfg {Array} [blockedKeystrokes=see example]\u000a	 */\u000a	blockedKeystrokes: [\u000a		CKEDITOR.CTRL + 66, // CTRL+B\u000a		CKEDITOR.CTRL + 73, // CTRL+I\u000a		CKEDITOR.CTRL + 85 // CTRL+U\u000a	]\u000a};\u000a\u000a/**\u000a * Indicates that some of the editor features, like alignment and text\u000a * direction, should use the "computed value" of the feature to indicate its\u000a * on/off state instead of using the "real value".\u000a *\u000a * If enabled in a Left-To-Right written document, the "Left Justify"\u000a * alignment button will be shown as active, even if the alignment style is not\u000a * explicitly applied to the current paragraph in the editor.\u000a *\u000a *		config.useComputedState = false;\u000a *\u000a * @since 3.4\u000a * @cfg {Boolean} [useComputedState=true]\u000a */\u000a\u000a/**\u000a * The base user interface color to be used by the editor. Not all skins are\u000a * compatible with this setting.\u000a *\u000a *		// Using a color code.\u000a *		config.uiColor = '#AADC6E';\u000a *\u000a *		// Using an HTML color name.\u000a *		config.uiColor = 'Gold';\u000a *\u000a * @cfg {String} uiColor\u000a */\u000a\u000a// PACKAGER_RENAME( CKEDITOR.config )\u000a\u000a// Define changes to default configuration here.\u000a// For complete reference see:\u000a// http://docs.ckeditor.com/#!/api/CKEDITOR.config\u000a\u000a// The toolbar groups arrangement, optimized for a single toolbar row.\u000aCKEDITOR.config.toolbarGroups = [\u000a	{ name: 'document',	   groups: [ 'mode', 'document', 'doctools' ] },\u000a	{ name: 'clipboard',   groups: [ 'clipboard', 'undo' ] },\u000a	{ name: 'editing',     groups: [ 'find', 'selection', 'spellchecker' ] },\u000a	{ name: 'forms' },\u000a	{ name: 'basicstyles', groups: [ 'basicstyles', 'cleanup' ] },\u000a	{ name: 'paragraph',   groups: [ 'list', 'indent', 'blocks', 'align', 'bidi' ] },\u000a	{ name: 'links' },\u000a	{ name: 'insert' },\u000a	{ name: 'styles' },\u000a	{ name: 'colors' },\u000a	{ name: 'tools' },\u000a	{ name: 'others' }\u000a];\u000a\u000a// The default plugins included in the basic setup define some buttons that\u000a// are not needed in a basic editor. They are removed here.\u000a// CKEDITOR.config.removeButtons = 'Cut,Copy,Paste,Undo,Redo,Anchor,Underline,Strike,Subscript,Superscript';\u000aCKEDITOR.config.removeButtons = 'Cut,Copy,Paste,Anchor,Strike,Subscript,Superscript';\u000a\u000a// Dialog windows are also simplified.\u000aCKEDITOR.config.removeDialogTabs = 'link:advanced';\u000a\u000aCKEDITOR.config.customConfig = null;\u000a\u000aCKEDITOR.skinName = 'bootstrapck';\u000a\u000aCKEDITOR.config.plugins = 'basicstyles,clipboard,enterkey,entities,floatingspace,indentlist,link,list,toolbar,undo,justify,blockquote,format';\u000a\u000aCKEDITOR.lang.languages = {\u000a	// es: 1,\u000a	en: 1\u000a};\u000aCKEDITOR.lang.rtl = {};\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.editor} class that represents an\u000a *		editor instance.\u000a */\u000a\u000a( function() {\u000a	// Override the basic constructor defined at editor_basic.js.\u000a	Editor.prototype = CKEDITOR.editor.prototype;\u000a	CKEDITOR.editor = Editor;\u000a\u000a	/**\u000a	 * Represents an editor instance. This constructor should be rarely\u000a	 * used in favor of the {@link CKEDITOR} editor creation functions.\u000a	 *\u000a	 * @class CKEDITOR.editor\u000a	 * @mixins CKEDITOR.event\u000a	 * @constructor Creates an editor class instance.\u000a	 * @param {Object} [instanceConfig] Configuration values for this specific instance.\u000a	 * @param {CKEDITOR.dom.element} [element] The DOM element upon which this editor\u000a	 * will be created.\u000a	 * @param {Number} [mode] The element creation mode to be used by this editor.\u000a	 */\u000a	function Editor( instanceConfig, element, mode ) {\u000a		// Call the CKEDITOR.event constructor to initialize this instance.\u000a		CKEDITOR.event.call( this );\u000a\u000a		// Make a clone of the config object, to avoid having it touched by our code. (#9636)\u000a		instanceConfig = instanceConfig && CKEDITOR.tools.clone( instanceConfig );\u000a\u000a		// if editor is created off one page element.\u000a		if ( element !== undefined ) {\u000a			// Asserting element and mode not null.\u000a			if ( !( element instanceof CKEDITOR.dom.element ) )\u000a				throw new Error( 'Expect element of type CKEDITOR.dom.element.' );\u000a			else if ( !mode )\u000a				throw new Error( 'One of the element modes must be specified.' );\u000a\u000a			if ( CKEDITOR.env.ie && CKEDITOR.env.quirks && mode == CKEDITOR.ELEMENT_MODE_INLINE )\u000a				throw new Error( 'Inline element mode is not supported on IE quirks.' );\u000a\u000a			if ( !isSupportedElement( element, mode ) )\u000a				throw new Error( 'The specified element mode is not supported on element: "' + element.getName() + '".' );\u000a\u000a			/**\u000a			 * The original host page element upon which the editor is created, it's only\u000a			 * supposed to be provided by the concrete editor creator and is not subjected to\u000a			 * be modified.\u000a			 *\u000a			 * @readonly\u000a			 * @property {CKEDITOR.dom.element}\u000a			 */\u000a			this.element = element;\u000a\u000a			/**\u000a			 * This property indicate the way how this instance is associated with the {@link #element}.\u000a			 *\u000a			 * @readonly\u000a			 * @property {Number}\u000a			 * @see CKEDITOR#ELEMENT_MODE_INLINE\u000a			 * @see CKEDITOR#ELEMENT_MODE_REPLACE\u000a			 */\u000a			this.elementMode = mode;\u000a\u000a			this.name = ( this.elementMode != CKEDITOR.ELEMENT_MODE_APPENDTO ) && ( element.getId() || element.getNameAtt() );\u000a		} else {\u000a			this.elementMode = CKEDITOR.ELEMENT_MODE_NONE;\u000a		}\u000a\u000a		// Declare the private namespace.\u000a		this._ = {};\u000a\u000a		this.commands = {};\u000a\u000a		/**\u000a		 * Contains all UI templates created for this editor instance.\u000a		 *\u000a		 * @readonly\u000a		 * @property {Object}\u000a		 */\u000a		this.templates = {};\u000a\u000a		/**\u000a		 * A unique identifier of this editor instance.\u000a		 *\u000a		 * **Note:** It will be originated from the ID or name\u000a		 * attribute of the {@link #element}, otherwise a name pattern of\u000a		 * `'editor{n}'` will be used.\u000a		 *\u000a		 * @readonly\u000a		 * @property {String}\u000a		 */\u000a		this.name = this.name || genEditorName();\u000a\u000a		/**\u000a		 * A unique random string assigned to each editor instance in the page.\u000a		 *\u000a		 * @readonly\u000a		 * @property {String}\u000a		 */\u000a		this.id = CKEDITOR.tools.getNextId();\u000a\u000a		/**\u000a		 * Indicates editor initialization status. The following statuses are available:\u000a		 *\u000a		 *	* **unloaded**: the initial state - editor's instance has been initialized,\u000a		 *	but its components (config, plugins, language files) are not loaded yet.\u000a		 *	* **loaded**: editor's components have been loaded - see {@link CKEDITOR.editor#loaded} event.\u000a		 *	* **ready**: editor is fully initialized and ready - see {@link CKEDITOR.editor#instanceReady} event.\u000a		 *	* **destroyed**: the editor has been destroyed - see {@link CKEDITOR.editor#method-destroy} method.\u000a		 *\u000a		 * @since 4.1\u000a		 * @readonly\u000a		 * @property {String}\u000a		 */\u000a		this.status = 'unloaded';\u000a\u000a		/**\u000a		 * The configurations for this editor instance. It inherits all\u000a		 * settings defined in {@link CKEDITOR.config}, combined with settings\u000a		 * loaded from custom configuration files and those defined inline in\u000a		 * the page when creating the editor.\u000a		 *\u000a		 *		var editor = CKEDITOR.instances.editor1;\u000a		 *		alert( editor.config.skin ); // e.g. 'moono'\u000a		 *\u000a		 * @readonly\u000a		 * @property {CKEDITOR.config}\u000a		 */\u000a		this.config = CKEDITOR.tools.prototypedCopy( CKEDITOR.config );\u000a\u000a		/**\u000a		 * Namespace containing UI features related to this editor instance.\u000a		 *\u000a		 * @readonly\u000a		 * @property {CKEDITOR.ui}\u000a		 */\u000a		this.ui = new CKEDITOR.ui( this );\u000a\u000a		/**\u000a		 * Controls the focus state of this editor instance. This property\u000a		 * is rarely used for normal API operations. It is mainly\u000a		 * destinated to developer adding UI elements to the editor interface.\u000a		 *\u000a		 * @readonly\u000a		 * @property {CKEDITOR.focusManager}\u000a		 */\u000a		this.focusManager = new CKEDITOR.focusManager( this );\u000a\u000a		/**\u000a		 * Controls keystrokes typing in this editor instance.\u000a		 *\u000a		 * @readonly\u000a		 * @property {CKEDITOR.keystrokeHandler}\u000a		 */\u000a		this.keystrokeHandler = new CKEDITOR.keystrokeHandler( this );\u000a\u000a		// Make the editor update its command states on mode change.\u000a		this.on( 'readOnly', updateCommands );\u000a		this.on( 'selectionChange', function( evt ) {\u000a			updateCommandsContext( this, evt.data.path );\u000a		} );\u000a		this.on( 'activeFilterChange', function() {\u000a			updateCommandsContext( this, this.elementPath(), true );\u000a		} );\u000a		this.on( 'mode', updateCommands );\u000a\u000a		// Handle startup focus.\u000a		this.on( 'instanceReady', function() {\u000a			this.config.startupFocus && this.focus();\u000a		} );\u000a\u000a		CKEDITOR.fire( 'instanceCreated', null, this );\u000a\u000a		// Add this new editor to the CKEDITOR.instances collections.\u000a		CKEDITOR.add( this );\u000a\u000a		// Return the editor instance immediately to enable early stage event registrations.\u000a		CKEDITOR.tools.setTimeout( function() {\u000a			initConfig( this, instanceConfig );\u000a		}, 0, this );\u000a	}\u000a\u000a	var nameCounter = 0;\u000a\u000a	function genEditorName() {\u000a		do {\u000a			var name = 'editor' + ( ++nameCounter );\u000a		}\u000a		while ( CKEDITOR.instances[ name ] );\u000a\u000a		return name;\u000a	}\u000a\u000a	// Asserting element DTD depending on mode.\u000a	function isSupportedElement( element, mode ) {\u000a		if ( mode == CKEDITOR.ELEMENT_MODE_INLINE )\u000a			return element.is( CKEDITOR.dtd.$editable ) || element.is( 'textarea' );\u000a		else if ( mode == CKEDITOR.ELEMENT_MODE_REPLACE )\u000a			return !element.is( CKEDITOR.dtd.$nonBodyContent );\u000a		return 1;\u000a	}\u000a\u000a	function updateCommands() {\u000a		var commands = this.commands,\u000a			name;\u000a\u000a		for ( name in commands )\u000a			updateCommand( this, commands[ name ] );\u000a	}\u000a\u000a	function updateCommand( editor, cmd ) {\u000a		cmd[ cmd.startDisabled ? 'disable' : editor.readOnly && !cmd.readOnly ? 'disable' : cmd.modes[ editor.mode ] ? 'enable' : 'disable' ]();\u000a	}\u000a\u000a	function updateCommandsContext( editor, path, forceRefresh ) {\u000a		// Commands cannot be refreshed without a path. In edge cases\u000a		// it may happen that there's no selection when this function is executed.\u000a		// For example when active filter is changed in #10877.\u000a		if ( !path )\u000a			return;\u000a\u000a		var command,\u000a			name,\u000a			commands = editor.commands;\u000a\u000a		for ( name in commands ) {\u000a			command = commands[ name ];\u000a\u000a			if ( forceRefresh || command.contextSensitive )\u000a				command.refresh( editor, path );\u000a		}\u000a	}\u000a\u000a	// ##### START: Config Privates\u000a\u000a	// These function loads custom configuration files and cache the\u000a	// CKEDITOR.editorConfig functions defined on them, so there is no need to\u000a	// download them more than once for several instances.\u000a	var loadConfigLoaded = {};\u000a\u000a	function loadConfig( editor ) {\u000a		var customConfig = editor.config.customConfig;\u000a\u000a		// Check if there is a custom config to load.\u000a		if ( !customConfig )\u000a			return false;\u000a\u000a		customConfig = CKEDITOR.getUrl( customConfig );\u000a\u000a		var loadedConfig = loadConfigLoaded[ customConfig ] || ( loadConfigLoaded[ customConfig ] = {} );\u000a\u000a		// If the custom config has already been downloaded, reuse it.\u000a		if ( loadedConfig.fn ) {\u000a			// Call the cached CKEDITOR.editorConfig defined in the custom\u000a			// config file for the editor instance depending on it.\u000a			loadedConfig.fn.call( editor, editor.config );\u000a\u000a			// If there is no other customConfig in the chain, fire the\u000a			// "configLoaded" event.\u000a			if ( CKEDITOR.getUrl( editor.config.customConfig ) == customConfig || !loadConfig( editor ) )\u000a				editor.fireOnce( 'customConfigLoaded' );\u000a		} else {\u000a			// Load the custom configuration file.\u000a			// To resolve customConfig race conflicts, use scriptLoader#queue\u000a			// instead of scriptLoader#load (#6504).\u000a			CKEDITOR.scriptLoader.queue( customConfig, function() {\u000a				// If the CKEDITOR.editorConfig function has been properly\u000a				// defined in the custom configuration file, cache it.\u000a				if ( CKEDITOR.editorConfig )\u000a					loadedConfig.fn = CKEDITOR.editorConfig;\u000a				else\u000a					loadedConfig.fn = function() {};\u000a\u000a				// Call the load config again. This time the custom\u000a				// config is already cached and so it will get loaded.\u000a				loadConfig( editor );\u000a			} );\u000a		}\u000a\u000a		return true;\u000a	}\u000a\u000a	function initConfig( editor, instanceConfig ) {\u000a		// Setup the lister for the "customConfigLoaded" event.\u000a		editor.on( 'customConfigLoaded', function() {\u000a			if ( instanceConfig ) {\u000a				// Register the events that may have been set at the instance\u000a				// configuration object.\u000a				if ( instanceConfig.on ) {\u000a					for ( var eventName in instanceConfig.on ) {\u000a						editor.on( eventName, instanceConfig.on[ eventName ] );\u000a					}\u000a				}\u000a\u000a				// Overwrite the settings from the in-page config.\u000a				CKEDITOR.tools.extend( editor.config, instanceConfig, true );\u000a\u000a				delete editor.config.on;\u000a			}\u000a\u000a			onConfigLoaded( editor );\u000a		} );\u000a\u000a		// The instance config may override the customConfig setting to avoid\u000a		// loading the default ~/config.js file.\u000a		if ( instanceConfig && instanceConfig.customConfig != null )\u000a			editor.config.customConfig = instanceConfig.customConfig;\u000a\u000a		// Load configs from the custom configuration files.\u000a		if ( !loadConfig( editor ) )\u000a			editor.fireOnce( 'customConfigLoaded' );\u000a	}\u000a\u000a	// ##### END: Config Privates\u000a\u000a	// Set config related properties.\u000a	function onConfigLoaded( editor ) {\u000a		var config = editor.config;\u000a\u000a		/**\u000a		 * Indicates the read-only state of this editor. This is a read-only property.\u000a		 *\u000a		 * @since 3.6\u000a		 * @readonly\u000a		 * @property {Boolean}\u000a		 * @see CKEDITOR.editor#setReadOnly\u000a		 */\u000a		editor.readOnly = !!(\u000a			config.readOnly || (\u000a				editor.elementMode == CKEDITOR.ELEMENT_MODE_INLINE ?\u000a						editor.element.is( 'textarea' ) ?\u000a								editor.element.hasAttribute( 'disabled' )\u000a							:\u000a								editor.element.isReadOnly()\u000a					:\u000a						editor.elementMode == CKEDITOR.ELEMENT_MODE_REPLACE ?\u000a								editor.element.hasAttribute( 'disabled' )\u000a							:\u000a								false\u000a			)\u000a		);\u000a\u000a		/**\u000a		 * Indicates that the editor is running in an environment where\u000a		 * no block elements are accepted inside the content.\u000a		 *\u000a		 * This can be for example inline editor based on `<h1>` element.\u000a		 *\u000a		 * @readonly\u000a		 * @property {Boolean}\u000a		 */\u000a		editor.blockless = editor.elementMode == CKEDITOR.ELEMENT_MODE_INLINE ?\u000a			!( editor.element.is( 'textarea' ) || CKEDITOR.dtd[ editor.element.getName() ].p ) :\u000a			false;\u000a\u000a		/**\u000a		 * The [tabbing navigation](http://en.wikipedia.org/wiki/Tabbing_navigation) order determined for this editor instance.\u000a		 * This can be set by the <code>{@link CKEDITOR.config#tabIndex}</code>\u000a		 * setting or taken from the `tabindex` attribute of the\u000a		 * {@link #element} associated with the editor.\u000a		 *\u000a		 *		alert( editor.tabIndex ); // e.g. 0\u000a		 *\u000a		 * @readonly\u000a		 * @property {Number} [=0]\u000a		 */\u000a		editor.tabIndex = config.tabIndex || editor.element && editor.element.getAttribute( 'tabindex' ) || 0;\u000a\u000a		editor.activeEnterMode = editor.enterMode = validateEnterMode( editor, config.enterMode );\u000a		editor.activeShiftEnterMode = editor.shiftEnterMode = validateEnterMode( editor, config.shiftEnterMode );\u000a\u000a		// Set CKEDITOR.skinName. Note that it is not possible to have\u000a		// different skins on the same page, so the last one to set it "wins".\u000a		if ( config.skin )\u000a			CKEDITOR.skinName = config.skin;\u000a\u000a		// Fire the "configLoaded" event.\u000a		editor.fireOnce( 'configLoaded' );\u000a\u000a		initComponents( editor );\u000a	}\u000a\u000a	// Various other core components that read editor configuration.\u000a	function initComponents( editor ) {\u000a		// Documented in dataprocessor.js.\u000a		editor.dataProcessor = new CKEDITOR.htmlDataProcessor( editor );\u000a\u000a		// Set activeFilter directly to avoid firing event.\u000a		editor.filter = editor.activeFilter = new CKEDITOR.filter( editor );\u000a\u000a		loadSkin( editor );\u000a	}\u000a\u000a	function loadSkin( editor ) {\u000a		CKEDITOR.skin.loadPart( 'editor', function() {\u000a			loadLang( editor );\u000a		} );\u000a	}\u000a\u000a	function loadLang( editor ) {\u000a		CKEDITOR.lang.load( editor.config.language, editor.config.defaultLanguage, function( languageCode, lang ) {\u000a			var configTitle = editor.config.title;\u000a\u000a			/**\u000a			 * The code for the language resources that have been loaded\u000a			 * for the user interface elements of this editor instance.\u000a			 *\u000a			 *		alert( editor.langCode ); // e.g. 'en'\u000a			 *\u000a			 * @readonly\u000a			 * @property {String}\u000a			 */\u000a			editor.langCode = languageCode;\u000a\u000a			/**\u000a			 * An object that contains all language strings used by the editor interface.\u000a			 *\u000a			 *		alert( editor.lang.basicstyles.bold ); // e.g. 'Negrito' (if the language is set to Portuguese)\u000a			 *\u000a			 * @readonly\u000a			 * @property {Object} lang\u000a			 */\u000a			// As we'll be adding plugin specific entries that could come\u000a			// from different language code files, we need a copy of lang,\u000a			// not a direct reference to it.\u000a			editor.lang = CKEDITOR.tools.prototypedCopy( lang );\u000a\u000a			/**\u000a			 * Indicates the human-readable title of this editor. Although this is a read-only property,\u000a			 * it can be initialized with {@link CKEDITOR.config#title}.\u000a			 *\u000a			 * **Note:** Please do not confuse this property with {@link CKEDITOR.editor#name editor.name}\u000a			 * which identifies the instance in the {@link CKEDITOR#instances} literal.\u000a			 *\u000a			 * @since 4.2\u000a			 * @readonly\u000a			 * @property {String/Boolean}\u000a			 */\u000a			editor.title = typeof configTitle == 'string' || configTitle === false ? configTitle : [ editor.lang.editor, editor.name ].join( ', ' );\u000a\u000a			if ( !editor.config.contentsLangDirection ) {\u000a				// Fallback to either the editable element direction or editor UI direction depending on creators.\u000a				editor.config.contentsLangDirection = editor.elementMode == CKEDITOR.ELEMENT_MODE_INLINE ? editor.element.getDirection( 1 ) : editor.lang.dir;\u000a			}\u000a\u000a			editor.fire( 'langLoaded' );\u000a\u000a			preloadStylesSet( editor );\u000a		} );\u000a	}\u000a\u000a	// Preloads styles set file (config.stylesSet).\u000a	// If stylesSet was defined directly (by an array)\u000a	// this function will call loadPlugins fully synchronously.\u000a	// If stylesSet is a string (path) loadPlugins will\u000a	// be called asynchronously.\u000a	// In both cases - styles will be preload before plugins initialization.\u000a	function preloadStylesSet( editor ) {\u000a		editor.getStylesSet( function( styles ) {\u000a			// Wait for editor#loaded, so plugins could add their listeners.\u000a			// But listen with high priority to fire editor#stylesSet before editor#uiReady and editor#setData.\u000a			editor.once( 'loaded', function() {\u000a				// Note: we can't use fireOnce because this event may canceled and fired again.\u000a				editor.fire( 'stylesSet', { styles: styles } );\u000a			}, null, null, 1 );\u000a\u000a			loadPlugins( editor );\u000a		} );\u000a	}\u000a\u000a	function loadPlugins( editor ) {\u000a		var config = editor.config,\u000a			plugins = config.plugins,\u000a			extraPlugins = config.extraPlugins,\u000a			removePlugins = config.removePlugins;\u000a\u000a		if ( extraPlugins ) {\u000a			// Remove them first to avoid duplications.\u000a			var extraRegex = new RegExp( '(?:^|,)(?:' + extraPlugins.replace( /\u005cs*,\u005cs*/g, '|' ) + ')(?=,|$)', 'g' );\u000a			plugins = plugins.replace( extraRegex, '' );\u000a\u000a			plugins += ',' + extraPlugins;\u000a		}\u000a\u000a		if ( removePlugins ) {\u000a			var removeRegex = new RegExp( '(?:^|,)(?:' + removePlugins.replace( /\u005cs*,\u005cs*/g, '|' ) + ')(?=,|$)', 'g' );\u000a			plugins = plugins.replace( removeRegex, '' );\u000a		}\u000a\u000a		// Load the Adobe AIR plugin conditionally.\u000a		CKEDITOR.env.air && ( plugins += ',adobeair' );\u000a\u000a		// Load all plugins defined in the "plugins" setting.\u000a		CKEDITOR.plugins.load( plugins.split( ',' ), function( plugins ) {\u000a			// The list of plugins.\u000a			var pluginsArray = [];\u000a\u000a			// The language code to get loaded for each plugin. Null\u000a			// entries will be appended for plugins with no language files.\u000a			var languageCodes = [];\u000a\u000a			// The list of URLs to language files.\u000a			var languageFiles = [];\u000a\u000a			/**\u000a			 * An object that contains references to all plugins used by this\u000a			 * editor instance.\u000a			 *\u000a			 *		alert( editor.plugins.dialog.path ); // e.g. 'http://example.com/ckeditor/plugins/dialog/'\u000a			 *\u000a			 *		// Check if a plugin is available.\u000a			 *		if ( editor.plugins.image ) {\u000a			 *			...\u000a			 *		}\u000a			 *\u000a			 * @readonly\u000a			 * @property {Object}\u000a			 */\u000a			editor.plugins = plugins;\u000a\u000a			// Loop through all plugins, to build the list of language\u000a			// files to get loaded.\u000a			//\u000a			// Check also whether any of loaded plugins doesn't require plugins\u000a			// defined in config.removePlugins. Throw non-blocking error if this happens.\u000a			for ( var pluginName in plugins ) {\u000a				var plugin = plugins[ pluginName ],\u000a					pluginLangs = plugin.lang,\u000a					lang = null,\u000a					requires = plugin.requires,\u000a					match, name;\u000a\u000a				// Transform it into a string, if it's not one.\u000a				if ( CKEDITOR.tools.isArray( requires ) )\u000a					requires = requires.join( ',' );\u000a\u000a				if ( requires && ( match = requires.match( removeRegex ) ) ) {\u000a					while ( ( name = match.pop() ) ) {\u000a						CKEDITOR.tools.setTimeout( function( name, pluginName ) {\u000a							throw new Error( 'Plugin "' + name.replace( ',', '' ) + '" cannot be removed from the plugins list, because it\u005c's required by "' + pluginName + '" plugin.' );\u000a						}, 0, null, [ name, pluginName ] );\u000a					}\u000a				}\u000a\u000a				// If the plugin has "lang".\u000a				if ( pluginLangs && !editor.lang[ pluginName ] ) {\u000a					// Trasnform the plugin langs into an array, if it's not one.\u000a					if ( pluginLangs.split )\u000a						pluginLangs = pluginLangs.split( ',' );\u000a\u000a					// Resolve the plugin language. If the current language\u000a					// is not available, get English or the first one.\u000a					if ( CKEDITOR.tools.indexOf( pluginLangs, editor.langCode ) >= 0 )\u000a						lang = editor.langCode;\u000a					else {\u000a						// The language code may have the locale information (zh-cn).\u000a						// Fall back to locale-less in that case (zh).\u000a						var langPart = editor.langCode.replace( /-.*/, '' );\u000a						if ( langPart != editor.langCode && CKEDITOR.tools.indexOf( pluginLangs, langPart ) >= 0 )\u000a							lang = langPart;\u000a						// Try the only "generic" option we have: English.\u000a						else if ( CKEDITOR.tools.indexOf( pluginLangs, 'en' ) >= 0 )\u000a							lang = 'en';\u000a						else\u000a							lang = pluginLangs[ 0 ];\u000a					}\u000a\u000a					if ( !plugin.langEntries || !plugin.langEntries[ lang ] ) {\u000a						// Put the language file URL into the list of files to\u000a						// get downloaded.\u000a						languageFiles.push( CKEDITOR.getUrl( plugin.path + 'lang/' + lang + '.js' ) );\u000a					} else {\u000a						editor.lang[ pluginName ] = plugin.langEntries[ lang ];\u000a						lang = null;\u000a					}\u000a				}\u000a\u000a				// Save the language code, so we know later which\u000a				// language has been resolved to this plugin.\u000a				languageCodes.push( lang );\u000a\u000a				pluginsArray.push( plugin );\u000a			}\u000a\u000a			// Load all plugin specific language files in a row.\u000a			CKEDITOR.scriptLoader.load( languageFiles, function() {\u000a				// Initialize all plugins that have the "beforeInit" and "init" methods defined.\u000a				var methods = [ 'beforeInit', 'init', 'afterInit' ];\u000a				for ( var m = 0; m < methods.length; m++ ) {\u000a					for ( var i = 0; i < pluginsArray.length; i++ ) {\u000a						var plugin = pluginsArray[ i ];\u000a\u000a						// Uses the first loop to update the language entries also.\u000a						if ( m === 0 && languageCodes[ i ] && plugin.lang && plugin.langEntries )\u000a							editor.lang[ plugin.name ] = plugin.langEntries[ languageCodes[ i ] ];\u000a\u000a						// Call the plugin method (beforeInit and init).\u000a						if ( plugin[ methods[ m ] ] )\u000a							plugin[ methods[ m ] ]( editor );\u000a					}\u000a				}\u000a\u000a				editor.fireOnce( 'pluginsLoaded' );\u000a\u000a				// Setup the configured keystrokes.\u000a				config.keystrokes && editor.setKeystroke( editor.config.keystrokes );\u000a\u000a				// Setup the configured blocked keystrokes.\u000a				for ( i = 0; i < editor.config.blockedKeystrokes.length; i++ )\u000a					editor.keystrokeHandler.blockedKeystrokes[ editor.config.blockedKeystrokes[ i ] ] = 1;\u000a\u000a				editor.status = 'loaded';\u000a				editor.fireOnce( 'loaded' );\u000a				CKEDITOR.fire( 'instanceLoaded', null, editor );\u000a			} );\u000a		} );\u000a	}\u000a\u000a	// Send to data output back to editor's associated element.\u000a	function updateEditorElement() {\u000a		var element = this.element;\u000a\u000a		// Some editor creation mode will not have the\u000a		// associated element.\u000a		if ( element && this.elementMode != CKEDITOR.ELEMENT_MODE_APPENDTO ) {\u000a			var data = this.getData();\u000a\u000a			if ( this.config.htmlEncodeOutput )\u000a				data = CKEDITOR.tools.htmlEncode( data );\u000a\u000a			if ( element.is( 'textarea' ) )\u000a				element.setValue( data );\u000a			else\u000a				element.setHtml( data );\u000a\u000a			return true;\u000a		}\u000a		return false;\u000a	}\u000a\u000a	// Always returns ENTER_BR in case of blockless editor.\u000a	function validateEnterMode( editor, enterMode ) {\u000a		return editor.blockless ? CKEDITOR.ENTER_BR : enterMode;\u000a	}\u000a\u000a	CKEDITOR.tools.extend( CKEDITOR.editor.prototype, {\u000a		/**\u000a		 * Adds a command definition to the editor instance. Commands added with\u000a		 * this function can be executed later with the <code>{@link #execCommand}</code> method.\u000a		 *\u000a		 * 		editorInstance.addCommand( 'sample', {\u000a		 * 			exec: function( editor ) {\u000a		 * 				alert( 'Executing a command for the editor name "' + editor.name + '"!' );\u000a		 * 			}\u000a		 * 		} );\u000a		 *\u000a		 * @param {String} commandName The indentifier name of the command.\u000a		 * @param {CKEDITOR.commandDefinition} commandDefinition The command definition.\u000a		 */\u000a		addCommand: function( commandName, commandDefinition ) {\u000a			commandDefinition.name = commandName.toLowerCase();\u000a			var cmd = new CKEDITOR.command( this, commandDefinition );\u000a\u000a			// Update command when mode is set.\u000a			// This guarantees that commands added before first editor#mode\u000a			// aren't immediately updated, but waits for editor#mode and that\u000a			// commands added later are immediately refreshed, even when added\u000a			// before instanceReady. #10103, #10249\u000a			if ( this.mode )\u000a				updateCommand( this, cmd );\u000a\u000a			return this.commands[ commandName ] = cmd;\u000a		},\u000a\u000a		/**\u000a		 * Attaches the editor to a form to call {@link #updateElement} before form submission.\u000a		 * This method is called by both creators ({@link CKEDITOR#replace replace} and\u000a		 * {@link CKEDITOR#inline inline}), so there is no reason to call it manually.\u000a		 *\u000a		 * @private\u000a		 */\u000a		_attachToForm: function() {\u000a			var editor = this,\u000a				element = editor.element,\u000a				form = new CKEDITOR.dom.element( element.$.form );\u000a\u000a			// If are replacing a textarea, we must\u000a			if ( element.is( 'textarea' ) ) {\u000a				if ( form ) {\u000a					form.on( 'submit', onSubmit );\u000a\u000a					// Check if there is no element/elements input with name == "submit".\u000a					// If they exists they will overwrite form submit function (form.$.submit).\u000a					// If form.$.submit is overwritten we can not do anything with it.\u000a					if ( isFunction( form.$.submit ) ) {\u000a						// Setup the submit function because it doesn't fire the\u000a						// "submit" event.\u000a						form.$.submit = CKEDITOR.tools.override( form.$.submit, function( originalSubmit ) {\u000a							return function() {\u000a								onSubmit();\u000a\u000a								// For IE, the DOM submit function is not a\u000a								// function, so we need third check.\u000a								if ( originalSubmit.apply )\u000a									originalSubmit.apply( this );\u000a								else\u000a									originalSubmit();\u000a							};\u000a						} );\u000a					}\u000a\u000a					// Remove 'submit' events registered on form element before destroying.(#3988)\u000a					editor.on( 'destroy', function() {\u000a						form.removeListener( 'submit', onSubmit );\u000a					} );\u000a				}\u000a			}\u000a\u000a			function onSubmit( evt ) {\u000a				editor.updateElement();\u000a\u000a				// #8031 If textarea had required attribute and editor is empty fire 'required' event and if\u000a				// it was cancelled, prevent submitting the form.\u000a				if ( editor._.required && !element.getValue() && editor.fire( 'required' ) === false ) {\u000a					// When user press save button event (evt) is undefined (see save plugin).\u000a					// This method works because it throws error so originalSubmit won't be called.\u000a					// Also this error won't be shown because it will be caught in save plugin.\u000a					evt.data.preventDefault();\u000a				}\u000a			}\u000a\u000a			function isFunction( f ) {\u000a				// For IE8 typeof fun == object so we cannot use it.\u000a				return !!( f && f.call && f.apply );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Destroys the editor instance, releasing all resources used by it.\u000a		 * If the editor replaced an element, the element will be recovered.\u000a		 *\u000a		 *		alert( CKEDITOR.instances.editor1 ); // e.g. object\u000a		 *		CKEDITOR.instances.editor1.destroy();\u000a		 *		alert( CKEDITOR.instances.editor1 ); // undefined\u000a		 *\u000a		 * @param {Boolean} [noUpdate] If the instance is replacing a DOM\u000a		 * element, this parameter indicates whether or not to update the\u000a		 * element with the instance contents.\u000a		 */\u000a		destroy: function( noUpdate ) {\u000a			this.fire( 'beforeDestroy' );\u000a\u000a			!noUpdate && updateEditorElement.call( this );\u000a\u000a			this.editable( null );\u000a\u000a			this.filter.destroy();\u000a			delete this.filter;\u000a			delete this.activeFilter;\u000a\u000a			this.status = 'destroyed';\u000a\u000a			this.fire( 'destroy' );\u000a\u000a			// Plug off all listeners to prevent any further events firing.\u000a			this.removeAllListeners();\u000a\u000a			CKEDITOR.remove( this );\u000a			CKEDITOR.fire( 'instanceDestroyed', null, this );\u000a		},\u000a\u000a		/**\u000a		 * Returns an {@link CKEDITOR.dom.elementPath element path} for the selection in the editor.\u000a		 *\u000a		 * @param {CKEDITOR.dom.node} [startNode] From which the path should start,\u000a		 * if not specified default to editor selection's\u000a		 * start element yield by {@link CKEDITOR.dom.selection#getStartElement}.\u000a		 * @returns {CKEDITOR.dom.elementPath}\u000a		 */\u000a		elementPath: function( startNode ) {\u000a			if ( !startNode ) {\u000a				var sel = this.getSelection();\u000a				if ( !sel )\u000a					return null;\u000a\u000a				startNode = sel.getStartElement();\u000a			}\u000a\u000a			return startNode ? new CKEDITOR.dom.elementPath( startNode, this.editable() ) : null;\u000a		},\u000a\u000a		/**\u000a		 * Shortcut to create a {@link CKEDITOR.dom.range} instance from the editable element.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.range} The dom range created if the editable has presented.\u000a		 * @see CKEDITOR.dom.range\u000a		 */\u000a		createRange: function() {\u000a			var editable = this.editable();\u000a			return editable ? new CKEDITOR.dom.range( editable ) : null;\u000a		},\u000a\u000a		/**\u000a		 * Executes a command associated with the editor.\u000a		 *\u000a		 *		editorInstance.execCommand( 'bold' );\u000a		 *\u000a		 * @param {String} commandName The indentifier name of the command.\u000a		 * @param {Object} [data] Data to be passed to the command.\u000a		 * @returns {Boolean} `true` if the command was executed\u000a		 * successfully, otherwise `false`.\u000a		 * @see CKEDITOR.editor#addCommand\u000a		 */\u000a		execCommand: function( commandName, data ) {\u000a			var command = this.getCommand( commandName );\u000a\u000a			var eventData = {\u000a				name: commandName,\u000a				commandData: data,\u000a				command: command\u000a			};\u000a\u000a			if ( command && command.state != CKEDITOR.TRISTATE_DISABLED ) {\u000a				if ( this.fire( 'beforeCommandExec', eventData ) !== false ) {\u000a					eventData.returnValue = command.exec( eventData.commandData );\u000a\u000a					// Fire the 'afterCommandExec' immediately if command is synchronous.\u000a					if ( !command.async && this.fire( 'afterCommandExec', eventData ) !== false )\u000a						return eventData.returnValue;\u000a				}\u000a			}\u000a\u000a			// throw 'Unknown command name "' + commandName + '"';\u000a			return false;\u000a		},\u000a\u000a		/**\u000a		 * Gets one of the registered commands. Note that after registering a\u000a		 * command definition with {@link #addCommand}, it is\u000a		 * transformed internally into an instance of\u000a		 * {@link CKEDITOR.command}, which will then be returned by this function.\u000a		 *\u000a		 * @param {String} commandName The name of the command to be returned.\u000a		 * This is the same name that is used to register the command with `addCommand`.\u000a		 * @returns {CKEDITOR.command} The command object identified by the provided name.\u000a		 */\u000a		getCommand: function( commandName ) {\u000a			return this.commands[ commandName ];\u000a		},\u000a\u000a		/**\u000a		 * Gets the editor data. The data will be in raw format. It is the same\u000a		 * data that is posted by the editor.\u000a		 *\u000a		 *		if ( CKEDITOR.instances.editor1.getData() == '' )\u000a		 *			alert( 'There is no data available' );\u000a		 *\u000a		 * @returns {String} The editor data.\u000a		 */\u000a		getData: function( noEvents ) {\u000a			!noEvents && this.fire( 'beforeGetData' );\u000a\u000a			var eventData = this._.data;\u000a\u000a			if ( typeof eventData != 'string' ) {\u000a				var element = this.element;\u000a				if ( element && this.elementMode == CKEDITOR.ELEMENT_MODE_REPLACE )\u000a					eventData = element.is( 'textarea' ) ? element.getValue() : element.getHtml();\u000a				else\u000a					eventData = '';\u000a			}\u000a\u000a			eventData = { dataValue: eventData };\u000a\u000a			// Fire "getData" so data manipulation may happen.\u000a			!noEvents && this.fire( 'getData', eventData );\u000a\u000a			return eventData.dataValue;\u000a		},\u000a\u000a		/**\u000a		 * Gets the "raw data" currently available in the editor. This is a\u000a		 * fast method which returns the data as is, without processing, so it is\u000a		 * not recommended to use it on resulting pages. Instead it can be used\u000a		 * combined with the {@link #method-loadSnapshot} method in order\u000a		 * to be able to automatically save the editor data from time to time\u000a		 * while the user is using the editor, to avoid data loss, without risking\u000a		 * performance issues.\u000a		 *\u000a		 *		alert( editor.getSnapshot() );\u000a		 *\u000a		 * @see CKEDITOR.editor#getData\u000a		 */\u000a		getSnapshot: function() {\u000a			var data = this.fire( 'getSnapshot' );\u000a\u000a			if ( typeof data != 'string' ) {\u000a				var element = this.element;\u000a				if ( element && this.elementMode == CKEDITOR.ELEMENT_MODE_REPLACE )\u000a					data = element.is( 'textarea' ) ? element.getValue() : element.getHtml();\u000a			}\u000a\u000a			return data;\u000a		},\u000a\u000a		/**\u000a		 * Loads "raw data" into the editor. The data is loaded with processing\u000a		 * straight to the editing area. It should not be used as a way to load\u000a		 * any kind of data, but instead in combination with\u000a		 * {@link #method-getSnapshot} produced data.\u000a		 *\u000a		 *		var data = editor.getSnapshot();\u000a		 *		editor.loadSnapshot( data );\u000a		 *\u000a		 * @see CKEDITOR.editor#setData\u000a		 */\u000a		loadSnapshot: function( snapshot ) {\u000a			this.fire( 'loadSnapshot', snapshot );\u000a		},\u000a\u000a		/**\u000a		 * Sets the editor data. The data must be provided in the raw format (HTML).\u000a		 *\u000a		 * Note that this method is asynchronous. The `callback` parameter must\u000a		 * be used if interaction with the editor is needed after setting the data.\u000a		 *\u000a		 *		CKEDITOR.instances.editor1.setData( '<p>This is the editor data.</p>' );\u000a		 *\u000a		 *		CKEDITOR.instances.editor1.setData( '<p>Some other editor data.</p>', {\u000a		 *			callback: function() {\u000a		 *				this.checkDirty(); // true\u000a		 *			}\u000a		 *		} );\u000a		 *\u000a		 * Note: In **CKEditor 4.4.2** the signature of this method has changed. All arguments\u000a		 * except `data` were wrapped into the `options` object. However, backward compatibility\u000a		 * was preserved and it is still possible to use the `data, callback, internal` arguments.\u000a		 *\u000a		 *\u000a		 * @param {String} data HTML code to replace current editor content.\u000a		 * @param {Object} [options]\u000a		 * @param {Boolean} [options.internal=false] Whether to suppress any event firing when copying data internally inside the editor.\u000a		 * @param {Function} [options.callback] Function to be called after `setData` is completed (on {@link #dataReady}).\u000a		 * @param {Boolean} [options.noSnapshot=false] If set to `true`, it will prevent recording an undo snapshot.\u000a		 * Introduced in CKEditor 4.4.2.\u000a		 */\u000a		setData: function( data, options, internal ) {\u000a			var fireSnapshot = true,\u000a				// Backward compatibility.\u000a				callback = options,\u000a				eventData;\u000a\u000a			if ( options && typeof options == 'object' ) {\u000a				internal = options.internal;\u000a				callback = options.callback;\u000a				fireSnapshot = !options.noSnapshot;\u000a			}\u000a\u000a			if ( !internal && fireSnapshot )\u000a				this.fire( 'saveSnapshot' );\u000a\u000a			if ( callback || !internal ) {\u000a				this.once( 'dataReady', function( evt ) {\u000a					if ( !internal && fireSnapshot )\u000a						this.fire( 'saveSnapshot' );\u000a\u000a					if ( callback )\u000a						callback.call( evt.editor );\u000a				} );\u000a			}\u000a\u000a			// Fire "setData" so data manipulation may happen.\u000a			eventData = { dataValue: data };\u000a			!internal && this.fire( 'setData', eventData );\u000a\u000a			this._.data = eventData.dataValue;\u000a\u000a			!internal && this.fire( 'afterSetData', eventData );\u000a		},\u000a\u000a		/**\u000a		 * Puts or restores the editor into read-only state. When in read-only,\u000a		 * the user is not able to change the editor contents, but can still use\u000a		 * some editor features. This function sets the {@link #property-readOnly}\u000a		 * property of the editor, firing the {@link #event-readOnly} event.\u000a		 *\u000a		 * **Note:** the current editing area will be reloaded.\u000a		 *\u000a		 * @since 3.6\u000a		 * @param {Boolean} [isReadOnly] Indicates that the editor must go\u000a		 * read-only (`true`, default) or be restored and made editable (`false`).\u000a		 */\u000a		setReadOnly: function( isReadOnly ) {\u000a			isReadOnly = ( isReadOnly == null ) || isReadOnly;\u000a\u000a			if ( this.readOnly != isReadOnly ) {\u000a				this.readOnly = isReadOnly;\u000a\u000a				// Block or release BACKSPACE key according to current read-only\u000a				// state to prevent browser's history navigation (#9761).\u000a				this.keystrokeHandler.blockedKeystrokes[ 8 ] = +isReadOnly;\u000a\u000a				this.editable().setReadOnly( isReadOnly );\u000a\u000a				// Fire the readOnly event so the editor features can update\u000a				// their state accordingly.\u000a				this.fire( 'readOnly' );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Inserts HTML code into the currently selected position in the editor in WYSIWYG mode.\u000a		 *\u000a		 * * `"html"` - content being inserted will completely override styles\u000a		 *    of selected position.\u000a		 * * `"unfiltered_html"` - like `"html"` but content isn't filtered with {@link CKEDITOR.filter}.\u000a		 * * `"text"` - content being inserted will inherit styles applied in\u000a		 *    selected position. This mode should be used when inserting "htmlified" plain text\u000a		 *    (HTML without inline styles and styling elements like\u000a		 *    `<b/>, <strong/>, <span style="..."/>`).\u000a		 *\u000a		 * Example:\u000a		 *\u000a		 *		CKEDITOR.instances.editor1.insertHtml( '<p>This is a new paragraph.</p>' );\u000a		 *\u000a		 * @param {String} html HTML code to be inserted into the editor.\u000a		 * @param {String} [mode='html'] Mode in which HTML will be inserted.\u000a		 */\u000a		insertHtml: function( html, mode ) {\u000a			this.fire( 'insertHtml', { dataValue: html, mode: mode } );\u000a		},\u000a\u000a		/**\u000a		 * Insert text content into the currently selected position in the\u000a		 * editor in WYSIWYG mode. The styles of the selected element will be applied to the inserted text.\u000a		 * Spaces around the text will be leaving untouched.\u000a		 *\u000a		 *		CKEDITOR.instances.editor1.insertText( ' line1 \u005cn\u005cn line2' );\u000a		 *\u000a		 * @since 3.5\u000a		 * @param {String} text Text to be inserted into the editor.\u000a		 */\u000a		insertText: function( text ) {\u000a			this.fire( 'insertText', text );\u000a		},\u000a\u000a		/**\u000a		 * Inserts an element into the currently selected position in the\u000a		 * editor in WYSIWYG mode.\u000a		 *\u000a		 *		var element = CKEDITOR.dom.element.createFromHtml( '<img src="hello.png" border="0" title="Hello" />' );\u000a		 *		CKEDITOR.instances.editor1.insertElement( element );\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} element The element to be inserted\u000a		 * into the editor.\u000a		 */\u000a		insertElement: function( element ) {\u000a			this.fire( 'insertElement', element );\u000a		},\u000a\u000a		/**\u000a		 * Moves the selection focus to the editing area space in the editor.\u000a		 */\u000a		focus: function() {\u000a			this.fire( 'beforeFocus' );\u000a		},\u000a\u000a		/**\u000a		 * Checks whether the current editor contents present changes when\u000a		 * compared to the contents loaded into the editor at startup, or to\u000a		 * the contents available in the editor when {@link #resetDirty}\u000a		 * was called.\u000a		 *\u000a		 *		function beforeUnload( evt ) {\u000a		 *			if ( CKEDITOR.instances.editor1.checkDirty() )\u000a		 *				return evt.returnValue = "You will lose the changes made in the editor.";\u000a		 *		}\u000a		 *\u000a		 *		if ( window.addEventListener )\u000a		 *			window.addEventListener( 'beforeunload', beforeUnload, false );\u000a		 *		else\u000a		 *			window.attachEvent( 'onbeforeunload', beforeUnload );\u000a		 *\u000a		 * @returns {Boolean} `true` if the contents contain changes.\u000a		 */\u000a		checkDirty: function() {\u000a			return this.status == 'ready' && this._.previousValue !== this.getSnapshot();\u000a		},\u000a\u000a		/**\u000a		 * Resets the "dirty state" of the editor so subsequent calls to\u000a		 * {@link #checkDirty} will return `false` if the user will not\u000a		 * have made further changes to the contents.\u000a		 *\u000a		 *		alert( editor.checkDirty() ); // e.g. true\u000a		 *		editor.resetDirty();\u000a		 *		alert( editor.checkDirty() ); // false\u000a		 */\u000a		resetDirty: function() {\u000a			this._.previousValue = this.getSnapshot();\u000a		},\u000a\u000a		/**\u000a		 * Updates the <code>&lt;textarea&gt;</code> element that was replaced by the editor with\u000a		 * the current data available in the editor.\u000a		 *\u000a		 * **Note:** This method will only affect those editor instances created\u000a		 * with {@link CKEDITOR#ELEMENT_MODE_REPLACE} element mode or inline instances\u000a		 * bound to `<textarea>` elements.\u000a		 *\u000a		 *		CKEDITOR.instances.editor1.updateElement();\u000a		 *		alert( document.getElementById( 'editor1' ).value ); // The current editor data.\u000a		 *\u000a		 * @see CKEDITOR.editor#element\u000a		 */\u000a		updateElement: function() {\u000a			return updateEditorElement.call( this );\u000a		},\u000a\u000a		/**\u000a		 * Assigns keystrokes associated to editor commands.\u000a		 *\u000a		 *		editor.setKeystroke( CKEDITOR.CTRL + 115, 'save' );	// Assigned CTRL+S to "save" command.\u000a		 *		editor.setKeystroke( CKEDITOR.CTRL + 115, false );	// Disabled CTRL+S keystroke assignment.\u000a		 *		editor.setKeystroke( [\u000a		 *			[ CKEDITOR.ALT + 122, false ],\u000a		 *			[ CKEDITOR.CTRL + 121, 'link' ],\u000a		 *			[ CKEDITOR.SHIFT + 120, 'bold' ]\u000a		 *		] );\u000a		 *\u000a		 * This method may be used in the following cases:\u000a		 *\u000a		 * * By plugins (like `link` or `basicstyles`) to set their keystrokes when plugins are being loaded.\u000a		 * * During the runtime to modify existing keystrokes.\u000a		 *\u000a		 * The editor handles keystroke configuration in the following order:\u000a		 *\u000a		 * 1. Plugins use this method to define default keystrokes.\u000a		 * 2. Editor extends default keystrokes with {@link CKEDITOR.config#keystrokes}.\u000a		 * 3. Editor blocks keystrokes defined in {@link CKEDITOR.config#blockedKeystrokes}.\u000a		 *\u000a		 * After all, you can still set new keystrokes using this method during the runtime.\u000a		 *\u000a		 * @since 4.0\u000a		 * @param {Number/Array} keystroke Keystroke or an array of keystroke definitions.\u000a		 * @param {String/Boolean} [behavior] A command to be executed on the keystroke.\u000a		 */\u000a		setKeystroke: function() {\u000a			var keystrokes = this.keystrokeHandler.keystrokes,\u000a				newKeystrokes = CKEDITOR.tools.isArray( arguments[ 0 ] ) ? arguments[ 0 ] : [ [].slice.call( arguments, 0 ) ],\u000a				keystroke, behavior;\u000a\u000a			for ( var i = newKeystrokes.length; i--; ) {\u000a				keystroke = newKeystrokes[ i ];\u000a				behavior = 0;\u000a\u000a				// It may be a pair of: [ key, command ]\u000a				if ( CKEDITOR.tools.isArray( keystroke ) ) {\u000a					behavior = keystroke[ 1 ];\u000a					keystroke = keystroke[ 0 ];\u000a				}\u000a\u000a				if ( behavior )\u000a					keystrokes[ keystroke ] = behavior;\u000a				else\u000a					delete keystrokes[ keystroke ];\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Shorthand for {@link CKEDITOR.filter#addFeature}.\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {CKEDITOR.feature} feature See {@link CKEDITOR.filter#addFeature}.\u000a		 * @returns {Boolean} See {@link CKEDITOR.filter#addFeature}.\u000a		 */\u000a		addFeature: function( feature ) {\u000a			return this.filter.addFeature( feature );\u000a		},\u000a\u000a		/**\u000a		 * Sets the active filter ({@link #activeFilter}). Fires {@link #activeFilterChange} event.\u000a		 *\u000a		 *		// Set active filter which allows only 4 elements.\u000a		 *		// Buttons like Bold, Italic will be disabled.\u000a		 *		var filter = new CKEDITOR.filter( 'p strong em br' );\u000a		 *		editor.setActiveFilter( filter );\u000a		 *\u000a		 * Setting new filter will also change the {@link #setActiveEnterMode active enter modes} to the first values\u000a		 * allowed by the new filter (see {@link CKEDITOR.filter#getAllowedEnterMode}).\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {CKEDITOR.filter} filter Filter instance or a falsy value (e.g. `null`) to reset to the default one.\u000a		 */\u000a		setActiveFilter: function( filter ) {\u000a			if ( !filter )\u000a				filter = this.filter;\u000a\u000a			if ( this.activeFilter !== filter ) {\u000a				this.activeFilter = filter;\u000a				this.fire( 'activeFilterChange' );\u000a\u000a				// Reseted active filter to the main one - reset enter modes too.\u000a				if ( filter === this.filter )\u000a					this.setActiveEnterMode( null, null );\u000a				else\u000a					this.setActiveEnterMode(\u000a						filter.getAllowedEnterMode( this.enterMode ),\u000a						filter.getAllowedEnterMode( this.shiftEnterMode, true )\u000a					);\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Sets the active enter modes ({@link #enterMode} and {@link #shiftEnterMode}).\u000a		 * Fires the {@link #activeEnterModeChange} event.\u000a		 *\u000a		 * Prior to CKEditor 4.3 enter modes were static and it was enough to check {@link CKEDITOR.config#enterMode}\u000a		 * and {@link CKEDITOR.config#shiftEnterMode} when implementing a feature which should depend on the enter modes.\u000a		 * Since CKEditor 4.3 these options are source of initial:\u000a		 *\u000a		 * * static {@link #enterMode} and {@link #shiftEnterMode} values,\u000a		 * * dynamic {@link #activeEnterMode} and {@link #activeShiftEnterMode} values.\u000a		 *\u000a		 * However, the dynamic enter modes can be changed during runtime by using this method, to reflect the selection context.\u000a		 * For example, if selection is moved to the {@link CKEDITOR.plugins.widget widget}'s nested editable which\u000a		 * is a {@link #blockless blockless one}, then the active enter modes should be changed to {@link CKEDITOR#ENTER_BR}\u000a		 * (in this case [Widget System](#!/guide/dev_widgets) takes care of that).\u000a		 *\u000a		 * **Note:** This method should not be used to configure editor &ndash; use {@link CKEDITOR.config#enterMode} and\u000a		 * {@link CKEDITOR.config#shiftEnterMode} instead. This method should be used only to dynamically change\u000a		 * enter modes during runtime based on selection changes.\u000a		 * Keep in mind that changed enter mode may be overwritten by other plugin/feature when it decided that\u000a		 * the changed context requires this.\u000a		 *\u000a		 * **Note:** In case of blockless editor (inline editor based on element which cannot contain block elements\u000a		 * &ndash; see {@link CKEDITOR.editor#blockless}) only {@link CKEDITOR#ENTER_BR} is a valid enter mode. Therefore\u000a		 * this method will not allow to set other values.\u000a		 *\u000a		 * **Note:** Changing the {@link #activeFilter active filter} may cause enter mode change if default enter modes\u000a		 * are not allowed by the new filter.\u000a		 *\u000a		 * @since 4.3\u000a		 * @param {Number} enterMode One of {@link CKEDITOR#ENTER_P}, {@link CKEDITOR#ENTER_DIV}, {@link CKEDITOR#ENTER_BR}.\u000a		 * Pass falsy value (e.g. `null`) to reset enter mode to the default value ({@link #enterMode} and/or {@link #shiftEnterMode}).\u000a		 * @param {Number} shiftEnterMode See the `enterMode` argument.\u000a		 */\u000a		setActiveEnterMode: function( enterMode, shiftEnterMode ) {\u000a			// Validate passed modes or use default ones (validated on init).\u000a			enterMode = enterMode ? validateEnterMode( this, enterMode ) : this.enterMode;\u000a			shiftEnterMode = shiftEnterMode ? validateEnterMode( this, shiftEnterMode ) : this.shiftEnterMode;\u000a\u000a			if ( this.activeEnterMode != enterMode || this.activeShiftEnterMode != shiftEnterMode ) {\u000a				this.activeEnterMode = enterMode;\u000a				this.activeShiftEnterMode = shiftEnterMode;\u000a				this.fire( 'activeEnterModeChange' );\u000a			}\u000a		}\u000a	} );\u000a} )();\u000a\u000a/**\u000a * The editor has no associated element.\u000a *\u000a * @readonly\u000a * @property {Number} [=0]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.ELEMENT_MODE_NONE = 0;\u000a\u000a/**\u000a * The element is to be replaced by the editor instance.\u000a *\u000a * @readonly\u000a * @property {Number} [=1]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.ELEMENT_MODE_REPLACE = 1;\u000a\u000a/**\u000a * The editor is to be created inside the element.\u000a *\u000a * @readonly\u000a * @property {Number} [=2]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.ELEMENT_MODE_APPENDTO = 2;\u000a\u000a/**\u000a * The editor is to be attached to the element, using it as the editing block.\u000a *\u000a * @readonly\u000a * @property {Number} [=3]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.ELEMENT_MODE_INLINE = 3;\u000a\u000a/**\u000a * Whether to escape HTML when the editor updates the original input element.\u000a *\u000a *		config.htmlEncodeOutput = true;\u000a *\u000a * @since 3.1\u000a * @cfg {Boolean} [htmlEncodeOutput=false]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * If `true`, makes the editor start in read-only state. Otherwise, it will check\u000a * if the linked `<textarea>` element has the `disabled` attribute.\u000a *\u000a *		config.readOnly = true;\u000a *\u000a * @since 3.6\u000a * @cfg {Boolean} [readOnly=false]\u000a * @member CKEDITOR.config\u000a * @see CKEDITOR.editor#setReadOnly\u000a */\u000a\u000a/**\u000a * Sets whether an editable element should have focus when the editor is loading for the first time.\u000a *\u000a *		config.startupFocus = true;\u000a *\u000a * @cfg {Boolean} [startupFocus=false]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a /**\u000a * Customizes the {@link CKEDITOR.editor#title human-readable title} of this editor. This title is displayed in\u000a * tooltips and impacts various accessibility aspects, e.g. it is commonly used by screen readers\u000a * for distinguishing editor instances and for navigation. Accepted values are a string or `false`.\u000a *\u000a * **Note:** When `config.title` is set globally, the same value will be applied to all editor instances\u000a * loaded with this config. This may severely affect accessibility as screen reader users will be unable\u000a * to distinguish particular editor instances and navigate between them.\u000a *\u000a * **Note:** Setting `config.title = false` may also impair accessibility in a similar way.\u000a *\u000a * **Note:** Please do not confuse this property with {@link CKEDITOR.editor#name}\u000a * which identifies the instance in the {@link CKEDITOR#instances} literal.\u000a *\u000a *		// Sets the title to 'My WYSIWYG editor.'. The original title of the element (if it exists)\u000a *		// will be restored once the editor instance is destroyed.\u000a *		config.title = 'My WYSIWYG editor.';\u000a *\u000a *		// Do not touch the title. If the element already has a title, it remains unchanged.\u000a *		// Also if no title attribute exists, nothing new will be added.\u000a *		config.title = false;\u000a *\u000a * @since 4.2\u000a * @cfg {String/Boolean} [title=based on editor.name]\u000a * @member CKEDITOR.config\u000a * @see CKEDITOR.editor.name\u000a * @see CKEDITOR.editor.title\u000a */\u000a\u000a/**\u000a * Sets listeners on editor's events.\u000a *\u000a * **Note:** This property can only be set in the `config` object passed directly\u000a * to {@link CKEDITOR#replace}, {@link CKEDITOR#inline}, and other creators.\u000a *\u000a *		CKEDITOR.replace( 'editor1', {\u000a *			on: {\u000a *				instanceReady: function() {\u000a *					alert( this.name ); // 'editor1'\u000a *				},\u000a *\u000a *				key: function() {\u000a *					// ...\u000a *				}\u000a *			}\u000a *		} );\u000a *\u000a * @cfg {Object} on\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * The outermost element in the DOM tree in which the editable element resides. It is provided\u000a * by a specific editor creator after editor UI is created and is not intended to\u000a * be modified.\u000a *\u000a *		var editor = CKEDITOR.instances.editor1;\u000a *		alert( editor.container.getName() ); // 'span'\u000a *\u000a * @readonly\u000a * @property {CKEDITOR.dom.element} container\u000a */\u000a\u000a/**\u000a * The document that stores the editor contents.\u000a *\u000a * * For the classic (`iframe`-based) editor it is equal to the document inside the\u000a * `iframe` containing the editable element.\u000a * * For the inline editor it is equal to {@link CKEDITOR#document}.\u000a *\u000a * The document object is available after the {@link #contentDom} event is fired\u000a * and may be invalidated when the {@link #contentDomUnload} event is fired\u000a * (classic editor only).\u000a *\u000a *		editor.on( 'contentDom', function() {\u000a *			console.log( editor.document );\u000a *		} );\u000a *\u000a * @readonly\u000a * @property {CKEDITOR.dom.document} document\u000a */\u000a\u000a/**\u000a * The window instance related to the {@link #document} property.\u000a *\u000a * It is always equal to the `editor.document.getWindow()`.\u000a *\u000a * See {@link #document} property documentation.\u000a *\u000a * @readonly\u000a * @property {CKEDITOR.dom.window} window\u000a */\u000a\u000a/**\u000a * The main filter instance used for input data filtering, data\u000a * transformations, and activation of features.\u000a *\u000a * It points to a {@link CKEDITOR.filter} instance set up based on\u000a * editor configuration.\u000a *\u000a * @since 4.1\u000a * @readonly\u000a * @property {CKEDITOR.filter} filter\u000a */\u000a\u000a/**\u000a * The active filter instance which should be used in the current context (location selection).\u000a * This instance will be used to make a decision which commands, buttons and other\u000a * {@link CKEDITOR.feature features} can be enabled.\u000a *\u000a * By default it equals the {@link #filter} and it can be changed by the {@link #setActiveFilter} method.\u000a *\u000a *		editor.on( 'activeFilterChange', function() {\u000a *			if ( editor.activeFilter.check( 'cite' ) )\u000a *				// Do something when <cite> was enabled - e.g. enable a button.\u000a *			else\u000a *				// Otherwise do something else.\u000a *		} );\u000a *\u000a * See also the {@link #setActiveEnterMode} method for an explanation of dynamic settings.\u000a *\u000a * @since 4.3\u000a * @readonly\u000a * @property {CKEDITOR.filter} activeFilter\u000a */\u000a\u000a/**\u000a * The main (static) enter mode which is a validated version of the {@link CKEDITOR.config#enterMode} setting.\u000a * Currently only one rule exists &ndash; {@link #blockless blockless editors} may have\u000a * enter modes set only to {@link CKEDITOR#ENTER_BR}.\u000a *\u000a * @since 4.3\u000a * @readonly\u000a * @property {Number} enterMode\u000a */\u000a\u000a/**\u000a * See the {@link #enterMode} property.\u000a *\u000a * @since 4.3\u000a * @readonly\u000a * @property {Number} shiftEnterMode\u000a */\u000a\u000a/**\u000a * The dynamic enter mode which should be used in the current context (selection location).\u000a * By default it equals the {@link #enterMode} and it can be changed by the {@link #setActiveEnterMode} method.\u000a *\u000a * See also the {@link #setActiveEnterMode} method for an explanation of dynamic settings.\u000a *\u000a * @since 4.3\u000a * @readonly\u000a * @property {Number} activeEnterMode\u000a */\u000a\u000a/**\u000a * See the {@link #activeEnterMode} property.\u000a *\u000a * @since 4.3\u000a * @readonly\u000a * @property {Number} activeShiftEnterMode\u000a */\u000a\u000a/**\u000a * Fired by the {@link #setActiveFilter} method when the {@link #activeFilter} is changed.\u000a *\u000a * @since 4.3\u000a * @event activeFilterChange\u000a */\u000a\u000a/**\u000a * Fired by the {@link #setActiveEnterMode} method when any of the active enter modes is changed.\u000a * See also the {@link #activeEnterMode} and {@link #activeShiftEnterMode} properties.\u000a *\u000a * @since 4.3\u000a * @event activeEnterModeChange\u000a */\u000a\u000a/**\u000a * Fired when a CKEDITOR instance is created, but still before initializing it.\u000a * To interact with a fully initialized instance, use the\u000a * {@link CKEDITOR#instanceReady} event instead.\u000a *\u000a * @event instanceCreated\u000a * @member CKEDITOR\u000a * @param {CKEDITOR.editor} editor The editor instance that has been created.\u000a */\u000a\u000a/**\u000a * Fired when CKEDITOR instance's components (config, languages and plugins) are fully\u000a * loaded and initialized. However, the editor will be fully ready to for interaction\u000a * on {@link CKEDITOR#instanceReady}.\u000a *\u000a * @event instanceLoaded\u000a * @member CKEDITOR\u000a * @param {CKEDITOR.editor} editor This editor instance that has been loaded.\u000a */\u000a\u000a/**\u000a * Fired when a CKEDITOR instance is destroyed.\u000a *\u000a * @event instanceDestroyed\u000a * @member CKEDITOR\u000a * @param {CKEDITOR.editor} editor The editor instance that has been destroyed.\u000a */\u000a\u000a/**\u000a * Fired when a CKEDITOR instance is created, fully initialized and ready for interaction.\u000a *\u000a * @event instanceReady\u000a * @member CKEDITOR\u000a * @param {CKEDITOR.editor} editor The editor instance that has been created.\u000a */\u000a\u000a/**\u000a * Fired when the language is loaded into the editor instance.\u000a *\u000a * @since 3.6.1\u000a * @event langLoaded\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Fired when all plugins are loaded and initialized into the editor instance.\u000a *\u000a * @event pluginsLoaded\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Fired when styles set is loaded. During editor initialization\u000a * phase the {@link #getStylesSet} method returns only styles that\u000a * are already loaded, which may not include e.g. styles parsed\u000a * by `stylesheetparser` plugin. Thus, to be notified when all\u000a * styles are ready you can listen on this event.\u000a *\u000a * @since 4.1\u000a * @event stylesSet\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param {Array} styles Array of styles definitions.\u000a */\u000a\u000a/**\u000a * Fired before the command execution when {@link #execCommand} is called.\u000a *\u000a * @event beforeCommandExec\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param data\u000a * @param {String} data.name The command name.\u000a * @param {Object} data.commandData The data to be sent to the command. This\u000a * can be manipulated by the event listener.\u000a * @param {CKEDITOR.command} data.command The command itself.\u000a */\u000a\u000a/**\u000a * Fired after the command execution when {@link #execCommand} is called.\u000a *\u000a * @event afterCommandExec\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param data\u000a * @param {String} data.name The command name.\u000a * @param {Object} data.commandData The data sent to the command.\u000a * @param {CKEDITOR.command} data.command The command itself.\u000a * @param {Object} data.returnValue The value returned by the command execution.\u000a */\u000a\u000a/**\u000a * Fired when the custom configuration file is loaded, before the final\u000a * configurations initialization.\u000a *\u000a * Custom configuration files can be loaded thorugh the\u000a * {@link CKEDITOR.config#customConfig} setting. Several files can be loaded\u000a * by changing this setting.\u000a *\u000a * @event customConfigLoaded\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Fired once the editor configuration is ready (loaded and processed).\u000a *\u000a * @event configLoaded\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Fired when this editor instance is destroyed. The editor at this\u000a * point is not usable and this event should be used to perform the clean-up\u000a * in any plugin.\u000a *\u000a * @event destroy\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Internal event to get the current data.\u000a *\u000a * @event beforeGetData\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Internal event to perform the {@link #method-getSnapshot} call.\u000a *\u000a * @event getSnapshot\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Internal event to perform the {@link #method-loadSnapshot} call.\u000a *\u000a * @event loadSnapshot\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param {String} data The data that will be used.\u000a */\u000a\u000a/**\u000a * Event fired before the {@link #method-getData} call returns allowing additional manipulation.\u000a *\u000a * @event getData\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param data\u000a * @param {String} data.dataValue The data that will be returned.\u000a */\u000a\u000a/**\u000a * Event fired before the {@link #method-setData} call is executed allowing additional manipulation.\u000a *\u000a * @event setData\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param data\u000a * @param {String} data.dataValue The data that will be used.\u000a */\u000a\u000a/**\u000a * Event fired at the end of the {@link #method-setData} call execution. Usually it is better to use the\u000a * {@link #dataReady} event.\u000a *\u000a * @event afterSetData\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param data\u000a * @param {String} data.dataValue The data that has been set.\u000a */\u000a\u000a/**\u000a * Fired as an indicator of the editor data loading. It may be the result of\u000a * calling {@link #method-setData} explicitly or an internal\u000a * editor function, like the editor editing mode switching (move to Source and back).\u000a *\u000a * @event dataReady\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Fired when the CKEDITOR instance is completely created, fully initialized\u000a * and ready for interaction.\u000a *\u000a * @event instanceReady\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Fired when editor's components (config, languages and plugins) are fully\u000a * loaded and initialized. However, the editor will be fully ready to for interaction\u000a * on {@link #instanceReady}.\u000a *\u000a * @event loaded\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Internal event to perform the {@link #method-insertHtml} call.\u000a *\u000a * @event insertHtml\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param data\u000a * @param {String} data.mode Mode in which data is inserted (see {@link #method-insertHtml}).\u000a * @param {String} data.dataValue The HTML to insert.\u000a */\u000a\u000a/**\u000a * Internal event to perform the {@link #method-insertText} call.\u000a *\u000a * @event insertText\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param {String} data The text to insert.\u000a */\u000a\u000a/**\u000a * Internal event to perform the {@link #method-insertElement} call.\u000a *\u000a * @event insertElement\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param {CKEDITOR.dom.element} data The element to insert.\u000a */\u000a\u000a/**\u000a * Event fired after the {@link #property-readOnly} property changes.\u000a *\u000a * @since 3.6\u000a * @event readOnly\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Event fired when an UI template is added to the editor instance. It makes\u000a * it possible to bring customizations to the template source.\u000a *\u000a * @event template\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param data\u000a * @param {String} data.name The template name.\u000a * @param {String} data.source The source data for this template.\u000a */\u000a\u000a/**\u000a * Fired when content of the editor (its DOM structure) is ready.\u000a * It is similar to native DOMContentLoaded event, but it concerns\u000a * editor's content. It is also a first event fired after\u000a * {@link CKEDITOR.editable} is initialized.\u000a *\u000a * This event is particularly important for classic (`iframe`-based)\u000a * editor, because on editor initialization and every time data are set\u000a * (by {@link CKEDITOR.editor#method-setData}) contents DOM structure\u000a * is rebuilt. Thus, e.g. you need to attach DOM events listeners\u000a * on editable one more time.\u000a *\u000a * On inline editor this event is fired only once - when editor\u000a * is initialized for the first time. That's because setting\u000a * editor's content doesn't cause editable destruction and creation.\u000a *\u000a * {@link #contentDom} goes along with {@link #contentDomUnload} which\u000a * is fired before contents DOM structure is destroyed. This is the\u000a * right moment to detach content DOM events listener. Otherwise\u000a * browsers like IE or Opera may throw exceptions when accessing\u000a * elements from detached document.\u000a *\u000a * **Note:** {@link CKEDITOR.editable#attachListener} is a convenient\u000a * way to attach listeners that will be detached on {@link #contentDomUnload}.\u000a *\u000a *		editor.on( 'contentDom', function() {\u000a *			var editable = editor.editable();\u000a *\u000a *			editable.attachListener( editable, 'click', function() {\u000a *				console.log( 'Editable has been clicked' );\u000a *			});\u000a *		});\u000a *\u000a * @event contentDom\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Fired before contents DOM structure is destroyed.\u000a * See {@link #contentDom} documentation for more details.\u000a *\u000a * @event contentDomUnload\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * The event fired when contents DOM changes and some of the references as well as\u000a * native DOM event listeners could be lost.\u000a * This event is useful when it is important to keep track of references\u000a * to elements in the editable contents from code.\u000a *\u000a * @since 4.3\u000a * @event contentDomInvalidated\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.template} class, which represents\u000a * an UI template for an editor instance.\u000a */\u000a\u000a( function() {\u000a	var cache = {},\u000a		rePlaceholder = /{([^}]+)}/g,\u000a		reEscapableChars = /([\u005c\u005c'])/g,\u000a		reNewLine = /\u005cn/g,\u000a		reCarriageReturn = /\u005cr/g;\u000a\u000a	/**\u000a	 * Lightweight template used to build the output string from variables.\u000a	 *\u000a	 *		// HTML template for presenting a label UI.\u000a	 *		var tpl = new CKEDITOR.template( '<div class="{cls}">{label}</div>' );\u000a	 *		alert( tpl.output( { cls: 'cke-label', label: 'foo'} ) ); // '<div class="cke-label">foo</div>'\u000a	 *\u000a	 * @class\u000a	 * @constructor Creates a template class instance.\u000a	 * @param {String} source The template source.\u000a	 */\u000a	CKEDITOR.template = function( source ) {\u000a		// Builds an optimized function body for the output() method, focused on performance.\u000a		// For example, if we have this "source":\u000a		//	'<div style="{style}">{editorName}</div>'\u000a		// ... the resulting function body will be (apart from the "buffer" handling):\u000a		//	return [ '<div style="', data['style'] == undefined ? '{style}' : data['style'], '">', data['editorName'] == undefined ? '{editorName}' : data['editorName'], '</div>' ].join('');\u000a\u000a		// Try to read from the cache.\u000a		if ( cache[ source ] )\u000a			this.output = cache[ source ];\u000a		else {\u000a			var fn = source\u000a				// Escape chars like slash "\u005c" or single quote "'".\u000a				.replace( reEscapableChars, '\u005c\u005c$1' )\u000a				.replace( reNewLine, '\u005c\u005cn' )\u000a				.replace( reCarriageReturn, '\u005c\u005cr' )\u000a				// Inject the template keys replacement.\u000a				.replace( rePlaceholder, function( m, key ) {\u000a					return "',data['" + key + "']==undefined?'{" + key + "}':data['" + key + "'],'";\u000a				} );\u000a\u000a			fn = "return buffer?buffer.push('" + fn + "'):['" + fn + "'].join('');";\u000a			this.output = cache[ source ] = Function( 'data', 'buffer', fn );\u000a		}\u000a	};\u000a} )();\u000a\u000a/**\u000a * Processes the template, filling its variables with the provided data.\u000a *\u000a * @method output\u000a * @param {Object} data An object containing properties which values will be\u000a * used to fill the template variables. The property names must match the\u000a * template variables names. Variables without matching properties will be\u000a * kept untouched.\u000a * @param {Array} [buffer] An array into which the output data will be pushed into.\u000a * The number of entries appended to the array is unknown.\u000a * @returns {String/Number} If `buffer` has not been provided, the processed\u000a * template output data, otherwise the new length of `buffer`.\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	/**\u000a	 * Represents an HTML data processor, which is responsible for translating and\u000a	 * transforming the editor data on input and output.\u000a	 *\u000a	 * @class\u000a	 * @extends CKEDITOR.dataProcessor\u000a	 * @constructor Creates an htmlDataProcessor class instance.\u000a	 * @param {CKEDITOR.editor} editor\u000a	 */\u000a	CKEDITOR.htmlDataProcessor = function( editor ) {\u000a		var dataFilter, htmlFilter,\u000a			that = this;\u000a\u000a		this.editor = editor;\u000a\u000a		/**\u000a		 * Data filter used when processing input by {@link #toHtml}.\u000a		 *\u000a		 * @property {CKEDITOR.htmlParser.filter}\u000a		 */\u000a		this.dataFilter = dataFilter = new CKEDITOR.htmlParser.filter();\u000a\u000a		/**\u000a		 * HTML filter used when processing output by {@link #toDataFormat}.\u000a		 *\u000a		 * @property {CKEDITOR.htmlParser.filter}\u000a		 */\u000a		this.htmlFilter = htmlFilter = new CKEDITOR.htmlParser.filter();\u000a\u000a		/**\u000a		 * The HTML writer used by this data processor to format the output.\u000a		 *\u000a		 * @property {CKEDITOR.htmlParser.basicWriter}\u000a		 */\u000a		this.writer = new CKEDITOR.htmlParser.basicWriter();\u000a\u000a		dataFilter.addRules( defaultDataFilterRulesEditableOnly );\u000a		dataFilter.addRules( defaultDataFilterRulesForAll, { applyToAll: true } );\u000a		dataFilter.addRules( createBogusAndFillerRules( editor, 'data' ), { applyToAll: true } );\u000a		htmlFilter.addRules( defaultHtmlFilterRulesEditableOnly );\u000a		htmlFilter.addRules( defaultHtmlFilterRulesForAll, { applyToAll: true } );\u000a		htmlFilter.addRules( createBogusAndFillerRules( editor, 'html' ), { applyToAll: true } );\u000a\u000a		editor.on( 'toHtml', function( evt ) {\u000a			var evtData = evt.data,\u000a				data = evtData.dataValue;\u000a\u000a			// The source data is already HTML, but we need to clean\u000a			// it up and apply the filter.\u000a			data = protectSource( data, editor );\u000a\u000a			// Protect content of textareas. (#9995)\u000a			// Do this before protecting attributes to avoid breaking:\u000a			// <textarea><img src="..." /></textarea>\u000a			data = protectElements( data, protectTextareaRegex );\u000a\u000a			// Before anything, we must protect the URL attributes as the\u000a			// browser may changing them when setting the innerHTML later in\u000a			// the code.\u000a			data = protectAttributes( data );\u000a\u000a			// Protect elements than can't be set inside a DIV. E.g. IE removes\u000a			// style tags from innerHTML. (#3710)\u000a			data = protectElements( data, protectElementsRegex );\u000a\u000a			// Certain elements has problem to go through DOM operation, protect\u000a			// them by prefixing 'cke' namespace. (#3591)\u000a			data = protectElementsNames( data );\u000a\u000a			// All none-IE browsers ignore self-closed custom elements,\u000a			// protecting them into open-close. (#3591)\u000a			data = protectSelfClosingElements( data );\u000a\u000a			// Compensate one leading line break after <pre> open as browsers\u000a			// eat it up. (#5789)\u000a			data = protectPreFormatted( data );\u000a\u000a			// There are attributes which may execute JavaScript code inside fixBin.\u000a			// Encode them greedily. They will be unprotected right after getting HTML from fixBin. (#10)\u000a			data = protectInsecureAttributes( data );\u000a\u000a			var fixBin = evtData.context || editor.editable().getName(),\u000a				isPre;\u000a\u000a			// Old IEs loose formats when load html into <pre>.\u000a			if ( CKEDITOR.env.ie && CKEDITOR.env.version < 9 && fixBin == 'pre' ) {\u000a				fixBin = 'div';\u000a				data = '<pre>' + data + '</pre>';\u000a				isPre = 1;\u000a			}\u000a\u000a			// Call the browser to help us fixing a possibly invalid HTML\u000a			// structure.\u000a			var el = editor.document.createElement( fixBin );\u000a			// Add fake character to workaround IE comments bug. (#3801)\u000a			el.setHtml( 'a' + data );\u000a			data = el.getHtml().substr( 1 );\u000a\u000a			// Restore shortly protected attribute names.\u000a			data = data.replace( new RegExp( 'data-cke-' + CKEDITOR.rnd + '-', 'ig' ), '' );\u000a\u000a			isPre && ( data = data.replace( /^<pre>|<\u005c/pre>$/gi, '' ) );\u000a\u000a			// Unprotect "some" of the protected elements at this point.\u000a			data = unprotectElementNames( data );\u000a\u000a			data = unprotectElements( data );\u000a\u000a			// Restore the comments that have been protected, in this way they\u000a			// can be properly filtered.\u000a			data = unprotectRealComments( data );\u000a\u000a			// Now use our parser to make further fixes to the structure, as\u000a			// well as apply the filter.\u000a			evtData.dataValue = CKEDITOR.htmlParser.fragment.fromHtml(\u000a				data, evtData.context, evtData.fixForBody === false ? false : getFixBodyTag( evtData.enterMode, editor.config.autoParagraph ) );\u000a		}, null, null, 5 );\u000a\u000a		// Filter incoming "data".\u000a		// Add element filter before htmlDataProcessor.dataFilter when purifying input data to correct html.\u000a		editor.on( 'toHtml', function( evt ) {\u000a			if ( evt.data.filter.applyTo( evt.data.dataValue, true, evt.data.dontFilter, evt.data.enterMode ) )\u000a				editor.fire( 'dataFiltered' );\u000a		}, null, null, 6 );\u000a\u000a		editor.on( 'toHtml', function( evt ) {\u000a			evt.data.dataValue.filterChildren( that.dataFilter, true );\u000a		}, null, null, 10 );\u000a\u000a		editor.on( 'toHtml', function( evt ) {\u000a			var evtData = evt.data,\u000a				data = evtData.dataValue,\u000a				writer = new CKEDITOR.htmlParser.basicWriter();\u000a\u000a			data.writeChildrenHtml( writer );\u000a			data = writer.getHtml( true );\u000a\u000a			// Protect the real comments again.\u000a			evtData.dataValue = protectRealComments( data );\u000a		}, null, null, 15 );\u000a\u000a\u000a		editor.on( 'toDataFormat', function( evt ) {\u000a			var data = evt.data.dataValue;\u000a\u000a			// #10854 - we need to strip leading blockless <br> which FF adds\u000a			// automatically when editable contains only non-editable content.\u000a			// We do that for every browser (so it's a constant behavior) and\u000a			// not in BR mode, in which chance of valid leading blockless <br> is higher.\u000a			if ( evt.data.enterMode != CKEDITOR.ENTER_BR )\u000a				data = data.replace( /^<br *\u005c/?>/i, '' );\u000a\u000a			evt.data.dataValue = CKEDITOR.htmlParser.fragment.fromHtml(\u000a				data, evt.data.context, getFixBodyTag( evt.data.enterMode, editor.config.autoParagraph ) );\u000a		}, null, null, 5 );\u000a\u000a		editor.on( 'toDataFormat', function( evt ) {\u000a			evt.data.dataValue.filterChildren( that.htmlFilter, true );\u000a		}, null, null, 10 );\u000a\u000a		// Transform outcoming "data".\u000a		// Add element filter after htmlDataProcessor.htmlFilter when preparing output data HTML.\u000a		editor.on( 'toDataFormat', function( evt ) {\u000a			evt.data.filter.applyTo( evt.data.dataValue, false, true );\u000a		}, null, null, 11 );\u000a\u000a		editor.on( 'toDataFormat', function( evt ) {\u000a			var data = evt.data.dataValue,\u000a				writer = that.writer;\u000a\u000a			writer.reset();\u000a			data.writeChildrenHtml( writer );\u000a			data = writer.getHtml( true );\u000a\u000a			// Restore those non-HTML protected source. (#4475,#4880)\u000a			data = unprotectRealComments( data );\u000a			data = unprotectSource( data, editor );\u000a\u000a			evt.data.dataValue = data;\u000a		}, null, null, 15 );\u000a	};\u000a\u000a	CKEDITOR.htmlDataProcessor.prototype = {\u000a		/**\u000a		 * Processes the input (potentially malformed) HTML to a purified form which\u000a		 * is suitable for using in the WYSIWYG editable.\u000a		 *\u000a		 * This method fires the {@link CKEDITOR.editor#toHtml} event which makes it possible\u000a		 * to hook into the process at various stages.\u000a		 *\u000a		 * **Note:** Since CKEditor 4.3 the signature of this method changed and all options\u000a		 * are now grouped in one `options` object. Previously `context`, `fixForBody` and `dontFilter`\u000a		 * were passed separately.\u000a		 *\u000a		 * @param {String} data The raw data.\u000a		 * @param {Object} [options] The options object.\u000a		 * @param {String} [options.context] The tag name of a context element within which\u000a		 * the input is to be processed, default to be the editable element.\u000a		 * If `null` is passed, then data will be parsed without context (as children of {@link CKEDITOR.htmlParser.fragment}).\u000a		 * See {@link CKEDITOR.htmlParser.fragment#fromHtml} for more details.\u000a		 * @param {Boolean} [options.fixForBody=true] Whether to trigger the auto paragraph for non-block contents.\u000a		 * @param {CKEDITOR.filter} [options.filter] When specified, instead of using the {@link CKEDITOR.editor#filter main filter},\u000a		 * passed instance will be used to filter the content.\u000a		 * @param {Boolean} [options.dontFilter] Do not filter data with {@link CKEDITOR.filter} (note: transformations\u000a		 * will be still applied).\u000a		 * @param {Number} [options.enterMode] When specified it will be used instead of the {@link CKEDITOR.editor#enterMode main enterMode}.\u000a		 * @returns {String}\u000a		 */\u000a		toHtml: function( data, options, fixForBody, dontFilter ) {\u000a			var editor = this.editor,\u000a				context, filter, enterMode;\u000a\u000a			// Typeof null == 'object', so check truthiness of options too.\u000a			if ( options && typeof options == 'object' ) {\u000a				context = options.context;\u000a				fixForBody = options.fixForBody;\u000a				dontFilter = options.dontFilter;\u000a				filter = options.filter;\u000a				enterMode = options.enterMode;\u000a			}\u000a			// Backward compatibility. Since CKEDITOR 4.3 every option was a separate argument.\u000a			else {\u000a				context = options;\u000a			}\u000a\u000a			// Fall back to the editable as context if not specified.\u000a			if ( !context && context !== null )\u000a				context = editor.editable().getName();\u000a\u000a			return editor.fire( 'toHtml', {\u000a				dataValue: data,\u000a				context: context,\u000a				fixForBody: fixForBody,\u000a				dontFilter: dontFilter,\u000a				filter: filter || editor.filter,\u000a				enterMode: enterMode || editor.enterMode\u000a			} ).dataValue;\u000a		},\u000a\u000a		/**\u000a		 * See {@link CKEDITOR.dataProcessor#toDataFormat}.\u000a		 *\u000a		 * This method fires the {@link CKEDITOR.editor#toDataFormat} event which makes it possible\u000a		 * to hook into the process at various steps.\u000a		 *\u000a		 * @param {String} html\u000a		 * @param {Object} [options] The options object.\u000a		 * @param {String} [options.context] The tag name of a context element within which\u000a		 * the input is to be processed, default to be the editable element.\u000a		 * @param {CKEDITOR.filter} [options.filter] When specified, instead of using the {@link CKEDITOR.editor#filter main filter},\u000a		 * passed instance will be used to apply content transformations to the content.\u000a		 * @param {Number} [options.enterMode] When specified it will be used instead of the {@link CKEDITOR.editor#enterMode main enterMode}.\u000a		 * @returns {String}\u000a		 */\u000a		toDataFormat: function( html, options ) {\u000a			var context, filter, enterMode;\u000a\u000a			// Do not shorten this to `options && options.xxx`, because\u000a			// falsy `options` will be passed instead of undefined.\u000a			if ( options ) {\u000a				context = options.context;\u000a				filter = options.filter;\u000a				enterMode = options.enterMode;\u000a			}\u000a\u000a			// Fall back to the editable as context if not specified.\u000a			if ( !context && context !== null )\u000a				context = this.editor.editable().getName();\u000a\u000a			return this.editor.fire( 'toDataFormat', {\u000a				dataValue: html,\u000a				filter: filter || this.editor.filter,\u000a				context: context,\u000a				enterMode: enterMode || this.editor.enterMode\u000a			} ).dataValue;\u000a		}\u000a	};\u000a\u000a	// Produce a set of filtering rules that handles bogus and filler node at the\u000a	// end of block/pseudo block, in the following consequence:\u000a	// 1. elements:<block> - this filter removes any bogus node, then check\u000a	// if it's an empty block that requires a filler.\u000a	// 2. elements:<br> - After cleaned with bogus, this filter checks the real\u000a	// line-break BR to compensate a filler after it.\u000a	//\u000a	// Terms definitions:\u000a	// filler: An element that's either <BR> or &NBSP; at the end of block that established line height.\u000a	// bogus: Whenever a filler is proceeded with inline content, it becomes a bogus which is subjected to be removed.\u000a	//\u000a	// Various forms of the filler:\u000a	// In output HTML: Filler should be consistently &NBSP; <BR> at the end of block is always considered as bogus.\u000a	// In Wysiwyg HTML: Browser dependent - see env.needsBrFiller. Either BR for when needsBrFiller is true, or &NBSP; otherwise.\u000a	// <BR> is NEVER considered as bogus when needsBrFiller is true.\u000a	function createBogusAndFillerRules( editor, type ) {\u000a		function createFiller( isOutput ) {\u000a			return isOutput || CKEDITOR.env.needsNbspFiller ?\u000a				new CKEDITOR.htmlParser.text( '\u005cxa0' ) :\u000a				new CKEDITOR.htmlParser.element( 'br', { 'data-cke-bogus': 1 } );\u000a		}\u000a\u000a		// This text block filter, remove any bogus and create the filler on demand.\u000a		function blockFilter( isOutput, fillEmptyBlock ) {\u000a\u000a			return function( block ) {\u000a				// DO NOT apply the filler if it's a fragment node.\u000a				if ( block.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )\u000a					return;\u000a\u000a				cleanBogus( block );\u000a\u000a				var shouldFillBlock = typeof fillEmptyBlock == 'function' ? fillEmptyBlock( block ) : fillEmptyBlock;\u000a\u000a				if ( shouldFillBlock !== false && isEmptyBlockNeedFiller( block ) ) {\u000a					block.add( createFiller( isOutput ) );\u000a				}\u000a			};\u000a		}\u000a\u000a		// Append a filler right after the last line-break BR, found at the end of block.\u000a		function brFilter( isOutput ) {\u000a			return function( br ) {\u000a				// DO NOT apply the filer if parent's a fragment node.\u000a				if ( br.parent.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )\u000a					return;\u000a\u000a				var attrs = br.attributes;\u000a				// Dismiss BRs that are either bogus or eol marker.\u000a				if ( 'data-cke-bogus' in attrs || 'data-cke-eol' in attrs ) {\u000a					delete attrs [ 'data-cke-bogus' ];\u000a					return;\u000a				}\u000a\u000a				// Judge the tail line-break BR, and to insert bogus after it.\u000a				var next = getNext( br ), previous = getPrevious( br );\u000a\u000a				if ( !next && isBlockBoundary( br.parent ) )\u000a					append( br.parent, createFiller( isOutput ) );\u000a				else if ( isBlockBoundary( next ) && previous && !isBlockBoundary( previous ) )\u000a					createFiller( isOutput ).insertBefore( next );\u000a			};\u000a		}\u000a\u000a		// Determinate whether this node is potentially a bogus node.\u000a		function maybeBogus( node, atBlockEnd ) {\u000a\u000a			// BR that's not from IE<11 DOM, except for a EOL marker.\u000a			if ( !( isOutput && !CKEDITOR.env.needsBrFiller ) &&\u000a					node.type == CKEDITOR.NODE_ELEMENT && node.name == 'br' &&\u000a					!node.attributes[ 'data-cke-eol' ] ) {\u000a				return true;\u000a			}\u000a\u000a			var match;\u000a\u000a			// NBSP, possibly.\u000a			if ( node.type == CKEDITOR.NODE_TEXT && ( match = node.value.match( tailNbspRegex ) ) ) {\u000a				// We need to separate tail NBSP out of a text node, for later removal.\u000a				if ( match.index ) {\u000a					( new CKEDITOR.htmlParser.text( node.value.substring( 0, match.index ) ) ).insertBefore( node );\u000a					node.value = match[ 0 ];\u000a				}\u000a\u000a				// From IE<11 DOM, at the end of a text block, or before block boundary.\u000a				if ( !CKEDITOR.env.needsBrFiller && isOutput && ( !atBlockEnd || node.parent.name in textBlockTags ) )\u000a					return true;\u000a\u000a				// From the output.\u000a				if ( !isOutput ) {\u000a					var previous = node.previous;\u000a\u000a					// Following a line-break at the end of block.\u000a					if ( previous && previous.name == 'br' )\u000a						return true;\u000a\u000a					// Or a single NBSP between two blocks.\u000a					if ( !previous || isBlockBoundary( previous ) )\u000a						return true;\u000a				}\u000a			}\u000a\u000a			return false;\u000a		}\u000a\u000a		// Removes all bogus inside of this block, and to convert fillers into the proper form.\u000a		function cleanBogus( block ) {\u000a			var bogus = [];\u000a			var last = getLast( block ), node, previous;\u000a\u000a			if ( last ) {\u000a				// Check for bogus at the end of this block.\u000a				// e.g. <p>foo<br /></p>\u000a				maybeBogus( last, 1 ) && bogus.push( last );\u000a\u000a				while ( last ) {\u000a					// Check for bogus at the end of any pseudo block contained.\u000a					if ( isBlockBoundary( last ) && ( node = getPrevious( last ) ) && maybeBogus( node ) ) {\u000a						// Bogus must have inline proceeding, instead single BR between two blocks,\u000a						// is considered as filler, e.g. <hr /><br /><hr />\u000a						if ( ( previous = getPrevious( node ) ) && !isBlockBoundary( previous ) )\u000a							bogus.push( node );\u000a						// Convert the filler into appropriate form.\u000a						else {\u000a							createFiller( isOutput ).insertAfter( node );\u000a							node.remove();\u000a						}\u000a					}\u000a\u000a					last = last.previous;\u000a				}\u000a			}\u000a\u000a			// Now remove all bogus collected from above.\u000a			for ( var i = 0 ; i < bogus.length ; i++ )\u000a				bogus[ i ].remove();\u000a		}\u000a\u000a		// Judge whether it's an empty block that requires a filler node.\u000a		function isEmptyBlockNeedFiller( block ) {\u000a\u000a			// DO NOT fill empty editable in IE<11.\u000a			if ( !isOutput && !CKEDITOR.env.needsBrFiller && block.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )\u000a				return false;\u000a\u000a			// 1. For IE version >=8,  empty blocks are displayed correctly themself in wysiwiyg;\u000a			// 2. For the rest, at least table cell and list item need no filler space. (#6248)\u000a			if ( !isOutput && !CKEDITOR.env.needsBrFiller &&\u000a				( document.documentMode > 7 ||\u000a					block.name in CKEDITOR.dtd.tr ||\u000a					block.name in CKEDITOR.dtd.$listItem ) ) {\u000a				return false;\u000a			}\u000a\u000a			var last = getLast( block );\u000a			return !last || block.name == 'form' && last.name == 'input' ;\u000a		}\u000a\u000a		var rules = { elements: {} },\u000a			isOutput = type == 'html',\u000a			textBlockTags = CKEDITOR.tools.extend( {}, blockLikeTags );\u000a\u000a		// Build the list of text blocks.\u000a		for ( var i in textBlockTags ) {\u000a			if ( !( '#' in dtd[ i ] ) )\u000a				delete textBlockTags[ i ];\u000a		}\u000a\u000a		for ( i in textBlockTags )\u000a			rules.elements[ i ] = blockFilter( isOutput, editor.config.fillEmptyBlocks );\u000a\u000a		// Editable element has to be checked separately.\u000a		rules.root = blockFilter( isOutput, false );\u000a		rules.elements.br = brFilter( isOutput );\u000a		return rules;\u000a	}\u000a\u000a	function getFixBodyTag( enterMode, autoParagraph ) {\u000a		return ( enterMode != CKEDITOR.ENTER_BR && autoParagraph !== false ) ? enterMode == CKEDITOR.ENTER_DIV ? 'div' : 'p' : false;\u000a	}\u000a\u000a	// Regex to scan for &nbsp; at the end of blocks, which are actually placeholders.\u000a	// Safari transforms the &nbsp; to \u005cxa0. (#4172)\u000a	var tailNbspRegex = /(?:&nbsp;|\u005cxa0)$/;\u000a\u000a	var protectedSourceMarker = '{cke_protected}';\u000a\u000a	function getLast( node ) {\u000a		var last = node.children[ node.children.length - 1 ];\u000a		while ( last && isEmpty( last ) )\u000a			last = last.previous;\u000a		return last;\u000a	}\u000a\u000a	function getNext( node ) {\u000a		var next = node.next;\u000a		while ( next && isEmpty( next ) )\u000a			next = next.next;\u000a		return next;\u000a	}\u000a\u000a	function getPrevious( node ) {\u000a		var previous = node.previous;\u000a		while ( previous && isEmpty( previous ) )\u000a			previous = previous.previous;\u000a		return previous;\u000a	}\u000a\u000a	// Judge whether the node is an ghost node to be ignored, when traversing.\u000a	function isEmpty( node ) {\u000a		return node.type == CKEDITOR.NODE_TEXT &&\u000a			!CKEDITOR.tools.trim( node.value ) ||\u000a			node.type == CKEDITOR.NODE_ELEMENT &&\u000a			node.attributes[ 'data-cke-bookmark' ];\u000a	}\u000a\u000a	// Judge whether the node is a block-like element.\u000a	function isBlockBoundary( node ) {\u000a		return node &&\u000a			( node.type == CKEDITOR.NODE_ELEMENT && node.name in blockLikeTags ||\u000a			node.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT );\u000a	}\u000a\u000a	function append( parent, node ) {\u000a		var last = parent.children[ parent.children.length - 1 ];\u000a		parent.children.push( node );\u000a		node.parent = parent;\u000a		if ( last ) {\u000a			last.next = node;\u000a			node.previous = last;\u000a		}\u000a	}\u000a\u000a	function getNodeIndex( node ) {\u000a		return node.parent ? node.getIndex() : -1;\u000a	}\u000a\u000a	var dtd = CKEDITOR.dtd,\u000a		// Define orders of table elements.\u000a		tableOrder = [ 'caption', 'colgroup', 'col', 'thead', 'tfoot', 'tbody' ],\u000a		// List of all block elements.\u000a		blockLikeTags = CKEDITOR.tools.extend( {}, dtd.$blockLimit, dtd.$block );\u000a\u000a	//\u000a	// DATA filter rules ------------------------------------------------------\u000a	//\u000a\u000a	var defaultDataFilterRulesEditableOnly = {\u000a		elements: {\u000a			input: protectReadOnly,\u000a			textarea: protectReadOnly\u000a		}\u000a	};\u000a\u000a	// These rules will also be applied to non-editable content.\u000a	var defaultDataFilterRulesForAll = {\u000a		attributeNames: [\u000a			// Event attributes (onXYZ) must not be directly set. They can become\u000a			// active in the editing area (IE|WebKit).\u000a			[ ( /^on/ ), 'data-cke-pa-on' ],\u000a\u000a			// Don't let some old expando enter editor. Concerns only IE8,\u000a			// but for consistency remove on all browsers.\u000a			[ ( /^data-cke-expando$/ ), '' ]\u000a		]\u000a	};\u000a\u000a	// Disable form elements editing mode provided by some browsers. (#5746)\u000a	function protectReadOnly( element ) {\u000a		var attrs = element.attributes;\u000a\u000a		// We should flag that the element was locked by our code so\u000a		// it'll be editable by the editor functions (#6046).\u000a		if ( attrs.contenteditable != 'false' )\u000a			attrs[ 'data-cke-editable' ] = attrs.contenteditable ? 'true' : 1;\u000a\u000a		attrs.contenteditable = 'false';\u000a	}\u000a\u000a	//\u000a	// HTML filter rules ------------------------------------------------------\u000a	//\u000a\u000a	var defaultHtmlFilterRulesEditableOnly = {\u000a		elements: {\u000a			embed: function( element ) {\u000a				var parent = element.parent;\u000a\u000a				// If the <embed> is child of a <object>, copy the width\u000a				// and height attributes from it.\u000a				if ( parent && parent.name == 'object' ) {\u000a					var parentWidth = parent.attributes.width,\u000a						parentHeight = parent.attributes.height;\u000a					if ( parentWidth )\u000a						element.attributes.width = parentWidth;\u000a					if ( parentHeight )\u000a						element.attributes.height = parentHeight;\u000a				}\u000a			},\u000a\u000a			// Remove empty link but not empty anchor. (#3829)\u000a			a: function( element ) {\u000a				if ( !( element.children.length || element.attributes.name || element.attributes[ 'data-cke-saved-name' ] ) )\u000a					return false;\u000a			}\u000a		}\u000a	};\u000a\u000a	// These rules will also be applied to non-editable content.\u000a	var defaultHtmlFilterRulesForAll = {\u000a		elementNames: [\u000a			// Remove the "cke:" namespace prefix.\u000a			[ ( /^cke:/ ), '' ],\u000a\u000a			// Ignore <?xml:namespace> tags.\u000a			[ ( /^\u005c?xml:namespace$/ ), '' ]\u000a		],\u000a\u000a		attributeNames: [\u000a			// Attributes saved for changes and protected attributes.\u000a			[ ( /^data-cke-(saved|pa)-/ ), '' ],\u000a\u000a			// All "data-cke-" attributes are to be ignored.\u000a			[ ( /^data-cke-.*/ ), '' ],\u000a\u000a			[ 'hidefocus', '' ]\u000a		],\u000a\u000a		elements: {\u000a			$: function( element ) {\u000a				var attribs = element.attributes;\u000a\u000a				if ( attribs ) {\u000a					// Elements marked as temporary are to be ignored.\u000a					if ( attribs[ 'data-cke-temp' ] )\u000a						return false;\u000a\u000a					// Remove duplicated attributes - #3789.\u000a					var attributeNames = [ 'name', 'href', 'src' ],\u000a						savedAttributeName;\u000a					for ( var i = 0; i < attributeNames.length; i++ ) {\u000a						savedAttributeName = 'data-cke-saved-' + attributeNames[ i ];\u000a						savedAttributeName in attribs && ( delete attribs[ attributeNames[ i ] ] );\u000a					}\u000a				}\u000a\u000a				return element;\u000a			},\u000a\u000a			// The contents of table should be in correct order (#4809).\u000a			table: function( element ) {\u000a				// Clone the array as it would become empty during the sort call.\u000a				var children = element.children.slice( 0 );\u000a\u000a				children.sort( function( node1, node2 ) {\u000a					var index1, index2;\u000a\u000a					// Compare in the predefined order.\u000a					if ( node1.type == CKEDITOR.NODE_ELEMENT && node2.type == node1.type ) {\u000a						index1 = CKEDITOR.tools.indexOf( tableOrder, node1.name );\u000a						index2 = CKEDITOR.tools.indexOf( tableOrder, node2.name );\u000a					}\u000a\u000a					// Make sure the sort is stable, if no order can be established above.\u000a					if ( !( index1 > -1 && index2 > -1 && index1 != index2 ) ) {\u000a						index1 = getNodeIndex( node1 );\u000a						index2 = getNodeIndex( node2 );\u000a					}\u000a\u000a					return index1 > index2 ? 1 : -1;\u000a				} );\u000a			},\u000a\u000a			// Restore param elements into self-closing.\u000a			param: function( param ) {\u000a				param.children = [];\u000a				param.isEmpty = true;\u000a				return param;\u000a			},\u000a\u000a			// Remove dummy span in webkit.\u000a			span: function( element ) {\u000a				if ( element.attributes[ 'class' ] == 'Apple-style-span' )\u000a					delete element.name;\u000a			},\u000a\u000a			html: function( element ) {\u000a				delete element.attributes.contenteditable;\u000a				delete element.attributes[ 'class' ];\u000a			},\u000a\u000a			body: function( element ) {\u000a				delete element.attributes.spellcheck;\u000a				delete element.attributes.contenteditable;\u000a			},\u000a\u000a			style: function( element ) {\u000a				var child = element.children[ 0 ];\u000a				if ( child && child.value )\u000a					child.value = CKEDITOR.tools.trim( child.value );\u000a\u000a				if ( !element.attributes.type )\u000a					element.attributes.type = 'text/css';\u000a			},\u000a\u000a			title: function( element ) {\u000a				var titleText = element.children[ 0 ];\u000a\u000a				// Append text-node to title tag if not present (i.e. non-IEs) (#9882).\u000a				!titleText && append( element, titleText = new CKEDITOR.htmlParser.text() );\u000a\u000a				// Transfer data-saved title to title tag.\u000a				titleText.value = element.attributes[ 'data-cke-title' ] || '';\u000a			},\u000a\u000a			input: unprotectReadyOnly,\u000a			textarea: unprotectReadyOnly\u000a		},\u000a\u000a		attributes: {\u000a			'class': function( value ) {\u000a				// Remove all class names starting with "cke_".\u000a				return CKEDITOR.tools.ltrim( value.replace( /(?:^|\u005cs+)cke_[^\u005cs]*/g, '' ) ) || false;\u000a			}\u000a		}\u000a	};\u000a\u000a	if ( CKEDITOR.env.ie ) {\u000a		// IE outputs style attribute in capital letters. We should convert\u000a		// them back to lower case, while not hurting the values (#5930)\u000a		defaultHtmlFilterRulesForAll.attributes.style = function( value ) {\u000a			return value.replace( /(^|;)([^\u005c:]+)/g, function( match ) {\u000a				return match.toLowerCase();\u000a			} );\u000a		};\u000a	}\u000a\u000a	// Disable form elements editing mode provided by some browsers. (#5746)\u000a	function unprotectReadyOnly( element ) {\u000a		var attrs = element.attributes;\u000a		switch ( attrs[ 'data-cke-editable' ] ) {\u000a			case 'true':\u000a				attrs.contenteditable = 'true';\u000a				break;\u000a			case '1':\u000a				delete attrs.contenteditable;\u000a				break;\u000a		}\u000a	}\u000a\u000a	//\u000a	// Preprocessor filters ---------------------------------------------------\u000a	//\u000a\u000a	var protectElementRegex = /<(a|area|img|input|source)\u005cb([^>]*)>/gi,\u000a		// Be greedy while looking for protected attributes. This will let us avoid an unfortunate\u000a		// situation when "nested attributes", which may appear valid, are also protected.\u000a		// I.e. if we consider the following HTML:\u000a		//\u000a		// 	<img data-x="&lt;a href=&quot;X&quot;" />\u000a		//\u000a		// then the "non-greedy match" returns:\u000a		//\u000a		// 	'href' => '&quot;X&quot;' // It's wrong! Href is not an attribute of <img>.\u000a		//\u000a		// while greedy match returns:\u000a		//\u000a		// 	'data-x' => '&lt;a href=&quot;X&quot;'\u000a		//\u000a		// which, can be easily filtered out (#11508).\u000a		protectAttributeRegex = /([\u005cw-]+)\u005cs*=\u005cs*(?:(?:"[^"]*")|(?:'[^']*')|(?:[^ "'>]+))/gi,\u000a		protectAttributeNameRegex = /^(href|src|name)$/i;\u000a\u000a		// Note: we use lazy star '*?' to prevent eating everything up to the last occurrence of </style> or </textarea>.\u000a	var protectElementsRegex = /(?:<style(?=[ >])[^>]*>[\u005cs\u005cS]*?<\u005c/style>)|(?:<(:?link|meta|base)[^>]*>)/gi,\u000a		protectTextareaRegex = /(<textarea(?=[ >])[^>]*>)([\u005cs\u005cS]*?)(?:<\u005c/textarea>)/gi,\u000a		encodedElementsRegex = /<cke:encoded>([^<]*)<\u005c/cke:encoded>/gi;\u000a\u000a	var protectElementNamesRegex = /(<\u005c/?)((?:object|embed|param|html|body|head|title)[^>]*>)/gi,\u000a		unprotectElementNamesRegex = /(<\u005c/?)cke:((?:html|body|head|title)[^>]*>)/gi;\u000a\u000a	var protectSelfClosingRegex = /<cke:(param|embed)([^>]*?)\u005c/?>(?!\u005cs*<\u005c/cke:\u005c1)/gi;\u000a\u000a	function protectAttributes( html ) {\u000a		return html.replace( protectElementRegex, function( element, tag, attributes ) {\u000a			return '<' + tag + attributes.replace( protectAttributeRegex, function( fullAttr, attrName ) {\u000a				// Avoid corrupting the inline event attributes (#7243).\u000a				// We should not rewrite the existed protected attributes, e.g. clipboard content from editor. (#5218)\u000a				if ( protectAttributeNameRegex.test( attrName ) && attributes.indexOf( 'data-cke-saved-' + attrName ) == -1 )\u000a					return ' data-cke-saved-' + fullAttr + ' data-cke-' + CKEDITOR.rnd + '-' + fullAttr;\u000a\u000a				return fullAttr;\u000a			} ) + '>';\u000a		} );\u000a	}\u000a\u000a	function protectElements( html, regex ) {\u000a		return html.replace( regex, function( match, tag, content ) {\u000a			// Encode < and > in textarea because this won't be done by a browser, since\u000a			// textarea will be protected during passing data through fix bin.\u000a			if ( match.indexOf( '<textarea' ) === 0 )\u000a				match = tag + unprotectRealComments( content ).replace( /</g, '&lt;' ).replace( />/g, '&gt;' ) + '</textarea>';\u000a\u000a			return '<cke:encoded>' + encodeURIComponent( match ) + '</cke:encoded>';\u000a		} );\u000a	}\u000a\u000a	function unprotectElements( html ) {\u000a		return html.replace( encodedElementsRegex, function( match, encoded ) {\u000a			return decodeURIComponent( encoded );\u000a		} );\u000a	}\u000a\u000a	function protectElementsNames( html ) {\u000a		return html.replace( protectElementNamesRegex, '$1cke:$2' );\u000a	}\u000a\u000a	function unprotectElementNames( html ) {\u000a		return html.replace( unprotectElementNamesRegex, '$1$2' );\u000a	}\u000a\u000a	function protectSelfClosingElements( html ) {\u000a		return html.replace( protectSelfClosingRegex, '<cke:$1$2></cke:$1>' );\u000a	}\u000a\u000a	function protectPreFormatted( html ) {\u000a		return html.replace( /(<pre\u005cb[^>]*>)(\u005cr\u005cn|\u005cn)/g, '$1$2$2' );\u000a	}\u000a\u000a	function protectRealComments( html ) {\u000a		return html.replace( /<!--(?!{cke_protected})[\u005cs\u005cS]+?-->/g, function( match ) {\u000a			return '<!--' + protectedSourceMarker +\u000a				'{C}' +\u000a				encodeURIComponent( match ).replace( /--/g, '%2D%2D' ) +\u000a				'-->';\u000a		} );\u000a	}\u000a\u000a	// Replace all "on\u005cw{3,}" strings which are not:\u000a	// * opening tags - e.g. `<onfoo`,\u000a	// * closing tags - e.g. </onfoo> (tested in "false positive 1"),\u000a	// * part of other attribute - e.g. `data-onfoo` or `fonfoo`.\u000a	function protectInsecureAttributes( html ) {\u000a		return html.replace( /([^a-z0-9<\u005c-])(on\u005cw{3,})(?!>)/gi, '$1data-cke-' + CKEDITOR.rnd + '-$2' );\u000a	}\u000a\u000a	function unprotectRealComments( html ) {\u000a		return html.replace( /<!--\u005c{cke_protected\u005c}\u005c{C\u005c}([\u005cs\u005cS]+?)-->/g, function( match, data ) {\u000a			return decodeURIComponent( data );\u000a		} );\u000a	}\u000a\u000a	function unprotectSource( html, editor ) {\u000a		var store = editor._.dataStore;\u000a\u000a		return html.replace( /<!--\u005c{cke_protected\u005c}([\u005cs\u005cS]+?)-->/g, function( match, data ) {\u000a			return decodeURIComponent( data );\u000a		} ).replace( /\u005c{cke_protected_(\u005cd+)\u005c}/g, function( match, id ) {\u000a			return store && store[ id ] || '';\u000a		} );\u000a	}\u000a\u000a	function protectSource( data, editor ) {\u000a		var protectedHtml = [],\u000a			protectRegexes = editor.config.protectedSource,\u000a			store = editor._.dataStore || ( editor._.dataStore = { id: 1 } ),\u000a			tempRegex = /<\u005c!--\u005c{cke_temp(comment)?\u005c}(\u005cd*?)-->/g;\u000a\u000a		var regexes = [\u000a			// Script tags will also be forced to be protected, otherwise\u000a			// IE will execute them.\u000a			( /<script[\u005cs\u005cS]*?<\u005c/script>/gi ),\u000a\u000a			// <noscript> tags (get lost in IE and messed up in FF).\u000a			/<noscript[\u005cs\u005cS]*?<\u005c/noscript>/gi,\u000a\u000a			// Avoid meta tags being stripped (#8117).\u000a			/<meta[\u005cs\u005cS]*?\u005c/?>/gi\u000a		].concat( protectRegexes );\u000a\u000a		// First of any other protection, we must protect all comments\u000a		// to avoid loosing them (of course, IE related).\u000a		// Note that we use a different tag for comments, as we need to\u000a		// transform them when applying filters.\u000a		data = data.replace( ( /<!--[\u005cs\u005cS]*?-->/g ), function( match ) {\u000a			return '<!--{cke_tempcomment}' + ( protectedHtml.push( match ) - 1 ) + '-->';\u000a		} );\u000a\u000a		for ( var i = 0; i < regexes.length; i++ ) {\u000a			data = data.replace( regexes[ i ], function( match ) {\u000a				match = match.replace( tempRegex, // There could be protected source inside another one. (#3869).\u000a				function( $, isComment, id ) {\u000a					return protectedHtml[ id ];\u000a				} );\u000a\u000a				// Avoid protecting over protected, e.g. /\u005c{.*?\u005c}/\u000a				return ( /cke_temp(comment)?/ ).test( match ) ? match : '<!--{cke_temp}' + ( protectedHtml.push( match ) - 1 ) + '-->';\u000a			} );\u000a		}\u000a		data = data.replace( tempRegex, function( $, isComment, id ) {\u000a			return '<!--' + protectedSourceMarker +\u000a				( isComment ? '{C}' : '' ) +\u000a				encodeURIComponent( protectedHtml[ id ] ).replace( /--/g, '%2D%2D' ) +\u000a				'-->';\u000a		} );\u000a\u000a		// Different protection pattern is used for those that\u000a		// live in attributes to avoid from being HTML encoded.\u000a		// Why so serious? See #9205, #8216, #7805, #11754, #11846.\u000a		data = data.replace( /<\u005cw+(?:\u005cs+(?:(?:[^\u005cs=>]+\u005cs*=\u005cs*(?:[^'"\u005cs>]+|'[^']*'|"[^"]*"))|[^\u005cs=>]+))+\u005cs*>/g, function( match ) {\u000a			return match.replace( /<!--\u005c{cke_protected\u005c}([^>]*)-->/g, function( match, data ) {\u000a				store[ store.id ] = decodeURIComponent( data );\u000a				return '{cke_protected_' + ( store.id++ ) + '}';\u000a			} );\u000a		} );\u000a\u000a		// This RegExp searches for innerText in all the title/iframe/textarea elements.\u000a		// This is because browser doesn't allow HTML in these elements, that's why we can't\u000a		// nest comments in there. (#11223)\u000a		data = data.replace( /<(title|iframe|textarea)([^>]*)>([\u005cs\u005cS]*?)<\u005c/\u005c1>/g, function( match, tagName, tagAttributes, innerText ) {\u000a			return '<' + tagName + tagAttributes + '>' + unprotectSource( unprotectRealComments( innerText ), editor ) + '</' + tagName + '>';\u000a		} );\u000a\u000a		return data;\u000a	}\u000a} )();\u000a\u000a/**\u000a * Whether a filler text (non-breaking space entity &mdash; `&nbsp;`) will be\u000a * inserted into empty block elements in HTML output.\u000a * This is used to render block elements properly with `line-height`.\u000a * When a function is specified instead, it will be passed a {@link CKEDITOR.htmlParser.element}\u000a * to decide whether adding the filler text by expecting a Boolean return value.\u000a *\u000a *		config.fillEmptyBlocks = false; // Prevent filler nodes in all empty blocks.\u000a *\u000a *		// Prevent filler node only in float cleaners.\u000a *		config.fillEmptyBlocks = function( element ) {\u000a *			if ( element.attributes[ 'class' ].indexOf( 'clear-both' ) != -1 )\u000a *				return false;\u000a *		};\u000a *\u000a * @since 3.5\u000a * @cfg {Boolean/Function} [fillEmptyBlocks=true]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * This event is fired by the {@link CKEDITOR.htmlDataProcessor} when input HTML\u000a * is to be purified by the {@link CKEDITOR.htmlDataProcessor#toHtml} method.\u000a *\u000a * By adding listeners with different priorities it is possible\u000a * to process input HTML on different stages:\u000a *\u000a *	* 1-4: Data is available in the original string format.\u000a *	* 5: Data is initially filtered with regexp patterns and parsed to\u000a *		{@link CKEDITOR.htmlParser.fragment} {@link CKEDITOR.htmlParser.element}.\u000a *	* 5-9: Data is available in the parsed format, but {@link CKEDITOR.htmlDataProcessor#dataFilter}\u000a *		is not applied yet.\u000a *	* 6: Data is filtered with the {CKEDITOR.filter content filter}.\u000a *	* 10: Data is processed with {@link CKEDITOR.htmlDataProcessor#dataFilter}.\u000a *	* 10-14: Data is available in the parsed format and {@link CKEDITOR.htmlDataProcessor#dataFilter}\u000a *		has already been applied.\u000a *	* 15: Data is written back to an HTML string.\u000a *	* 15-*: Data is available in an HTML string.\u000a *\u000a * For example to be able to process parsed, but not yet filtered data add listener this way:\u000a *\u000a *		editor.on( 'toHtml', function( evt) {\u000a *			evt.data.dataValue; // -> CKEDITOR.htmlParser.fragment instance\u000a *		}, null, null, 7 );\u000a *\u000a * @since 4.1\u000a * @event toHtml\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param data\u000a * @param {String/CKEDITOR.htmlParser.fragment/CKEDITOR.htmlParser.element} data.dataValue Input data to be purified.\u000a * @param {String} data.context See {@link CKEDITOR.htmlDataProcessor#toHtml} The `context` argument.\u000a * @param {Boolean} data.fixForBody See {@link CKEDITOR.htmlDataProcessor#toHtml} The `fixForBody` argument.\u000a * @param {Boolean} data.dontFilter See {@link CKEDITOR.htmlDataProcessor#toHtml} The `dontFilter` argument.\u000a * @param {Boolean} data.filter See {@link CKEDITOR.htmlDataProcessor#toHtml} The `filter` argument.\u000a * @param {Boolean} data.enterMode See {@link CKEDITOR.htmlDataProcessor#toHtml} The `enterMode` argument.\u000a */\u000a\u000a/**\u000a * This event is fired when {@link CKEDITOR.htmlDataProcessor} is converting\u000a * internal HTML to output data HTML.\u000a *\u000a * By adding listeners with different priorities it is possible\u000a * to process input HTML on different stages:\u000a *\u000a *	* 1-4: Data is available in the original string format.\u000a *	* 5: Data is initially filtered with regexp patterns and parsed to\u000a *		{@link CKEDITOR.htmlParser.fragment} {@link CKEDITOR.htmlParser.element}.\u000a *	* 5-9: Data is available in the parsed format, but {@link CKEDITOR.htmlDataProcessor#htmlFilter}\u000a *		is not applied yet.\u000a *	* 10: Data is filtered with {@link CKEDITOR.htmlDataProcessor#htmlFilter}.\u000a *  * 11: Data is filtered with the {CKEDITOR.filter content filter} (on output the content filter makes\u000a *		only transformations, without filtering).\u000a *	* 10-14: Data is available in the parsed format and {@link CKEDITOR.htmlDataProcessor#htmlFilter}\u000a *		has already been applied.\u000a *	* 15: Data is written back to an HTML string.\u000a *	* 15-*: Data is available in an HTML string.\u000a *\u000a * For example to be able to process parsed and already processed data add listener this way:\u000a *\u000a *		editor.on( 'toDataFormat', function( evt) {\u000a *			evt.data.dataValue; // -> CKEDITOR.htmlParser.fragment instance\u000a *		}, null, null, 12 );\u000a *\u000a * @since 4.1\u000a * @event toDataFormat\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param data\u000a * @param {String/CKEDITOR.htmlParser.fragment/CKEDITOR.htmlParser.element} data.dataValue Output data to be prepared.\u000a * @param {String} data.context See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `context` argument.\u000a * @param {Boolean} data.filter See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `filter` argument.\u000a * @param {Boolean} data.enterMode See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `enterMode` argument.\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Contains the third and last part of the {@link CKEDITOR} object\u000a *		definition.\u000a */\u000a\u000a/** @class CKEDITOR */\u000a\u000a// Remove the CKEDITOR.loadFullCore reference defined on ckeditor_basic.\u000adelete CKEDITOR.loadFullCore;\u000a\u000a/**\u000a * Stores references to all editor instances created. The name of the properties\u000a * in this object correspond to instance names, and their values contain the\u000a * {@link CKEDITOR.editor} object representing them.\u000a *\u000a *		alert( CKEDITOR.instances.editor1.name ); // 'editor1'\u000a *\u000a * @property {Object}\u000a */\u000aCKEDITOR.instances = {};\u000a\u000a/**\u000a * The document of the window storing the CKEDITOR object.\u000a *\u000a *		alert( CKEDITOR.document.getBody().getName() ); // 'body'\u000a *\u000a * @property {CKEDITOR.dom.document}\u000a */\u000aCKEDITOR.document = new CKEDITOR.dom.document( document );\u000a\u000a/**\u000a * Adds an editor instance to the global {@link CKEDITOR} object. This function\u000a * is available for internal use mainly.\u000a *\u000a * @param {CKEDITOR.editor} editor The editor instance to be added.\u000a */\u000aCKEDITOR.add = function( editor ) {\u000a	CKEDITOR.instances[ editor.name ] = editor;\u000a\u000a	editor.on( 'focus', function() {\u000a		if ( CKEDITOR.currentInstance != editor ) {\u000a			CKEDITOR.currentInstance = editor;\u000a			CKEDITOR.fire( 'currentInstance' );\u000a		}\u000a	} );\u000a\u000a	editor.on( 'blur', function() {\u000a		if ( CKEDITOR.currentInstance == editor ) {\u000a			CKEDITOR.currentInstance = null;\u000a			CKEDITOR.fire( 'currentInstance' );\u000a		}\u000a	} );\u000a\u000a	CKEDITOR.fire( 'instance', null, editor );\u000a};\u000a\u000a/**\u000a * Removes an editor instance from the global {@link CKEDITOR} object. This function\u000a * is available for internal use only. External code must use {@link CKEDITOR.editor#method-destroy}.\u000a *\u000a * @private\u000a * @param {CKEDITOR.editor} editor The editor instance to be removed.\u000a */\u000aCKEDITOR.remove = function( editor ) {\u000a	delete CKEDITOR.instances[ editor.name ];\u000a};\u000a\u000a( function() {\u000a	var tpls = {};\u000a\u000a	/**\u000a	 * Adds a named {@link CKEDITOR.template} instance to be reused among all editors.\u000a	 * This will return the existing one if a template with same name is already\u000a	 * defined. Additionally, it fires the "template" event to allow template source customization.\u000a	 *\u000a	 * @param {String} name The name which identifies a UI template.\u000a	 * @param {String} source The source string for constructing this template.\u000a	 * @returns {CKEDITOR.template} The created template instance.\u000a	 */\u000a	CKEDITOR.addTemplate = function( name, source ) {\u000a		var tpl = tpls[ name ];\u000a		if ( tpl )\u000a			return tpl;\u000a\u000a		// Make it possible to customize the template through event.\u000a		var params = { name: name, source: source };\u000a		CKEDITOR.fire( 'template', params );\u000a\u000a		return ( tpls[ name ] = new CKEDITOR.template( params.source ) );\u000a	};\u000a\u000a	/**\u000a	 * Retrieves a defined template created with {@link CKEDITOR#addTemplate}.\u000a	 *\u000a	 * @param {String} name The template name.\u000a	 */\u000a	CKEDITOR.getTemplate = function( name ) {\u000a		return tpls[ name ];\u000a	};\u000a} )();\u000a\u000a( function() {\u000a	var styles = [];\u000a\u000a	/**\u000a	 * Adds CSS rules to be appended to the editor document.\u000a	 * This method is mostly used by plugins to add custom styles to the editor\u000a	 * document. For basic content styling the `contents.css` file should be\u000a	 * used instead.\u000a	 *\u000a	 * **Note:** This function should be called before the creation of editor instances.\u000a	 *\u000a	 *		// Add styles for all headings inside editable contents.\u000a	 *		CKEDITOR.addCss( '.cke_editable h1,.cke_editable h2,.cke_editable h3 { border-bottom: 1px dotted red }' );\u000a	 *\u000a	 * @param {String} css The style rules to be appended.\u000a	 * @see CKEDITOR.config#contentsCss\u000a	 */\u000a	CKEDITOR.addCss = function( css ) {\u000a		styles.push( css );\u000a	};\u000a\u000a	/**\u000a	 * Returns a string will all CSS rules passed to the {@link CKEDITOR#addCss} method.\u000a	 *\u000a	 * @returns {String} A string containing CSS rules.\u000a	 */\u000a	CKEDITOR.getCss = function() {\u000a		return styles.join( '\u005cn' );\u000a	};\u000a} )();\u000a\u000a// Perform global clean up to free as much memory as possible\u000a// when there are no instances left\u000aCKEDITOR.on( 'instanceDestroyed', function() {\u000a	if ( CKEDITOR.tools.isEmpty( this.instances ) )\u000a		CKEDITOR.fire( 'reset' );\u000a} );\u000a\u000a// Load the bootstrap script.\u000a// CKEDITOR.loader.load( '_bootstrap' ); // %REMOVE_LINE%\u000a\u000a// Tri-state constants.\u000a/**\u000a * Used to indicate the ON or ACTIVE state.\u000a *\u000a * @readonly\u000a * @property {Number} [=1]\u000a */\u000aCKEDITOR.TRISTATE_ON = 1;\u000a\u000a/**\u000a * Used to indicate the OFF or INACTIVE state.\u000a *\u000a * @readonly\u000a * @property {Number} [=2]\u000a */\u000aCKEDITOR.TRISTATE_OFF = 2;\u000a\u000a/**\u000a * Used to indicate the DISABLED state.\u000a *\u000a * @readonly\u000a * @property {Number} [=0]\u000a */\u000aCKEDITOR.TRISTATE_DISABLED = 0;\u000a\u000a/**\u000a * The editor which is currently active (has user focus).\u000a *\u000a *		function showCurrentEditorName() {\u000a *			if ( CKEDITOR.currentInstance )\u000a *				alert( CKEDITOR.currentInstance.name );\u000a *			else\u000a *				alert( 'Please focus an editor first.' );\u000a *		}\u000a *\u000a * @property {CKEDITOR.editor} currentInstance\u000a * @see CKEDITOR#event-currentInstance\u000a */\u000a\u000a/**\u000a * Fired when the CKEDITOR.currentInstance object reference changes. This may\u000a * happen when setting the focus on different editor instances in the page.\u000a *\u000a *		var editor; // A variable to store a reference to the current editor.\u000a *		CKEDITOR.on( 'currentInstance', function() {\u000a *			editor = CKEDITOR.currentInstance;\u000a *		} );\u000a *\u000a * @event currentInstance\u000a */\u000a\u000a/**\u000a * Fired when the last instance has been destroyed. This event is used to perform\u000a * global memory cleanup.\u000a *\u000a * @event reset\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	/**\u000a	 * Editable class which provides all editing related activities by\u000a	 * the `contenteditable` element, dynamically get attached to editor instance.\u000a	 *\u000a	 * @class CKEDITOR.editable\u000a	 * @extends CKEDITOR.dom.element\u000a	 */\u000a	CKEDITOR.editable = CKEDITOR.tools.createClass( {\u000a		base: CKEDITOR.dom.element,\u000a		/**\u000a		 * The constructor only stores generic editable creation logic that is commonly shared among\u000a		 * all different editable elements.\u000a		 *\u000a		 * @constructor Creates an editable class instance.\u000a		 * @param {CKEDITOR.editor} editor The editor instance on which the editable operates.\u000a		 * @param {HTMLElement/CKEDITOR.dom.element} element Any DOM element that was as the editor's\u000a		 * editing container, e.g. it could be either an HTML element with the `contenteditable` attribute\u000a		 * set to the `true` that handles WYSIWYG editing or a `<textarea>` element that handles source editing.\u000a		 */\u000a		$: function( editor, element ) {\u000a			// Transform the element into a CKEDITOR.dom.element instance.\u000a			this.base( element.$ || element );\u000a\u000a			this.editor = editor;\u000a\u000a			/**\u000a			 * Indicates the initialization status of the editable element. The following statuses are available:\u000a			 *\u000a			 *	* **unloaded** &ndash; the initial state. The editable's instance was created but\u000a			 *	is not fully loaded (in particular it has no data).\u000a			 *	* **ready** &ndash; the editable is fully initialized. The `ready` status is set after\u000a			 *	the first {@link CKEDITOR.editor#method-setData} is called.\u000a			 *	* **detached** &ndash; the editable was detached.\u000a			 *\u000a			 * @since 4.3.3\u000a			 * @readonly\u000a			 * @property {String}\u000a			 */\u000a			this.status = 'unloaded';\u000a\u000a			/**\u000a			 * Indicates whether the editable element gained focus.\u000a			 *\u000a			 * @property {Boolean} hasFocus\u000a			 */\u000a			this.hasFocus = false;\u000a\u000a			// The bootstrapping logic.\u000a			this.setup();\u000a		},\u000a		proto: {\u000a\u000a			focus: function() {\u000a\u000a				var active;\u000a\u000a				// [Webkit] When DOM focus is inside of nested contenteditable elements,\u000a				// apply focus on the main editable will compromise it's text selection.\u000a				if ( CKEDITOR.env.webkit && !this.hasFocus ) {\u000a					// Restore focus on element which we cached (on selectionCheck) as previously active.\u000a					active = this.editor._.previousActive || this.getDocument().getActive();\u000a					if ( this.contains( active ) ) {\u000a						active.focus();\u000a						return;\u000a					}\u000a				}\u000a\u000a				// [IE] Use instead "setActive" method to focus the editable if it belongs to\u000a				// the host page document, to avoid bringing an unexpected scroll.\u000a				try {\u000a					this.$[ CKEDITOR.env.ie && this.getDocument().equals( CKEDITOR.document ) ? 'setActive' : 'focus' ]();\u000a				} catch ( e ) {\u000a					// IE throws unspecified error when focusing editable after closing dialog opened on nested editable.\u000a					if ( !CKEDITOR.env.ie )\u000a						throw e;\u000a				}\u000a\u000a				// Remedy if Safari doens't applies focus properly. (#279)\u000a				if ( CKEDITOR.env.safari && !this.isInline() ) {\u000a					active = CKEDITOR.document.getActive();\u000a					if ( !active.equals( this.getWindow().getFrame() ) )\u000a						this.getWindow().focus();\u000a\u000a				}\u000a			},\u000a\u000a			/**\u000a			 * Overrides {@link CKEDITOR.dom.element#on} to have special `focus/blur` handling.\u000a			 * The `focusin/focusout` events are used in IE to replace regular `focus/blur` events\u000a			 * because we want to avoid the asynchronous nature of later ones.\u000a			 */\u000a			on: function( name, fn ) {\u000a				var args = Array.prototype.slice.call( arguments, 0 );\u000a\u000a				if ( CKEDITOR.env.ie && ( /^focus|blur$/ ).exec( name ) ) {\u000a					name = name == 'focus' ? 'focusin' : 'focusout';\u000a\u000a					// The "focusin/focusout" events bubbled, e.g. If there are elements with layout\u000a					// they fire this event when clicking in to edit them but it must be ignored\u000a					// to allow edit their contents. (#4682)\u000a					fn = isNotBubbling( fn, this );\u000a					args[ 0 ] = name;\u000a					args[ 1 ] = fn;\u000a				}\u000a\u000a				return CKEDITOR.dom.element.prototype.on.apply( this, args );\u000a			},\u000a\u000a			/**\u000a			 * Registers an event listener that needs to be removed when detaching this editable.\u000a			 * This means that it will be automatically removed when {@link #detach} is executed,\u000a			 * for example on {@link CKEDITOR.editor#setMode changing editor mode} or destroying editor.\u000a			 *\u000a			 * Except for `obj` all other arguments have the same meaning as in {@link CKEDITOR.event#on}.\u000a			 *\u000a			 * This method is strongly related to the {@link CKEDITOR.editor#contentDom} and\u000a			 * {@link CKEDITOR.editor#contentDomUnload} events, because they are fired\u000a			 * when an editable is being attached and detached. Therefore, this method is usually used\u000a			 * in the following way:\u000a			 *\u000a			 *		editor.on( 'contentDom', function() {\u000a			 *			var editable = editor.editable();\u000a			 *			editable.attachListener( editable, 'mousedown', function() {\u000a			 *				// ...\u000a			 *			} );\u000a			 *		} );\u000a			 *\u000a			 * This code will attach the `mousedown` listener every time a new editable is attached\u000a			 * to the editor, which in classic (`iframe`-based) editor happens every time the\u000a			 * data or the mode is set. This listener will also be removed when that editable is detached.\u000a			 *\u000a			 * It is also possible to attach a listener to another object (e.g. to a document).\u000a			 *\u000a			 *		editor.on( 'contentDom', function() {\u000a			 *			editor.editable().attachListener( editor.document, 'mousedown', function() {\u000a			 *				// ...\u000a			 *			} );\u000a			 *		} );\u000a			 *\u000a			 * @param {CKEDITOR.event} obj The element/object to which the listener will be attached. Every object\u000a			 * which inherits from {@link CKEDITOR.event} may be used including {@link CKEDITOR.dom.element},\u000a			 * {@link CKEDITOR.dom.document}, and {@link CKEDITOR.editable}.\u000a			 * @param {String} eventName The name of the event that will be listened to.\u000a			 * @param {Function} listenerFunction The function listening to the\u000a			 * event. A single {@link CKEDITOR.eventInfo} object instance\u000a			 * containing all the event data is passed to this function.\u000a			 * @param {Object} [scopeObj] The object used to scope the listener\u000a			 * call (the `this` object). If omitted, the current object is used.\u000a			 * @param {Object} [listenerData] Data to be sent as the\u000a			 * {@link CKEDITOR.eventInfo#listenerData} when calling the listener.\u000a			 * @param {Number} [priority=10] The listener priority. Lower priority\u000a			 * listeners are called first. Listeners with the same priority\u000a			 * value are called in the registration order.\u000a			 * @returns {Object} An object containing the `removeListener`\u000a			 * function that can be used to remove the listener at any time.\u000a			 */\u000a			attachListener: function( obj /*, event, fn, scope, listenerData, priority*/ ) {\u000a				!this._.listeners && ( this._.listeners = [] );\u000a				// Register the listener.\u000a				var args = Array.prototype.slice.call( arguments, 1 ),\u000a					listener = obj.on.apply( obj, args );\u000a\u000a				this._.listeners.push( listener );\u000a\u000a				return listener;\u000a			},\u000a\u000a			/**\u000a			 * Remove all event listeners registered from {@link #attachListener}.\u000a			 */\u000a			clearListeners: function() {\u000a				var listeners = this._.listeners;\u000a				// Don't get broken by this.\u000a				try {\u000a					while ( listeners.length )\u000a						listeners.pop().removeListener();\u000a				} catch ( e ) {}\u000a			},\u000a\u000a			/**\u000a			 * Restore all attribution changes made by {@link #changeAttr }.\u000a			 */\u000a			restoreAttrs: function() {\u000a				var changes = this._.attrChanges, orgVal;\u000a				for ( var attr in changes ) {\u000a					if ( changes.hasOwnProperty( attr ) ) {\u000a						orgVal = changes[ attr ];\u000a						// Restore original attribute.\u000a						orgVal !== null ? this.setAttribute( attr, orgVal ) : this.removeAttribute( attr );\u000a					}\u000a				}\u000a			},\u000a\u000a			/**\u000a			 * Adds a CSS class name to this editable that needs to be removed on detaching.\u000a			 *\u000a			 * @param {String} className The class name to be added.\u000a			 * @see CKEDITOR.dom.element#addClass\u000a			 */\u000a			attachClass: function( cls ) {\u000a				var classes = this.getCustomData( 'classes' );\u000a				if ( !this.hasClass( cls ) ) {\u000a					!classes && ( classes = [] ), classes.push( cls );\u000a					this.setCustomData( 'classes', classes );\u000a					this.addClass( cls );\u000a				}\u000a			},\u000a\u000a			/**\u000a			 * Make an attribution change that would be reverted on editable detaching.\u000a			 * @param {String} attr The attribute name to be changed.\u000a			 * @param {String} val The value of specified attribute.\u000a			 */\u000a			changeAttr: function( attr, val ) {\u000a				var orgVal = this.getAttribute( attr );\u000a				if ( val !== orgVal ) {\u000a					!this._.attrChanges && ( this._.attrChanges = {} );\u000a\u000a					// Saved the original attribute val.\u000a					if ( !( attr in this._.attrChanges ) )\u000a						this._.attrChanges[ attr ] = orgVal;\u000a\u000a					this.setAttribute( attr, val );\u000a				}\u000a			},\u000a\u000a			/**\u000a			 * @see CKEDITOR.editor#insertHtml\u000a			 */\u000a			insertHtml: function( data, mode ) {\u000a				beforeInsert( this );\u000a				// Default mode is 'html'.\u000a				insert( this, mode || 'html', data );\u000a			},\u000a\u000a			/**\u000a			 * @see CKEDITOR.editor#insertText\u000a			 */\u000a			insertText: function( text ) {\u000a				beforeInsert( this );\u000a\u000a				var editor = this.editor,\u000a					mode = editor.getSelection().getStartElement().hasAscendant( 'pre', true ) ? CKEDITOR.ENTER_BR : editor.activeEnterMode,\u000a					isEnterBrMode = mode == CKEDITOR.ENTER_BR,\u000a					tools = CKEDITOR.tools;\u000a\u000a				// CRLF -> LF\u000a				var html = tools.htmlEncode( text.replace( /\u005cr\u005cn/g, '\u005cn' ) );\u000a\u000a				// Tab -> &nbsp x 4;\u000a				html = html.replace( /\u005ct/g, '&nbsp;&nbsp; &nbsp;' );\u000a\u000a				var paragraphTag = mode == CKEDITOR.ENTER_P ? 'p' : 'div';\u000a\u000a				// Two line-breaks create one paragraphing block.\u000a				if ( !isEnterBrMode ) {\u000a					var duoLF = /\u005cn{2}/g;\u000a					if ( duoLF.test( html ) )\u000a					{\u000a						var openTag = '<' + paragraphTag + '>', endTag = '</' + paragraphTag + '>';\u000a						html = openTag + html.replace( duoLF, function() {\u000a							return endTag + openTag;\u000a						} ) + endTag;\u000a					}\u000a				}\u000a\u000a				// One <br> per line-break.\u000a				html = html.replace( /\u005cn/g, '<br>' );\u000a\u000a				// Compensate padding <br> at the end of block, avoid loosing them during insertion.\u000a				if ( !isEnterBrMode ) {\u000a					html = html.replace( new RegExp( '<br>(?=</' + paragraphTag + '>)' ), function( match ) {\u000a						return tools.repeat( match, 2 );\u000a					} );\u000a				}\u000a\u000a				// Preserve spaces at the ends, so they won't be lost after insertion (merged with adjacent ones).\u000a				html = html.replace( /^ | $/g, '&nbsp;' );\u000a\u000a				// Finally, preserve whitespaces that are to be lost.\u000a				html = html.replace( /(>|\u005cs) /g, function( match, before ) {\u000a					return before + '&nbsp;';\u000a				} ).replace( / (?=<)/g, '&nbsp;' );\u000a\u000a				insert( this, 'text', html );\u000a			},\u000a\u000a			/**\u000a			 * @see CKEDITOR.editor#insertElement\u000a			 */\u000a			insertElement: function( element, range ) {\u000a				if ( !range )\u000a					this.insertElementIntoSelection( element );\u000a				else\u000a					this.insertElementIntoRange( element, range );\u000a			},\u000a\u000a			/**\u000a			 * Inserts an element into the position in the editor determined by range.\u000a			 *\u000a			 * @param {CKEDITOR.dom.element} element The element to be inserted.\u000a			 * @param {CKEDITOR.dom.range} range The range as a place of insertion.\u000a			 * @returns {Boolean} Informs whether insertion was successful.\u000a			 */\u000a			insertElementIntoRange: function( element, range ) {\u000a				var editor = this.editor,\u000a					enterMode = editor.config.enterMode,\u000a					elementName = element.getName(),\u000a					isBlock = CKEDITOR.dtd.$block[ elementName ];\u000a\u000a				if ( range.checkReadOnly() )\u000a					return false;\u000a\u000a				// Remove the original contents, merge split nodes.\u000a				range.deleteContents( 1 );\u000a\u000a				// If range is placed in inermediate element (not td or th), we need to do three things:\u000a				// * fill emptied <td/th>s with if browser needs them,\u000a				// * remove empty text nodes so IE8 won't crash (http://dev.ckeditor.com/ticket/11183#comment:8),\u000a				// * fix structure and move range into the <td/th> element.\u000a				if ( range.startContainer.type == CKEDITOR.NODE_ELEMENT && range.startContainer.is( { tr: 1, table: 1, tbody: 1, thead: 1, tfoot: 1 } ) )\u000a					fixTableAfterContentsDeletion( range );\u000a\u000a				// If we're inserting a block at dtd-violated position, split\u000a				// the parent blocks until we reach blockLimit.\u000a				var current, dtd;\u000a\u000a				if ( isBlock ) {\u000a					while ( ( current = range.getCommonAncestor( 0, 1 ) ) &&\u000a							( dtd = CKEDITOR.dtd[ current.getName() ] ) &&\u000a							!( dtd && dtd[ elementName ] ) ) {\u000a						// Split up inline elements.\u000a						if ( current.getName() in CKEDITOR.dtd.span )\u000a							range.splitElement( current );\u000a\u000a						// If we're in an empty block which indicate a new paragraph,\u000a						// simply replace it with the inserting block.(#3664)\u000a						else if ( range.checkStartOfBlock() && range.checkEndOfBlock() ) {\u000a							range.setStartBefore( current );\u000a							range.collapse( true );\u000a							current.remove();\u000a						} else {\u000a							range.splitBlock( enterMode == CKEDITOR.ENTER_DIV ? 'div' : 'p', editor.editable() );\u000a						}\u000a					}\u000a				}\u000a\u000a				// Insert the new node.\u000a				range.insertNode( element );\u000a\u000a				// Return true if insertion was successful.\u000a				return true;\u000a			},\u000a\u000a			/**\u000a			 * Inserts an element into the currently selected position in the editor.\u000a			 *\u000a			 * @param {CKEDITOR.dom.element} element The element to be inserted.\u000a			 */\u000a			insertElementIntoSelection: function( element ) {\u000a				// Prepare for the insertion. For example - focus editor (#11848).\u000a				beforeInsert( this );\u000a\u000a				var editor = this.editor,\u000a					enterMode = editor.activeEnterMode,\u000a					selection = editor.getSelection(),\u000a					range = selection.getRanges()[ 0 ],\u000a					elementName = element.getName(),\u000a					isBlock = CKEDITOR.dtd.$block[ elementName ];\u000a\u000a				// Insert element into first range only and ignore the rest (#11183).\u000a				if ( this.insertElementIntoRange( element, range ) ) {\u000a					range.moveToPosition( element, CKEDITOR.POSITION_AFTER_END );\u000a\u000a					// If we're inserting a block element, the new cursor position must be\u000a					// optimized. (#3100,#5436,#8950)\u000a					if ( isBlock ) {\u000a						// Find next, meaningful element.\u000a						var next = element.getNext( function( node ) {\u000a							return isNotEmpty( node ) && !isBogus( node );\u000a						} );\u000a\u000a						if ( next && next.type == CKEDITOR.NODE_ELEMENT && next.is( CKEDITOR.dtd.$block ) ) {\u000a							// If the next one is a text block, move cursor to the start of it's content.\u000a							if ( next.getDtd()[ '#' ] )\u000a								range.moveToElementEditStart( next );\u000a							// Otherwise move cursor to the before end of the last element.\u000a							else\u000a								range.moveToElementEditEnd( element );\u000a						}\u000a						// Open a new line if the block is inserted at the end of parent.\u000a						else if ( !next && enterMode != CKEDITOR.ENTER_BR ) {\u000a							next = range.fixBlock( true, enterMode == CKEDITOR.ENTER_DIV ? 'div' : 'p' );\u000a							range.moveToElementEditStart( next );\u000a						}\u000a					}\u000a				}\u000a\u000a				// Set up the correct selection.\u000a				selection.selectRanges( [ range ] );\u000a\u000a				afterInsert( this );\u000a			},\u000a\u000a			/**\u000a			 * @see CKEDITOR.editor#setData\u000a			 */\u000a			setData: function( data, isSnapshot ) {\u000a				if ( !isSnapshot )\u000a					data = this.editor.dataProcessor.toHtml( data );\u000a\u000a				this.setHtml( data );\u000a\u000a				// Editable is ready after first setData.\u000a				if ( this.status == 'unloaded' )\u000a					this.status = 'ready';\u000a\u000a				this.editor.fire( 'dataReady' );\u000a			},\u000a\u000a			/**\u000a			 * @see CKEDITOR.editor#getData\u000a			 */\u000a			getData: function( isSnapshot ) {\u000a				var data = this.getHtml();\u000a\u000a				if ( !isSnapshot )\u000a					data = this.editor.dataProcessor.toDataFormat( data );\u000a\u000a				return data;\u000a			},\u000a\u000a			/**\u000a			 * Change the read-only state on this editable.\u000a			 *\u000a			 * @param {Boolean} isReadOnly\u000a			 */\u000a			setReadOnly: function( isReadOnly ) {\u000a				this.setAttribute( 'contenteditable', !isReadOnly );\u000a			},\u000a\u000a			/**\u000a			 * Detach this editable object from the DOM (remove classes, listeners, etc.)\u000a			 */\u000a			detach: function() {\u000a				// Cleanup the element.\u000a				this.removeClass( 'cke_editable' );\u000a\u000a				this.status = 'detached';\u000a\u000a				// Save the editor reference which will be lost after\u000a				// calling detach from super class.\u000a				var editor = this.editor;\u000a\u000a				this._.detach();\u000a\u000a				delete editor.document;\u000a				delete editor.window;\u000a			},\u000a\u000a			/**\u000a			 * Check if the editable is one of the host page element, indicates the\u000a			 * an inline editing environment.\u000a			 *\u000a			 * @returns {Boolean}\u000a			 */\u000a			isInline: function() {\u000a				return this.getDocument().equals( CKEDITOR.document );\u000a			},\u000a\u000a			/**\u000a			 * Editable element bootstrapping.\u000a			 *\u000a			 * @private\u000a			 */\u000a			setup: function() {\u000a				var editor = this.editor;\u000a\u000a				// Handle the load/read of editor data/snapshot.\u000a				this.attachListener( editor, 'beforeGetData', function() {\u000a					var data = this.getData();\u000a\u000a					// Post processing html output of wysiwyg editable.\u000a					if ( !this.is( 'textarea' ) ) {\u000a						// Reset empty if the document contains only one empty paragraph.\u000a						if ( editor.config.ignoreEmptyParagraph !== false )\u000a							data = data.replace( emptyParagraphRegexp, function( match, lookback ) {\u000a								return lookback;\u000a							} );\u000a					}\u000a\u000a					editor.setData( data, null, 1 );\u000a				}, this );\u000a\u000a				this.attachListener( editor, 'getSnapshot', function( evt ) {\u000a					evt.data = this.getData( 1 );\u000a				}, this );\u000a\u000a				this.attachListener( editor, 'afterSetData', function() {\u000a					this.setData( editor.getData( 1 ) );\u000a				}, this );\u000a				this.attachListener( editor, 'loadSnapshot', function( evt ) {\u000a					this.setData( evt.data, 1 );\u000a				}, this );\u000a\u000a				// Delegate editor focus/blur to editable.\u000a				this.attachListener( editor, 'beforeFocus', function() {\u000a					var sel = editor.getSelection(),\u000a						ieSel = sel && sel.getNative();\u000a\u000a					// IE considers control-type element as separate\u000a					// focus host when selected, avoid destroying the\u000a					// selection in such case. (#5812) (#8949)\u000a					if ( ieSel && ieSel.type == 'Control' )\u000a						return;\u000a\u000a					this.focus();\u000a				}, this );\u000a\u000a				this.attachListener( editor, 'insertHtml', function( evt ) {\u000a					this.insertHtml( evt.data.dataValue, evt.data.mode );\u000a				}, this );\u000a				this.attachListener( editor, 'insertElement', function( evt ) {\u000a					this.insertElement( evt.data );\u000a				}, this );\u000a				this.attachListener( editor, 'insertText', function( evt ) {\u000a					this.insertText( evt.data );\u000a				}, this );\u000a\u000a				// Update editable state.\u000a				this.setReadOnly( editor.readOnly );\u000a\u000a				// The editable class.\u000a				this.attachClass( 'cke_editable' );\u000a\u000a				// The element mode css class.\u000a				this.attachClass( editor.elementMode == CKEDITOR.ELEMENT_MODE_INLINE ?\u000a					'cke_editable_inline' :\u000a					editor.elementMode == CKEDITOR.ELEMENT_MODE_REPLACE ||\u000a					editor.elementMode == CKEDITOR.ELEMENT_MODE_APPENDTO ?\u000a					'cke_editable_themed' : ''\u000a				);\u000a\u000a				this.attachClass( 'cke_contents_' + editor.config.contentsLangDirection );\u000a\u000a				// Setup editor keystroke handlers on this element.\u000a				var keystrokeHandler = editor.keystrokeHandler;\u000a\u000a				// If editor is read-only, then make sure that BACKSPACE key\u000a				// is blocked to prevent browser history navigation.\u000a				keystrokeHandler.blockedKeystrokes[ 8 ] = +editor.readOnly;\u000a\u000a				editor.keystrokeHandler.attach( this );\u000a\u000a				// Update focus states.\u000a				this.on( 'blur', function() {\u000a					this.hasFocus = false;\u000a				}, null, null, -1 );\u000a\u000a				this.on( 'focus', function() {\u000a					this.hasFocus = true;\u000a				}, null, null, -1 );\u000a\u000a				// Register to focus manager.\u000a				editor.focusManager.add( this );\u000a\u000a				// Inherit the initial focus on editable element.\u000a				if ( this.equals( CKEDITOR.document.getActive() ) ) {\u000a					this.hasFocus = true;\u000a					// Pending until this editable has attached.\u000a					editor.once( 'contentDom', function() {\u000a						editor.focusManager.focus( this );\u000a					}, this );\u000a				}\u000a\u000a				// Apply tab index on demand, with original direction saved.\u000a				if ( this.isInline() ) {\u000a\u000a					// tabIndex of the editable is different than editor's one.\u000a					// Update the attribute of the editable.\u000a					this.changeAttr( 'tabindex', editor.tabIndex );\u000a				}\u000a\u000a				// The above is all we'll be doing for a <textarea> editable.\u000a				if ( this.is( 'textarea' ) )\u000a					return;\u000a\u000a				// The DOM document which the editing acts upon.\u000a				editor.document = this.getDocument();\u000a				editor.window = this.getWindow();\u000a\u000a				var doc = editor.document;\u000a\u000a				this.changeAttr( 'spellcheck', !editor.config.disableNativeSpellChecker );\u000a\u000a				// Apply contents direction on demand, with original direction saved.\u000a				var dir = editor.config.contentsLangDirection;\u000a				if ( this.getDirection( 1 ) != dir )\u000a					this.changeAttr( 'dir', dir );\u000a\u000a				// Create the content stylesheet for this document.\u000a				var styles = CKEDITOR.getCss();\u000a				if ( styles ) {\u000a					var head = doc.getHead();\u000a					if ( !head.getCustomData( 'stylesheet' ) ) {\u000a						var sheet = doc.appendStyleText( styles );\u000a						sheet = new CKEDITOR.dom.element( sheet.ownerNode || sheet.owningElement );\u000a						head.setCustomData( 'stylesheet', sheet );\u000a						sheet.data( 'cke-temp', 1 );\u000a					}\u000a				}\u000a\u000a				// Update the stylesheet sharing count.\u000a				var ref = doc.getCustomData( 'stylesheet_ref' ) || 0;\u000a				doc.setCustomData( 'stylesheet_ref', ref + 1 );\u000a\u000a				// Pass this configuration to styles system.\u000a				this.setCustomData( 'cke_includeReadonly', !editor.config.disableReadonlyStyling );\u000a\u000a				// Prevent the browser opening read-only links. (#6032 & #10912)\u000a				this.attachListener( this, 'click', function( evt ) {\u000a					evt = evt.data;\u000a\u000a					var link = new CKEDITOR.dom.elementPath( evt.getTarget(), this ).contains( 'a' );\u000a\u000a					if ( link && evt.$.button != 2 && link.isReadOnly() )\u000a						evt.preventDefault();\u000a				} );\u000a\u000a				var backspaceOrDelete = { 8: 1, 46: 1 };\u000a\u000a				// Override keystrokes which should have deletion behavior\u000a				//  on fully selected element . (#4047) (#7645)\u000a				this.attachListener( editor, 'key', function( evt ) {\u000a					if ( editor.readOnly )\u000a						return true;\u000a\u000a					// Use getKey directly in order to ignore modifiers.\u000a					// Justification: http://dev.ckeditor.com/ticket/11861#comment:13\u000a					var keyCode = evt.data.domEvent.getKey(),\u000a						isHandled;\u000a\u000a					// Backspace OR Delete.\u000a					if ( keyCode in backspaceOrDelete ) {\u000a						var sel = editor.getSelection(),\u000a							selected,\u000a							range = sel.getRanges()[ 0 ],\u000a							path = range.startPath(),\u000a							block,\u000a							parent,\u000a							next,\u000a							rtl = keyCode == 8;\u000a\u000a						if (\u000a								// [IE<11] Remove selected image/anchor/etc here to avoid going back in history. (#10055)\u000a								( CKEDITOR.env.ie && CKEDITOR.env.version < 11 && ( selected = sel.getSelectedElement() ) ) ||\u000a								// Remove the entire list/table on fully selected content. (#7645)\u000a								( selected = getSelectedTableList( sel ) ) ) {\u000a							// Make undo snapshot.\u000a							editor.fire( 'saveSnapshot' );\u000a\u000a							// Delete any element that 'hasLayout' (e.g. hr,table) in IE8 will\u000a							// break up the selection, safely manage it here. (#4795)\u000a							range.moveToPosition( selected, CKEDITOR.POSITION_BEFORE_START );\u000a							// Remove the control manually.\u000a							selected.remove();\u000a							range.select();\u000a\u000a							editor.fire( 'saveSnapshot' );\u000a\u000a							isHandled = 1;\u000a						} else if ( range.collapsed ) {\u000a							// Handle the following special cases: (#6217)\u000a							// 1. Del/Backspace key before/after table;\u000a							// 2. Backspace Key after start of table.\u000a							if ( ( block = path.block ) &&\u000a									( next = block[ rtl ? 'getPrevious' : 'getNext' ]( isNotWhitespace ) ) &&\u000a									( next.type == CKEDITOR.NODE_ELEMENT ) &&\u000a									next.is( 'table' ) &&\u000a									range[ rtl ? 'checkStartOfBlock' : 'checkEndOfBlock' ]() ) {\u000a								editor.fire( 'saveSnapshot' );\u000a\u000a								// Remove the current empty block.\u000a								if ( range[ rtl ? 'checkEndOfBlock' : 'checkStartOfBlock' ]() )\u000a									block.remove();\u000a\u000a								// Move cursor to the beginning/end of table cell.\u000a								range[ 'moveToElementEdit' + ( rtl ? 'End' : 'Start' ) ]( next );\u000a								range.select();\u000a\u000a								editor.fire( 'saveSnapshot' );\u000a\u000a								isHandled = 1;\u000a							}\u000a							else if ( path.blockLimit && path.blockLimit.is( 'td' ) &&\u000a									( parent = path.blockLimit.getAscendant( 'table' ) ) &&\u000a									range.checkBoundaryOfElement( parent, rtl ? CKEDITOR.START : CKEDITOR.END ) &&\u000a									( next = parent[ rtl ? 'getPrevious' : 'getNext' ]( isNotWhitespace ) ) ) {\u000a								editor.fire( 'saveSnapshot' );\u000a\u000a								// Move cursor to the end of previous block.\u000a								range[ 'moveToElementEdit' + ( rtl ? 'End' : 'Start' ) ]( next );\u000a\u000a								// Remove any previous empty block.\u000a								if ( range.checkStartOfBlock() && range.checkEndOfBlock() )\u000a									next.remove();\u000a								else\u000a									range.select();\u000a\u000a								editor.fire( 'saveSnapshot' );\u000a\u000a								isHandled = 1;\u000a							}\u000a							// BACKSPACE/DEL pressed at the start/end of table cell.\u000a							else if ( ( parent = path.contains( [ 'td', 'th', 'caption' ] ) ) &&\u000a									range.checkBoundaryOfElement( parent, rtl ? CKEDITOR.START : CKEDITOR.END ) ) {\u000a								isHandled = 1;\u000a							}\u000a						}\u000a\u000a					}\u000a\u000a					return !isHandled;\u000a				} );\u000a\u000a				// On IE>=11 we need to fill blockless editable with <br> if it was deleted.\u000a				if ( editor.blockless && CKEDITOR.env.ie && CKEDITOR.env.needsBrFiller ) {\u000a					this.attachListener( this, 'keyup', function( evt ) {\u000a						if ( evt.data.getKeystroke() in backspaceOrDelete && !this.getFirst( isNotEmpty ) ) {\u000a							this.appendBogus();\u000a\u000a							// Set the selection before bogus, because IE tends to put it after.\u000a							var range = editor.createRange();\u000a							range.moveToPosition( this, CKEDITOR.POSITION_AFTER_START );\u000a							range.select();\u000a						}\u000a					} );\u000a				}\u000a\u000a				this.attachListener( this, 'dblclick', function( evt ) {\u000a					if ( editor.readOnly )\u000a						return false;\u000a\u000a					var data = { element: evt.data.getTarget() };\u000a					editor.fire( 'doubleclick', data );\u000a				} );\u000a\u000a				// Prevent automatic submission in IE #6336\u000a				CKEDITOR.env.ie && this.attachListener( this, 'click', blockInputClick );\u000a\u000a				// Gecko/Webkit need some help when selecting control type elements. (#3448)\u000a				if ( !CKEDITOR.env.ie ) {\u000a					this.attachListener( this, 'mousedown', function( ev ) {\u000a						var control = ev.data.getTarget();\u000a						// #11727. Note: htmlDP assures that input/textarea/select have contenteditable=false\u000a						// attributes. However, they also have data-cke-editable attribute, so isReadOnly() returns false,\u000a						// and therefore those elements are correctly selected by this code.\u000a						if ( control.is( 'img', 'hr', 'input', 'textarea', 'select' ) && !control.isReadOnly() ) {\u000a							editor.getSelection().selectElement( control );\u000a\u000a							// Prevent focus from stealing from the editable. (#9515)\u000a							if ( control.is( 'input', 'textarea', 'select' ) )\u000a								ev.data.preventDefault();\u000a						}\u000a					} );\u000a				}\u000a\u000a				// Prevent right click from selecting an empty block even\u000a				// when selection is anchored inside it. (#5845)\u000a				if ( CKEDITOR.env.gecko ) {\u000a					this.attachListener( this, 'mouseup', function( ev ) {\u000a						if ( ev.data.$.button == 2 ) {\u000a							var target = ev.data.getTarget();\u000a\u000a							if ( !target.getOuterHtml().replace( emptyParagraphRegexp, '' ) ) {\u000a								var range = editor.createRange();\u000a								range.moveToElementEditStart( target );\u000a								range.select( true );\u000a							}\u000a						}\u000a					} );\u000a				}\u000a\u000a				// Webkit: avoid from editing form control elements content.\u000a				if ( CKEDITOR.env.webkit ) {\u000a					// Prevent from tick checkbox/radiobox/select\u000a					this.attachListener( this, 'click', function( ev ) {\u000a						if ( ev.data.getTarget().is( 'input', 'select' ) )\u000a							ev.data.preventDefault();\u000a					} );\u000a\u000a					// Prevent from editig textfield/textarea value.\u000a					this.attachListener( this, 'mouseup', function( ev ) {\u000a						if ( ev.data.getTarget().is( 'input', 'textarea' ) )\u000a							ev.data.preventDefault();\u000a					} );\u000a				}\u000a\u000a				// Prevent Webkit/Blink from going rogue when joining\u000a				// blocks on BACKSPACE/DEL (#11861,#9998).\u000a				if ( CKEDITOR.env.webkit ) {\u000a					this.attachListener( editor, 'key', function( evt ) {\u000a						// Use getKey directly in order to ignore modifiers.\u000a						// Justification: http://dev.ckeditor.com/ticket/11861#comment:13\u000a						var key = evt.data.domEvent.getKey();\u000a\u000a						if ( !( key in backspaceOrDelete ) )\u000a							return;\u000a\u000a						var backspace = key == 8,\u000a							range = editor.getSelection().getRanges()[ 0 ],\u000a							startPath = range.startPath();\u000a\u000a						if ( range.collapsed ) {\u000a							if ( !mergeBlocksCollapsedSelection( editor, range, backspace, startPath ) )\u000a								return;\u000a						} else {\u000a							if ( !mergeBlocksNonCollapsedSelection( editor, range, startPath ) )\u000a								return;\u000a						}\u000a\u000a						// Scroll to the new position of the caret (#11960).\u000a						editor.getSelection().scrollIntoView();\u000a						editor.fire( 'saveSnapshot' );\u000a\u000a						return false;\u000a					}, this, null, 100 ); // Later is better \u2013 do not override existing listeners.\u000a				}\u000a			}\u000a		},\u000a\u000a		_: {\u000a			detach: function() {\u000a				// Update the editor cached data with current data.\u000a				this.editor.setData( this.editor.getData(), 0, 1 );\u000a\u000a				this.clearListeners();\u000a				this.restoreAttrs();\u000a\u000a				// Cleanup our custom classes.\u000a				var classes;\u000a				if ( ( classes = this.removeCustomData( 'classes' ) ) ) {\u000a					while ( classes.length )\u000a						this.removeClass( classes.pop() );\u000a				}\u000a\u000a				// Remove contents stylesheet from document if it's the last usage.\u000a				if ( !this.is( 'textarea' ) ) {\u000a					var doc = this.getDocument(),\u000a						head = doc.getHead();\u000a					if ( head.getCustomData( 'stylesheet' ) ) {\u000a						var refs = doc.getCustomData( 'stylesheet_ref' );\u000a						if ( !( --refs ) ) {\u000a							doc.removeCustomData( 'stylesheet_ref' );\u000a							var sheet = head.removeCustomData( 'stylesheet' );\u000a							sheet.remove();\u000a						} else {\u000a							doc.setCustomData( 'stylesheet_ref', refs );\u000a						}\u000a					}\u000a				}\u000a\u000a				this.editor.fire( 'contentDomUnload' );\u000a\u000a				// Free up the editor reference.\u000a				delete this.editor;\u000a			}\u000a		}\u000a	} );\u000a\u000a	/**\u000a	 * Create, retrieve or detach an editable element of the editor,\u000a	 * this method should always be used instead of calling directly {@link CKEDITOR.editable}.\u000a	 *\u000a	 * @method editable\u000a	 * @member CKEDITOR.editor\u000a	 * @param {CKEDITOR.dom.element/CKEDITOR.editable} elementOrEditable The\u000a	 * DOM element to become the editable or a {@link CKEDITOR.editable} object.\u000a	 */\u000a	CKEDITOR.editor.prototype.editable = function( element ) {\u000a		var editable = this._.editable;\u000a\u000a		// This editor has already associated with\u000a		// an editable element, silently fails.\u000a		if ( editable && element )\u000a			return 0;\u000a\u000a		if ( arguments.length ) {\u000a			editable = this._.editable = element ? ( element instanceof CKEDITOR.editable ? element : new CKEDITOR.editable( this, element ) ) :\u000a			// Detach the editable from editor.\u000a			( editable && editable.detach(), null );\u000a		}\u000a\u000a		// Just retrieve the editable.\u000a		return editable;\u000a	};\u000a\u000a	// Auto-fixing block-less content by wrapping paragraph (#3190), prevent\u000a	// non-exitable-block by padding extra br.(#3189)\u000a	// Returns truly value when dom was changed, falsy otherwise.\u000a	function fixDom( evt ) {\u000a		var editor = evt.editor,\u000a			path = evt.data.path,\u000a			blockLimit = path.blockLimit,\u000a			selection = evt.data.selection,\u000a			range = selection.getRanges()[ 0 ],\u000a			selectionUpdateNeeded;\u000a\u000a		if ( CKEDITOR.env.gecko || ( CKEDITOR.env.ie && CKEDITOR.env.needsBrFiller ) ) {\u000a			var blockNeedsFiller = needsBrFiller( selection, path );\u000a			if ( blockNeedsFiller ) {\u000a				blockNeedsFiller.appendBogus();\u000a				// IE tends to place selection after appended bogus, so we need to\u000a				// select the original range (placed before bogus).\u000a				selectionUpdateNeeded = CKEDITOR.env.ie;\u000a			}\u000a		}\u000a\u000a		// When we're in block enter mode, a new paragraph will be established\u000a		// to encapsulate inline contents inside editable. (#3657)\u000a		// Don't autoparagraph if browser (namely - IE) incorrectly anchored selection\u000a		// inside non-editable content. This happens e.g. if non-editable block is the only\u000a		// content of editable.\u000a		if ( shouldAutoParagraph( editor, path.block, blockLimit ) && range.collapsed && !range.getCommonAncestor().isReadOnly() ) {\u000a			var testRng = range.clone();\u000a			testRng.enlarge( CKEDITOR.ENLARGE_BLOCK_CONTENTS );\u000a			var walker = new CKEDITOR.dom.walker( testRng );\u000a			walker.guard = function( node ) {\u000a				return !isNotEmpty( node ) ||\u000a					node.type == CKEDITOR.NODE_COMMENT ||\u000a					node.isReadOnly();\u000a			};\u000a\u000a			// 1. Inline content discovered under cursor;\u000a			// 2. Empty editable.\u000a			if ( !walker.checkForward() || testRng.checkStartOfBlock() && testRng.checkEndOfBlock() ) {\u000a				var fixedBlock = range.fixBlock( true, editor.activeEnterMode == CKEDITOR.ENTER_DIV ? 'div' : 'p' );\u000a\u000a				// For IE<11, we should remove any filler node which was introduced before.\u000a				if ( !CKEDITOR.env.needsBrFiller ) {\u000a					var first = fixedBlock.getFirst( isNotEmpty );\u000a					if ( first && isNbsp( first ) )\u000a						first.remove();\u000a				}\u000a\u000a				selectionUpdateNeeded = 1;\u000a\u000a				// Cancel this selection change in favor of the next (correct). (#6811)\u000a				evt.cancel();\u000a			}\u000a		}\u000a\u000a		if ( selectionUpdateNeeded )\u000a			range.select();\u000a	}\u000a\u000a	// Checks whether current selection requires br filler to be appended.\u000a	// @returns Block which needs filler or falsy value.\u000a	function needsBrFiller( selection, path ) {\u000a		// Fake selection does not need filler, because it is fake.\u000a		if ( selection.isFake )\u000a			return 0;\u000a\u000a		// Ensure bogus br could help to move cursor (out of styles) to the end of block. (#7041)\u000a		var pathBlock = path.block || path.blockLimit,\u000a			lastNode = pathBlock && pathBlock.getLast( isNotEmpty );\u000a\u000a		// Check some specialities of the current path block:\u000a		// 1. It is really displayed as block; (#7221)\u000a		// 2. It doesn't end with one inner block; (#7467)\u000a		// 3. It doesn't have bogus br yet.\u000a		if (\u000a			pathBlock && pathBlock.isBlockBoundary() &&\u000a			!( lastNode && lastNode.type == CKEDITOR.NODE_ELEMENT && lastNode.isBlockBoundary() ) &&\u000a			!pathBlock.is( 'pre' ) && !pathBlock.getBogus()\u000a		)\u000a			return pathBlock;\u000a	}\u000a\u000a	function blockInputClick( evt ) {\u000a		var element = evt.data.getTarget();\u000a		if ( element.is( 'input' ) ) {\u000a			var type = element.getAttribute( 'type' );\u000a			if ( type == 'submit' || type == 'reset' )\u000a				evt.data.preventDefault();\u000a		}\u000a	}\u000a\u000a	function isNotEmpty( node ) {\u000a		return isNotWhitespace( node ) && isNotBookmark( node );\u000a	}\u000a\u000a	function isNbsp( node ) {\u000a		return node.type == CKEDITOR.NODE_TEXT && CKEDITOR.tools.trim( node.getText() ).match( /^(?:&nbsp;|\u005cxa0)$/ );\u000a	}\u000a\u000a	function isNotBubbling( fn, src ) {\u000a		return function( evt ) {\u000a			var other = CKEDITOR.dom.element.get( evt.data.$.toElement || evt.data.$.fromElement || evt.data.$.relatedTarget );\u000a			if ( !( other && ( src.equals( other ) || src.contains( other ) ) ) )\u000a				fn.call( this, evt );\u000a		};\u000a	}\u000a\u000a	var isBogus = CKEDITOR.dom.walker.bogus();\u000a\u000a	// Check if the entire table/list contents is selected.\u000a	function getSelectedTableList( sel ) {\u000a		var selected,\u000a			range = sel.getRanges()[ 0 ],\u000a			editable = sel.root,\u000a			path = range.startPath(),\u000a			structural = { table: 1, ul: 1, ol: 1, dl: 1 };\u000a\u000a		if ( path.contains( structural ) ) {\u000a			// Clone the original range.\u000a			var walkerRng = range.clone();\u000a\u000a			// Enlarge the range: X<ul><li>[Y]</li></ul>X => [X<ul><li>]Y</li></ul>X\u000a			walkerRng.collapse( 1 );\u000a			walkerRng.setStartAt( editable, CKEDITOR.POSITION_AFTER_START );\u000a\u000a			// Create a new walker.\u000a			var walker = new CKEDITOR.dom.walker( walkerRng );\u000a\u000a			// Assign a new guard to the walker.\u000a			walker.guard = guard();\u000a\u000a			// Go backwards checking for selected structural node.\u000a			walker.checkBackward();\u000a\u000a			// If there's a selected structured element when checking backwards,\u000a			// then check the same forwards.\u000a			if ( selected ) {\u000a				// Clone the original range.\u000a				walkerRng = range.clone();\u000a\u000a				// Enlarge the range (assuming <ul> is selected element from guard):\u000a				//\u000a				// 	   X<ul><li>[Y]</li></ul>X    =>    X<ul><li>Y[</li></ul>]X\u000a				//\u000a				// If the walker went deeper down DOM than a while ago when traversing\u000a				// backwards, then it doesn't make sense: an element must be selected\u000a				// symmetrically. By placing range end **after previously selected node**,\u000a				// we make sure we don't go no deeper in DOM when going forwards.\u000a				walkerRng.collapse();\u000a				walkerRng.setEndAt( selected, CKEDITOR.POSITION_AFTER_END );\u000a\u000a				// Create a new walker.\u000a				walker = new CKEDITOR.dom.walker( walkerRng );\u000a\u000a				// Assign a new guard to the walker.\u000a				walker.guard = guard( true );\u000a\u000a				// Reset selected node.\u000a				selected = false;\u000a\u000a				// Go forwards checking for selected structural node.\u000a				walker.checkForward();\u000a\u000a				return selected;\u000a			}\u000a		}\u000a\u000a		return null;\u000a\u000a		function guard( forwardGuard ) {\u000a			return function( node, isWalkOut ) {\u000a				// Save the encountered node as selected if going down the DOM structure\u000a				// and the node is structured element.\u000a				if ( isWalkOut && node.type == CKEDITOR.NODE_ELEMENT && node.is( structural ) )\u000a					selected = node;\u000a\u000a				// Stop the walker when either traversing another non-empty node at the same\u000a				// DOM level as in previous step.\u000a				// NOTE: When going forwards, stop if encountered a bogus.\u000a				if ( !isWalkOut && isNotEmpty( node ) && !( forwardGuard && isBogus( node ) ) )\u000a					return false;\u000a			};\u000a		}\u000a	}\u000a\u000a	// Whether in given context (pathBlock, pathBlockLimit and editor settings)\u000a	// editor should automatically wrap inline contents with blocks.\u000a	function shouldAutoParagraph( editor, pathBlock, pathBlockLimit ) {\u000a		// Check whether pathBlock equals pathBlockLimit to support nested editable (#12162).\u000a		return editor.config.autoParagraph !== false &&\u000a			editor.activeEnterMode != CKEDITOR.ENTER_BR &&\u000a			( editor.editable().equals( pathBlockLimit ) && !pathBlock ) || ( pathBlock && pathBlock.getAttribute( 'contenteditable' ) == 'true' );\u000a	}\u000a\u000a	// Matching an empty paragraph at the end of document.\u000a	var emptyParagraphRegexp = /(^|<body\u005cb[^>]*>)\u005cs*<(p|div|address|h\u005cd|center|pre)[^>]*>\u005cs*(?:<br[^>]*>|&nbsp;|\u005cu00A0|&#160;)?\u005cs*(:?<\u005c/\u005c2>)?\u005cs*(?=$|<\u005c/body>)/gi;\u000a\u000a	var isNotWhitespace = CKEDITOR.dom.walker.whitespaces( true ),\u000a		isNotBookmark = CKEDITOR.dom.walker.bookmark( false, true );\u000a\u000a	CKEDITOR.on( 'instanceLoaded', function( evt ) {\u000a		var editor = evt.editor;\u000a\u000a		// and flag that the element was locked by our code so it'll be editable by the editor functions (#6046).\u000a		editor.on( 'insertElement', function( evt ) {\u000a			var element = evt.data;\u000a			if ( element.type == CKEDITOR.NODE_ELEMENT && ( element.is( 'input' ) || element.is( 'textarea' ) ) ) {\u000a				// // The element is still not inserted yet, force attribute-based check.\u000a				if ( element.getAttribute( 'contentEditable' ) != 'false' )\u000a					element.data( 'cke-editable', element.hasAttribute( 'contenteditable' ) ? 'true' : '1' );\u000a				element.setAttribute( 'contentEditable', false );\u000a			}\u000a		} );\u000a\u000a		editor.on( 'selectionChange', function( evt ) {\u000a			if ( editor.readOnly )\u000a				return;\u000a\u000a			// Auto fixing on some document structure weakness to enhance usabilities. (#3190 and #3189)\u000a			var sel = editor.getSelection();\u000a			// Do it only when selection is not locked. (#8222)\u000a			if ( sel && !sel.isLocked ) {\u000a				var isDirty = editor.checkDirty();\u000a\u000a				// Lock undoM before touching DOM to prevent\u000a				// recording these changes as separate snapshot.\u000a				editor.fire( 'lockSnapshot' );\u000a				fixDom( evt );\u000a				editor.fire( 'unlockSnapshot' );\u000a\u000a				!isDirty && editor.resetDirty();\u000a			}\u000a		} );\u000a	} );\u000a\u000a\u000a	CKEDITOR.on( 'instanceCreated', function( evt ) {\u000a		var editor = evt.editor;\u000a\u000a		editor.on( 'mode', function() {\u000a\u000a			var editable = editor.editable();\u000a\u000a			// Setup proper ARIA roles and properties for inline editable, classic\u000a			// (iframe-based) editable is instead handled by plugin.\u000a			if ( editable && editable.isInline() ) {\u000a\u000a				var ariaLabel = editor.title;\u000a\u000a				editable.changeAttr( 'role', 'textbox' );\u000a				editable.changeAttr( 'aria-label', ariaLabel );\u000a\u000a				if ( ariaLabel )\u000a					editable.changeAttr( 'title', ariaLabel );\u000a\u000a				var helpLabel = editor.fire( 'ariaEditorHelpLabel', {} ).label;\u000a				if ( helpLabel ) {\u000a					// Put the voice label in different spaces, depending on element mode, so\u000a					// the DOM element get auto detached on mode reload or editor destroy.\u000a					var ct = this.ui.space( this.elementMode == CKEDITOR.ELEMENT_MODE_INLINE ? 'top' : 'contents' );\u000a					if ( ct ) {\u000a						var ariaDescId = CKEDITOR.tools.getNextId(),\u000a							desc = CKEDITOR.dom.element.createFromHtml( '<span id="' + ariaDescId + '" class="cke_voice_label">' + helpLabel + '</span>' );\u000a						ct.append( desc );\u000a						editable.changeAttr( 'aria-describedby', ariaDescId );\u000a					}\u000a				}\u000a			}\u000a		} );\u000a	} );\u000a\u000a	// #9222: Show text cursor in Gecko.\u000a	// Show default cursor over control elements on all non-IEs.\u000a	CKEDITOR.addCss( '.cke_editable{cursor:text}.cke_editable img,.cke_editable input,.cke_editable textarea{cursor:default}' );\u000a\u000a	//\u000a	// Functions related to insertXXX methods\u000a	//\u000a	var insert = ( function() {\u000a		'use strict';\u000a\u000a		var DTD = CKEDITOR.dtd;\u000a\u000a		// Inserts the given (valid) HTML into the range position (with range content deleted),\u000a		// guarantee it's result to be a valid DOM tree.\u000a		function insert( editable, type, data ) {\u000a			var editor = editable.editor,\u000a				selection = editor.getSelection(),\u000a				// HTML insertion only considers the first range.\u000a				// Note: getRanges will be overwritten for tests since we want to test\u000a				// 		custom ranges and bypass native selections.\u000a				// TODO what should we do with others? Remove?\u000a				range = selection.getRanges()[ 0 ],\u000a				dontFilter = false;\u000a\u000a			if ( type == 'unfiltered_html' ) {\u000a				type = 'html';\u000a				dontFilter = true;\u000a			}\u000a\u000a			// Check range spans in non-editable.\u000a			if ( range.checkReadOnly() )\u000a				return;\u000a\u000a			// RANGE PREPARATIONS\u000a\u000a			var path = new CKEDITOR.dom.elementPath( range.startContainer, range.root ),\u000a				// Let root be the nearest block that's impossible to be split\u000a				// during html processing.\u000a				blockLimit = path.blockLimit || range.root,\u000a				// The "state" value.\u000a				that = {\u000a					type: type,\u000a					dontFilter: dontFilter,\u000a					editable: editable,\u000a					editor: editor,\u000a					range: range,\u000a					blockLimit: blockLimit,\u000a					// During pre-processing / preparations startContainer of affectedRange should be placed\u000a					// in this element in which inserted or moved (in case when we merge blocks) content\u000a					// could create situation that will need merging inline elements.\u000a					// Examples:\u000a					// <div><b>A</b>^B</div> + <b>C</b> => <div><b>A</b><b>C</b>B</div> - affected container is <div>.\u000a					// <p><b>A[B</b></p><p><b>C]D</b></p> + E => <p><b>AE</b></p><p><b>D</b></p> =>\u000a					//		<p><b>AE</b><b>D</b></p> - affected container is <p> (in text mode).\u000a					mergeCandidates: [],\u000a					zombies: []\u000a				};\u000a\u000a			prepareRangeToDataInsertion( that );\u000a\u000a			// DATA PROCESSING\u000a\u000a			// Select range and stop execution.\u000a			// If data has been totally emptied after the filtering,\u000a			// any insertion is pointless (#10339).\u000a			if ( data && processDataForInsertion( that, data ) ) {\u000a				// DATA INSERTION\u000a				insertDataIntoRange( that );\u000a			}\u000a\u000a			// FINAL CLEANUP\u000a			// Set final range position and clean up.\u000a\u000a			cleanupAfterInsertion( that );\u000a\u000a			// Make the final range selection.\u000a			range.select();\u000a\u000a			afterInsert( editable );\u000a		}\u000a\u000a		// Prepare range to its data deletion.\u000a		// Delete its contents.\u000a		// Prepare it to insertion.\u000a		function prepareRangeToDataInsertion( that ) {\u000a			var range = that.range,\u000a				mergeCandidates = that.mergeCandidates,\u000a				node, marker, path, startPath, endPath, previous, bm;\u000a\u000a			// If range starts in inline element then insert a marker, so empty\u000a			// inline elements won't be removed while range.deleteContents\u000a			// and we will be able to move range back into this element.\u000a			// E.g. 'aa<b>[bb</b>]cc' -> (after deleting) 'aa<b><span/></b>cc'\u000a			if ( that.type == 'text' && range.shrink( CKEDITOR.SHRINK_ELEMENT, true, false ) ) {\u000a				marker = CKEDITOR.dom.element.createFromHtml( '<span>&nbsp;</span>', range.document );\u000a				range.insertNode( marker );\u000a				range.setStartAfter( marker );\u000a			}\u000a\u000a			// By using path we can recover in which element was startContainer\u000a			// before deleting contents.\u000a			// Start and endPathElements will be used to squash selected blocks, after removing\u000a			// selection contents. See rule 5.\u000a			startPath = new CKEDITOR.dom.elementPath( range.startContainer );\u000a			that.endPath = endPath = new CKEDITOR.dom.elementPath( range.endContainer );\u000a\u000a			if ( !range.collapsed ) {\u000a				// Anticipate the possibly empty block at the end of range after deletion.\u000a				node = endPath.block || endPath.blockLimit;\u000a				var ancestor = range.getCommonAncestor();\u000a				if ( node && !( node.equals( ancestor ) || node.contains( ancestor ) ) && range.checkEndOfBlock() ) {\u000a					that.zombies.push( node );\u000a				}\u000a\u000a				range.deleteContents();\u000a			}\u000a\u000a			// Rule 4.\u000a			// Move range into the previous block.\u000a			while (\u000a				( previous = getRangePrevious( range ) ) && checkIfElement( previous ) && previous.isBlockBoundary() &&\u000a				// Check if previousNode was parent of range's startContainer before deleteContents.\u000a				startPath.contains( previous )\u000a			)\u000a				range.moveToPosition( previous, CKEDITOR.POSITION_BEFORE_END );\u000a\u000a			// Rule 5.\u000a			mergeAncestorElementsOfSelectionEnds( range, that.blockLimit, startPath, endPath );\u000a\u000a			// Rule 1.\u000a			if ( marker ) {\u000a				// If marker was created then move collapsed range into its place.\u000a				range.setEndBefore( marker );\u000a				range.collapse();\u000a				marker.remove();\u000a			}\u000a\u000a			// Split inline elements so HTML will be inserted with its own styles.\u000a			path = range.startPath();\u000a			if ( ( node = path.contains( isInline, false, 1 ) ) ) {\u000a				range.splitElement( node );\u000a				that.inlineStylesRoot = node;\u000a				that.inlineStylesPeak = path.lastElement;\u000a			}\u000a\u000a			// Record inline merging candidates for later cleanup in place.\u000a			bm = range.createBookmark();\u000a\u000a			// 1. Inline siblings.\u000a			node = bm.startNode.getPrevious( isNotEmpty );\u000a			node && checkIfElement( node ) && isInline( node ) && mergeCandidates.push( node );\u000a			node = bm.startNode.getNext( isNotEmpty );\u000a			node && checkIfElement( node ) && isInline( node ) && mergeCandidates.push( node );\u000a\u000a			// 2. Inline parents.\u000a			node = bm.startNode;\u000a			while ( ( node = node.getParent() ) && isInline( node ) )\u000a				mergeCandidates.push( node );\u000a\u000a			range.moveToBookmark( bm );\u000a		}\u000a\u000a		function processDataForInsertion( that, data ) {\u000a			var range = that.range;\u000a\u000a			// Rule 8. - wrap entire data in inline styles.\u000a			// (e.g. <p><b>x^z</b></p> + <p>a</p><p>b</p> -> <b><p>a</p><p>b</p></b>)\u000a			// Incorrect tags order will be fixed by htmlDataProcessor.\u000a			if ( that.type == 'text' && that.inlineStylesRoot )\u000a				data = wrapDataWithInlineStyles( data, that );\u000a\u000a\u000a			var context = that.blockLimit.getName();\u000a\u000a			// Wrap data to be inserted, to avoid loosing leading whitespaces\u000a			// when going through the below procedure.\u000a			if ( /^\u005cs+|\u005cs+$/.test( data ) && 'span' in CKEDITOR.dtd[ context ] ) {\u000a				var protect = '<span data-cke-marker="1">&nbsp;</span>';\u000a				data =  protect + data + protect;\u000a			}\u000a\u000a			// Process the inserted html, in context of the insertion root.\u000a			// Don't use the "fix for body" feature as auto paragraphing must\u000a			// be handled during insertion.\u000a			data = that.editor.dataProcessor.toHtml( data, {\u000a				context: null,\u000a				fixForBody: false,\u000a				dontFilter: that.dontFilter,\u000a				// Use the current, contextual settings.\u000a				filter: that.editor.activeFilter,\u000a				enterMode: that.editor.activeEnterMode\u000a			} );\u000a\u000a\u000a			// Build the node list for insertion.\u000a			var doc = range.document,\u000a				wrapper = doc.createElement( 'body' );\u000a\u000a			wrapper.setHtml( data );\u000a\u000a			// Eventually remove the temporaries.\u000a			if ( protect ) {\u000a				wrapper.getFirst().remove();\u000a				wrapper.getLast().remove();\u000a			}\u000a\u000a			// Rule 7.\u000a			var block = range.startPath().block;\u000a			if ( block &&													// Apply when there exists path block after deleting selection's content...\u000a				!( block.getChildCount() == 1 && block.getBogus() ) ) {		// ... and the only content of this block isn't a bogus.\u000a				stripBlockTagIfSingleLine( wrapper );\u000a			}\u000a\u000a			that.dataWrapper = wrapper;\u000a\u000a			return data;\u000a		}\u000a\u000a		function insertDataIntoRange( that ) {\u000a			var range = that.range,\u000a				doc = range.document,\u000a				path,\u000a				blockLimit = that.blockLimit,\u000a				nodesData, nodeData, node,\u000a				nodeIndex = 0,\u000a				bogus,\u000a				bogusNeededBlocks = [],\u000a				pathBlock, fixBlock,\u000a				splittingContainer = 0,\u000a				dontMoveCaret = 0,\u000a				insertionContainer, toSplit, newContainer,\u000a				startContainer = range.startContainer,\u000a				endContainer = that.endPath.elements[ 0 ],\u000a				filteredNodes,\u000a				// If endContainer was merged into startContainer: <p>a[b</p><p>c]d</p>\u000a				// or it's equal to startContainer: <p>a^b</p>\u000a				// or different situation happened :P\u000a				// then there's no separate container for the end of selection.\u000a				pos = endContainer.getPosition( startContainer ),\u000a				separateEndContainer = !!endContainer.getCommonAncestor( startContainer ) && // endC is not detached.\u000a					pos != CKEDITOR.POSITION_IDENTICAL && !( pos & CKEDITOR.POSITION_CONTAINS + CKEDITOR.POSITION_IS_CONTAINED ); // endC & endS are in separate branches.\u000a\u000a			nodesData = extractNodesData( that.dataWrapper, that );\u000a\u000a			removeBrsAdjacentToPastedBlocks( nodesData, range );\u000a\u000a			for ( ; nodeIndex < nodesData.length; nodeIndex++ ) {\u000a				nodeData = nodesData[ nodeIndex ];\u000a\u000a				// Ignore trailing <brs>\u000a				if ( nodeData.isLineBreak && splitOnLineBreak( range, blockLimit, nodeData ) ) {\u000a					// Do not move caret towards the text (in cleanupAfterInsertion),\u000a					// because caret was placed after a line break.\u000a					dontMoveCaret = nodeIndex > 0;\u000a					continue;\u000a				}\u000a\u000a				path = range.startPath();\u000a\u000a				// Auto paragraphing.\u000a				if ( !nodeData.isBlock && shouldAutoParagraph( that.editor, path.block, path.blockLimit ) && ( fixBlock = autoParagraphTag( that.editor ) ) ) {\u000a					fixBlock = doc.createElement( fixBlock );\u000a					fixBlock.appendBogus();\u000a					range.insertNode( fixBlock );\u000a					if ( CKEDITOR.env.needsBrFiller && ( bogus = fixBlock.getBogus() ) )\u000a						bogus.remove();\u000a					range.moveToPosition( fixBlock, CKEDITOR.POSITION_BEFORE_END );\u000a				}\u000a\u000a				node = range.startPath().block;\u000a\u000a				// Remove any bogus element on the current path block for now, and mark\u000a				// it for later compensation.\u000a				if ( node && !node.equals( pathBlock ) ) {\u000a					bogus = node.getBogus();\u000a					if ( bogus ) {\u000a						bogus.remove();\u000a						bogusNeededBlocks.push( node );\u000a					}\u000a\u000a					pathBlock = node;\u000a				}\u000a\u000a				// First not allowed node reached - start splitting original container\u000a				if ( nodeData.firstNotAllowed )\u000a					splittingContainer = 1;\u000a\u000a				if ( splittingContainer && nodeData.isElement ) {\u000a					insertionContainer = range.startContainer;\u000a					toSplit = null;\u000a\u000a					// Find the first ancestor that can contain current node.\u000a					// This one won't be split.\u000a					while ( insertionContainer && !DTD[ insertionContainer.getName() ][ nodeData.name ] ) {\u000a						if ( insertionContainer.equals( blockLimit ) ) {\u000a							insertionContainer = null;\u000a							break;\u000a						}\u000a\u000a						toSplit = insertionContainer;\u000a						insertionContainer = insertionContainer.getParent();\u000a					}\u000a\u000a					// If split has to be done - do it and mark both ends as a possible zombies.\u000a					if ( insertionContainer ) {\u000a						if ( toSplit ) {\u000a							newContainer = range.splitElement( toSplit );\u000a							that.zombies.push( newContainer );\u000a							that.zombies.push( toSplit );\u000a						}\u000a					}\u000a					// Unable to make the insertion happen in place, resort to the content filter.\u000a					else {\u000a						// If everything worked fine insertionContainer == blockLimit here.\u000a						filteredNodes = filterElement( nodeData.node, blockLimit.getName(), !nodeIndex, nodeIndex == nodesData.length - 1 );\u000a					}\u000a				}\u000a\u000a				if ( filteredNodes ) {\u000a					while ( ( node = filteredNodes.pop() ) )\u000a						range.insertNode( node );\u000a					filteredNodes = 0;\u000a				} else {\u000a					// Insert current node at the start of range.\u000a					range.insertNode( nodeData.node );\u000a				}\u000a\u000a				// Move range to the endContainer for the final allowed elements.\u000a				if ( nodeData.lastNotAllowed && nodeIndex < nodesData.length - 1 ) {\u000a					// If separateEndContainer exists move range there.\u000a					// Otherwise try to move range to container created during splitting.\u000a					// If this doesn't work - don't move range.\u000a					newContainer = separateEndContainer ? endContainer : newContainer;\u000a					newContainer && range.setEndAt( newContainer, CKEDITOR.POSITION_AFTER_START );\u000a					splittingContainer = 0;\u000a				}\u000a\u000a				// Collapse range after insertion to end.\u000a				range.collapse();\u000a			}\u000a\u000a			that.dontMoveCaret = dontMoveCaret;\u000a			that.bogusNeededBlocks = bogusNeededBlocks;\u000a		}\u000a\u000a		function cleanupAfterInsertion( that ) {\u000a			var range = that.range,\u000a				node, testRange, movedIntoInline,\u000a				bogusNeededBlocks = that.bogusNeededBlocks,\u000a				// Create a bookmark to defend against the following range deconstructing operations.\u000a				bm = range.createBookmark();\u000a\u000a			// Remove all elements that could be created while splitting nodes\u000a			// with ranges at its start|end.\u000a			// E.g. remove <div><p></p></div>\u000a			// But not <div><p> </p></div>\u000a			// And replace <div><p><span data="cke-bookmark"/></p></div> with found bookmark.\u000a			while ( ( node = that.zombies.pop() ) ) {\u000a				// Detached element.\u000a				if ( !node.getParent() )\u000a					continue;\u000a\u000a				testRange = range.clone();\u000a				testRange.moveToElementEditStart( node );\u000a				testRange.removeEmptyBlocksAtEnd();\u000a			}\u000a\u000a			if ( bogusNeededBlocks ) {\u000a				// Bring back all block bogus nodes.\u000a				while ( ( node = bogusNeededBlocks.pop() ) ) {\u000a					if ( CKEDITOR.env.needsBrFiller )\u000a						node.appendBogus();\u000a					else\u000a						node.append( range.document.createText( '\u005cu00a0' ) );\u000a				}\u000a			}\u000a\u000a			// Eventually merge identical inline elements.\u000a			while ( ( node = that.mergeCandidates.pop() ) )\u000a				node.mergeSiblings();\u000a\u000a			range.moveToBookmark( bm );\u000a\u000a			// Rule 3.\u000a			// Shrink range to the BEFOREEND of previous innermost editable node in source order.\u000a\u000a			if ( !that.dontMoveCaret ) {\u000a				node = getRangePrevious( range );\u000a\u000a				while ( node && checkIfElement( node ) && !node.is( DTD.$empty ) ) {\u000a					if ( node.isBlockBoundary() )\u000a						range.moveToPosition( node, CKEDITOR.POSITION_BEFORE_END );\u000a					else {\u000a						// Don't move into inline element (which ends with a text node)\u000a						// found which contains white-space at its end.\u000a						// If not - move range's end to the end of this element.\u000a						if ( isInline( node ) && node.getHtml().match( /(\u005cs|&nbsp;)$/g ) ) {\u000a							movedIntoInline = null;\u000a							break;\u000a						}\u000a\u000a						movedIntoInline = range.clone();\u000a						movedIntoInline.moveToPosition( node, CKEDITOR.POSITION_BEFORE_END );\u000a					}\u000a\u000a					node = node.getLast( isNotEmpty );\u000a				}\u000a\u000a				movedIntoInline && range.moveToRange( movedIntoInline );\u000a			}\u000a\u000a		}\u000a\u000a		//\u000a		// HELPERS ------------------------------------------------------------\u000a		//\u000a\u000a		function autoParagraphTag( editor ) {\u000a			return ( editor.activeEnterMode != CKEDITOR.ENTER_BR && editor.config.autoParagraph !== false ) ? editor.activeEnterMode == CKEDITOR.ENTER_DIV ? 'div' : 'p' : false;\u000a		}\u000a\u000a		function checkIfElement( node ) {\u000a			return node.type == CKEDITOR.NODE_ELEMENT;\u000a		}\u000a\u000a		function extractNodesData( dataWrapper, that ) {\u000a			var node, sibling, nodeName, allowed,\u000a				nodesData = [],\u000a				startContainer = that.range.startContainer,\u000a				path = that.range.startPath(),\u000a				allowedNames = DTD[ startContainer.getName() ],\u000a				nodeIndex = 0,\u000a				nodesList = dataWrapper.getChildren(),\u000a				nodesCount = nodesList.count(),\u000a				firstNotAllowed = -1,\u000a				lastNotAllowed = -1,\u000a				lineBreak = 0,\u000a				blockSibling;\u000a\u000a			// Selection start within a list.\u000a			var insideOfList = path.contains( DTD.$list );\u000a\u000a			for ( ; nodeIndex < nodesCount; ++nodeIndex ) {\u000a				node = nodesList.getItem( nodeIndex );\u000a\u000a				if ( checkIfElement( node ) ) {\u000a					nodeName = node.getName();\u000a\u000a					// Extract only the list items, when insertion happens\u000a					// inside of a list, reads as rearrange list items. (#7957)\u000a					if ( insideOfList && nodeName in CKEDITOR.dtd.$list ) {\u000a						nodesData = nodesData.concat( extractNodesData( node, that ) );\u000a						continue;\u000a					}\u000a\u000a					allowed = !!allowedNames[ nodeName ];\u000a\u000a					// Mark <brs data-cke-eol="1"> at the beginning and at the end.\u000a					if ( nodeName == 'br' && node.data( 'cke-eol' ) && ( !nodeIndex || nodeIndex == nodesCount - 1 ) ) {\u000a						sibling = nodeIndex ? nodesData[ nodeIndex - 1 ].node : nodesList.getItem( nodeIndex + 1 );\u000a\u000a						// Line break has to have sibling which is not an <br>.\u000a						lineBreak = sibling && ( !checkIfElement( sibling ) || !sibling.is( 'br' ) );\u000a						// Line break has block element as a sibling.\u000a						blockSibling = sibling && checkIfElement( sibling ) && DTD.$block[ sibling.getName() ];\u000a					}\u000a\u000a					if ( firstNotAllowed == -1 && !allowed )\u000a						firstNotAllowed = nodeIndex;\u000a					if ( !allowed )\u000a						lastNotAllowed = nodeIndex;\u000a\u000a					nodesData.push( {\u000a						isElement: 1,\u000a						isLineBreak: lineBreak,\u000a						isBlock: node.isBlockBoundary(),\u000a						hasBlockSibling: blockSibling,\u000a						node: node,\u000a						name: nodeName,\u000a						allowed: allowed\u000a					} );\u000a\u000a					lineBreak = 0;\u000a					blockSibling = 0;\u000a				} else {\u000a					nodesData.push( { isElement: 0, node: node, allowed: 1 } );\u000a				}\u000a			}\u000a\u000a			// Mark first node that cannot be inserted directly into startContainer\u000a			// and last node for which startContainer has to be split.\u000a			if ( firstNotAllowed > -1 )\u000a				nodesData[ firstNotAllowed ].firstNotAllowed = 1;\u000a			if ( lastNotAllowed > -1 )\u000a				nodesData[ lastNotAllowed ].lastNotAllowed = 1;\u000a\u000a			return nodesData;\u000a		}\u000a\u000a		// TODO: Review content transformation rules on filtering element.\u000a		function filterElement( element, parentName, isFirst, isLast ) {\u000a			var nodes = filterElementInner( element, parentName ),\u000a				nodes2 = [],\u000a				nodesCount = nodes.length,\u000a				nodeIndex = 0,\u000a				node,\u000a				afterSpace = 0,\u000a				lastSpaceIndex = -1;\u000a\u000a			// Remove duplicated spaces and spaces at the:\u000a			// * beginnig if filtered element isFirst (isFirst that's going to be inserted)\u000a			// * end if filtered element isLast.\u000a			for ( ; nodeIndex < nodesCount; nodeIndex++ ) {\u000a				node = nodes[ nodeIndex ];\u000a\u000a				if ( node == ' ' ) {\u000a					// Don't push doubled space and if it's leading space for insertion.\u000a					if ( !afterSpace && !( isFirst && !nodeIndex ) ) {\u000a						nodes2.push( new CKEDITOR.dom.text( ' ' ) );\u000a						lastSpaceIndex = nodes2.length;\u000a					}\u000a					afterSpace = 1;\u000a				} else {\u000a					nodes2.push( node );\u000a					afterSpace = 0;\u000a				}\u000a			}\u000a\u000a			// Remove trailing space.\u000a			if ( isLast && lastSpaceIndex == nodes2.length )\u000a				nodes2.pop();\u000a\u000a			return nodes2;\u000a		}\u000a\u000a		function filterElementInner( element, parentName ) {\u000a			var nodes = [],\u000a				children = element.getChildren(),\u000a				childrenCount = children.count(),\u000a				child,\u000a				childIndex = 0,\u000a				allowedNames = DTD[ parentName ],\u000a				surroundBySpaces = !element.is( DTD.$inline ) || element.is( 'br' );\u000a\u000a			if ( surroundBySpaces )\u000a				nodes.push( ' ' );\u000a\u000a			for ( ; childIndex < childrenCount; childIndex++ ) {\u000a				child = children.getItem( childIndex );\u000a\u000a				if ( checkIfElement( child ) && !child.is( allowedNames ) )\u000a					nodes = nodes.concat( filterElementInner( child, parentName ) );\u000a				else\u000a					nodes.push( child );\u000a			}\u000a\u000a			if ( surroundBySpaces )\u000a				nodes.push( ' ' );\u000a\u000a			return nodes;\u000a		}\u000a\u000a		function getRangePrevious( range ) {\u000a			return checkIfElement( range.startContainer ) && range.startContainer.getChild( range.startOffset - 1 );\u000a		}\u000a\u000a		function isInline( node ) {\u000a			return node && checkIfElement( node ) && ( node.is( DTD.$removeEmpty ) || node.is( 'a' ) && !node.isBlockBoundary() );\u000a		}\u000a\u000a		var blockMergedTags = { p: 1, div: 1, h1: 1, h2: 1, h3: 1, h4: 1, h5: 1, h6: 1, ul: 1, ol: 1, li: 1, pre: 1, dl: 1, blockquote: 1 };\u000a\u000a		// See rule 5. in TCs.\u000a		// Initial situation:\u000a		// <ul><li>AA^</li></ul><ul><li>BB</li></ul>\u000a		// We're looking for 2nd <ul>, comparing with 1st <ul> and merging.\u000a		// We're not merging if caret is between these elements.\u000a		function mergeAncestorElementsOfSelectionEnds( range, blockLimit, startPath, endPath ) {\u000a			var walkerRange = range.clone(),\u000a				walker, nextNode, previousNode;\u000a\u000a			walkerRange.setEndAt( blockLimit, CKEDITOR.POSITION_BEFORE_END );\u000a			walker = new CKEDITOR.dom.walker( walkerRange );\u000a\u000a			if ( ( nextNode = walker.next() ) &&							// Find next source node\u000a				checkIfElement( nextNode ) &&								// which is an element\u000a				blockMergedTags[ nextNode.getName() ] &&					// that can be merged.\u000a				( previousNode = nextNode.getPrevious() ) &&				// Take previous one\u000a				checkIfElement( previousNode ) &&							// which also has to be an element.\u000a				!previousNode.getParent().equals( range.startContainer ) && // Fail if caret is on the same level.\u000a																			// This means that caret is between these nodes.\u000a				startPath.contains( previousNode ) &&						// Elements path of start of selection has\u000a				endPath.contains( nextNode ) &&								// to contain prevNode and vice versa.\u000a				nextNode.isIdentical( previousNode ) )						// Check if elements are identical.\u000a			{\u000a				// Merge blocks and repeat.\u000a				nextNode.moveChildren( previousNode );\u000a				nextNode.remove();\u000a				mergeAncestorElementsOfSelectionEnds( range, blockLimit, startPath, endPath );\u000a			}\u000a		}\u000a\u000a		// If last node that will be inserted is a block (but not a <br>)\u000a		// and it will be inserted right before <br> remove this <br>.\u000a		// Do the same for the first element that will be inserted and preceding <br>.\u000a		function removeBrsAdjacentToPastedBlocks( nodesData, range ) {\u000a			var succeedingNode = range.endContainer.getChild( range.endOffset ),\u000a				precedingNode = range.endContainer.getChild( range.endOffset - 1 );\u000a\u000a			if ( succeedingNode )\u000a				remove( succeedingNode, nodesData[ nodesData.length - 1 ] );\u000a\u000a			if ( precedingNode && remove( precedingNode, nodesData[ 0 ] ) ) {\u000a				// If preceding <br> was removed - move range left.\u000a				range.setEnd( range.endContainer, range.endOffset - 1 );\u000a				range.collapse();\u000a			}\u000a\u000a			function remove( maybeBr, maybeBlockData ) {\u000a				if ( maybeBlockData.isBlock && maybeBlockData.isElement && !maybeBlockData.node.is( 'br' ) &&\u000a					checkIfElement( maybeBr ) && maybeBr.is( 'br' ) ) {\u000a					maybeBr.remove();\u000a					return 1;\u000a				}\u000a			}\u000a		}\u000a\u000a		// Return 1 if <br> should be skipped when inserting, 0 otherwise.\u000a		function splitOnLineBreak( range, blockLimit, nodeData ) {\u000a			var firstBlockAscendant, pos;\u000a\u000a			if ( nodeData.hasBlockSibling )\u000a				return 1;\u000a\u000a			firstBlockAscendant = range.startContainer.getAscendant( DTD.$block, 1 );\u000a			if ( !firstBlockAscendant || !firstBlockAscendant.is( { div: 1, p: 1 } ) )\u000a				return 0;\u000a\u000a			pos = firstBlockAscendant.getPosition( blockLimit );\u000a\u000a			if ( pos == CKEDITOR.POSITION_IDENTICAL || pos == CKEDITOR.POSITION_CONTAINS )\u000a				return 0;\u000a\u000a			var newContainer = range.splitElement( firstBlockAscendant );\u000a			range.moveToPosition( newContainer, CKEDITOR.POSITION_AFTER_START );\u000a\u000a			return 1;\u000a		}\u000a\u000a		var stripSingleBlockTags = { p: 1, div: 1, h1: 1, h2: 1, h3: 1, h4: 1, h5: 1, h6: 1 },\u000a			inlineButNotBr = CKEDITOR.tools.extend( {}, DTD.$inline );\u000a		delete inlineButNotBr.br;\u000a\u000a		// Rule 7.\u000a		function stripBlockTagIfSingleLine( dataWrapper ) {\u000a			var block, children;\u000a\u000a			if ( dataWrapper.getChildCount() == 1 &&					// Only one node bein inserted.\u000a				checkIfElement( block = dataWrapper.getFirst() ) &&		// And it's an element.\u000a				block.is( stripSingleBlockTags ) )						// That's <p> or <div> or header.\u000a			{\u000a				// Check children not containing block.\u000a				children = block.getElementsByTag( '*' );\u000a				for ( var i = 0, child, count = children.count(); i < count; i++ ) {\u000a					child = children.getItem( i );\u000a					if ( !child.is( inlineButNotBr ) )\u000a						return;\u000a				}\u000a\u000a				block.moveChildren( block.getParent( 1 ) );\u000a				block.remove();\u000a			}\u000a		}\u000a\u000a		function wrapDataWithInlineStyles( data, that ) {\u000a			var element = that.inlineStylesPeak,\u000a				doc = element.getDocument(),\u000a				wrapper = doc.createText( '{cke-peak}' ),\u000a				limit = that.inlineStylesRoot.getParent();\u000a\u000a			while ( !element.equals( limit ) ) {\u000a				wrapper = wrapper.appendTo( element.clone() );\u000a				element = element.getParent();\u000a			}\u000a\u000a			// Don't use String.replace because it fails in IE7 if special replacement\u000a			// characters ($$, $&, etc.) are in data (#10367).\u000a			return wrapper.getOuterHtml().split( '{cke-peak}' ).join( data );\u000a		}\u000a\u000a		return insert;\u000a	} )();\u000a\u000a	function beforeInsert( editable ) {\u000a		// TODO: For unknown reason we must call directly on the editable to put the focus immediately.\u000a		editable.editor.focus();\u000a\u000a		editable.editor.fire( 'saveSnapshot' );\u000a	}\u000a\u000a	function afterInsert( editable ) {\u000a		var editor = editable.editor;\u000a\u000a		// Scroll using selection, not ranges, to affect native pastes.\u000a		editor.getSelection().scrollIntoView();\u000a\u000a		// Save snaps after the whole execution completed.\u000a		// This's a workaround for make DOM modification's happened after\u000a		// 'insertElement' to be included either, e.g. Form-based dialogs' 'commitContents'\u000a		// call.\u000a		setTimeout( function() {\u000a			editor.fire( 'saveSnapshot' );\u000a		}, 0 );\u000a	}\u000a\u000a	// 1. Fixes a range which is a result of deleteContents() and is placed in an intermediate element (see dtd.$intermediate),\u000a	// inside a table. A goal is to find a closest <td> or <th> element and when this fails, recreate the structure of the table.\u000a	// 2. Fixes empty cells by appending bogus <br>s or deleting empty text nodes in IE<=8 case.\u000a	var fixTableAfterContentsDeletion = ( function() {\u000a		// Creates an element walker which can only "go deeper". It won't\u000a		// move out from any element. Therefore it can be used to find <td>x</td> in cases like:\u000a		// <table><tbody><tr><td>x</td></tr></tbody>^<tfoot>...\u000a		function getFixTableSelectionWalker( testRange ) {\u000a			var walker = new CKEDITOR.dom.walker( testRange );\u000a			walker.guard = function( node, isMovingOut ) {\u000a				if ( isMovingOut )\u000a					return false;\u000a				if ( node.type == CKEDITOR.NODE_ELEMENT )\u000a					return node.is( CKEDITOR.dtd.$tableContent );\u000a			};\u000a			walker.evaluator = function( node ) {\u000a				return node.type == CKEDITOR.NODE_ELEMENT;\u000a			};\u000a\u000a			return walker;\u000a		}\u000a\u000a		function fixTableStructure( element, newElementName, appendToStart ) {\u000a			var temp = element.getDocument().createElement( newElementName );\u000a			element.append( temp, appendToStart );\u000a			return temp;\u000a		}\u000a\u000a		// Fix empty cells. This means:\u000a		// * add bogus <br> if browser needs it\u000a		// * remove empty text nodes on IE8, because it will crash (http://dev.ckeditor.com/ticket/11183#comment:8).\u000a		function fixEmptyCells( cells ) {\u000a			var i = cells.count(),\u000a				cell;\u000a\u000a			for ( i; i-- > 0; ) {\u000a				cell = cells.getItem( i );\u000a\u000a				if ( !CKEDITOR.tools.trim( cell.getHtml() ) ) {\u000a					cell.appendBogus();\u000a					if ( CKEDITOR.env.ie && CKEDITOR.env.version < 9 && cell.getChildCount() )\u000a						cell.getFirst().remove();\u000a				}\u000a			}\u000a		}\u000a\u000a		return function( range ) {\u000a			var container = range.startContainer,\u000a				table = container.getAscendant( 'table', 1 ),\u000a				testRange,\u000a				deeperSibling,\u000a				appendToStart = false;\u000a\u000a			fixEmptyCells( table.getElementsByTag( 'td' ) );\u000a			fixEmptyCells( table.getElementsByTag( 'th' ) );\u000a\u000a			// Look left.\u000a			testRange = range.clone();\u000a			testRange.setStart( container, 0 );\u000a			deeperSibling = getFixTableSelectionWalker( testRange ).lastBackward();\u000a\u000a			// If left is empty, look right.\u000a			if ( !deeperSibling ) {\u000a				testRange = range.clone();\u000a				testRange.setEndAt( container, CKEDITOR.POSITION_BEFORE_END );\u000a				deeperSibling = getFixTableSelectionWalker( testRange ).lastForward();\u000a				appendToStart = true;\u000a			}\u000a\u000a			// If there's no deeper nested element in both direction - container is empty - we'll use it then.\u000a			if ( !deeperSibling )\u000a				deeperSibling = container;\u000a\u000a			// Fix structure...\u000a\u000a			// We found a table what means that it's empty - remove it completely.\u000a			if ( deeperSibling.is( 'table' ) ) {\u000a				range.setStartAt( deeperSibling, CKEDITOR.POSITION_BEFORE_START );\u000a				range.collapse( true );\u000a				deeperSibling.remove();\u000a				return;\u000a			}\u000a\u000a			// Found an empty txxx element - append tr.\u000a			if ( deeperSibling.is( { tbody: 1, thead: 1, tfoot: 1 } ) )\u000a				deeperSibling = fixTableStructure( deeperSibling, 'tr', appendToStart );\u000a\u000a			// Found an empty tr element - append td/th.\u000a			if ( deeperSibling.is( 'tr' ) )\u000a				deeperSibling = fixTableStructure( deeperSibling, deeperSibling.getParent().is( 'thead' ) ? 'th' : 'td', appendToStart );\u000a\u000a			// To avoid setting selection after bogus, remove it from the current cell.\u000a			// We can safely do that, because we'll insert element into that cell.\u000a			var bogus = deeperSibling.getBogus();\u000a			if ( bogus )\u000a				bogus.remove();\u000a\u000a			range.moveToPosition( deeperSibling, appendToStart ? CKEDITOR.POSITION_AFTER_START : CKEDITOR.POSITION_BEFORE_END );\u000a		};\u000a	} )();\u000a\u000a	function mergeBlocksCollapsedSelection( editor, range, backspace, startPath ) {\u000a		var startBlock = startPath.block;\u000a\u000a		// Selection must be collapsed and to be anchored in a block.\u000a		if ( !startBlock )\u000a			return false;\u000a\u000a		// Exclude cases where, i.e. if pressed arrow key, selection\u000a		// would move within the same block (merge inside a block).\u000a		if ( !range[ backspace ? 'checkStartOfBlock' : 'checkEndOfBlock' ]() )\u000a			return false;\u000a\u000a		// Make sure, there's an editable position to put selection,\u000a		// which i.e. would be used if pressed arrow key, but abort\u000a		// if such position exists but means a selected non-editable element.\u000a		if ( !range.moveToClosestEditablePosition( startBlock, !backspace ) || !range.collapsed )\u000a			return false;\u000a\u000a		// Handle special case, when block's sibling is a <hr>. Delete it and keep selection\u000a		// in the same place (http://dev.ckeditor.com/ticket/11861#comment:9).\u000a		if ( range.startContainer.type == CKEDITOR.NODE_ELEMENT ) {\u000a			var touched = range.startContainer.getChild( range.startOffset - ( backspace ? 1 : 0 ) );\u000a			if ( touched && touched.type  == CKEDITOR.NODE_ELEMENT && touched.is( 'hr' ) ) {\u000a				editor.fire( 'saveSnapshot' );\u000a				touched.remove();\u000a				return true;\u000a			}\u000a		}\u000a\u000a		var siblingBlock = range.startPath().block;\u000a\u000a		// Abort if an editable position exists, but either it's not\u000a		// in a block or that block is the parent of the start block\u000a		// (merging child into parent).\u000a		if ( !siblingBlock || ( siblingBlock && siblingBlock.contains( startBlock ) ) )\u000a			return;\u000a\u000a		editor.fire( 'saveSnapshot' );\u000a\u000a		// Remove bogus to avoid duplicated boguses.\u000a		var bogus;\u000a		if ( ( bogus = ( backspace ? siblingBlock : startBlock ).getBogus() ) )\u000a			bogus.remove();\u000a\u000a		// Save selection. It will be restored.\u000a		var selection = editor.getSelection(),\u000a			bookmarks = selection.createBookmarks();\u000a\u000a		// Merge blocks.\u000a		( backspace ? startBlock : siblingBlock ).moveChildren( backspace ? siblingBlock : startBlock, false );\u000a\u000a		// Also merge children along with parents.\u000a		startPath.lastElement.mergeSiblings();\u000a\u000a		// Cut off removable branch of the DOM tree.\u000a		pruneEmptyDisjointAncestors( startBlock, siblingBlock, !backspace );\u000a\u000a		// Restore selection.\u000a		selection.selectBookmarks( bookmarks );\u000a\u000a		return true;\u000a	}\u000a\u000a	function mergeBlocksNonCollapsedSelection( editor, range, startPath ) {\u000a		var startBlock = startPath.block,\u000a			endPath = range.endPath(),\u000a			endBlock = endPath.block;\u000a\u000a		// Selection must be anchored in two different blocks.\u000a		if ( !startBlock || !endBlock || startBlock.equals( endBlock ) )\u000a			return false;\u000a\u000a		editor.fire( 'saveSnapshot' );\u000a\u000a		// Remove bogus to avoid duplicated boguses.\u000a		var bogus;\u000a		if ( ( bogus = startBlock.getBogus() ) )\u000a			bogus.remove();\u000a\u000a		// Delete range contents. Do NOT merge. Merging is weird.\u000a		range.deleteContents();\u000a\u000a		// If something has left of the block to be merged, clean it up.\u000a		// It may happen when merging with list items.\u000a		if ( endBlock.getParent() ) {\u000a			// Move children to the first block.\u000a			endBlock.moveChildren( startBlock, false );\u000a\u000a			// ...and merge them if that's possible.\u000a			startPath.lastElement.mergeSiblings();\u000a\u000a			// If expanded selection, things are always merged like with BACKSPACE.\u000a			pruneEmptyDisjointAncestors( startBlock, endBlock, true );\u000a		}\u000a\u000a		// Make sure the result selection is collapsed.\u000a		range = editor.getSelection().getRanges()[ 0 ];\u000a		range.collapse( 1 );\u000a		range.select();\u000a\u000a		return true;\u000a	}\u000a\u000a	// Finds the innermost child of common parent, which,\u000a	// if removed, removes nothing but the contents of the element.\u000a	//\u000a	//	before: <div><p><strong>first</strong></p><p>second</p></div>\u000a	//	after:  <div><p>second</p></div>\u000a	//\u000a	//	before: <div><p>x<strong>first</strong></p><p>second</p></div>\u000a	//	after:  <div><p>x</p><p>second</p></div>\u000a	//\u000a	//	isPruneToEnd=true\u000a	//	before: <div><p><strong>first</strong></p><p>second</p></div>\u000a	//	after:  <div><p><strong>first</strong></p></div>\u000a	//\u000a	// @param {CKEDITOR.dom.element} first\u000a	// @param {CKEDITOR.dom.element} second\u000a	// @param {Boolean} isPruneToEnd\u000a	function pruneEmptyDisjointAncestors( first, second, isPruneToEnd ) {\u000a		var commonParent = first.getCommonAncestor( second ),\u000a			node = isPruneToEnd ? second : first,\u000a			removableParent = node;\u000a\u000a		while ( ( node = node.getParent() ) && !commonParent.equals( node ) && node.getChildCount() == 1 )\u000a			removableParent = node;\u000a\u000a		removableParent.remove();\u000a	}\u000a\u000a} )();\u000a\u000a/**\u000a * Whether the editor must output an empty value (`''`) if its content only consists\u000a * of an empty paragraph.\u000a *\u000a *		config.ignoreEmptyParagraph = false;\u000a *\u000a * @cfg {Boolean} [ignoreEmptyParagraph=true]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * Event fired by the editor in order to get accessibility help label.\u000a * The event is responded to by a component which provides accessibility\u000a * help (i.e. the `a11yhelp` plugin) hence the editor is notified whether\u000a * accessibility help is available.\u000a *\u000a * Providing info:\u000a *\u000a *		editor.on( 'ariaEditorHelpLabel', function( evt ) {\u000a *				evt.data.label = editor.lang.common.editorHelp;\u000a *		} );\u000a *\u000a * Getting label:\u000a *\u000a *		var helpLabel = editor.fire( 'ariaEditorHelpLabel', {} ).label;\u000a *\u000a * @since 4.4.3\u000a * @event ariaEditorHelpLabel\u000a * @param {String} label The label to be used.\u000a * @member CKEDITOR.editor\u000a */\u000a\u000a/**\u000a * Event fired when the user double-clicks in the editable area.\u000a * The event allows to open a dialog window for a clicked element in a convenient way:\u000a *\u000a *		editor.on( 'doubleclick', function( evt ) {\u000a *			var element = evt.data.element;\u000a *\u000a *			if ( element.is( 'table' ) )\u000a *				evt.data.dialog = 'tableProperties';\u000a *		} );\u000a *\u000a * **Note:** To handle double-click on a widget use {@link CKEDITOR.plugins.widget#doubleclick}.\u000a *\u000a * @event doubleclick\u000a * @param data\u000a * @param {CKEDITOR.dom.element} data.element The double-clicked element.\u000a * @param {String} data.dialog The dialog window to be opened. If set by the listener,\u000a * the specified dialog window will be opened.\u000a * @member CKEDITOR.editor\u000a */\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	// #### checkSelectionChange : START\u000a\u000a	// The selection change check basically saves the element parent tree of\u000a	// the current node and check it on successive requests. If there is any\u000a	// change on the tree, then the selectionChange event gets fired.\u000a	function checkSelectionChange() {\u000a		// A possibly available fake-selection.\u000a		var sel = this._.fakeSelection,\u000a			realSel;\u000a\u000a		if ( sel ) {\u000a			realSel = this.getSelection( 1 );\u000a\u000a			// If real (not locked/stored) selection was moved from hidden container,\u000a			// then the fake-selection must be invalidated.\u000a			if ( !realSel || !realSel.isHidden() ) {\u000a				// Remove the cache from fake-selection references in use elsewhere.\u000a				sel.reset();\u000a\u000a				// Have the code using the native selection.\u000a				sel = 0;\u000a			}\u000a		}\u000a\u000a		// If not fake-selection is available then get the native selection.\u000a		if ( !sel ) {\u000a			sel = realSel || this.getSelection( 1 );\u000a\u000a			// Editor may have no selection at all.\u000a			if ( !sel || sel.getType() == CKEDITOR.SELECTION_NONE )\u000a				return;\u000a		}\u000a\u000a		this.fire( 'selectionCheck', sel );\u000a\u000a		var currentPath = this.elementPath();\u000a		if ( !currentPath.compare( this._.selectionPreviousPath ) ) {\u000a			// Cache the active element, which we'll eventually lose on Webkit.\u000a			if ( CKEDITOR.env.webkit )\u000a				this._.previousActive = this.document.getActive();\u000a\u000a			this._.selectionPreviousPath = currentPath;\u000a			this.fire( 'selectionChange', { selection: sel, path: currentPath } );\u000a		}\u000a	}\u000a\u000a	var checkSelectionChangeTimer, checkSelectionChangeTimeoutPending;\u000a\u000a	function checkSelectionChangeTimeout() {\u000a		// Firing the "OnSelectionChange" event on every key press started to\u000a		// be too slow. This function guarantees that there will be at least\u000a		// 200ms delay between selection checks.\u000a\u000a		checkSelectionChangeTimeoutPending = true;\u000a\u000a		if ( checkSelectionChangeTimer )\u000a			return;\u000a\u000a		checkSelectionChangeTimeoutExec.call( this );\u000a\u000a		checkSelectionChangeTimer = CKEDITOR.tools.setTimeout( checkSelectionChangeTimeoutExec, 200, this );\u000a	}\u000a\u000a	function checkSelectionChangeTimeoutExec() {\u000a		checkSelectionChangeTimer = null;\u000a\u000a		if ( checkSelectionChangeTimeoutPending ) {\u000a			// Call this with a timeout so the browser properly moves the\u000a			// selection after the mouseup. It happened that the selection was\u000a			// being moved after the mouseup when clicking inside selected text\u000a			// with Firefox.\u000a			CKEDITOR.tools.setTimeout( checkSelectionChange, 0, this );\u000a\u000a			checkSelectionChangeTimeoutPending = false;\u000a		}\u000a	}\u000a\u000a	// #### checkSelectionChange : END\u000a\u000a	var isVisible = CKEDITOR.dom.walker.invisible( 1 );\u000a	function rangeRequiresFix( range ) {\u000a		function isTextCt( node, isAtEnd ) {\u000a			if ( !node || node.type == CKEDITOR.NODE_TEXT )\u000a				return false;\u000a\u000a			var testRng = range.clone();\u000a			return testRng[ 'moveToElementEdit' + ( isAtEnd ? 'End' : 'Start' ) ]( node );\u000a		}\u000a\u000a		// Range root must be the editable element, it's to avoid creating filler char\u000a		// on any temporary internal selection.\u000a		if ( !( range.root instanceof CKEDITOR.editable ) )\u000a			return false;\u000a\u000a		var ct = range.startContainer;\u000a\u000a		var previous = range.getPreviousNode( isVisible, null, ct ),\u000a			next = range.getNextNode( isVisible, null, ct );\u000a\u000a		// Any adjacent text container may absorb the cursor, e.g.\u000a		// <p><strong>text</strong>^foo</p>\u000a		// <p>foo^<strong>text</strong></p>\u000a		// <div>^<p>foo</p></div>\u000a		if ( isTextCt( previous ) || isTextCt( next, 1 ) )\u000a			return true;\u000a\u000a		// Empty block/inline element is also affected. <span>^</span>, <p>^</p> (#7222)\u000a		if ( !( previous || next ) && !( ct.type == CKEDITOR.NODE_ELEMENT && ct.isBlockBoundary() && ct.getBogus() ) )\u000a			return true;\u000a\u000a		return false;\u000a	}\u000a\u000a	function createFillingChar( element ) {\u000a		removeFillingChar( element, false );\u000a\u000a		var fillingChar = element.getDocument().createText( '\u005cu200B' );\u000a		element.setCustomData( 'cke-fillingChar', fillingChar );\u000a\u000a		return fillingChar;\u000a	}\u000a\u000a	function getFillingChar( element ) {\u000a		return element.getCustomData( 'cke-fillingChar' );\u000a	}\u000a\u000a	// Checks if a filling char has been used, eventualy removing it (#1272).\u000a	function checkFillingChar( element ) {\u000a		var fillingChar = getFillingChar( element );\u000a		if ( fillingChar ) {\u000a			// Use this flag to avoid removing the filling char right after\u000a			// creating it.\u000a			if ( fillingChar.getCustomData( 'ready' ) )\u000a				removeFillingChar( element );\u000a			else\u000a				fillingChar.setCustomData( 'ready', 1 );\u000a		}\u000a	}\u000a\u000a	function removeFillingChar( element, keepSelection ) {\u000a		var fillingChar = element && element.removeCustomData( 'cke-fillingChar' );\u000a		if ( fillingChar ) {\u000a\u000a			// Text selection position might get mangled by\u000a			// subsequent dom modification, save it now for restoring. (#8617)\u000a			if ( keepSelection !== false ) {\u000a				var bm,\u000a					sel = element.getDocument().getSelection().getNative(),\u000a					// Be error proof.\u000a					range = sel && sel.type != 'None' && sel.getRangeAt( 0 );\u000a\u000a				if ( fillingChar.getLength() > 1 && range && range.intersectsNode( fillingChar.$ ) ) {\u000a					bm = createNativeSelectionBookmark( sel );\u000a\u000a					// Anticipate the offset change brought by the removed char.\u000a					var startAffected = sel.anchorNode == fillingChar.$ && sel.anchorOffset > 0,\u000a						endAffected = sel.focusNode == fillingChar.$ && sel.focusOffset > 0;\u000a					startAffected && bm[ 0 ].offset--;\u000a					endAffected && bm[ 1 ].offset--;\u000a				}\u000a			}\u000a\u000a			// We can't simply remove the filling node because the user\u000a			// will actually enlarge it when typing, so we just remove the\u000a			// invisible char from it.\u000a			fillingChar.setText( replaceFillingChar( fillingChar.getText() ) );\u000a\u000a			// Restore the bookmark preserving selection's direction.\u000a			if ( bm ) {\u000a				moveNativeSelectionToBookmark( element.getDocument().$, bm );\u000a			}\u000a		}\u000a	}\u000a\u000a	function replaceFillingChar( html ) {\u000a		return html.replace( /\u005cu200B( )?/g, function( match ) {\u000a			// #10291 if filling char is followed by a space replace it with nbsp.\u000a			return match[ 1 ] ? '\u005cxa0' : '';\u000a		} );\u000a	}\u000a\u000a	function createNativeSelectionBookmark( sel ) {\u000a		return [\u000a			{ node: sel.anchorNode, offset: sel.anchorOffset },\u000a			{ node: sel.focusNode, offset: sel.focusOffset }\u000a		];\u000a	}\u000a\u000a	function moveNativeSelectionToBookmark( document, bm ) {\u000a		var sel = document.getSelection(),\u000a			range = document.createRange();\u000a\u000a		range.setStart( bm[ 0 ].node, bm[ 0 ].offset );\u000a		range.collapse( true );\u000a		sel.removeAllRanges();\u000a		sel.addRange( range );\u000a		sel.extend( bm[ 1 ].node, bm[ 1 ].offset );\u000a	}\u000a\u000a	// Read the comments in selection constructor.\u000a	function fixInitialSelection( root, nativeSel, doFocus ) {\u000a		// It may happen that setting proper selection will\u000a		// cause focus to be fired (even without actually focusing root).\u000a		// Cancel it because focus shouldn't be fired when retriving selection. (#10115)\u000a		var listener = root.on( 'focus', function( evt ) {\u000a			evt.cancel();\u000a		}, null, null, -100 );\u000a\u000a		// FF && Webkit.\u000a		if ( !CKEDITOR.env.ie ) {\u000a			var range = new CKEDITOR.dom.range( root );\u000a			range.moveToElementEditStart( root );\u000a\u000a			var nativeRange = root.getDocument().$.createRange();\u000a			nativeRange.setStart( range.startContainer.$, range.startOffset );\u000a			nativeRange.collapse( 1 );\u000a\u000a			nativeSel.removeAllRanges();\u000a			nativeSel.addRange( nativeRange );\u000a		}\u000a		else {\u000a			// IE in specific case may also fire selectionchange.\u000a			// We cannot block bubbling selectionchange, so at least we\u000a			// can prevent from falling into inf recursion caused by fix for #9699\u000a			// (see wysiwygarea plugin).\u000a			// http://dev.ckeditor.com/ticket/10438#comment:13\u000a			var listener2 = root.getDocument().on( 'selectionchange', function( evt ) {\u000a				evt.cancel();\u000a			}, null, null, -100 );\u000a		}\u000a\u000a		doFocus && root.focus();\u000a\u000a		listener.removeListener();\u000a		listener2 && listener2.removeListener();\u000a	}\u000a\u000a	// Creates cke_hidden_sel container and puts real selection there.\u000a	function hideSelection( editor ) {\u000a		var style = CKEDITOR.env.ie ? 'display:none' : 'position:fixed;top:0;left:-1000px',\u000a			hiddenEl = CKEDITOR.dom.element.createFromHtml(\u000a				'<div data-cke-hidden-sel="1" data-cke-temp="1" style="' + style + '">&nbsp;</div>',\u000a				editor.document );\u000a\u000a		editor.fire( 'lockSnapshot' );\u000a\u000a		editor.editable().append( hiddenEl );\u000a\u000a			// Always use real selection to avoid overriding locked one (http://dev.ckeditor.com/ticket/11104#comment:13).\u000a		var sel = editor.getSelection( 1 ),\u000a			range = editor.createRange(),\u000a			// Cancel selectionchange fired by selectRanges - prevent from firing selectionChange.\u000a			listener = sel.root.on( 'selectionchange', function( evt ) {\u000a				evt.cancel();\u000a			}, null, null, 0 );\u000a\u000a		range.setStartAt( hiddenEl, CKEDITOR.POSITION_AFTER_START );\u000a		range.setEndAt( hiddenEl, CKEDITOR.POSITION_BEFORE_END );\u000a		sel.selectRanges( [ range ] );\u000a\u000a		listener.removeListener();\u000a\u000a		editor.fire( 'unlockSnapshot' );\u000a\u000a		// Set this value at the end, so reset() executed by selectRanges()\u000a		// will clean up old hidden selection container.\u000a		editor._.hiddenSelectionContainer = hiddenEl;\u000a	}\u000a\u000a	function removeHiddenSelectionContainer( editor ) {\u000a		var hiddenEl = editor._.hiddenSelectionContainer;\u000a\u000a		if ( hiddenEl ) {\u000a			var isDirty = editor.checkDirty();\u000a\u000a			editor.fire( 'lockSnapshot' );\u000a			hiddenEl.remove();\u000a			editor.fire( 'unlockSnapshot' );\u000a\u000a			!isDirty && editor.resetDirty();\u000a		}\u000a\u000a		delete editor._.hiddenSelectionContainer;\u000a	}\u000a\u000a	// Object containing keystroke handlers for fake selection.\u000a	var fakeSelectionDefaultKeystrokeHandlers = ( function() {\u000a		function leave( right ) {\u000a			return function( evt ) {\u000a				var range = evt.editor.createRange();\u000a\u000a				// Move selection only if there's a editable place for it.\u000a				// It no, then do nothing (keystroke will be blocked, widget selection kept).\u000a				if ( range.moveToClosestEditablePosition( evt.selected, right ) )\u000a					evt.editor.getSelection().selectRanges( [ range ] );\u000a\u000a				// Prevent default.\u000a				return false;\u000a			};\u000a		}\u000a\u000a		function del( right ) {\u000a			return function( evt ) {\u000a				var editor = evt.editor,\u000a					range = editor.createRange(),\u000a					found;\u000a\u000a				// If haven't found place for caret on the default side,\u000a				// try to find it on the other side.\u000a				if ( !( found = range.moveToClosestEditablePosition( evt.selected, right ) ) )\u000a					found = range.moveToClosestEditablePosition( evt.selected, !right );\u000a\u000a				if ( found )\u000a					editor.getSelection().selectRanges( [ range ] );\u000a\u000a				// Save the state before removing selected element.\u000a				editor.fire( 'saveSnapshot' );\u000a\u000a				evt.selected.remove();\u000a\u000a				// Haven't found any editable space before removing element,\u000a				// try to place the caret anywhere (most likely, in empty editable).\u000a				if ( !found ) {\u000a					range.moveToElementEditablePosition( editor.editable() );\u000a					editor.getSelection().selectRanges( [ range ] );\u000a				}\u000a\u000a				editor.fire( 'saveSnapshot' );\u000a\u000a				// Prevent default.\u000a				return false;\u000a			};\u000a		}\u000a\u000a		var leaveLeft = leave(),\u000a			leaveRight = leave( 1 );\u000a\u000a		return {\u000a			37: leaveLeft,		// LEFT\u000a			38: leaveLeft,		// UP\u000a			39: leaveRight,		// RIGHT\u000a			40: leaveRight,		// DOWN\u000a			8: del(),			// BACKSPACE\u000a			46: del( 1 )		// DELETE\u000a		};\u000a	} )();\u000a\u000a	// Handle left, right, delete and backspace keystrokes next to non-editable elements\u000a	// by faking selection on them.\u000a	function getOnKeyDownListener( editor ) {\u000a		var keystrokes = { 37: 1, 39: 1, 8: 1, 46: 1 };\u000a\u000a		return function( evt ) {\u000a			var keystroke = evt.data.getKeystroke();\u000a\u000a			// Handle only left/right/del/bspace keys.\u000a			if ( !keystrokes[ keystroke ] )\u000a				return;\u000a\u000a			var sel = editor.getSelection(),\u000a				ranges = sel.getRanges(),\u000a				range = ranges[ 0 ];\u000a\u000a			// Handle only single range and it has to be collapsed.\u000a			if ( ranges.length != 1 || !range.collapsed )\u000a				return;\u000a\u000a			var next = range[ keystroke < 38 ? 'getPreviousEditableNode' : 'getNextEditableNode' ]();\u000a\u000a			if ( next && next.type == CKEDITOR.NODE_ELEMENT && next.getAttribute( 'contenteditable' ) == 'false' ) {\u000a				editor.getSelection().fake( next );\u000a				evt.data.preventDefault();\u000a				evt.cancel();\u000a			}\u000a		};\u000a	}\u000a\u000a	// If fake selection should be applied this function will return instance of\u000a	// CKEDITOR.dom.element which should gain fake selection.\u000a	function getNonEditableFakeSelectionReceiver( ranges ) {\u000a		var enclosedNode, shrinkedNode, clone, range;\u000a\u000a		if ( ranges.length == 1 && !( range = ranges[ 0 ] ).collapsed &&\u000a			( enclosedNode = range.getEnclosedNode() ) && enclosedNode.type == CKEDITOR.NODE_ELEMENT ) {\u000a			// So far we can't say that enclosed element is non-editable. Before checking,\u000a			// we'll shrink range (clone). Shrinking will stop on non-editable range, or\u000a			// innermost element (#11114).\u000a			clone = range.clone();\u000a			clone.shrink( CKEDITOR.SHRINK_ELEMENT, true );\u000a\u000a			// If shrinked range still encloses an element, check this one (shrink stops only on non-editable elements).\u000a			if ( ( shrinkedNode = clone.getEnclosedNode() ) && shrinkedNode.type == CKEDITOR.NODE_ELEMENT )\u000a				enclosedNode = shrinkedNode;\u000a\u000a			if ( enclosedNode.getAttribute( 'contenteditable' ) == 'false' )\u000a				return enclosedNode;\u000a		}\u000a	}\u000a\u000a	// Fix ranges which may end after hidden selection container.\u000a	// Note: this function may only be used if hidden selection container\u000a	// is not in DOM any more.\u000a	function fixRangesAfterHiddenSelectionContainer( ranges, root ) {\u000a		var range;\u000a		for ( var i = 0; i < ranges.length; ++i ) {\u000a			range = ranges[ i ];\u000a			if ( range.endContainer.equals( root ) ) {\u000a				// We can use getChildCount() because hidden selection container is not in DOM.\u000a				range.endOffset = Math.min( range.endOffset, root.getChildCount() );\u000a			}\u000a		}\u000a	}\u000a\u000a	// Extract only editable part or ranges.\u000a	// Note: this function modifies ranges list!\u000a	// @param {CKEDITOR.dom.rangeList} ranges\u000a	function extractEditableRanges( ranges ) {\u000a		for ( var i = 0; i < ranges.length; i++ ) {\u000a			var range = ranges[ i ];\u000a\u000a			// Drop range spans inside one ready-only node.\u000a			var parent = range.getCommonAncestor();\u000a			if ( parent.isReadOnly() )\u000a				ranges.splice( i, 1 );\u000a\u000a			if ( range.collapsed )\u000a				continue;\u000a\u000a			// Range may start inside a non-editable element,\u000a			// replace the range start after it.\u000a			if ( range.startContainer.isReadOnly() ) {\u000a				var current = range.startContainer,\u000a					isElement;\u000a\u000a				while ( current ) {\u000a					isElement = current.type == CKEDITOR.NODE_ELEMENT;\u000a\u000a					if ( ( isElement && current.is( 'body' ) ) || !current.isReadOnly() )\u000a						break;\u000a\u000a					if ( isElement && current.getAttribute( 'contentEditable' ) == 'false' )\u000a						range.setStartAfter( current );\u000a\u000a					current = current.getParent();\u000a				}\u000a			}\u000a\u000a			var startContainer = range.startContainer,\u000a				endContainer = range.endContainer,\u000a				startOffset = range.startOffset,\u000a				endOffset = range.endOffset,\u000a				walkerRange = range.clone();\u000a\u000a			// Enlarge range start/end with text node to avoid walker\u000a			// being DOM destructive, it doesn't interfere our checking\u000a			// of elements below as well.\u000a			if ( startContainer && startContainer.type == CKEDITOR.NODE_TEXT ) {\u000a				if ( startOffset >= startContainer.getLength() )\u000a					walkerRange.setStartAfter( startContainer );\u000a				else\u000a					walkerRange.setStartBefore( startContainer );\u000a			}\u000a\u000a			if ( endContainer && endContainer.type == CKEDITOR.NODE_TEXT ) {\u000a				if ( !endOffset )\u000a					walkerRange.setEndBefore( endContainer );\u000a				else\u000a					walkerRange.setEndAfter( endContainer );\u000a			}\u000a\u000a			// Looking for non-editable element inside the range.\u000a			var walker = new CKEDITOR.dom.walker( walkerRange );\u000a			walker.evaluator = function( node ) {\u000a				if ( node.type == CKEDITOR.NODE_ELEMENT && node.isReadOnly() ) {\u000a					var newRange = range.clone();\u000a					range.setEndBefore( node );\u000a\u000a					// Drop collapsed range around read-only elements,\u000a					// it make sure the range list empty when selecting\u000a					// only non-editable elements.\u000a					if ( range.collapsed )\u000a						ranges.splice( i--, 1 );\u000a\u000a					// Avoid creating invalid range.\u000a					if ( !( node.getPosition( walkerRange.endContainer ) & CKEDITOR.POSITION_CONTAINS ) ) {\u000a						newRange.setStartAfter( node );\u000a						if ( !newRange.collapsed )\u000a							ranges.splice( i + 1, 0, newRange );\u000a					}\u000a\u000a					return true;\u000a				}\u000a\u000a				return false;\u000a			};\u000a\u000a			walker.next();\u000a		}\u000a\u000a		return ranges;\u000a	}\u000a\u000a	// Setup all editor instances for the necessary selection hooks.\u000a	CKEDITOR.on( 'instanceCreated', function( ev ) {\u000a		var editor = ev.editor;\u000a\u000a		editor.on( 'contentDom', function() {\u000a			var doc = editor.document,\u000a				outerDoc = CKEDITOR.document,\u000a				editable = editor.editable(),\u000a				body = doc.getBody(),\u000a				html = doc.getDocumentElement();\u000a\u000a			var isInline = editable.isInline();\u000a\u000a			var restoreSel,\u000a				lastSel;\u000a\u000a			// Give the editable an initial selection on first focus,\u000a			// put selection at a consistent position at the start\u000a			// of the contents. (#9507)\u000a			if ( CKEDITOR.env.gecko ) {\u000a				editable.attachListener( editable, 'focus', function( evt ) {\u000a					evt.removeListener();\u000a\u000a					if ( restoreSel !== 0 ) {\u000a						var nativ = editor.getSelection().getNative();\u000a						// Do it only if the native selection is at an unwanted\u000a						// place (at the very start of the editable). #10119\u000a						if ( nativ && nativ.isCollapsed && nativ.anchorNode == editable.$ ) {\u000a							var rng = editor.createRange();\u000a							rng.moveToElementEditStart( editable );\u000a							rng.select();\u000a						}\u000a					}\u000a				}, null, null, -2 );\u000a			}\u000a\u000a			// Plays the magic here to restore/save dom selection on editable focus/blur.\u000a			editable.attachListener( editable, CKEDITOR.env.webkit ? 'DOMFocusIn' : 'focus', function() {\u000a				// On Webkit we use DOMFocusIn which is fired more often than focus - e.g. when moving from main editable\u000a				// to nested editable (or the opposite). Unlock selection all, but restore only when it was locked\u000a				// for the same active element, what will e.g. mean restoring after displaying dialog.\u000a				if ( restoreSel && CKEDITOR.env.webkit )\u000a					restoreSel = editor._.previousActive && editor._.previousActive.equals( doc.getActive() );\u000a\u000a				editor.unlockSelection( restoreSel );\u000a				restoreSel = 0;\u000a			}, null, null, -1 );\u000a\u000a			// Disable selection restoring when clicking in.\u000a			editable.attachListener( editable, 'mousedown', function() {\u000a				restoreSel = 0;\u000a			} );\u000a\u000a			// Save a cloned version of current selection.\u000a			function saveSel() {\u000a				lastSel = new CKEDITOR.dom.selection( editor.getSelection() );\u000a				lastSel.lock();\u000a			}\u000a\u000a			// Browsers could loose the selection once the editable lost focus,\u000a			// in such case we need to reproduce it by saving a locked selection\u000a			// and restoring it upon focus gain.\u000a			if ( CKEDITOR.env.ie || isInline ) {\u000a				// For old IEs, we can retrieve the last correct DOM selection upon the "beforedeactivate" event.\u000a				// For the rest, a more frequent check is required for each selection change made.\u000a				if ( isMSSelection )\u000a					editable.attachListener( editable, 'beforedeactivate', saveSel, null, null, -1 );\u000a				else\u000a					editable.attachListener( editor, 'selectionCheck', saveSel, null, null, -1 );\u000a\u000a				// Lock the selection and mark it to be restored.\u000a				// On Webkit we use DOMFocusOut which is fired more often than blur. I.e. it will also be\u000a				// fired when nested editable is blurred.\u000a				editable.attachListener( editable, CKEDITOR.env.webkit ? 'DOMFocusOut' : 'blur', function() {\u000a					editor.lockSelection( lastSel );\u000a					restoreSel = 1;\u000a				}, null, null, -1 );\u000a\u000a				// Disable selection restoring when clicking in.\u000a				editable.attachListener( editable, 'mousedown', function() {\u000a					restoreSel = 0;\u000a				} );\u000a			}\u000a\u000a			// The following selection-related fixes only apply to classic (`iframe`-based) editable.\u000a			if ( CKEDITOR.env.ie && !isInline ) {\u000a				var scroll;\u000a				editable.attachListener( editable, 'mousedown', function( evt ) {\u000a					// IE scrolls document to top on right mousedown\u000a					// when editor has no focus, remember this scroll\u000a					// position and revert it before context menu opens. (#5778)\u000a					if ( evt.data.$.button == 2 ) {\u000a						var sel = editor.document.getSelection();\u000a						if ( !sel || sel.getType() == CKEDITOR.SELECTION_NONE )\u000a							scroll = editor.window.getScrollPosition();\u000a					}\u000a				} );\u000a\u000a				editable.attachListener( editable, 'mouseup', function( evt ) {\u000a					// Restore recorded scroll position when needed on right mouseup.\u000a					if ( evt.data.$.button == 2 && scroll ) {\u000a						editor.document.$.documentElement.scrollLeft = scroll.x;\u000a						editor.document.$.documentElement.scrollTop = scroll.y;\u000a					}\u000a					scroll = null;\u000a				} );\u000a\u000a				// When content doc is in standards mode, IE doesn't focus the editor when\u000a				// clicking at the region below body (on html element) content, we emulate\u000a				// the normal behavior on old IEs. (#1659, #7932)\u000a				if ( doc.$.compatMode != 'BackCompat' ) {\u000a					if ( CKEDITOR.env.ie7Compat || CKEDITOR.env.ie6Compat ) {\u000a						html.on( 'mousedown', function( evt ) {\u000a							evt = evt.data;\u000a\u000a							// Expand the text range along with mouse move.\u000a							function onHover( evt ) {\u000a								evt = evt.data.$;\u000a								if ( textRng ) {\u000a									// Read the current cursor.\u000a									var rngEnd = body.$.createTextRange();\u000a\u000a									moveRangeToPoint( rngEnd, evt.clientX, evt.clientY );\u000a\u000a									// Handle drag directions.\u000a									textRng.setEndPoint(\u000a										startRng.compareEndPoints( 'StartToStart', rngEnd ) < 0 ?\u000a										'EndToEnd' : 'StartToStart', rngEnd );\u000a\u000a									// Update selection with new range.\u000a									textRng.select();\u000a								}\u000a							}\u000a\u000a							function removeListeners() {\u000a								outerDoc.removeListener( 'mouseup', onSelectEnd );\u000a								html.removeListener( 'mouseup', onSelectEnd );\u000a							}\u000a\u000a							function onSelectEnd() {\u000a								html.removeListener( 'mousemove', onHover );\u000a								removeListeners();\u000a\u000a								// Make it in effect on mouse up. (#9022)\u000a								textRng.select();\u000a							}\u000a\u000a\u000a							// We're sure that the click happens at the region\u000a							// below body, but not on scrollbar.\u000a							if ( evt.getTarget().is( 'html' ) &&\u000a									evt.$.y < html.$.clientHeight &&\u000a									evt.$.x < html.$.clientWidth ) {\u000a								// Start to build the text range.\u000a								var textRng = body.$.createTextRange();\u000a								moveRangeToPoint( textRng, evt.$.clientX, evt.$.clientY );\u000a\u000a								// Records the dragging start of the above text range.\u000a								var startRng = textRng.duplicate();\u000a\u000a								html.on( 'mousemove', onHover );\u000a								outerDoc.on( 'mouseup', onSelectEnd );\u000a								html.on( 'mouseup', onSelectEnd );\u000a							}\u000a						} );\u000a					}\u000a\u000a					// It's much simpler for IE8+, we just need to reselect the reported range.\u000a					// This hack does not work on IE>=11 because there's no old selection&range APIs.\u000a					if ( CKEDITOR.env.version > 7 && CKEDITOR.env.version < 11 ) {\u000a						html.on( 'mousedown', function( evt ) {\u000a							if ( evt.data.getTarget().is( 'html' ) ) {\u000a								// Limit the text selection mouse move inside of editable. (#9715)\u000a								outerDoc.on( 'mouseup', onSelectEnd );\u000a								html.on( 'mouseup', onSelectEnd );\u000a							}\u000a						} );\u000a					}\u000a				}\u000a			}\u000a\u000a			// We check the selection change:\u000a			// 1. Upon "selectionchange" event from the editable element. (which might be faked event fired by our code)\u000a			// 2. After the accomplish of keyboard and mouse events.\u000a			editable.attachListener( editable, 'selectionchange', checkSelectionChange, editor );\u000a			editable.attachListener( editable, 'keyup', checkSelectionChangeTimeout, editor );\u000a			// Always fire the selection change on focus gain.\u000a			// On Webkit do this on DOMFocusIn, because the selection is unlocked on it too and\u000a			// we need synchronization between those listeners to not lost cached editor._.previousActive property\u000a			// (which is updated on selectionCheck).\u000a			editable.attachListener( editable, CKEDITOR.env.webkit ? 'DOMFocusIn' : 'focus', function() {\u000a				editor.forceNextSelectionCheck();\u000a				editor.selectionChange( 1 );\u000a			} );\u000a\u000a			// #9699: On Webkit&Gecko in inline editor we have to check selection when it was changed\u000a			// by dragging and releasing mouse button outside editable. Dragging (mousedown)\u000a			// has to be initialized in editable, but for mouseup we listen on document element.\u000a			if ( isInline && ( CKEDITOR.env.webkit || CKEDITOR.env.gecko ) ) {\u000a				var mouseDown;\u000a				editable.attachListener( editable, 'mousedown', function() {\u000a					mouseDown = 1;\u000a				} );\u000a				editable.attachListener( doc.getDocumentElement(), 'mouseup', function() {\u000a					if ( mouseDown )\u000a						checkSelectionChangeTimeout.call( editor );\u000a					mouseDown = 0;\u000a				} );\u000a			}\u000a			// In all other cases listen on simple mouseup over editable, as we did before #9699.\u000a			//\u000a			// Use document instead of editable in non-IEs for observing mouseup\u000a			// since editable won't fire the event if selection process started within iframe and ended out\u000a			// of the editor (#9851).\u000a			else {\u000a				editable.attachListener( CKEDITOR.env.ie ? editable : doc.getDocumentElement(), 'mouseup', checkSelectionChangeTimeout, editor );\u000a			}\u000a\u000a			if ( CKEDITOR.env.webkit ) {\u000a				// Before keystroke is handled by editor, check to remove the filling char.\u000a				editable.attachListener( doc, 'keydown', function( evt ) {\u000a					var key = evt.data.getKey();\u000a					// Remove the filling char before some keys get\u000a					// executed, so they'll not get blocked by it.\u000a					switch ( key ) {\u000a						case 13: // ENTER\u000a						case 33: // PAGEUP\u000a						case 34: // PAGEDOWN\u000a						case 35: // HOME\u000a						case 36: // END\u000a						case 37: // LEFT-ARROW\u000a						case 39: // RIGHT-ARROW\u000a						case 8: // BACKSPACE\u000a						case 45: // INS\u000a						case 46: // DEl\u000a							removeFillingChar( editable );\u000a					}\u000a\u000a				}, null, null, -1 );\u000a			}\u000a\u000a			// Automatically select non-editable element when navigating into\u000a			// it by left/right or backspace/del keys.\u000a			editable.attachListener( editable, 'keydown', getOnKeyDownListener( editor ), null, null, -1 );\u000a\u000a			function moveRangeToPoint( range, x, y ) {\u000a				// Error prune in IE7. (#9034, #9110)\u000a				try {\u000a					range.moveToPoint( x, y );\u000a				} catch ( e ) {}\u000a			}\u000a\u000a			function removeListeners() {\u000a				outerDoc.removeListener( 'mouseup', onSelectEnd );\u000a				html.removeListener( 'mouseup', onSelectEnd );\u000a			}\u000a\u000a			function onSelectEnd() {\u000a				removeListeners();\u000a\u000a				// The event is not fired when clicking on the scrollbars,\u000a				// so we can safely check the following to understand\u000a				// whether the empty space following <body> has been clicked.\u000a				var sel = CKEDITOR.document.$.selection,\u000a					range = sel.createRange();\u000a\u000a				// The selection range is reported on host, but actually it should applies to the content doc.\u000a				if ( sel.type != 'None' && range.parentElement().ownerDocument == doc.$ )\u000a					range.select();\u000a			}\u000a		} );\u000a\u000a		editor.on( 'setData', function() {\u000a			// Invalidate locked selection when unloading DOM.\u000a			// (#9521, #5217#comment:32 and #11500#comment:11)\u000a			editor.unlockSelection();\u000a\u000a			// Webkit's selection will mess up after the data loading.\u000a			if ( CKEDITOR.env.webkit )\u000a				clearSelection();\u000a		} );\u000a\u000a		// Catch all the cases which above setData listener couldn't catch.\u000a		// For example: switching to source mode and destroying editor.\u000a		editor.on( 'contentDomUnload', function() {\u000a			editor.unlockSelection();\u000a		} );\u000a\u000a		// IE9 might cease to work if there's an object selection inside the iframe (#7639).\u000a		if ( CKEDITOR.env.ie9Compat )\u000a			editor.on( 'beforeDestroy', clearSelection, null, null, 9 );\u000a\u000a		// Check selection change on data reload.\u000a		editor.on( 'dataReady', function() {\u000a			// Clean up fake selection after setting data.\u000a			delete editor._.fakeSelection;\u000a			delete editor._.hiddenSelectionContainer;\u000a\u000a			editor.selectionChange( 1 );\u000a		} );\u000a\u000a		// When loaded data are ready check whether hidden selection container was not loaded.\u000a		editor.on( 'loadSnapshot', function() {\u000a			// TODO replace with el.find() which will be introduced in #9764,\u000a			// because it may happen that hidden sel container won't be the last element.\u000a			var el = editor.editable().getLast( function( node ) {\u000a				return node.type == CKEDITOR.NODE_ELEMENT;\u000a			} );\u000a\u000a			if ( el && el.hasAttribute( 'data-cke-hidden-sel' ) )\u000a				el.remove();\u000a		}, null, null, 100 );\u000a\u000a		editor.on( 'key', function( evt ) {\u000a			if ( editor.mode != 'wysiwyg' )\u000a				return;\u000a\u000a			var sel = editor.getSelection();\u000a			if ( !sel.isFake )\u000a				return;\u000a\u000a			var handler = fakeSelectionDefaultKeystrokeHandlers[ evt.data.keyCode ];\u000a			if ( handler )\u000a				return handler( { editor: editor, selected: sel.getSelectedElement(), selection: sel, keyEvent: evt } );\u000a		} );\u000a\u000a		function clearSelection() {\u000a			var sel = editor.getSelection();\u000a			sel && sel.removeAllRanges();\u000a		}\u000a	} );\u000a\u000a	CKEDITOR.on( 'instanceReady', function( evt ) {\u000a		var editor = evt.editor,\u000a			fillingCharBefore,\u000a			selectionBookmark;\u000a\u000a		// On WebKit only, we need a special "filling" char on some situations\u000a		// (#1272). Here we set the events that should invalidate that char.\u000a		if ( CKEDITOR.env.webkit ) {\u000a			editor.on( 'selectionChange', function() {\u000a				checkFillingChar( editor.editable() );\u000a			}, null, null, -1 );\u000a			editor.on( 'beforeSetMode', function() {\u000a				removeFillingChar( editor.editable() );\u000a			}, null, null, -1 );\u000a\u000a			editor.on( 'beforeUndoImage', beforeData );\u000a			editor.on( 'afterUndoImage', afterData );\u000a			editor.on( 'beforeGetData', beforeData, null, null, 0 );\u000a			editor.on( 'getData', afterData );\u000a		}\u000a\u000a		function beforeData() {\u000a			var editable = editor.editable();\u000a			if ( !editable )\u000a				return;\u000a\u000a			var fillingChar = getFillingChar( editable );\u000a\u000a			if ( fillingChar ) {\u000a				// If the selection's focus or anchor is located in the filling char's text node,\u000a				// we need to restore the selection in afterData, because it will be lost\u000a				// when setting text. Selection's direction must be preserved.\u000a				// (#7437, #12489, #12491 comment:3)\u000a				var sel = editor.document.$.getSelection();\u000a				if ( sel.type != 'None' && ( sel.anchorNode == fillingChar.$ || sel.focusNode == fillingChar.$ ) )\u000a					selectionBookmark = createNativeSelectionBookmark( sel );\u000a\u000a				fillingCharBefore = fillingChar.getText();\u000a				fillingChar.setText( replaceFillingChar( fillingCharBefore ) );\u000a			}\u000a		}\u000a\u000a		function afterData() {\u000a			var editable = editor.editable();\u000a			if ( !editable )\u000a				return;\u000a\u000a			var fillingChar = getFillingChar( editable );\u000a\u000a			if ( fillingChar ) {\u000a				fillingChar.setText( fillingCharBefore );\u000a\u000a				if ( selectionBookmark ) {\u000a					moveNativeSelectionToBookmark( editor.document.$, selectionBookmark );\u000a					selectionBookmark = null;\u000a				}\u000a			}\u000a		}\u000a	} );\u000a\u000a	/**\u000a	 * Check the selection change in editor and potentially fires\u000a	 * the {@link CKEDITOR.editor#event-selectionChange} event.\u000a	 *\u000a	 * @method\u000a	 * @member CKEDITOR.editor\u000a	 * @param {Boolean} [checkNow=false] Force the check to happen immediately\u000a	 * instead of coming with a timeout delay (default).\u000a	 */\u000a	CKEDITOR.editor.prototype.selectionChange = function( checkNow ) {\u000a		( checkNow ? checkSelectionChange : checkSelectionChangeTimeout ).call( this );\u000a	};\u000a\u000a	/**\u000a	 * Retrieve the editor selection in scope of editable element.\u000a	 *\u000a	 * **Note:** Since the native browser selection provides only one single\u000a	 * selection at a time per document, so if editor's editable element has lost focus,\u000a	 * this method will return a null value unless the {@link CKEDITOR.editor#lockSelection}\u000a	 * has been called beforehand so the saved selection is retrieved.\u000a	 *\u000a	 *		var selection = CKEDITOR.instances.editor1.getSelection();\u000a	 *		alert( selection.getType() );\u000a	 *\u000a	 * @method\u000a	 * @member CKEDITOR.editor\u000a	 * @param {Boolean} forceRealSelection Return real selection, instead of saved or fake one.\u000a	 * @returns {CKEDITOR.dom.selection} A selection object or null if not available for the moment.\u000a	 */\u000a	CKEDITOR.editor.prototype.getSelection = function( forceRealSelection ) {\u000a\u000a		// Check if there exists a locked or fake selection.\u000a		if ( ( this._.savedSelection || this._.fakeSelection ) && !forceRealSelection )\u000a			return this._.savedSelection || this._.fakeSelection;\u000a\u000a		// Editable element might be absent or editor might not be in a wysiwyg mode.\u000a		var editable = this.editable();\u000a		return editable && this.mode == 'wysiwyg' ? new CKEDITOR.dom.selection( editable ) : null;\u000a	};\u000a\u000a	/**\u000a	 * Locks the selection made in the editor in order to make it possible to\u000a	 * manipulate it without browser interference. A locked selection is\u000a	 * cached and remains unchanged until it is released with the\u000a	 * {@link CKEDITOR.editor#unlockSelection} method.\u000a	 *\u000a	 * @method\u000a	 * @member CKEDITOR.editor\u000a	 * @param {CKEDITOR.dom.selection} [sel] Specify the selection to be locked.\u000a	 * @returns {Boolean} `true` if selection was locked.\u000a	 */\u000a	CKEDITOR.editor.prototype.lockSelection = function( sel ) {\u000a		sel = sel || this.getSelection( 1 );\u000a		if ( sel.getType() != CKEDITOR.SELECTION_NONE ) {\u000a			!sel.isLocked && sel.lock();\u000a			this._.savedSelection = sel;\u000a			return true;\u000a		}\u000a		return false;\u000a	};\u000a\u000a	/**\u000a	 * Unlocks the selection made in the editor and locked with the\u000a	 * {@link CKEDITOR.editor#unlockSelection} method. An unlocked selection\u000a	 * is no longer cached and can be changed.\u000a	 *\u000a	 * @method\u000a	 * @member CKEDITOR.editor\u000a	 * @param {Boolean} [restore] If set to `true`, the selection is\u000a	 * restored back to the selection saved earlier by using the\u000a	 * {@link CKEDITOR.dom.selection#lock} method.\u000a	 */\u000a	CKEDITOR.editor.prototype.unlockSelection = function( restore ) {\u000a		var sel = this._.savedSelection;\u000a		if ( sel ) {\u000a			sel.unlock( restore );\u000a			delete this._.savedSelection;\u000a			return true;\u000a		}\u000a\u000a		return false;\u000a	};\u000a\u000a	/**\u000a	 * @method\u000a	 * @member CKEDITOR.editor\u000a	 * @todo\u000a	 */\u000a	CKEDITOR.editor.prototype.forceNextSelectionCheck = function() {\u000a		delete this._.selectionPreviousPath;\u000a	};\u000a\u000a	/**\u000a	 * Gets the current selection in context of the document's body element.\u000a	 *\u000a	 *		var selection = CKEDITOR.instances.editor1.document.getSelection();\u000a	 *		alert( selection.getType() );\u000a	 *\u000a	 * @method\u000a	 * @member CKEDITOR.dom.document\u000a	 * @returns {CKEDITOR.dom.selection} A selection object.\u000a	 */\u000a	CKEDITOR.dom.document.prototype.getSelection = function() {\u000a		return new CKEDITOR.dom.selection( this );\u000a	};\u000a\u000a	/**\u000a	 * Select this range as the only one with {@link CKEDITOR.dom.selection#selectRanges}.\u000a	 *\u000a	 * @method\u000a	 * @returns {CKEDITOR.dom.selection}\u000a	 * @member CKEDITOR.dom.range\u000a	 */\u000a	CKEDITOR.dom.range.prototype.select = function() {\u000a		var sel = this.root instanceof CKEDITOR.editable ? this.root.editor.getSelection() : new CKEDITOR.dom.selection( this.root );\u000a\u000a		sel.selectRanges( [ this ] );\u000a\u000a		return sel;\u000a	};\u000a\u000a	/**\u000a	 * No selection.\u000a	 *\u000a	 *		if ( editor.getSelection().getType() == CKEDITOR.SELECTION_NONE )\u000a	 *			alert( 'Nothing is selected' );\u000a	 *\u000a	 * @readonly\u000a	 * @property {Number} [=1]\u000a	 * @member CKEDITOR\u000a	 */\u000a	CKEDITOR.SELECTION_NONE = 1;\u000a\u000a	/**\u000a	 * A text or a collapsed selection.\u000a	 *\u000a	 *		if ( editor.getSelection().getType() == CKEDITOR.SELECTION_TEXT )\u000a	 *			alert( 'A text is selected' );\u000a	 *\u000a	 * @readonly\u000a	 * @property {Number} [=2]\u000a	 * @member CKEDITOR\u000a	 */\u000a	CKEDITOR.SELECTION_TEXT = 2;\u000a\u000a	/**\u000a	 * Element selection.\u000a	 *\u000a	 *		if ( editor.getSelection().getType() == CKEDITOR.SELECTION_ELEMENT )\u000a	 *			alert( 'An element is selected' );\u000a	 *\u000a	 * @readonly\u000a	 * @property {Number} [=3]\u000a	 * @member CKEDITOR\u000a	 */\u000a	CKEDITOR.SELECTION_ELEMENT = 3;\u000a\u000a	var isMSSelection = typeof window.getSelection != 'function',\u000a		nextRev = 1;\u000a\u000a	/**\u000a	 * Manipulates the selection within a DOM element. If the current browser selection\u000a	 * spans outside of the element, an empty selection object is returned.\u000a	 *\u000a	 * Despite the fact that selection's constructor allows to create selection instances,\u000a	 * usually it's better to get selection from the editor instance:\u000a	 *\u000a	 *		var sel = editor.getSelection();\u000a	 *\u000a	 * See {@link CKEDITOR.editor#getSelection}.\u000a	 *\u000a	 * @class\u000a	 * @constructor Creates a selection class instance.\u000a	 *\u000a	 *		// Selection scoped in document.\u000a	 *		var sel = new CKEDITOR.dom.selection( CKEDITOR.document );\u000a	 *\u000a	 *		// Selection scoped in element with 'editable' id.\u000a	 *		var sel = new CKEDITOR.dom.selection( CKEDITOR.document.getById( 'editable' ) );\u000a	 *\u000a	 *		// Cloning selection.\u000a	 *		var clone = new CKEDITOR.dom.selection( sel );\u000a	 *\u000a	 * @param {CKEDITOR.dom.document/CKEDITOR.dom.element/CKEDITOR.dom.selection} target\u000a	 * The DOM document/element that the DOM selection is restrained to. Only selection which spans\u000a	 * within the target element is considered as valid.\u000a	 *\u000a	 * If {@link CKEDITOR.dom.selection} is passed, then its clone will be created.\u000a	 */\u000a	CKEDITOR.dom.selection = function( target ) {\u000a		// Target is a selection - clone it.\u000a		if ( target instanceof CKEDITOR.dom.selection ) {\u000a			var selection = target;\u000a			target = target.root;\u000a		}\u000a\u000a		var isElement = target instanceof CKEDITOR.dom.element,\u000a			root;\u000a\u000a		this.rev = selection ? selection.rev : nextRev++;\u000a		this.document = target instanceof CKEDITOR.dom.document ? target : target.getDocument();\u000a		this.root = root = isElement ? target : this.document.getBody();\u000a		this.isLocked = 0;\u000a		this._ = {\u000a			cache: {}\u000a		};\u000a\u000a		// Clone selection.\u000a		if ( selection ) {\u000a			CKEDITOR.tools.extend( this._.cache, selection._.cache );\u000a			this.isFake = selection.isFake;\u000a			this.isLocked = selection.isLocked;\u000a			return this;\u000a		}\u000a\u000a		// On WebKit, it may happen that we've already have focus\u000a		// on the editable element while still having no selection\u000a		// available. We normalize it here by replicating the\u000a		// behavior of other browsers.\u000a		//\u000a		// Webkit's condition covers also the case when editable hasn't been focused\u000a		// at all. Thanks to this hack Webkit always has selection in the right place.\u000a		//\u000a		// On FF and IE we only fix the first case, when editable was activated\u000a		// but the selection is broken - usually this happens after setData if editor was focused.\u000a\u000a		var sel = isMSSelection ? this.document.$.selection : this.document.getWindow().$.getSelection();\u000a\u000a		if ( CKEDITOR.env.webkit ) {\u000a			if ( sel.type == 'None' && this.document.getActive().equals( root ) || sel.type == 'Caret' && sel.anchorNode.nodeType == CKEDITOR.NODE_DOCUMENT )\u000a				fixInitialSelection( root, sel );\u000a		}\u000a		else if ( CKEDITOR.env.gecko ) {\u000a			if ( sel && this.document.getActive().equals( root ) &&\u000a				sel.anchorNode && sel.anchorNode.nodeType == CKEDITOR.NODE_DOCUMENT )\u000a				fixInitialSelection( root, sel, true );\u000a		}\u000a		else if ( CKEDITOR.env.ie ) {\u000a			var active = this.document.getActive();\u000a\u000a			// IEs 9+.\u000a			if ( !isMSSelection ) {\u000a				var anchorNode = sel && sel.anchorNode;\u000a\u000a				if ( anchorNode )\u000a					anchorNode = new CKEDITOR.dom.node( anchorNode );\u000a\u000a				if ( active && active.equals( this.document.getDocumentElement() ) &&\u000a					anchorNode && ( root.equals( anchorNode ) || root.contains( anchorNode ) ) )\u000a					fixInitialSelection( root, null, true );\u000a			}\u000a			// IEs 7&8.\u000a			else if ( sel.type == 'None' && active && active.equals( this.document.getDocumentElement() ) ) {\u000a				fixInitialSelection( root, null, true );\u000a			}\u000a		}\u000a\u000a		// Check whether browser focus is really inside of the editable element.\u000a\u000a		var nativeSel = this.getNative(),\u000a			rangeParent,\u000a			range;\u000a\u000a		if ( nativeSel ) {\u000a			if ( nativeSel.getRangeAt ) {\u000a				range = nativeSel.rangeCount && nativeSel.getRangeAt( 0 );\u000a				rangeParent = range && new CKEDITOR.dom.node( range.commonAncestorContainer );\u000a			}\u000a			// For old IEs.\u000a			else {\u000a				// Sometimes, mostly when selection is close to the table or hr,\u000a				// IE throws "Unspecified error".\u000a				try {\u000a					range = nativeSel.createRange();\u000a				} catch ( err ) {}\u000a				rangeParent = range && CKEDITOR.dom.element.get( range.item && range.item( 0 ) || range.parentElement() );\u000a			}\u000a		}\u000a\u000a		// Selection out of concerned range, empty the selection.\u000a		// TODO check whether this condition cannot be reverted to its old\u000a		// form (commented out) after we closed #10438.\u000a		//if ( !( rangeParent && ( root.equals( rangeParent ) || root.contains( rangeParent ) ) ) ) {\u000a		if ( !(\u000a			rangeParent &&\u000a			( rangeParent.type == CKEDITOR.NODE_ELEMENT || rangeParent.type == CKEDITOR.NODE_TEXT ) &&\u000a			( this.root.equals( rangeParent ) || this.root.contains( rangeParent ) )\u000a		) ) {\u000a\u000a			this._.cache.type = CKEDITOR.SELECTION_NONE;\u000a			this._.cache.startElement = null;\u000a			this._.cache.selectedElement = null;\u000a			this._.cache.selectedText = '';\u000a			this._.cache.ranges = new CKEDITOR.dom.rangeList();\u000a		}\u000a\u000a		return this;\u000a	};\u000a\u000a	var styleObjectElements = { img: 1, hr: 1, li: 1, table: 1, tr: 1, td: 1, th: 1, embed: 1, object: 1, ol: 1, ul: 1,\u000a			a: 1, input: 1, form: 1, select: 1, textarea: 1, button: 1, fieldset: 1, thead: 1, tfoot: 1 };\u000a\u000a	CKEDITOR.dom.selection.prototype = {\u000a		/**\u000a		 * Gets the native selection object from the browser.\u000a		 *\u000a		 *		var selection = editor.getSelection().getNative();\u000a		 *\u000a		 * @returns {Object} The native browser selection object.\u000a		 */\u000a		getNative: function() {\u000a			if ( this._.cache.nativeSel !== undefined )\u000a				return this._.cache.nativeSel;\u000a\u000a			return ( this._.cache.nativeSel = isMSSelection ? this.document.$.selection : this.document.getWindow().$.getSelection() );\u000a		},\u000a\u000a		/**\u000a		 * Gets the type of the current selection. The following values are\u000a		 * available:\u000a		 *\u000a		 * * {@link CKEDITOR#SELECTION_NONE} (1): No selection.\u000a		 * * {@link CKEDITOR#SELECTION_TEXT} (2): A text or a collapsed selection is selected.\u000a		 * * {@link CKEDITOR#SELECTION_ELEMENT} (3): An element is selected.\u000a		 *\u000a		 * Example:\u000a		 *\u000a		 *		if ( editor.getSelection().getType() == CKEDITOR.SELECTION_TEXT )\u000a		 *			alert( 'A text is selected' );\u000a		 *\u000a		 * @method\u000a		 * @returns {Number} One of the following constant values: {@link CKEDITOR#SELECTION_NONE},\u000a		 * {@link CKEDITOR#SELECTION_TEXT} or {@link CKEDITOR#SELECTION_ELEMENT}.\u000a		 */\u000a		getType: isMSSelection ?\u000a		function() {\u000a			var cache = this._.cache;\u000a			if ( cache.type )\u000a				return cache.type;\u000a\u000a			var type = CKEDITOR.SELECTION_NONE;\u000a\u000a			try {\u000a				var sel = this.getNative(),\u000a					ieType = sel.type;\u000a\u000a				if ( ieType == 'Text' )\u000a					type = CKEDITOR.SELECTION_TEXT;\u000a\u000a				if ( ieType == 'Control' )\u000a					type = CKEDITOR.SELECTION_ELEMENT;\u000a\u000a				// It is possible that we can still get a text range\u000a				// object even when type == 'None' is returned by IE.\u000a				// So we'd better check the object returned by\u000a				// createRange() rather than by looking at the type.\u000a				if ( sel.createRange().parentElement() )\u000a					type = CKEDITOR.SELECTION_TEXT;\u000a			} catch ( e ) {}\u000a\u000a			return ( cache.type = type );\u000a		} : function() {\u000a			var cache = this._.cache;\u000a			if ( cache.type )\u000a				return cache.type;\u000a\u000a			var type = CKEDITOR.SELECTION_TEXT;\u000a\u000a			var sel = this.getNative();\u000a\u000a			if ( !( sel && sel.rangeCount ) )\u000a				type = CKEDITOR.SELECTION_NONE;\u000a			else if ( sel.rangeCount == 1 ) {\u000a				// Check if the actual selection is a control (IMG,\u000a				// TABLE, HR, etc...).\u000a\u000a				var range = sel.getRangeAt( 0 ),\u000a					startContainer = range.startContainer;\u000a\u000a				if ( startContainer == range.endContainer && startContainer.nodeType == 1 &&\u000a					( range.endOffset - range.startOffset ) == 1 &&\u000a					styleObjectElements[ startContainer.childNodes[ range.startOffset ].nodeName.toLowerCase() ] ) {\u000a					type = CKEDITOR.SELECTION_ELEMENT;\u000a				}\u000a\u000a			}\u000a\u000a			return ( cache.type = type );\u000a		},\u000a\u000a		/**\u000a		 * Retrieves the {@link CKEDITOR.dom.range} instances that represent the current selection.\u000a		 *\u000a		 * Note: Some browsers return multiple ranges even for a continuous selection. Firefox, for example, returns\u000a		 * one range for each table cell when one or more table rows are selected.\u000a		 *\u000a		 *		var ranges = selection.getRanges();\u000a		 *		alert( ranges.length );\u000a		 *\u000a		 * @method\u000a		 * @param {Boolean} [onlyEditables] If set to `true`, this function retrives editable ranges only.\u000a		 * @returns {Array} Range instances that represent the current selection.\u000a		 */\u000a		getRanges: ( function() {\u000a			var func = isMSSelection ? ( function() {\u000a				function getNodeIndex( node ) {\u000a					return new CKEDITOR.dom.node( node ).getIndex();\u000a				}\u000a\u000a				// Finds the container and offset for a specific boundary\u000a				// of an IE range.\u000a				var getBoundaryInformation = function( range, start ) {\u000a					// Creates a collapsed range at the requested boundary.\u000a					range = range.duplicate();\u000a					range.collapse( start );\u000a\u000a					// Gets the element that encloses the range entirely.\u000a					var parent = range.parentElement();\u000a\u000a					// Empty parent element, e.g. <i>^</i>\u000a					if ( !parent.hasChildNodes() )\u000a						return { container: parent, offset: 0 };\u000a\u000a					var siblings = parent.children,\u000a						child, sibling,\u000a						testRange = range.duplicate(),\u000a						startIndex = 0,\u000a						endIndex = siblings.length - 1,\u000a						index = -1,\u000a						position, distance, container;\u000a\u000a					// Binary search over all element childs to test the range to see whether\u000a					// range is right on the boundary of one element.\u000a					while ( startIndex <= endIndex ) {\u000a						index = Math.floor( ( startIndex + endIndex ) / 2 );\u000a						child = siblings[ index ];\u000a						testRange.moveToElementText( child );\u000a						position = testRange.compareEndPoints( 'StartToStart', range );\u000a\u000a						if ( position > 0 )\u000a							endIndex = index - 1;\u000a						else if ( position < 0 )\u000a							startIndex = index + 1;\u000a						else\u000a							return { container: parent, offset: getNodeIndex( child ) };\u000a					}\u000a\u000a					// All childs are text nodes,\u000a					// or to the right hand of test range are all text nodes. (#6992)\u000a					if ( index == -1 || index == siblings.length - 1 && position < 0 ) {\u000a						// Adapt test range to embrace the entire parent contents.\u000a						testRange.moveToElementText( parent );\u000a						testRange.setEndPoint( 'StartToStart', range );\u000a\u000a						// IE report line break as CRLF with range.text but\u000a						// only LF with textnode.nodeValue, normalize them to avoid\u000a						// breaking character counting logic below. (#3949)\u000a						distance = testRange.text.replace( /(\u005cr\u005cn|\u005cr)/g, '\u005cn' ).length;\u000a\u000a						siblings = parent.childNodes;\u000a\u000a						// Actual range anchor right beside test range at the boundary of text node.\u000a						if ( !distance ) {\u000a							child = siblings[ siblings.length - 1 ];\u000a\u000a							if ( child.nodeType != CKEDITOR.NODE_TEXT )\u000a								return { container: parent, offset: siblings.length };\u000a							else\u000a								return { container: child, offset: child.nodeValue.length };\u000a						}\u000a\u000a						// Start the measuring until distance overflows, meanwhile count the text nodes.\u000a						var i = siblings.length;\u000a						while ( distance > 0 && i > 0 ) {\u000a							sibling = siblings[ --i ];\u000a							if ( sibling.nodeType == CKEDITOR.NODE_TEXT ) {\u000a								container = sibling;\u000a								distance -= sibling.nodeValue.length;\u000a							}\u000a						}\u000a\u000a						return { container: container, offset: -distance };\u000a					}\u000a					// Test range was one offset beyond OR behind the anchored text node.\u000a					else {\u000a						// Adapt one side of test range to the actual range\u000a						// for measuring the offset between them.\u000a						testRange.collapse( position > 0 ? true : false );\u000a						testRange.setEndPoint( position > 0 ? 'StartToStart' : 'EndToStart', range );\u000a\u000a						// IE report line break as CRLF with range.text but\u000a						// only LF with textnode.nodeValue, normalize them to avoid\u000a						// breaking character counting logic below. (#3949)\u000a						distance = testRange.text.replace( /(\u005cr\u005cn|\u005cr)/g, '\u005cn' ).length;\u000a\u000a						// Actual range anchor right beside test range at the inner boundary of text node.\u000a						if ( !distance )\u000a							return { container: parent, offset: getNodeIndex( child ) + ( position > 0 ? 0 : 1 ) };\u000a\u000a						// Start the measuring until distance overflows, meanwhile count the text nodes.\u000a						while ( distance > 0 ) {\u000a							try {\u000a								sibling = child[ position > 0 ? 'previousSibling' : 'nextSibling' ];\u000a								if ( sibling.nodeType == CKEDITOR.NODE_TEXT ) {\u000a									distance -= sibling.nodeValue.length;\u000a									container = sibling;\u000a								}\u000a								child = sibling;\u000a							}\u000a							// Measurement in IE could be somtimes wrong because of <select> element. (#4611)\u000a							catch ( e ) {\u000a								return { container: parent, offset: getNodeIndex( child ) };\u000a							}\u000a						}\u000a\u000a						return { container: container, offset: position > 0 ? -distance : container.nodeValue.length + distance };\u000a					}\u000a				};\u000a\u000a				return function() {\u000a					// IE doesn't have range support (in the W3C way), so we\u000a					// need to do some magic to transform selections into\u000a					// CKEDITOR.dom.range instances.\u000a\u000a					var sel = this.getNative(),\u000a						nativeRange = sel && sel.createRange(),\u000a						type = this.getType(),\u000a						range;\u000a\u000a					if ( !sel )\u000a						return [];\u000a\u000a					if ( type == CKEDITOR.SELECTION_TEXT ) {\u000a						range = new CKEDITOR.dom.range( this.root );\u000a\u000a						var boundaryInfo = getBoundaryInformation( nativeRange, true );\u000a						range.setStart( new CKEDITOR.dom.node( boundaryInfo.container ), boundaryInfo.offset );\u000a\u000a						boundaryInfo = getBoundaryInformation( nativeRange );\u000a						range.setEnd( new CKEDITOR.dom.node( boundaryInfo.container ), boundaryInfo.offset );\u000a\u000a						// Correct an invalid IE range case on empty list item. (#5850)\u000a						if ( range.endContainer.getPosition( range.startContainer ) & CKEDITOR.POSITION_PRECEDING && range.endOffset <= range.startContainer.getIndex() )\u000a							range.collapse();\u000a\u000a						return [ range ];\u000a					} else if ( type == CKEDITOR.SELECTION_ELEMENT ) {\u000a						var retval = [];\u000a\u000a						for ( var i = 0; i < nativeRange.length; i++ ) {\u000a							var element = nativeRange.item( i ),\u000a								parentElement = element.parentNode,\u000a								j = 0;\u000a\u000a							range = new CKEDITOR.dom.range( this.root );\u000a\u000a							for ( ; j < parentElement.childNodes.length && parentElement.childNodes[ j ] != element; j++ ) {\u000a\u000a							}\u000a\u000a							range.setStart( new CKEDITOR.dom.node( parentElement ), j );\u000a							range.setEnd( new CKEDITOR.dom.node( parentElement ), j + 1 );\u000a							retval.push( range );\u000a						}\u000a\u000a						return retval;\u000a					}\u000a\u000a					return [];\u000a				};\u000a			} )() :\u000a			function() {\u000a				// On browsers implementing the W3C range, we simply\u000a				// tranform the native ranges in CKEDITOR.dom.range\u000a				// instances.\u000a\u000a				var ranges = [],\u000a					range,\u000a					sel = this.getNative();\u000a\u000a				if ( !sel )\u000a					return ranges;\u000a\u000a				for ( var i = 0; i < sel.rangeCount; i++ ) {\u000a					var nativeRange = sel.getRangeAt( i );\u000a\u000a					range = new CKEDITOR.dom.range( this.root );\u000a\u000a					range.setStart( new CKEDITOR.dom.node( nativeRange.startContainer ), nativeRange.startOffset );\u000a					range.setEnd( new CKEDITOR.dom.node( nativeRange.endContainer ), nativeRange.endOffset );\u000a					ranges.push( range );\u000a				}\u000a				return ranges;\u000a			};\u000a\u000a			return function( onlyEditables ) {\u000a				var cache = this._.cache,\u000a					ranges = cache.ranges;\u000a\u000a				if ( !ranges )\u000a					cache.ranges = ranges = new CKEDITOR.dom.rangeList( func.call( this ) );\u000a\u000a				if ( !onlyEditables )\u000a					return ranges;\u000a\u000a				// Split range into multiple by read-only nodes.\u000a				// Clone ranges array to avoid changing cached ranges (#11493).\u000a				return extractEditableRanges( new CKEDITOR.dom.rangeList( ranges.slice() ) );\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Gets the DOM element in which the selection starts.\u000a		 *\u000a		 *		var element = editor.getSelection().getStartElement();\u000a		 *		alert( element.getName() );\u000a		 *\u000a		 * @returns {CKEDITOR.dom.element} The element at the beginning of the selection.\u000a		 */\u000a		getStartElement: function() {\u000a			var cache = this._.cache;\u000a			if ( cache.startElement !== undefined )\u000a				return cache.startElement;\u000a\u000a			var node;\u000a\u000a			switch ( this.getType() ) {\u000a				case CKEDITOR.SELECTION_ELEMENT:\u000a					return this.getSelectedElement();\u000a\u000a				case CKEDITOR.SELECTION_TEXT:\u000a\u000a					var range = this.getRanges()[ 0 ];\u000a\u000a					if ( range ) {\u000a						if ( !range.collapsed ) {\u000a							range.optimize();\u000a\u000a							// Decrease the range content to exclude particial\u000a							// selected node on the start which doesn't have\u000a							// visual impact. ( #3231 )\u000a							while ( 1 ) {\u000a								var startContainer = range.startContainer,\u000a									startOffset = range.startOffset;\u000a								// Limit the fix only to non-block elements.(#3950)\u000a								if ( startOffset == ( startContainer.getChildCount ? startContainer.getChildCount() : startContainer.getLength() ) && !startContainer.isBlockBoundary() )\u000a									range.setStartAfter( startContainer );\u000a								else\u000a									break;\u000a							}\u000a\u000a							node = range.startContainer;\u000a\u000a							if ( node.type != CKEDITOR.NODE_ELEMENT )\u000a								return node.getParent();\u000a\u000a							node = node.getChild( range.startOffset );\u000a\u000a							if ( !node || node.type != CKEDITOR.NODE_ELEMENT )\u000a								node = range.startContainer;\u000a							else {\u000a								var child = node.getFirst();\u000a								while ( child && child.type == CKEDITOR.NODE_ELEMENT ) {\u000a									node = child;\u000a									child = child.getFirst();\u000a								}\u000a							}\u000a						} else {\u000a							node = range.startContainer;\u000a							if ( node.type != CKEDITOR.NODE_ELEMENT )\u000a								node = node.getParent();\u000a						}\u000a\u000a						node = node.$;\u000a					}\u000a			}\u000a\u000a			return cache.startElement = ( node ? new CKEDITOR.dom.element( node ) : null );\u000a		},\u000a\u000a		/**\u000a		 * Gets the currently selected element.\u000a		 *\u000a		 *		var element = editor.getSelection().getSelectedElement();\u000a		 *		alert( element.getName() );\u000a		 *\u000a		 * @returns {CKEDITOR.dom.element} The selected element. Null if no\u000a		 * selection is available or the selection type is not {@link CKEDITOR#SELECTION_ELEMENT}.\u000a		 */\u000a		getSelectedElement: function() {\u000a			var cache = this._.cache;\u000a			if ( cache.selectedElement !== undefined )\u000a				return cache.selectedElement;\u000a\u000a			var self = this;\u000a\u000a			var node = CKEDITOR.tools.tryThese(\u000a				// Is it native IE control type selection?\u000a				function() {\u000a					return self.getNative().createRange().item( 0 );\u000a				},\u000a				// Figure it out by checking if there's a single enclosed\u000a				// node of the range.\u000a				function() {\u000a					var range = self.getRanges()[ 0 ].clone(),\u000a						enclosed, selected;\u000a\u000a					// Check first any enclosed element, e.g. <ul>[<li><a href="#">item</a></li>]</ul>\u000a					for ( var i = 2; i && !( ( enclosed = range.getEnclosedNode() ) && ( enclosed.type == CKEDITOR.NODE_ELEMENT ) && styleObjectElements[ enclosed.getName() ] && ( selected = enclosed ) ); i-- ) {\u000a						// Then check any deep wrapped element, e.g. [<b><i><img /></i></b>]\u000a						range.shrink( CKEDITOR.SHRINK_ELEMENT );\u000a					}\u000a\u000a					return selected && selected.$;\u000a				}\u000a			);\u000a\u000a			return cache.selectedElement = ( node ? new CKEDITOR.dom.element( node ) : null );\u000a		},\u000a\u000a		/**\u000a		 * Retrieves the text contained within the range. An empty string is returned for non-text selection.\u000a		 *\u000a		 *		var text = editor.getSelection().getSelectedText();\u000a		 *		alert( text );\u000a		 *\u000a		 * @since 3.6.1\u000a		 * @returns {String} A string of text within the current selection.\u000a		 */\u000a		getSelectedText: function() {\u000a			var cache = this._.cache;\u000a			if ( cache.selectedText !== undefined )\u000a				return cache.selectedText;\u000a\u000a			var nativeSel = this.getNative(),\u000a				text = isMSSelection ? nativeSel.type == 'Control' ? '' : nativeSel.createRange().text : nativeSel.toString();\u000a\u000a			return ( cache.selectedText = text );\u000a		},\u000a\u000a		/**\u000a		 * Locks the selection made in the editor in order to make it possible to\u000a		 * manipulate it without browser interference. A locked selection is\u000a		 * cached and remains unchanged until it is released with the {@link #unlock} method.\u000a		 *\u000a		 *		editor.getSelection().lock();\u000a		 */\u000a		lock: function() {\u000a			// Call all cacheable function.\u000a			this.getRanges();\u000a			this.getStartElement();\u000a			this.getSelectedElement();\u000a			this.getSelectedText();\u000a\u000a			// The native selection is not available when locked.\u000a			this._.cache.nativeSel = null;\u000a\u000a			this.isLocked = 1;\u000a		},\u000a\u000a		/**\u000a		 * @todo\u000a		 */\u000a		unlock: function( restore ) {\u000a			if ( !this.isLocked )\u000a				return;\u000a\u000a			if ( restore ) {\u000a				var selectedElement = this.getSelectedElement(),\u000a					ranges = !selectedElement && this.getRanges(),\u000a					faked = this.isFake;\u000a			}\u000a\u000a			this.isLocked = 0;\u000a			this.reset();\u000a\u000a			if ( restore ) {\u000a				// Saved selection may be outdated (e.g. anchored in offline nodes).\u000a				// Avoid getting broken by such.\u000a				var common = selectedElement || ranges[ 0 ] && ranges[ 0 ].getCommonAncestor();\u000a				if ( !( common && common.getAscendant( 'body', 1 ) ) )\u000a					return;\u000a\u000a				if ( faked )\u000a					this.fake( selectedElement );\u000a				else if ( selectedElement )\u000a					this.selectElement( selectedElement );\u000a				else\u000a					this.selectRanges( ranges );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Clears the selection cache.\u000a		 *\u000a		 *		editor.getSelection().reset();\u000a		 */\u000a		reset: function() {\u000a			this._.cache = {};\u000a			this.isFake = 0;\u000a\u000a			var editor = this.root.editor;\u000a\u000a			// Invalidate any fake selection available in the editor.\u000a			if ( editor && editor._.fakeSelection ) {\u000a				// Test whether this selection is the one that was\u000a				// faked or its clone.\u000a				if ( this.rev == editor._.fakeSelection.rev ) {\u000a					delete editor._.fakeSelection;\u000a\u000a					removeHiddenSelectionContainer( editor );\u000a				}\u000a				// jshint ignore:start\u000a				// TODO after #9786 use commented out lines instead of console.log.\u000a				else { // %REMOVE_LINE%\u000a					window.console && console.log( 'Wrong selection instance resets fake selection.' ); // %REMOVE_LINE%\u000a				} // %REMOVE_LINE%\u000a				// else // %REMOVE_LINE%\u000a				//	CKEDITOR.debug.error( 'Wrong selection instance resets fake selection.', CKEDITOR.DEBUG_CRITICAL ); // %REMOVE_LINE%\u000a				// jshint ignore:end\u000a			}\u000a\u000a			this.rev = nextRev++;\u000a		},\u000a\u000a		/**\u000a		 * Makes the current selection of type {@link CKEDITOR#SELECTION_ELEMENT} by enclosing the specified element.\u000a		 *\u000a		 *		var element = editor.document.getById( 'sampleElement' );\u000a		 *		editor.getSelection().selectElement( element );\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} element The element to enclose in the selection.\u000a		 */\u000a		selectElement: function( element ) {\u000a			var range = new CKEDITOR.dom.range( this.root );\u000a			range.setStartBefore( element );\u000a			range.setEndAfter( element );\u000a			this.selectRanges( [ range ] );\u000a		},\u000a\u000a		/**\u000a		 * Clears the original selection and adds the specified ranges to the document selection.\u000a		 *\u000a		 * 		// Move selection to the end of the editable element.\u000a		 *		var range = editor.createRange();\u000a		 *		range.moveToPosition( range.root, CKEDITOR.POSITION_BEFORE_END );\u000a		 *		editor.getSelection().selectRanges( [ ranges ] );\u000a		 *\u000a		 * @param {Array} ranges An array of {@link CKEDITOR.dom.range} instances\u000a		 * representing ranges to be added to the document.\u000a		 */\u000a		selectRanges: function( ranges ) {\u000a			var editor = this.root.editor,\u000a				hadHiddenSelectionContainer = editor && editor._.hiddenSelectionContainer;\u000a\u000a			this.reset();\u000a\u000a			// Check if there's a hiddenSelectionContainer in editable at some index.\u000a			// Some ranges may be anchored after the hiddenSelectionContainer and,\u000a			// once the container is removed while resetting the selection, they\u000a			// may need new endOffset (one element less within the range) (#11021 #11393).\u000a			if ( hadHiddenSelectionContainer )\u000a				fixRangesAfterHiddenSelectionContainer( ranges, this.root );\u000a\u000a			if ( !ranges.length )\u000a				return;\u000a\u000a			// Refresh the locked selection.\u000a			if ( this.isLocked ) {\u000a				// making a new DOM selection will force the focus on editable in certain situation,\u000a				// we have to save the currently focused element for later recovery.\u000a				var focused = CKEDITOR.document.getActive();\u000a				this.unlock();\u000a				this.selectRanges( ranges );\u000a				this.lock();\u000a				// Return to the previously focused element.\u000a				focused && !focused.equals( this.root ) && focused.focus();\u000a				return;\u000a			}\u000a\u000a			// Handle special case - automatic fake selection on non-editable elements.\u000a			var receiver = getNonEditableFakeSelectionReceiver( ranges );\u000a\u000a			if ( receiver ) {\u000a				this.fake( receiver );\u000a				return;\u000a			}\u000a\u000a			if ( isMSSelection ) {\u000a				var notWhitespaces = CKEDITOR.dom.walker.whitespaces( true ),\u000a					fillerTextRegex = /\u005cufeff|\u005cu00a0/,\u000a					nonCells = { table: 1, tbody: 1, tr: 1 };\u000a\u000a				if ( ranges.length > 1 ) {\u000a					// IE doesn't accept multiple ranges selection, so we join all into one.\u000a					var last = ranges[ ranges.length - 1 ];\u000a					ranges[ 0 ].setEnd( last.endContainer, last.endOffset );\u000a				}\u000a\u000a				var range = ranges[ 0 ];\u000a				var collapsed = range.collapsed,\u000a					isStartMarkerAlone, dummySpan, ieRange;\u000a\u000a				// Try to make a object selection, be careful with selecting phase element in IE\u000a				// will breaks the selection in non-framed environment.\u000a				var selected = range.getEnclosedNode();\u000a				if ( selected && selected.type == CKEDITOR.NODE_ELEMENT && selected.getName() in styleObjectElements &&\u000a					!( selected.is( 'a' ) && selected.getText() ) ) {\u000a					try {\u000a						ieRange = selected.$.createControlRange();\u000a						ieRange.addElement( selected.$ );\u000a						ieRange.select();\u000a						return;\u000a					} catch ( er ) {}\u000a				}\u000a\u000a				// IE doesn't support selecting the entire table row/cell, move the selection into cells, e.g.\u000a				// <table><tbody><tr>[<td>cell</b></td>... => <table><tbody><tr><td>[cell</td>...\u000a				if ( range.startContainer.type == CKEDITOR.NODE_ELEMENT && range.startContainer.getName() in nonCells ||\u000a					range.endContainer.type == CKEDITOR.NODE_ELEMENT && range.endContainer.getName() in nonCells ) {\u000a					range.shrink( CKEDITOR.NODE_ELEMENT, true );\u000a					// The range might get collapsed (#7975). Update cached variable.\u000a					collapsed = range.collapsed;\u000a				}\u000a\u000a				var bookmark = range.createBookmark();\u000a\u000a				// Create marker tags for the start and end boundaries.\u000a				var startNode = bookmark.startNode;\u000a\u000a				var endNode;\u000a				if ( !collapsed )\u000a					endNode = bookmark.endNode;\u000a\u000a				// Create the main range which will be used for the selection.\u000a				ieRange = range.document.$.body.createTextRange();\u000a\u000a				// Position the range at the start boundary.\u000a				ieRange.moveToElementText( startNode.$ );\u000a				ieRange.moveStart( 'character', 1 );\u000a\u000a				if ( endNode ) {\u000a					// Create a tool range for the end.\u000a					var ieRangeEnd = range.document.$.body.createTextRange();\u000a\u000a					// Position the tool range at the end.\u000a					ieRangeEnd.moveToElementText( endNode.$ );\u000a\u000a					// Move the end boundary of the main range to match the tool range.\u000a					ieRange.setEndPoint( 'EndToEnd', ieRangeEnd );\u000a					ieRange.moveEnd( 'character', -1 );\u000a				} else {\u000a					// The isStartMarkerAlone logic comes from V2. It guarantees that the lines\u000a					// will expand and that the cursor will be blinking on the right place.\u000a					// Actually, we are using this flag just to avoid using this hack in all\u000a					// situations, but just on those needed.\u000a					var next = startNode.getNext( notWhitespaces );\u000a					var inPre = startNode.hasAscendant( 'pre' );\u000a					isStartMarkerAlone = ( !( next && next.getText && next.getText().match( fillerTextRegex ) ) && // already a filler there?\u000a						( inPre || !startNode.hasPrevious() || ( startNode.getPrevious().is && startNode.getPrevious().is( 'br' ) ) ) );\u000a\u000a					// Append a temporary <span>&#65279;</span> before the selection.\u000a					// This is needed to avoid IE destroying selections inside empty\u000a					// inline elements, like <b></b> (#253).\u000a					// It is also needed when placing the selection right after an inline\u000a					// element to avoid the selection moving inside of it.\u000a					dummySpan = range.document.createElement( 'span' );\u000a					dummySpan.setHtml( '&#65279;' ); // Zero Width No-Break Space (U+FEFF). See #1359.\u000a					dummySpan.insertBefore( startNode );\u000a\u000a					if ( isStartMarkerAlone ) {\u000a						// To expand empty blocks or line spaces after <br>, we need\u000a						// instead to have any char, which will be later deleted using the\u000a						// selection.\u000a						// \u005cufeff = Zero Width No-Break Space (U+FEFF). (#1359)\u000a						range.document.createText( '\u005cufeff' ).insertBefore( startNode );\u000a					}\u000a				}\u000a\u000a				// Remove the markers (reset the position, because of the changes in the DOM tree).\u000a				range.setStartBefore( startNode );\u000a				startNode.remove();\u000a\u000a				if ( collapsed ) {\u000a					if ( isStartMarkerAlone ) {\u000a						// Move the selection start to include the temporary \u005cufeff.\u000a						ieRange.moveStart( 'character', -1 );\u000a\u000a						ieRange.select();\u000a\u000a						// Remove our temporary stuff.\u000a						range.document.$.selection.clear();\u000a					} else {\u000a						ieRange.select();\u000a					}\u000a\u000a					range.moveToPosition( dummySpan, CKEDITOR.POSITION_BEFORE_START );\u000a					dummySpan.remove();\u000a				} else {\u000a					range.setEndBefore( endNode );\u000a					endNode.remove();\u000a					ieRange.select();\u000a				}\u000a			} else {\u000a				var sel = this.getNative();\u000a\u000a				// getNative() returns null if iframe is "display:none" in FF. (#6577)\u000a				if ( !sel )\u000a					return;\u000a\u000a				this.removeAllRanges();\u000a\u000a				for ( var i = 0; i < ranges.length; i++ ) {\u000a					// Joining sequential ranges introduced by\u000a					// readonly elements protection.\u000a					if ( i < ranges.length - 1 ) {\u000a						var left = ranges[ i ],\u000a							right = ranges[ i + 1 ],\u000a							between = left.clone();\u000a						between.setStart( left.endContainer, left.endOffset );\u000a						between.setEnd( right.startContainer, right.startOffset );\u000a\u000a						// Don't confused by Firefox adjancent multi-ranges\u000a						// introduced by table cells selection.\u000a						if ( !between.collapsed ) {\u000a							between.shrink( CKEDITOR.NODE_ELEMENT, true );\u000a							var ancestor = between.getCommonAncestor(),\u000a								enclosed = between.getEnclosedNode();\u000a\u000a							// The following cases has to be considered:\u000a							// 1. <span contenteditable="false">[placeholder]</span>\u000a							// 2. <input contenteditable="false"  type="radio"/> (#6621)\u000a							if ( ancestor.isReadOnly() || enclosed && enclosed.isReadOnly() ) {\u000a								right.setStart( left.startContainer, left.startOffset );\u000a								ranges.splice( i--, 1 );\u000a								continue;\u000a							}\u000a						}\u000a					}\u000a\u000a					range = ranges[ i ];\u000a\u000a					var nativeRange = this.document.$.createRange();\u000a\u000a					if ( range.collapsed && CKEDITOR.env.webkit && rangeRequiresFix( range ) ) {\u000a						// Append a zero-width space so WebKit will not try to\u000a						// move the selection by itself (#1272).\u000a						var fillingChar = createFillingChar( this.root );\u000a						range.insertNode( fillingChar );\u000a\u000a						next = fillingChar.getNext();\u000a\u000a						// If the filling char is followed by a <br>, whithout\u000a						// having something before it, it'll not blink.\u000a						// Let's remove it in this case.\u000a						if ( next && !fillingChar.getPrevious() && next.type == CKEDITOR.NODE_ELEMENT && next.getName() == 'br' ) {\u000a							removeFillingChar( this.root );\u000a							range.moveToPosition( next, CKEDITOR.POSITION_BEFORE_START );\u000a						} else {\u000a							range.moveToPosition( fillingChar, CKEDITOR.POSITION_AFTER_END );\u000a						}\u000a					}\u000a\u000a					nativeRange.setStart( range.startContainer.$, range.startOffset );\u000a\u000a					try {\u000a						nativeRange.setEnd( range.endContainer.$, range.endOffset );\u000a					} catch ( e ) {\u000a						// There is a bug in Firefox implementation (it would be too easy\u000a						// otherwise). The new start can't be after the end (W3C says it can).\u000a						// So, let's create a new range and collapse it to the desired point.\u000a						if ( e.toString().indexOf( 'NS_ERROR_ILLEGAL_VALUE' ) >= 0 ) {\u000a							range.collapse( 1 );\u000a							nativeRange.setEnd( range.endContainer.$, range.endOffset );\u000a						} else {\u000a							throw e;\u000a						}\u000a					}\u000a\u000a					// Select the range.\u000a					sel.addRange( nativeRange );\u000a				}\u000a			}\u000a\u000a			this.reset();\u000a\u000a			// Fakes the IE DOM event "selectionchange" on editable.\u000a			this.root.fire( 'selectionchange' );\u000a		},\u000a\u000a		/**\u000a		 * Makes a "fake selection" of an element.\u000a		 *\u000a		 * A fake selection does not render UI artifacts over the selected\u000a		 * element. Additionally, the browser native selection system is not\u000a		 * aware of the fake selection. In practice, the native selection is\u000a		 * moved to a hidden place where no native selection UI artifacts are\u000a		 * displayed to the user.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} element The element to be "selected".\u000a		 */\u000a		fake: function( element ) {\u000a			var editor = this.root.editor;\u000a\u000a			// Cleanup after previous selection - e.g. remove hidden sel container.\u000a			this.reset();\u000a\u000a			hideSelection( editor );\u000a\u000a			// Set this value after executing hiseSelection, because it may\u000a			// cause reset() which overwrites cache.\u000a			var cache = this._.cache;\u000a\u000a			// Caches a range than holds the element.\u000a			var range = new CKEDITOR.dom.range( this.root );\u000a			range.setStartBefore( element );\u000a			range.setEndAfter( element );\u000a			cache.ranges = new CKEDITOR.dom.rangeList( range );\u000a\u000a			// Put this element in the cache.\u000a			cache.selectedElement = cache.startElement = element;\u000a			cache.type = CKEDITOR.SELECTION_ELEMENT;\u000a\u000a			// Properties that will not be available when isFake.\u000a			cache.selectedText = cache.nativeSel = null;\u000a\u000a			this.isFake = 1;\u000a			this.rev = nextRev++;\u000a\u000a			// Save this selection, so it can be returned by editor.getSelection().\u000a			editor._.fakeSelection = this;\u000a\u000a			// Fire selectionchange, just like a normal selection.\u000a			this.root.fire( 'selectionchange' );\u000a		},\u000a\u000a		/**\u000a		 * Checks whether selection is placed in hidden element.\u000a		 *\u000a		 * This method is to be used to verify whether fake selection\u000a		 * (see {@link #fake}) is still hidden.\u000a		 *\u000a		 * **Note:** this method should be executed on real selection - e.g.:\u000a		 *\u000a		 *		editor.getSelection( true ).isHidden();\u000a		 *\u000a		 * @returns {Boolean}\u000a		 */\u000a		isHidden: function() {\u000a			var el = this.getCommonAncestor();\u000a\u000a			if ( el && el.type == CKEDITOR.NODE_TEXT )\u000a				el = el.getParent();\u000a\u000a			return !!( el && el.data( 'cke-hidden-sel' ) );\u000a		},\u000a\u000a		/**\u000a		 * Creates a bookmark for each range of this selection (from {@link #getRanges})\u000a		 * by calling the {@link CKEDITOR.dom.range#createBookmark} method,\u000a		 * with extra care taken to avoid interference among those ranges. The arguments\u000a		 * received are the same as with the underlying range method.\u000a		 *\u000a		 *		var bookmarks = editor.getSelection().createBookmarks();\u000a		 *\u000a		 * @returns {Array} Array of bookmarks for each range.\u000a		 */\u000a		createBookmarks: function( serializable ) {\u000a			var bookmark = this.getRanges().createBookmarks( serializable );\u000a			this.isFake && ( bookmark.isFake = 1 );\u000a			return bookmark;\u000a		},\u000a\u000a		/**\u000a		 * Creates a bookmark for each range of this selection (from {@link #getRanges})\u000a		 * by calling the {@link CKEDITOR.dom.range#createBookmark2} method,\u000a		 * with extra care taken to avoid interference among those ranges. The arguments\u000a		 * received are the same as with the underlying range method.\u000a		 *\u000a		 *		var bookmarks = editor.getSelection().createBookmarks2();\u000a		 *\u000a		 * @returns {Array} Array of bookmarks for each range.\u000a		 */\u000a		createBookmarks2: function( normalized ) {\u000a			var bookmark = this.getRanges().createBookmarks2( normalized );\u000a			this.isFake && ( bookmark.isFake = 1 );\u000a			return bookmark;\u000a		},\u000a\u000a		/**\u000a		 * Selects the virtual ranges denoted by the bookmarks by calling {@link #selectRanges}.\u000a		 *\u000a		 *		var bookmarks = editor.getSelection().createBookmarks();\u000a		 *		editor.getSelection().selectBookmarks( bookmarks );\u000a		 *\u000a		 * @param {Array} bookmarks The bookmarks representing ranges to be selected.\u000a		 * @returns {CKEDITOR.dom.selection} This selection object, after the ranges were selected.\u000a		 */\u000a		selectBookmarks: function( bookmarks ) {\u000a			var ranges = [];\u000a			for ( var i = 0; i < bookmarks.length; i++ ) {\u000a				var range = new CKEDITOR.dom.range( this.root );\u000a				range.moveToBookmark( bookmarks[ i ] );\u000a				ranges.push( range );\u000a			}\u000a\u000a			if ( bookmarks.isFake )\u000a				this.fake( ranges[ 0 ].getEnclosedNode() );\u000a			else\u000a				this.selectRanges( ranges );\u000a\u000a			return this;\u000a		},\u000a\u000a		/**\u000a		 * Retrieves the common ancestor node of the first range and the last range.\u000a		 *\u000a		 *		var ancestor = editor.getSelection().getCommonAncestor();\u000a		 *\u000a		 * @returns {CKEDITOR.dom.element} The common ancestor of the selection or `null` if selection is empty.\u000a		 */\u000a		getCommonAncestor: function() {\u000a			var ranges = this.getRanges();\u000a			if ( !ranges.length )\u000a				return null;\u000a\u000a			var startNode = ranges[ 0 ].startContainer,\u000a				endNode = ranges[ ranges.length - 1 ].endContainer;\u000a			return startNode.getCommonAncestor( endNode );\u000a		},\u000a\u000a		/**\u000a		 * Moves the scrollbar to the starting position of the current selection.\u000a		 *\u000a		 *		editor.getSelection().scrollIntoView();\u000a		 */\u000a		scrollIntoView: function() {\u000a			// Scrolls the first range into view.\u000a			if ( this.type != CKEDITOR.SELECTION_NONE )\u000a				this.getRanges()[ 0 ].scrollIntoView();\u000a		},\u000a\u000a		/**\u000a		 * Remove all the selection ranges from the document.\u000a		 */\u000a		removeAllRanges: function() {\u000a			// Don't clear selection outside this selection's root (#11500).\u000a			if ( this.getType() == CKEDITOR.SELECTION_NONE )\u000a				return;\u000a\u000a			var nativ = this.getNative();\u000a\u000a			try {\u000a				nativ && nativ[ isMSSelection ? 'empty' : 'removeAllRanges' ]();\u000a			} catch ( er ) {}\u000a\u000a			this.reset();\u000a		}\u000a	};\u000a\u000a} )();\u000a\u000a\u000a/**\u000a * Fired when selection inside editor has been changed. Note that this event\u000a * is fired only when selection's start element (container of a selecion start)\u000a * changes, not on every possible selection change. Thanks to that `selectionChange`\u000a * is fired less frequently, but on every context\u000a * (the {@link CKEDITOR.editor#elementPath elements path} holding selection's start) change.\u000a *\u000a * @event selectionChange\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param data\u000a * @param {CKEDITOR.dom.selection} data.selection\u000a * @param {CKEDITOR.dom.elementPath} data.path\u000a */\u000a\u000a/**\u000a * Selection's revision. This value is incremented every time new\u000a * selection is created or existing one is modified.\u000a *\u000a * @since 4.3\u000a * @readonly\u000a * @property {Number} rev\u000a */\u000a\u000a/**\u000a * Document in which selection is anchored.\u000a *\u000a * @readonly\u000a * @property {CKEDITOR.dom.document} document\u000a */\u000a\u000a/**\u000a * Selection's root element.\u000a *\u000a * @readonly\u000a * @property {CKEDITOR.dom.element} root\u000a */\u000a\u000a/**\u000a * Whether selection is locked (cannot be modified).\u000a *\u000a * See {@link #lock} and {@link #unlock} methods.\u000a *\u000a * @readonly\u000a * @property {Boolean} isLocked\u000a */\u000a\u000a/**\u000a * Whether selection is a fake selection.\u000a *\u000a * See {@link #fake} method.\u000a *\u000a * @readonly\u000a * @property {Boolean} isFake\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a'use strict';\u000a\u000a/**\u000a * Block style type.\u000a *\u000a * Read more in the {@link CKEDITOR.style} class documentation.\u000a *\u000a * @readonly\u000a * @property {Number} [=1]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.STYLE_BLOCK = 1;\u000a\u000a/**\u000a * Inline style type.\u000a *\u000a * Read more in the {@link CKEDITOR.style} class documentation.\u000a *\u000a * @readonly\u000a * @property {Number} [=2]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.STYLE_INLINE = 2;\u000a\u000a/**\u000a * Object style type.\u000a *\u000a * Read more in the {@link CKEDITOR.style} class documentation.\u000a *\u000a * @readonly\u000a * @property {Number} [=3]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.STYLE_OBJECT = 3;\u000a\u000a( function() {\u000a	var blockElements = {\u000a			address: 1, div: 1, h1: 1, h2: 1, h3: 1, h4: 1, h5: 1, h6: 1, p: 1,\u000a			pre: 1, section: 1, header: 1, footer: 1, nav: 1, article: 1, aside: 1, figure: 1,\u000a			dialog: 1, hgroup: 1, time: 1, meter: 1, menu: 1, command: 1, keygen: 1, output: 1,\u000a			progress: 1, details: 1, datagrid: 1, datalist: 1\u000a		},\u000a\u000a		objectElements = {\u000a			a: 1, blockquote: 1, embed: 1, hr: 1, img: 1, li: 1, object: 1, ol: 1, table: 1, td: 1,\u000a			tr: 1, th: 1, ul: 1, dl: 1, dt: 1, dd: 1, form: 1, audio: 1, video: 1\u000a		};\u000a\u000a	var semicolonFixRegex = /\u005cs*(?:;\u005cs*|$)/,\u000a		varRegex = /#\u005c((.+?)\u005c)/g;\u000a\u000a	var notBookmark = CKEDITOR.dom.walker.bookmark( 0, 1 ),\u000a		nonWhitespaces = CKEDITOR.dom.walker.whitespaces( 1 );\u000a\u000a	/**\u000a	 * A class representing a style instance for the specific style definition.\u000a	 * In this approach, a style is a set of properties, like attributes and styles,\u000a	 * which can be applied to and removed from a {@link CKEDITOR.dom.selection selection} through\u000a	 * {@link CKEDITOR.editor editor} methods: {@link CKEDITOR.editor#applyStyle} and {@link CKEDITOR.editor#removeStyle},\u000a	 * respectively.\u000a	 *\u000a	 * Three default style types are available: {@link CKEDITOR#STYLE_BLOCK STYLE_BLOCK}, {@link CKEDITOR#STYLE_INLINE STYLE_INLINE},\u000a	 * and {@link CKEDITOR#STYLE_OBJECT STYLE_OBJECT}. Based on its type, a style heavily changes its behavior.\u000a	 * You can read more about style types in the [Style Types section of the Styles guide](#!/guide/dev_styles-section-style-types).\u000a	 *\u000a	 * It is possible to define a custom style type by subclassing this class by using the {@link #addCustomHandler} method.\u000a	 * However, because of great complexity of the styles handling job, it is only possible in very specific cases.\u000a	 *\u000a	 * ### Usage\u000a	 *\u000a	 * Basic usage:\u000a	 *\u000a	 *		// Define a block style.\u000a	 *		var style = new CKEDITOR.style( { element: 'h1' } );\u000a	 *\u000a	 *		// Considering the following selection:\u000a	 *		// <p>Foo</p><p>Bar^</p>\u000a	 *		// Executing:\u000a	 *		editor.applyStyle( style );\u000a	 *		// Will give:\u000a	 *		// <p>Foo</p><h1>Bar^</h1>\u000a	 *		style.checkActive( editor.elementPath(), editor ); // -> true\u000a	 *\u000a	 *		editor.removeStyle( style );\u000a	 *		// Will give:\u000a	 *		// <p>Foo</p><p>Bar^</p>\u000a	 *\u000a	 *		style.checkActive( editor.elementPath(), editor ); // -> false\u000a	 *\u000a	 * Object style:\u000a	 *\u000a	 *		// Define an object style.\u000a	 *		var style = new CKEDITOR.style( { element: 'img', attributes: { 'class': 'foo' } } );\u000a	 *\u000a	 *		// Considering the following selection:\u000a	 *		// <p><img src="bar.png" alt="" />Foo^</p>\u000a	 *		// Executing:\u000a	 *		editor.applyStyle( style );\u000a	 *		// Will not apply the style, because the image is not selected.\u000a	 *		// You can check if a style can be applied on the current selection with:\u000a	 *		style.checkApplicable( editor.elementPath(), editor ); // -> false\u000a	 *\u000a	 *		// Considering the following selection:\u000a	 *		// <p>[<img src="bar.png" alt="" />]Foo</p>\u000a	 *		// Executing\u000a	 *		editor.applyStyle( style );\u000a	 *		// Will give:\u000a	 *		// <p>[<img src="bar.png" alt="" class="foo" />]Foo</p>\u000a	 *\u000a	 * ### API changes introduced in CKEditor 4.4\u000a	 *\u000a	 * Before CKEditor 4.4 all style instances had no access at all to the {@link CKEDITOR.editor editor instance}\u000a	 * within which the style is used. Neither the style constructor, nor style methods were requiring\u000a	 * passing the editor instance which made styles independent of the editor and hence its settings and state.\u000a	 * This design decision came from CKEditor 3; it started causing problems and became an unsolvable obstacle for\u000a	 * the {@link CKEDITOR.style.customHandlers.widget widget style handler} which we introduced in CKEditor 4.4.\u000a	 *\u000a	 * There were two possible solutions. Passing an editor instance to the style constructor or to every method.\u000a	 * The first approach would be clean, however, having in mind the backward compatibility, we did not decide\u000a	 * to go for it. It would bind the style to one editor instance, making it unusable with other editor instances.\u000a	 * That could break many implementations reusing styles between editors. Therefore, we decided to take the longer\u000a	 * but safer path &mdash; the editor instance became an argument for nearly all style methods, however,\u000a	 * for backward compatibility reasons, all these methods will work without it. Even the newly\u000a	 * implemented {@link CKEDITOR.style.customHandlers.widget widget style handler}'s methods will not fail,\u000a	 * although they will also not work by aborting at an early stage.\u000a	 *\u000a	 * Therefore, you can safely upgrade to CKEditor 4.4 even if you use style methods without providing\u000a	 * the editor instance. You must only align your code if your implementation should handle widget styles\u000a	 * or any other custom style handler. Of course, we recommend doing this in any case to avoid potential\u000a	 * problems in the future.\u000a	 *\u000a	 * @class\u000a	 * @constructor Creates a style class instance.\u000a	 * @param styleDefinition\u000a	 * @param variablesValues\u000a	 */\u000a	CKEDITOR.style = function( styleDefinition, variablesValues ) {\u000a		if ( typeof styleDefinition.type == 'string' )\u000a			return new CKEDITOR.style.customHandlers[ styleDefinition.type ]( styleDefinition );\u000a\u000a		// Inline style text as attribute should be converted\u000a		// to styles object.\u000a		var attrs = styleDefinition.attributes;\u000a		if ( attrs && attrs.style ) {\u000a			styleDefinition.styles = CKEDITOR.tools.extend( {},\u000a				styleDefinition.styles, CKEDITOR.tools.parseCssText( attrs.style ) );\u000a			delete attrs.style;\u000a		}\u000a\u000a		if ( variablesValues ) {\u000a			styleDefinition = CKEDITOR.tools.clone( styleDefinition );\u000a\u000a			replaceVariables( styleDefinition.attributes, variablesValues );\u000a			replaceVariables( styleDefinition.styles, variablesValues );\u000a		}\u000a\u000a		var element = this.element = styleDefinition.element ?\u000a			(\u000a				typeof styleDefinition.element == 'string' ?\u000a					styleDefinition.element.toLowerCase() : styleDefinition.element\u000a			) : '*';\u000a\u000a		this.type = styleDefinition.type ||\u000a			(\u000a				blockElements[ element ] ? CKEDITOR.STYLE_BLOCK :\u000a				objectElements[ element ] ? CKEDITOR.STYLE_OBJECT :\u000a				CKEDITOR.STYLE_INLINE\u000a			);\u000a\u000a		// If the 'element' property is an object with a set of possible element, it will be applied like an object style: only to existing elements\u000a		if ( typeof this.element == 'object' )\u000a			this.type = CKEDITOR.STYLE_OBJECT;\u000a\u000a		this._ = {\u000a			definition: styleDefinition\u000a		};\u000a	};\u000a\u000a	CKEDITOR.style.prototype = {\u000a		/**\u000a		 * Applies the style on the editor's current selection.\u000a		 *\u000a		 * Before the style is applied, the method checks if the {@link #checkApplicable style is applicable}.\u000a		 *\u000a		 * **Note:** The recommended way of applying the style is by using the\u000a		 * {@link CKEDITOR.editor#applyStyle} method, which is a shorthand for this method.\u000a		 *\u000a		 * @param {CKEDITOR.editor/CKEDITOR.dom.document} editor The editor instance in which\u000a		 * the style will be applied.\u000a		 * A {@link CKEDITOR.dom.document} instance is accepted for backward compatibility\u000a		 * reasons, although since CKEditor 4.4 this type of argument is deprecated. Read more about\u000a		 * the signature change in the {@link CKEDITOR.style} documentation.\u000a		 */\u000a		apply: function( editor ) {\u000a			// Backward compatibility.\u000a			if ( editor instanceof CKEDITOR.dom.document )\u000a				return applyStyleOnSelection.call( this, editor.getSelection() );\u000a\u000a			if ( this.checkApplicable( editor.elementPath(), editor ) ) {\u000a				var initialEnterMode = this._.enterMode;\u000a\u000a				// See comment in removeStyle.\u000a				if ( !initialEnterMode )\u000a					this._.enterMode = editor.activeEnterMode;\u000a				applyStyleOnSelection.call( this, editor.getSelection(), 0, editor );\u000a				this._.enterMode = initialEnterMode;\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Removes the style from the editor's current selection.\u000a		 *\u000a		 * Before the style is applied, the method checks if {@link #checkApplicable style could be applied}.\u000a		 *\u000a		 * **Note:** The recommended way of removing the style is by using the\u000a		 * {@link CKEDITOR.editor#removeStyle} method, which is a shorthand for this method.\u000a		 *\u000a		 * @param {CKEDITOR.editor/CKEDITOR.dom.document} editor The editor instance in which\u000a		 * the style will be removed.\u000a		 * A {@link CKEDITOR.dom.document} instance is accepted for backward compatibility\u000a		 * reasons, although since CKEditor 4.4 this type of argument is deprecated. Read more about\u000a		 * the signature change in the {@link CKEDITOR.style} documentation.\u000a		 */\u000a		remove: function( editor ) {\u000a			// Backward compatibility.\u000a			if ( editor instanceof CKEDITOR.dom.document )\u000a				return applyStyleOnSelection.call( this, editor.getSelection(), 1 );\u000a\u000a			if ( this.checkApplicable( editor.elementPath(), editor ) ) {\u000a				var initialEnterMode = this._.enterMode;\u000a\u000a				// Before CKEditor 4.4 style knew nothing about editor, so in order to provide enterMode\u000a				// which should be used developers were forced to hack the style object (see #10190).\u000a				// Since CKEditor 4.4 style knows about editor (at least when it's being applied/removed), but we\u000a				// use _.enterMode for backward compatibility with those hacks.\u000a				// Note: we should not change style's enter mode if it was already set.\u000a				if ( !initialEnterMode )\u000a					this._.enterMode = editor.activeEnterMode;\u000a				applyStyleOnSelection.call( this, editor.getSelection(), 1, editor );\u000a				this._.enterMode = initialEnterMode;\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Applies the style on the provided range. Unlike {@link #apply} this\u000a		 * method does not take care of setting the selection, however, the range\u000a		 * is updated to the correct place.\u000a		 *\u000a		 * **Note:** If you want to apply the style on the editor selection,\u000a		 * you probably want to use {@link CKEDITOR.editor#applyStyle}.\u000a		 *\u000a		 * @param {CKEDITOR.dom.range} range\u000a		 * @param {CKEDITOR.editor} editor The editor instance. Required argument since\u000a		 * CKEditor 4.4. The style system will work without it, but it is highly\u000a		 * recommended to provide it for integration with all features.  Read more about\u000a		 * the signature change in the {@link CKEDITOR.style} documentation.\u000a		 */\u000a		applyToRange: function( range ) {\u000a			this.applyToRange =\u000a				this.type == CKEDITOR.STYLE_INLINE ? applyInlineStyle :\u000a				this.type == CKEDITOR.STYLE_BLOCK ? applyBlockStyle :\u000a				this.type == CKEDITOR.STYLE_OBJECT ? applyObjectStyle :\u000a				null;\u000a\u000a			return this.applyToRange( range );\u000a		},\u000a\u000a		/**\u000a		 * Removes the style from the provided range. Unlike {@link #remove} this\u000a		 * method does not take care of setting the selection, however, the range\u000a		 * is updated to the correct place.\u000a		 *\u000a		 * **Note:** If you want to remove the style from the editor selection,\u000a		 * you probably want to use {@link CKEDITOR.editor#removeStyle}.\u000a		 *\u000a		 * @param {CKEDITOR.dom.range} range\u000a		 * @param {CKEDITOR.editor} editor The editor instance. Required argument since\u000a		 * CKEditor 4.4. The style system will work without it, but it is highly\u000a		 * recommended to provide it for integration with all features. Read more about\u000a		 * the signature change in the {@link CKEDITOR.style} documentation.\u000a		 */\u000a		removeFromRange: function( range ) {\u000a			this.removeFromRange =\u000a				this.type == CKEDITOR.STYLE_INLINE ? removeInlineStyle :\u000a				this.type == CKEDITOR.STYLE_BLOCK ? removeBlockStyle :\u000a				this.type == CKEDITOR.STYLE_OBJECT ? removeObjectStyle :\u000a				null;\u000a\u000a			return this.removeFromRange( range );\u000a		},\u000a\u000a		/**\u000a		 * Applies the style to the element. This method bypasses all checks\u000a		 * and applies the style attributes directly on the provided element. Use with caution.\u000a		 *\u000a		 * See {@link CKEDITOR.editor#applyStyle}.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} element\u000a		 * @param {CKEDITOR.editor} editor The editor instance. Required argument since\u000a		 * CKEditor 4.4. The style system will work without it, but it is highly\u000a		 * recommended to provide it for integration with all features. Read more about\u000a		 * the signature change in the {@link CKEDITOR.style} documentation.\u000a		 */\u000a		applyToObject: function( element ) {\u000a			setupElement( element, this );\u000a		},\u000a\u000a		/**\u000a		 * Gets the style state inside the elements path.\u000a		 *\u000a		 * @param {CKEDITOR.dom.elementPath} elementPath\u000a		 * @param {CKEDITOR.editor} editor The editor instance. Required argument since\u000a		 * CKEditor 4.4. The style system will work without it, but it is highly\u000a		 * recommended to provide it for integration with all features. Read more about\u000a		 * the signature change in the {@link CKEDITOR.style} documentation.\u000a		 * @returns {Boolean} `true` if the element is active in the elements path.\u000a		 */\u000a		checkActive: function( elementPath, editor ) {\u000a			switch ( this.type ) {\u000a				case CKEDITOR.STYLE_BLOCK:\u000a					return this.checkElementRemovable( elementPath.block || elementPath.blockLimit, true, editor );\u000a\u000a				case CKEDITOR.STYLE_OBJECT:\u000a				case CKEDITOR.STYLE_INLINE:\u000a\u000a					var elements = elementPath.elements;\u000a\u000a					for ( var i = 0, element; i < elements.length; i++ ) {\u000a						element = elements[ i ];\u000a\u000a						if ( this.type == CKEDITOR.STYLE_INLINE && ( element == elementPath.block || element == elementPath.blockLimit ) )\u000a							continue;\u000a\u000a						if ( this.type == CKEDITOR.STYLE_OBJECT ) {\u000a							var name = element.getName();\u000a							if ( !( typeof this.element == 'string' ? name == this.element : name in this.element ) )\u000a								continue;\u000a						}\u000a\u000a						if ( this.checkElementRemovable( element, true, editor ) )\u000a							return true;\u000a					}\u000a			}\u000a			return false;\u000a		},\u000a\u000a		/**\u000a		 * Whether this style can be applied at the specified elements path.\u000a		 *\u000a		 * @param {CKEDITOR.dom.elementPath} elementPath The elements path to\u000a		 * check the style against.\u000a		 * @param {CKEDITOR.editor} editor The editor instance. Required argument since\u000a		 * CKEditor 4.4. The style system will work without it, but it is highly\u000a		 * recommended to provide it for integration with all features. Read more about\u000a		 * the signature change in the {@link CKEDITOR.style} documentation.\u000a		 * @param {CKEDITOR.filter} [filter] If defined, the style will be\u000a		 * checked against this filter as well.\u000a		 * @returns {Boolean} `true` if this style can be applied at the elements path.\u000a		 */\u000a		checkApplicable: function( elementPath, editor, filter ) {\u000a			// Backward compatibility.\u000a			if ( editor && editor instanceof CKEDITOR.filter )\u000a				filter = editor;\u000a\u000a			if ( filter && !filter.check( this ) )\u000a				return false;\u000a\u000a			switch ( this.type ) {\u000a				case CKEDITOR.STYLE_OBJECT:\u000a					return !!elementPath.contains( this.element );\u000a				case CKEDITOR.STYLE_BLOCK:\u000a					return !!elementPath.blockLimit.getDtd()[ this.element ];\u000a			}\u000a\u000a			return true;\u000a		},\u000a\u000a		/**\u000a		 * Checks if the element matches the current style definition.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} element\u000a		 * @param {Boolean} fullMatch\u000a		 * @param {CKEDITOR.editor} editor The editor instance. Required argument since\u000a		 * CKEditor 4.4. The style system will work without it, but it is highly\u000a		 * recommended to provide it for integration with all features. Read more about\u000a		 * the signature change in the {@link CKEDITOR.style} documentation.\u000a		 * @returns {Boolean}\u000a		 */\u000a		checkElementMatch: function( element, fullMatch ) {\u000a			var def = this._.definition;\u000a\u000a			if ( !element || !def.ignoreReadonly && element.isReadOnly() )\u000a				return false;\u000a\u000a			var attribs,\u000a				name = element.getName();\u000a\u000a			// If the element name is the same as the style name.\u000a			if ( typeof this.element == 'string' ? name == this.element : name in this.element ) {\u000a				// If no attributes are defined in the element.\u000a				if ( !fullMatch && !element.hasAttributes() )\u000a					return true;\u000a\u000a				attribs = getAttributesForComparison( def );\u000a\u000a				if ( attribs._length ) {\u000a					for ( var attName in attribs ) {\u000a						if ( attName == '_length' )\u000a							continue;\u000a\u000a						var elementAttr = element.getAttribute( attName ) || '';\u000a\u000a						// Special treatment for 'style' attribute is required.\u000a						if ( attName == 'style' ? compareCssText( attribs[ attName ], elementAttr ) : attribs[ attName ] == elementAttr ) {\u000a							if ( !fullMatch )\u000a								return true;\u000a						} else if ( fullMatch ) {\u000a							return false;\u000a						}\u000a					}\u000a					if ( fullMatch )\u000a						return true;\u000a				} else {\u000a					return true;\u000a				}\u000a			}\u000a\u000a			return false;\u000a		},\u000a\u000a		/**\u000a		 * Checks if an element, or any of its attributes, is removable by the\u000a		 * current style definition.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} element\u000a		 * @param {Boolean} fullMatch\u000a		 * @param {CKEDITOR.editor} editor The editor instance. Required argument since\u000a		 * CKEditor 4.4. The style system will work without it, but it is highly\u000a		 * recommended to provide it for integration with all features. Read more about\u000a		 * the signature change in the {@link CKEDITOR.style} documentation.\u000a		 * @returns {Boolean}\u000a		 */\u000a		checkElementRemovable: function( element, fullMatch, editor ) {\u000a			// Check element matches the style itself.\u000a			if ( this.checkElementMatch( element, fullMatch, editor ) )\u000a				return true;\u000a\u000a			// Check if the element matches the style overrides.\u000a			var override = getOverrides( this )[ element.getName() ];\u000a			if ( override ) {\u000a				var attribs, attName;\u000a\u000a				// If no attributes have been defined, remove the element.\u000a				if ( !( attribs = override.attributes ) )\u000a					return true;\u000a\u000a				for ( var i = 0; i < attribs.length; i++ ) {\u000a					attName = attribs[ i ][ 0 ];\u000a					var actualAttrValue = element.getAttribute( attName );\u000a					if ( actualAttrValue ) {\u000a						var attValue = attribs[ i ][ 1 ];\u000a\u000a						// Remove the attribute if:\u000a						//    - The override definition value is null;\u000a						//    - The override definition value is a string that\u000a						//      matches the attribute value exactly.\u000a						//    - The override definition value is a regex that\u000a						//      has matches in the attribute value.\u000a						if ( attValue === null || ( typeof attValue == 'string' && actualAttrValue == attValue ) || attValue.test( actualAttrValue ) )\u000a							return true;\u000a					}\u000a				}\u000a			}\u000a			return false;\u000a		},\u000a\u000a		/**\u000a		 * Builds the preview HTML based on the styles definition.\u000a		 *\u000a		 * @param {String} [label] The label used in the style preview.\u000a		 * @return {String} The HTML of preview.\u000a		 */\u000a		buildPreview: function( label ) {\u000a			var styleDefinition = this._.definition,\u000a				html = [],\u000a				elementName = styleDefinition.element;\u000a\u000a			// Avoid <bdo> in the preview.\u000a			if ( elementName == 'bdo' )\u000a				elementName = 'span';\u000a\u000a			html = [ '<', elementName ];\u000a\u000a			// Assign all defined attributes.\u000a			var attribs = styleDefinition.attributes;\u000a			if ( attribs ) {\u000a				for ( var att in attribs )\u000a					html.push( ' ', att, '="', attribs[ att ], '"' );\u000a			}\u000a\u000a			// Assign the style attribute.\u000a			var cssStyle = CKEDITOR.style.getStyleText( styleDefinition );\u000a			if ( cssStyle )\u000a				html.push( ' style="', cssStyle, '"' );\u000a\u000a			html.push( '>', ( label || styleDefinition.name ), '</', elementName, '>' );\u000a\u000a			return html.join( '' );\u000a		},\u000a\u000a		/**\u000a		 * Returns the style definition.\u000a		 *\u000a		 * @since 4.1\u000a		 * @returns {Object}\u000a		 */\u000a		getDefinition: function() {\u000a			return this._.definition;\u000a		}\u000a\u000a		/**\u000a		 * If defined (for example by {@link CKEDITOR.style#addCustomHandler custom style handler}), it returns\u000a		 * the {@link CKEDITOR.filter.allowedContentRules allowed content rules} which should be added to the\u000a		 * {@link CKEDITOR.filter} when enabling this style.\u000a		 *\u000a		 * **Note:** This method is not defined in the {@link CKEDITOR.style} class.\u000a		 *\u000a		 * @since 4.4\u000a		 * @method toAllowedContentRules\u000a		 * @param {CKEDITOR.editor} [editor] The editor instance.\u000a		 * @returns {CKEDITOR.filter.allowedContentRules} The rules that should represent this style in the {@link CKEDITOR.filter}.\u000a		 */\u000a	};\u000a\u000a	/**\u000a	 * Builds the inline style text based on the style definition.\u000a	 *\u000a	 * @static\u000a	 * @param styleDefinition\u000a	 * @returns {String} Inline style text.\u000a	 */\u000a	CKEDITOR.style.getStyleText = function( styleDefinition ) {\u000a		// If we have already computed it, just return it.\u000a		var stylesDef = styleDefinition._ST;\u000a		if ( stylesDef )\u000a			return stylesDef;\u000a\u000a		stylesDef = styleDefinition.styles;\u000a\u000a		// Builds the StyleText.\u000a		var stylesText = ( styleDefinition.attributes && styleDefinition.attributes.style ) || '',\u000a			specialStylesText = '';\u000a\u000a		if ( stylesText.length )\u000a			stylesText = stylesText.replace( semicolonFixRegex, ';' );\u000a\u000a		for ( var style in stylesDef ) {\u000a			var styleVal = stylesDef[ style ],\u000a				text = ( style + ':' + styleVal ).replace( semicolonFixRegex, ';' );\u000a\u000a			// Some browsers don't support 'inherit' property value, leave them intact. (#5242)\u000a			if ( styleVal == 'inherit' )\u000a				specialStylesText += text;\u000a			else\u000a				stylesText += text;\u000a		}\u000a\u000a		// Browsers make some changes to the style when applying them. So, here\u000a		// we normalize it to the browser format.\u000a		if ( stylesText.length )\u000a			stylesText = CKEDITOR.tools.normalizeCssText( stylesText, true );\u000a\u000a		stylesText += specialStylesText;\u000a\u000a		// Return it, saving it to the next request.\u000a		return ( styleDefinition._ST = stylesText );\u000a	};\u000a\u000a	/**\u000a	 * Namespace containing custom style handlers added with {@link CKEDITOR.style#addCustomHandler}.\u000a	 *\u000a	 * @since 4.4\u000a	 * @class\u000a	 * @singleton\u000a	 */\u000a	CKEDITOR.style.customHandlers = {};\u000a\u000a	/**\u000a	 * Creates a {@link CKEDITOR.style} subclass and registers it in the style system.\u000a	 * Registered class will be used as a handler for a style of this type. This allows\u000a	 * to extend the styles system, which by default uses only the {@link CKEDITOR.style}, with\u000a	 * new functionality. Registered classes are accessible in the {@link CKEDITOR.style.customHandlers}.\u000a	 *\u000a	 * ### The Style Class Definition\u000a	 *\u000a	 * The definition object is used to override properties in a prototype inherited\u000a	 * from the {@link CKEDITOR.style} class. It must contain a `type` property which is\u000a	 * a name of the new type and therefore it must be unique. The default style types\u000a	 * ({@link CKEDITOR#STYLE_BLOCK STYLE_BLOCK}, {@link CKEDITOR#STYLE_INLINE STYLE_INLINE},\u000a	 * and {@link CKEDITOR#STYLE_OBJECT STYLE_OBJECT}) are integers, but for easier identification\u000a	 * it is recommended to use strings as custom type names.\u000a	 *\u000a	 * Besides `type`, the definition may contain two more special properties:\u000a	 *\u000a	 *  * `setup {Function}` &ndash; An optional callback executed when a style instance is created.\u000a	 * Like the style constructor, it is executed in style context and with the style definition as an argument.\u000a	 *  * `assignedTo {Number}` &ndash; Can be set to one of the default style types. Some editor\u000a	 * features like the Styles drop-down assign styles to one of the default groups based on\u000a	 * the style type. By using this property it is possible to notify them to which group this\u000a	 * custom style should be assigned. It defaults to the {@link CKEDITOR#STYLE_OBJECT}.\u000a	 *\u000a	 * Other properties of the definition object will just be used to extend the prototype inherited\u000a	 * from the {@link CKEDITOR.style} class. So if the definition contains an `apply` method, it will\u000a	 * override the {@link CKEDITOR.style#apply} method.\u000a	 *\u000a	 * ### Usage\u000a	 *\u000a	 * Registering a basic handler:\u000a	 *\u000a	 *		var styleClass = CKEDITOR.style.addCustomHandler( {\u000a	 *			type: 'custom'\u000a	 *		} );\u000a	 *\u000a	 *		var style = new styleClass( { ... } );\u000a	 *		style instanceof styleClass; // -> true\u000a	 *		style instanceof CKEDITOR.style; // -> true\u000a	 *		style.type; // -> 'custom'\u000a	 *\u000a	 * The {@link CKEDITOR.style} constructor used as a factory:\u000a	 *\u000a	 *		var styleClass = CKEDITOR.style.addCustomHandler( {\u000a	 *			type: 'custom'\u000a	 *		} );\u000a	 *\u000a	 *		// Style constructor accepts style definition (do not confuse with style class definition).\u000a	 *		var style = new CKEDITOR.style( { type: 'custom', attributes: ... } );\u000a	 *		style instanceof styleClass; // -> true\u000a	 *\u000a	 * Thanks to that, integration code using styles does not need to know\u000a	 * which style handler it should use. It is determined by the {@link CKEDITOR.style} constructor.\u000a	 *\u000a	 * Overriding existing {@link CKEDITOR.style} methods:\u000a	 *\u000a	 *		var styleClass = CKEDITOR.style.addCustomHandler( {\u000a	 *			type: 'custom',\u000a	 *			apply: function( editor ) {\u000a	 *				console.log( 'apply' );\u000a	 *			},\u000a	 *			remove: function( editor ) {\u000a	 *				console.log( 'remove' );\u000a	 *			}\u000a	 *		} );\u000a	 *\u000a	 *		var style = new CKEDITOR.style( { type: 'custom', attributes: ... } );\u000a	 *		editor.applyStyle( style ); // logged 'apply'\u000a	 *\u000a	 *		style = new CKEDITOR.style( { element: 'img', attributes: { 'class': 'foo' } } );\u000a	 *		editor.applyStyle( style ); // style is really applied if image was selected\u000a	 *\u000a	 * ### Practical Recommendations\u000a	 *\u000a	 * The style handling job, which includes such tasks as applying, removing, checking state, and\u000a	 * checking if a style can be applied, is very complex. Therefore without deep knowledge\u000a	 * about DOM and especially {@link CKEDITOR.dom.range ranges} and {@link CKEDITOR.dom.walker DOM walker} it is impossible\u000a	 * to implement a completely custom style handler able to handle block, inline, and object type styles.\u000a	 * However, it is possible to customize the default implementation by overriding default methods and\u000a	 * reusing them.\u000a	 *\u000a	 * The only style handler which can be implemented from scratch without huge effort is a style\u000a	 * applicable to objects ([read more about types](http://docs.ckeditor.com/#!/guide/dev_styles-section-style-types)).\u000a	 * Such style can only be applied when a specific object is selected. An example implementation can\u000a	 * be found in the [widget plugin](https://github.com/ckeditor/ckeditor-dev/blob/master/plugins/widget/plugin.js).\u000a	 *\u000a	 * When implementing a style handler from scratch at least the following methods must be defined:\u000a	 *\u000a	 * * {@link CKEDITOR.style#apply apply} and {@link CKEDITOR.style#remove remove},\u000a	 * * {@link CKEDITOR.style#checkElementRemovable checkElementRemovable} and\u000a	 * {@link CKEDITOR.style#checkElementMatch checkElementMatch} &ndash; Note that both methods reuse the same logic,\u000a	 * * {@link CKEDITOR.style#checkActive checkActive} &ndash; Reuses\u000a	 * {@link CKEDITOR.style#checkElementMatch checkElementMatch},\u000a	 * * {@link CKEDITOR.style#toAllowedContentRules toAllowedContentRules} &ndash; Not required, but very useful in\u000a	 * case of a custom style that has to notify the {@link CKEDITOR.filter} which rules it allows when registered.\u000a	 *\u000a	 * @since 4.4\u000a	 * @static\u000a	 * @member CKEDITOR.style\u000a	 * @param definition The style class definition.\u000a	 * @returns {CKEDITOR.style} The new style class created for the provided definition.\u000a	 */\u000a	CKEDITOR.style.addCustomHandler = function( definition ) {\u000a		var styleClass = function( styleDefinition ) {\u000a			this._ = {\u000a				definition: styleDefinition\u000a			};\u000a\u000a			if ( this.setup )\u000a				this.setup( styleDefinition );\u000a		};\u000a\u000a		styleClass.prototype = CKEDITOR.tools.extend(\u000a			// Prototype of CKEDITOR.style.\u000a			CKEDITOR.tools.prototypedCopy( CKEDITOR.style.prototype ),\u000a			// Defaults.\u000a			{\u000a				assignedTo: CKEDITOR.STYLE_OBJECT\u000a			},\u000a			// Passed definition - overrides.\u000a			definition,\u000a			true\u000a		);\u000a\u000a		this.customHandlers[ definition.type ] = styleClass;\u000a\u000a		return styleClass;\u000a	};\u000a\u000a	// Gets the parent element which blocks the styling for an element. This\u000a	// can be done through read-only elements (contenteditable=false) or\u000a	// elements with the "data-nostyle" attribute.\u000a	function getUnstylableParent( element, root ) {\u000a		var unstylable, editable;\u000a\u000a		while ( ( element = element.getParent() ) ) {\u000a			if ( element.equals( root ) )\u000a				break;\u000a\u000a			if ( element.getAttribute( 'data-nostyle' ) )\u000a				unstylable = element;\u000a			else if ( !editable ) {\u000a				var contentEditable = element.getAttribute( 'contentEditable' );\u000a\u000a				if ( contentEditable == 'false' )\u000a					unstylable = element;\u000a				else if ( contentEditable == 'true' )\u000a					editable = 1;\u000a			}\u000a		}\u000a\u000a		return unstylable;\u000a	}\u000a\u000a	var posPrecedingIdenticalContained =\u000a			CKEDITOR.POSITION_PRECEDING | CKEDITOR.POSITION_IDENTICAL | CKEDITOR.POSITION_IS_CONTAINED,\u000a		posFollowingIdenticalContained =\u000a			CKEDITOR.POSITION_FOLLOWING | CKEDITOR.POSITION_IDENTICAL | CKEDITOR.POSITION_IS_CONTAINED;\u000a\u000a	// Checks if the current node can be a child of the style element.\u000a	function checkIfNodeCanBeChildOfStyle( def, currentNode, lastNode, nodeName, dtd, nodeIsNoStyle, nodeIsReadonly, includeReadonly ) {\u000a		// Style can be applied to text node.\u000a		if ( !nodeName )\u000a			return 1;\u000a\u000a		// Style definitely cannot be applied if DTD or data-nostyle do not allow.\u000a		if ( !dtd[ nodeName ] || nodeIsNoStyle  )\u000a			return 0;\u000a\u000a		// Non-editable element cannot be styled is we shouldn't include readonly elements.\u000a		if ( nodeIsReadonly && !includeReadonly  )\u000a			return 0;\u000a\u000a		// Check that we haven't passed lastNode yet and that style's childRule allows this style on current element.\u000a		return checkPositionAndRule( currentNode, lastNode, def, posPrecedingIdenticalContained );\u000a	}\u000a\u000a	// Check if the style element can be a child of the current\u000a	// node parent or if the element is not defined in the DTD.\u000a	function checkIfStyleCanBeChildOf( def, currentParent, elementName, isUnknownElement ) {\u000a		return currentParent &&\u000a			( ( currentParent.getDtd() || CKEDITOR.dtd.span )[ elementName ] || isUnknownElement ) &&\u000a			( !def.parentRule || def.parentRule( currentParent ) );\u000a	}\u000a\u000a	function checkIfStartsRange( nodeName, currentNode, lastNode ) {\u000a		return (\u000a			!nodeName || !CKEDITOR.dtd.$removeEmpty[ nodeName ] ||\u000a			( currentNode.getPosition( lastNode ) | posPrecedingIdenticalContained ) == posPrecedingIdenticalContained\u000a		);\u000a	}\u000a\u000a	function checkIfTextOrReadonlyOrEmptyElement( currentNode, nodeIsReadonly ) {\u000a		var nodeType = currentNode.type;\u000a		return nodeType == CKEDITOR.NODE_TEXT || nodeIsReadonly || ( nodeType == CKEDITOR.NODE_ELEMENT && !currentNode.getChildCount() );\u000a	}\u000a\u000a	// Checks if position is a subset of posBitFlags and that nodeA fulfills style def rule.\u000a	function checkPositionAndRule( nodeA, nodeB, def, posBitFlags ) {\u000a		return ( nodeA.getPosition( nodeB ) | posBitFlags ) == posBitFlags &&\u000a			( !def.childRule || def.childRule( nodeA ) );\u000a	}\u000a\u000a	function applyInlineStyle( range ) {\u000a		var document = range.document;\u000a\u000a		if ( range.collapsed ) {\u000a			// Create the element to be inserted in the DOM.\u000a			var collapsedElement = getElement( this, document );\u000a\u000a			// Insert the empty element into the DOM at the range position.\u000a			range.insertNode( collapsedElement );\u000a\u000a			// Place the selection right inside the empty element.\u000a			range.moveToPosition( collapsedElement, CKEDITOR.POSITION_BEFORE_END );\u000a\u000a			return;\u000a		}\u000a\u000a		var elementName = this.element,\u000a			def = this._.definition,\u000a			isUnknownElement;\u000a\u000a		// Indicates that fully selected read-only elements are to be included in the styling range.\u000a		var ignoreReadonly = def.ignoreReadonly,\u000a			includeReadonly = ignoreReadonly || def.includeReadonly;\u000a\u000a		// If the read-only inclusion is not available in the definition, try\u000a		// to get it from the root data (most often it's the editable).\u000a		if ( includeReadonly == null )\u000a			includeReadonly = range.root.getCustomData( 'cke_includeReadonly' );\u000a\u000a		// Get the DTD definition for the element. Defaults to "span".\u000a		var dtd = CKEDITOR.dtd[ elementName ];\u000a		if ( !dtd ) {\u000a			isUnknownElement = true;\u000a			dtd = CKEDITOR.dtd.span;\u000a		}\u000a\u000a		// Expand the range.\u000a		range.enlarge( CKEDITOR.ENLARGE_INLINE, 1 );\u000a		range.trim();\u000a\u000a		// Get the first node to be processed and the last, which concludes the processing.\u000a		var boundaryNodes = range.createBookmark(),\u000a			firstNode = boundaryNodes.startNode,\u000a			lastNode = boundaryNodes.endNode,\u000a			currentNode = firstNode,\u000a			styleRange;\u000a\u000a		if ( !ignoreReadonly ) {\u000a			// Check if the boundaries are inside non stylable elements.\u000a			var root = range.getCommonAncestor(),\u000a				firstUnstylable = getUnstylableParent( firstNode, root ),\u000a				lastUnstylable = getUnstylableParent( lastNode, root );\u000a\u000a			// If the first element can't be styled, we'll start processing right\u000a			// after its unstylable root.\u000a			if ( firstUnstylable )\u000a				currentNode = firstUnstylable.getNextSourceNode( true );\u000a\u000a			// If the last element can't be styled, we'll stop processing on its\u000a			// unstylable root.\u000a			if ( lastUnstylable )\u000a				lastNode = lastUnstylable;\u000a		}\u000a\u000a		// Do nothing if the current node now follows the last node to be processed.\u000a		if ( currentNode.getPosition( lastNode ) == CKEDITOR.POSITION_FOLLOWING )\u000a			currentNode = 0;\u000a\u000a		while ( currentNode ) {\u000a			var applyStyle = false;\u000a\u000a			if ( currentNode.equals( lastNode ) ) {\u000a				currentNode = null;\u000a				applyStyle = true;\u000a			} else {\u000a				var nodeName = currentNode.type == CKEDITOR.NODE_ELEMENT ? currentNode.getName() : null,\u000a					nodeIsReadonly = nodeName && ( currentNode.getAttribute( 'contentEditable' ) == 'false' ),\u000a					nodeIsNoStyle = nodeName && currentNode.getAttribute( 'data-nostyle' );\u000a\u000a				// Skip bookmarks.\u000a				if ( nodeName && currentNode.data( 'cke-bookmark' ) ) {\u000a					currentNode = currentNode.getNextSourceNode( true );\u000a					continue;\u000a				}\u000a\u000a				// Find all nested editables of a non-editable block and apply this style inside them.\u000a				if ( nodeIsReadonly && includeReadonly && CKEDITOR.dtd.$block[ nodeName ] )\u000a					applyStyleOnNestedEditables.call( this, currentNode );\u000a\u000a				// Check if the current node can be a child of the style element.\u000a				if ( checkIfNodeCanBeChildOfStyle( def, currentNode, lastNode, nodeName, dtd, nodeIsNoStyle, nodeIsReadonly, includeReadonly ) ) {\u000a					var currentParent = currentNode.getParent();\u000a\u000a					// Check if the style element can be a child of the current\u000a					// node parent or if the element is not defined in the DTD.\u000a					if ( checkIfStyleCanBeChildOf( def, currentParent, elementName, isUnknownElement ) ) {\u000a						// This node will be part of our range, so if it has not\u000a						// been started, place its start right before the node.\u000a						// In the case of an element node, it will be included\u000a						// only if it is entirely inside the range.\u000a						if ( !styleRange && checkIfStartsRange( nodeName, currentNode, lastNode ) ) {\u000a							styleRange = range.clone();\u000a							styleRange.setStartBefore( currentNode );\u000a						}\u000a\u000a						// Non element nodes, readonly elements, or empty\u000a						// elements can be added completely to the range.\u000a						if ( checkIfTextOrReadonlyOrEmptyElement( currentNode, nodeIsReadonly ) ) {\u000a							var includedNode = currentNode;\u000a							var parentNode;\u000a\u000a							// This node is about to be included completelly, but,\u000a							// if this is the last node in its parent, we must also\u000a							// check if the parent itself can be added completelly\u000a							// to the range, otherwise apply the style immediately.\u000a							while (\u000a								( applyStyle = !includedNode.getNext( notBookmark ) ) &&\u000a								( parentNode = includedNode.getParent(), dtd[ parentNode.getName() ] ) &&\u000a								checkPositionAndRule( parentNode, firstNode, def, posFollowingIdenticalContained )\u000a							) {\u000a								includedNode = parentNode;\u000a							}\u000a\u000a							styleRange.setEndAfter( includedNode );\u000a\u000a						}\u000a					} else {\u000a						applyStyle = true;\u000a					}\u000a				}\u000a				// Style isn't applicable to current element, so apply style to\u000a				// range ending at previously chosen position, or nowhere if we haven't\u000a				// yet started styleRange.\u000a				else {\u000a					applyStyle = true;\u000a				}\u000a\u000a				// Get the next node to be processed.\u000a				// If we're currently on a non-editable element or non-styleable element,\u000a				// then we'll be moved to current node's sibling (or even further), so we'll\u000a				// avoid messing up its content.\u000a				currentNode = currentNode.getNextSourceNode( nodeIsNoStyle || nodeIsReadonly );\u000a			}\u000a\u000a			// Apply the style if we have something to which apply it.\u000a			if ( applyStyle && styleRange && !styleRange.collapsed ) {\u000a				// Build the style element, based on the style object definition.\u000a				var styleNode = getElement( this, document ),\u000a					styleHasAttrs = styleNode.hasAttributes();\u000a\u000a				// Get the element that holds the entire range.\u000a				var parent = styleRange.getCommonAncestor();\u000a\u000a				var removeList = {\u000a					styles: {},\u000a					attrs: {},\u000a					// Styles cannot be removed.\u000a					blockedStyles: {},\u000a					// Attrs cannot be removed.\u000a					blockedAttrs: {}\u000a				};\u000a\u000a				var attName, styleName, value;\u000a\u000a				// Loop through the parents, removing the redundant attributes\u000a				// from the element to be applied.\u000a				while ( styleNode && parent ) {\u000a					if ( parent.getName() == elementName ) {\u000a						for ( attName in def.attributes ) {\u000a							if ( removeList.blockedAttrs[ attName ] || !( value = parent.getAttribute( styleName ) ) )\u000a								continue;\u000a\u000a							if ( styleNode.getAttribute( attName ) == value )\u000a								removeList.attrs[ attName ] = 1;\u000a							else\u000a								removeList.blockedAttrs[ attName ] = 1;\u000a						}\u000a\u000a						for ( styleName in def.styles ) {\u000a							if ( removeList.blockedStyles[ styleName ] || !( value = parent.getStyle( styleName ) ) )\u000a								continue;\u000a\u000a							if ( styleNode.getStyle( styleName ) == value )\u000a								removeList.styles[ styleName ] = 1;\u000a							else\u000a								removeList.blockedStyles[ styleName ] = 1;\u000a						}\u000a					}\u000a\u000a					parent = parent.getParent();\u000a				}\u000a\u000a				for ( attName in removeList.attrs )\u000a					styleNode.removeAttribute( attName );\u000a\u000a				for ( styleName in removeList.styles )\u000a					styleNode.removeStyle( styleName );\u000a\u000a				if ( styleHasAttrs && !styleNode.hasAttributes() )\u000a					styleNode = null;\u000a\u000a				if ( styleNode ) {\u000a					// Move the contents of the range to the style element.\u000a					styleRange.extractContents().appendTo( styleNode );\u000a\u000a					// Insert it into the range position (it is collapsed after\u000a					// extractContents.\u000a					styleRange.insertNode( styleNode );\u000a\u000a					// Here we do some cleanup, removing all duplicated\u000a					// elements from the style element.\u000a					removeFromInsideElement.call( this, styleNode );\u000a\u000a					// Let's merge our new style with its neighbors, if possible.\u000a					styleNode.mergeSiblings();\u000a\u000a					// As the style system breaks text nodes constantly, let's normalize\u000a					// things for performance.\u000a					// With IE, some paragraphs get broken when calling normalize()\u000a					// repeatedly. Also, for IE, we must normalize body, not documentElement.\u000a					// IE is also known for having a "crash effect" with normalize().\u000a					// We should try to normalize with IE too in some way, somewhere.\u000a					if ( !CKEDITOR.env.ie )\u000a						styleNode.$.normalize();\u000a				}\u000a				// Style already inherit from parents, left just to clear up any internal overrides. (#5931)\u000a				else {\u000a					styleNode = new CKEDITOR.dom.element( 'span' );\u000a					styleRange.extractContents().appendTo( styleNode );\u000a					styleRange.insertNode( styleNode );\u000a					removeFromInsideElement.call( this, styleNode );\u000a					styleNode.remove( true );\u000a				}\u000a\u000a				// Style applied, let's release the range, so it gets\u000a				// re-initialization in the next loop.\u000a				styleRange = null;\u000a			}\u000a		}\u000a\u000a		// Remove the bookmark nodes.\u000a		range.moveToBookmark( boundaryNodes );\u000a\u000a		// Minimize the result range to exclude empty text nodes. (#5374)\u000a		range.shrink( CKEDITOR.SHRINK_TEXT );\u000a\u000a		// Get inside the remaining element if range.shrink( TEXT ) has failed because of non-editable elements inside.\u000a		// E.g. range.shrink( TEXT ) will not get inside:\u000a		// [<b><i contenteditable="false">x</i></b>]\u000a		// but range.shrink( ELEMENT ) will.\u000a		range.shrink( CKEDITOR.NODE_ELEMENT, true );\u000a	}\u000a\u000a	function removeInlineStyle( range ) {\u000a		// Make sure our range has included all "collpased" parent inline nodes so\u000a		// that our operation logic can be simpler.\u000a		range.enlarge( CKEDITOR.ENLARGE_INLINE, 1 );\u000a\u000a		var bookmark = range.createBookmark(),\u000a			startNode = bookmark.startNode;\u000a\u000a		if ( range.collapsed ) {\u000a			var startPath = new CKEDITOR.dom.elementPath( startNode.getParent(), range.root ),\u000a				// The topmost element in elementspatch which we should jump out of.\u000a				boundaryElement;\u000a\u000a\u000a			for ( var i = 0, element; i < startPath.elements.length && ( element = startPath.elements[ i ] ); i++ ) {\u000a				// 1. If it's collaped inside text nodes, try to remove the style from the whole element.\u000a				//\u000a				// 2. Otherwise if it's collapsed on element boundaries, moving the selection\u000a				//  outside the styles instead of removing the whole tag,\u000a				//  also make sure other inner styles were well preserverd.(#3309)\u000a				if ( element == startPath.block || element == startPath.blockLimit )\u000a					break;\u000a\u000a				if ( this.checkElementRemovable( element ) ) {\u000a					var isStart;\u000a\u000a					if ( range.collapsed && ( range.checkBoundaryOfElement( element, CKEDITOR.END ) || ( isStart = range.checkBoundaryOfElement( element, CKEDITOR.START ) ) ) ) {\u000a						boundaryElement = element;\u000a						boundaryElement.match = isStart ? 'start' : 'end';\u000a					} else {\u000a						// Before removing the style node, there may be a sibling to the style node\u000a						// that's exactly the same to the one to be removed. To the user, it makes\u000a						// no difference that they're separate entities in the DOM tree. So, merge\u000a						// them before removal.\u000a						element.mergeSiblings();\u000a						if ( element.is( this.element ) )\u000a							removeFromElement.call( this, element );\u000a						else\u000a							removeOverrides( element, getOverrides( this )[ element.getName() ] );\u000a					}\u000a				}\u000a			}\u000a\u000a			// Re-create the style tree after/before the boundary element,\u000a			// the replication start from bookmark start node to define the\u000a			// new range.\u000a			if ( boundaryElement ) {\u000a				var clonedElement = startNode;\u000a				for ( i = 0; ; i++ ) {\u000a					var newElement = startPath.elements[ i ];\u000a					if ( newElement.equals( boundaryElement ) )\u000a						break;\u000a					// Avoid copying any matched element.\u000a					else if ( newElement.match )\u000a						continue;\u000a					else\u000a						newElement = newElement.clone();\u000a					newElement.append( clonedElement );\u000a					clonedElement = newElement;\u000a				}\u000a				clonedElement[ boundaryElement.match == 'start' ? 'insertBefore' : 'insertAfter' ]( boundaryElement );\u000a			}\u000a		} else {\u000a			// Now our range isn't collapsed. Lets walk from the start node to the end\u000a			// node via DFS and remove the styles one-by-one.\u000a			var endNode = bookmark.endNode,\u000a				me = this;\u000a\u000a			breakNodes();\u000a\u000a			// Now, do the DFS walk.\u000a			var currentNode = startNode;\u000a			while ( !currentNode.equals( endNode ) ) {\u000a				// Need to get the next node first because removeFromElement() can remove\u000a				// the current node from DOM tree.\u000a				var nextNode = currentNode.getNextSourceNode();\u000a				if ( currentNode.type == CKEDITOR.NODE_ELEMENT && this.checkElementRemovable( currentNode ) ) {\u000a					// Remove style from element or overriding element.\u000a					if ( currentNode.getName() == this.element )\u000a						removeFromElement.call( this, currentNode );\u000a					else\u000a						removeOverrides( currentNode, getOverrides( this )[ currentNode.getName() ] );\u000a\u000a					// removeFromElement() may have merged the next node with something before\u000a					// the startNode via mergeSiblings(). In that case, the nextNode would\u000a					// contain startNode and we'll have to call breakNodes() again and also\u000a					// reassign the nextNode to something after startNode.\u000a					if ( nextNode.type == CKEDITOR.NODE_ELEMENT && nextNode.contains( startNode ) ) {\u000a						breakNodes();\u000a						nextNode = startNode.getNext();\u000a					}\u000a				}\u000a				currentNode = nextNode;\u000a			}\u000a		}\u000a\u000a		range.moveToBookmark( bookmark );\u000a		// See the comment for range.shrink in applyInlineStyle.\u000a		range.shrink( CKEDITOR.NODE_ELEMENT, true );\u000a\u000a		// Find out the style ancestor that needs to be broken down at startNode\u000a		// and endNode.\u000a		function breakNodes() {\u000a			var startPath = new CKEDITOR.dom.elementPath( startNode.getParent() ),\u000a				endPath = new CKEDITOR.dom.elementPath( endNode.getParent() ),\u000a				breakStart = null,\u000a				breakEnd = null;\u000a\u000a			for ( var i = 0; i < startPath.elements.length; i++ ) {\u000a				var element = startPath.elements[ i ];\u000a\u000a				if ( element == startPath.block || element == startPath.blockLimit )\u000a					break;\u000a\u000a				if ( me.checkElementRemovable( element ) )\u000a					breakStart = element;\u000a			}\u000a\u000a			for ( i = 0; i < endPath.elements.length; i++ ) {\u000a				element = endPath.elements[ i ];\u000a\u000a				if ( element == endPath.block || element == endPath.blockLimit )\u000a					break;\u000a\u000a				if ( me.checkElementRemovable( element ) )\u000a					breakEnd = element;\u000a			}\u000a\u000a			if ( breakEnd )\u000a				endNode.breakParent( breakEnd );\u000a			if ( breakStart )\u000a				startNode.breakParent( breakStart );\u000a		}\u000a	}\u000a\u000a	// Apply style to nested editables inside editablesContainer.\u000a	// @param {CKEDITOR.dom.element} editablesContainer\u000a	// @context CKEDITOR.style\u000a	function applyStyleOnNestedEditables( editablesContainer ) {\u000a		var editables = findNestedEditables( editablesContainer ),\u000a			editable,\u000a			l = editables.length,\u000a			i = 0,\u000a			range = l && new CKEDITOR.dom.range( editablesContainer.getDocument() );\u000a\u000a		for ( ; i < l; ++i ) {\u000a			editable = editables[ i ];\u000a			// Check if style is allowed by this editable's ACF.\u000a			if ( checkIfAllowedInEditable( editable, this ) ) {\u000a				range.selectNodeContents( editable );\u000a				applyInlineStyle.call( this, range );\u000a			}\u000a		}\u000a	}\u000a\u000a	// Finds nested editables within container. Does not return\u000a	// editables nested in another editable (twice).\u000a	function findNestedEditables( container ) {\u000a		var editables = [];\u000a\u000a		container.forEach( function( element ) {\u000a			if ( element.getAttribute( 'contenteditable' ) == 'true' ) {\u000a				editables.push( element );\u000a				return false; // Skip children.\u000a			}\u000a		}, CKEDITOR.NODE_ELEMENT, true );\u000a\u000a		return editables;\u000a	}\u000a\u000a	// Checks if style is allowed in this editable.\u000a	function checkIfAllowedInEditable( editable, style ) {\u000a		var filter = CKEDITOR.filter.instances[ editable.data( 'cke-filter' ) ];\u000a\u000a		return filter ? filter.check( style ) : 1;\u000a	}\u000a\u000a	// Checks if style is allowed by iterator's active filter.\u000a	function checkIfAllowedByIterator( iterator, style ) {\u000a		return iterator.activeFilter ? iterator.activeFilter.check( style ) : 1;\u000a	}\u000a\u000a	function applyObjectStyle( range ) {\u000a		// Selected or parent element. (#9651)\u000a		var start = range.getEnclosedNode() || range.getCommonAncestor( false, true ),\u000a			element = new CKEDITOR.dom.elementPath( start, range.root ).contains( this.element, 1 );\u000a\u000a		element && !element.isReadOnly() && setupElement( element, this );\u000a	}\u000a\u000a	function removeObjectStyle( range ) {\u000a		var parent = range.getCommonAncestor( true, true ),\u000a			element = new CKEDITOR.dom.elementPath( parent, range.root ).contains( this.element, 1 );\u000a\u000a		if ( !element )\u000a			return;\u000a\u000a		var style = this,\u000a			def = style._.definition,\u000a			attributes = def.attributes;\u000a\u000a		// Remove all defined attributes.\u000a		if ( attributes ) {\u000a			for ( var att in attributes )\u000a				element.removeAttribute( att, attributes[ att ] );\u000a		}\u000a\u000a		// Assign all defined styles.\u000a		if ( def.styles ) {\u000a			for ( var i in def.styles ) {\u000a				if ( def.styles.hasOwnProperty( i ) )\u000a					element.removeStyle( i );\u000a			}\u000a		}\u000a	}\u000a\u000a	function applyBlockStyle( range ) {\u000a		// Serializible bookmarks is needed here since\u000a		// elements may be merged.\u000a		var bookmark = range.createBookmark( true );\u000a\u000a		var iterator = range.createIterator();\u000a		iterator.enforceRealBlocks = true;\u000a\u000a		// make recognize <br /> tag as a separator in ENTER_BR mode (#5121)\u000a		if ( this._.enterMode )\u000a			iterator.enlargeBr = ( this._.enterMode != CKEDITOR.ENTER_BR );\u000a\u000a		var block,\u000a			doc = range.document,\u000a			newBlock;\u000a\u000a		while ( ( block = iterator.getNextParagraph() ) ) {\u000a			if ( !block.isReadOnly() && checkIfAllowedByIterator( iterator, this ) ) {\u000a				newBlock = getElement( this, doc, block );\u000a				replaceBlock( block, newBlock );\u000a			}\u000a		}\u000a\u000a		range.moveToBookmark( bookmark );\u000a	}\u000a\u000a	function removeBlockStyle( range ) {\u000a		// Serializible bookmarks is needed here since\u000a		// elements may be merged.\u000a		var bookmark = range.createBookmark( 1 );\u000a\u000a		var iterator = range.createIterator();\u000a		iterator.enforceRealBlocks = true;\u000a		iterator.enlargeBr = this._.enterMode != CKEDITOR.ENTER_BR;\u000a\u000a		var block,\u000a			newBlock;\u000a\u000a		while ( ( block = iterator.getNextParagraph() ) ) {\u000a			if ( this.checkElementRemovable( block ) ) {\u000a				// <pre> get special treatment.\u000a				if ( block.is( 'pre' ) ) {\u000a					newBlock = this._.enterMode == CKEDITOR.ENTER_BR ? null :\u000a							range.document.createElement( this._.enterMode == CKEDITOR.ENTER_P ? 'p' : 'div' );\u000a\u000a					newBlock && block.copyAttributes( newBlock );\u000a					replaceBlock( block, newBlock );\u000a				} else {\u000a					removeFromElement.call( this, block );\u000a				}\u000a			}\u000a		}\u000a\u000a		range.moveToBookmark( bookmark );\u000a	}\u000a\u000a	// Replace the original block with new one, with special treatment\u000a	// for <pre> blocks to make sure content format is well preserved, and merging/splitting adjacent\u000a	// when necessary. (#3188)\u000a	function replaceBlock( block, newBlock ) {\u000a		// Block is to be removed, create a temp element to\u000a		// save contents.\u000a		var removeBlock = !newBlock;\u000a		if ( removeBlock ) {\u000a			newBlock = block.getDocument().createElement( 'div' );\u000a			block.copyAttributes( newBlock );\u000a		}\u000a\u000a		var newBlockIsPre = newBlock && newBlock.is( 'pre' ),\u000a			blockIsPre = block.is( 'pre' ),\u000a			isToPre = newBlockIsPre && !blockIsPre,\u000a			isFromPre = !newBlockIsPre && blockIsPre;\u000a\u000a		if ( isToPre )\u000a			newBlock = toPre( block, newBlock );\u000a		else if ( isFromPre )\u000a			// Split big <pre> into pieces before start to convert.\u000a			newBlock = fromPres( removeBlock ? [ block.getHtml() ] : splitIntoPres( block ), newBlock );\u000a		else\u000a			block.moveChildren( newBlock );\u000a\u000a		newBlock.replace( block );\u000a\u000a		if ( newBlockIsPre ) {\u000a			// Merge previous <pre> blocks.\u000a			mergePre( newBlock );\u000a		} else if ( removeBlock ) {\u000a			removeNoAttribsElement( newBlock );\u000a		}\u000a	}\u000a\u000a	// Merge a <pre> block with a previous sibling if available.\u000a	function mergePre( preBlock ) {\u000a		var previousBlock;\u000a		if ( !( ( previousBlock = preBlock.getPrevious( nonWhitespaces ) ) && previousBlock.type == CKEDITOR.NODE_ELEMENT && previousBlock.is( 'pre' ) ) )\u000a			return;\u000a\u000a		// Merge the previous <pre> block contents into the current <pre>\u000a		// block.\u000a		//\u000a		// Another thing to be careful here is that currentBlock might contain\u000a		// a '\u005cn' at the beginning, and previousBlock might contain a '\u005cn'\u000a		// towards the end. These new lines are not normally displayed but they\u000a		// become visible after merging.\u000a		var mergedHtml = replace( previousBlock.getHtml(), /\u005cn$/, '' ) + '\u005cn\u005cn' +\u000a			replace( preBlock.getHtml(), /^\u005cn/, '' );\u000a\u000a		// Krugle: IE normalizes innerHTML from <pre>, breaking whitespaces.\u000a		if ( CKEDITOR.env.ie )\u000a			preBlock.$.outerHTML = '<pre>' + mergedHtml + '</pre>';\u000a		else\u000a			preBlock.setHtml( mergedHtml );\u000a\u000a		previousBlock.remove();\u000a	}\u000a\u000a	// Split into multiple <pre> blocks separated by double line-break.\u000a	function splitIntoPres( preBlock ) {\u000a		// Exclude the ones at header OR at tail,\u000a		// and ignore bookmark content between them.\u000a		var duoBrRegex = /(\u005cS\u005cs*)\u005cn(?:\u005cs|(<span[^>]+data-cke-bookmark.*?\u005c/span>))*\u005cn(?!$)/gi,\u000a			pres = [],\u000a			splitedHtml = replace( preBlock.getOuterHtml(), duoBrRegex, function( match, charBefore, bookmark ) {\u000a				return charBefore + '</pre>' + bookmark + '<pre>';\u000a			} );\u000a\u000a		splitedHtml.replace( /<pre\u005cb.*?>([\u005cs\u005cS]*?)<\u005c/pre>/gi, function( match, preContent ) {\u000a			pres.push( preContent );\u000a		} );\u000a		return pres;\u000a	}\u000a\u000a	// Wrapper function of String::replace without considering of head/tail bookmarks nodes.\u000a	function replace( str, regexp, replacement ) {\u000a		var headBookmark = '',\u000a			tailBookmark = '';\u000a\u000a		str = str.replace( /(^<span[^>]+data-cke-bookmark.*?\u005c/span>)|(<span[^>]+data-cke-bookmark.*?\u005c/span>$)/gi, function( str, m1, m2 ) {\u000a			m1 && ( headBookmark = m1 );\u000a			m2 && ( tailBookmark = m2 );\u000a			return '';\u000a		} );\u000a		return headBookmark + str.replace( regexp, replacement ) + tailBookmark;\u000a	}\u000a\u000a	// Converting a list of <pre> into blocks with format well preserved.\u000a	function fromPres( preHtmls, newBlock ) {\u000a		var docFrag;\u000a		if ( preHtmls.length > 1 )\u000a			docFrag = new CKEDITOR.dom.documentFragment( newBlock.getDocument() );\u000a\u000a		for ( var i = 0; i < preHtmls.length; i++ ) {\u000a			var blockHtml = preHtmls[ i ];\u000a\u000a			// 1. Trim the first and last line-breaks immediately after and before <pre>,\u000a			// they're not visible.\u000a			blockHtml = blockHtml.replace( /(\u005cr\u005cn|\u005cr)/g, '\u005cn' );\u000a			blockHtml = replace( blockHtml, /^[ \u005ct]*\u005cn/, '' );\u000a			blockHtml = replace( blockHtml, /\u005cn$/, '' );\u000a			// 2. Convert spaces or tabs at the beginning or at the end to &nbsp;\u000a			blockHtml = replace( blockHtml, /^[ \u005ct]+|[ \u005ct]+$/g, function( match, offset ) {\u000a				if ( match.length == 1 ) // one space, preserve it\u000a					return '&nbsp;';\u000a				else if ( !offset ) // beginning of block\u000a					return CKEDITOR.tools.repeat( '&nbsp;', match.length - 1 ) + ' ';\u000a				else // end of block\u000a					return ' ' + CKEDITOR.tools.repeat( '&nbsp;', match.length - 1 );\u000a			} );\u000a\u000a			// 3. Convert \u005cn to <BR>.\u000a			// 4. Convert contiguous (i.e. non-singular) spaces or tabs to &nbsp;\u000a			blockHtml = blockHtml.replace( /\u005cn/g, '<br>' );\u000a			blockHtml = blockHtml.replace( /[ \u005ct]{2,}/g, function( match ) {\u000a				return CKEDITOR.tools.repeat( '&nbsp;', match.length - 1 ) + ' ';\u000a			} );\u000a\u000a			if ( docFrag ) {\u000a				var newBlockClone = newBlock.clone();\u000a				newBlockClone.setHtml( blockHtml );\u000a				docFrag.append( newBlockClone );\u000a			} else {\u000a				newBlock.setHtml( blockHtml );\u000a			}\u000a		}\u000a\u000a		return docFrag || newBlock;\u000a	}\u000a\u000a	// Converting from a non-PRE block to a PRE block in formatting operations.\u000a	function toPre( block, newBlock ) {\u000a		var bogus = block.getBogus();\u000a		bogus && bogus.remove();\u000a\u000a		// First trim the block content.\u000a		var preHtml = block.getHtml();\u000a\u000a		// 1. Trim head/tail spaces, they're not visible.\u000a		preHtml = replace( preHtml, /(?:^[ \u005ct\u005cn\u005cr]+)|(?:[ \u005ct\u005cn\u005cr]+$)/g, '' );\u000a		// 2. Delete ANSI whitespaces immediately before and after <BR> because\u000a		//    they are not visible.\u000a		preHtml = preHtml.replace( /[ \u005ct\u005cr\u005cn]*(<br[^>]*>)[ \u005ct\u005cr\u005cn]*/gi, '$1' );\u000a		// 3. Compress other ANSI whitespaces since they're only visible as one\u000a		//    single space previously.\u000a		// 4. Convert &nbsp; to spaces since &nbsp; is no longer needed in <PRE>.\u000a		preHtml = preHtml.replace( /([ \u005ct\u005cn\u005cr]+|&nbsp;)/g, ' ' );\u000a		// 5. Convert any <BR /> to \u005cn. This must not be done earlier because\u000a		//    the \u005cn would then get compressed.\u000a		preHtml = preHtml.replace( /<br\u005cb[^>]*>/gi, '\u005cn' );\u000a\u000a		// Krugle: IE normalizes innerHTML to <pre>, breaking whitespaces.\u000a		if ( CKEDITOR.env.ie ) {\u000a			var temp = block.getDocument().createElement( 'div' );\u000a			temp.append( newBlock );\u000a			newBlock.$.outerHTML = '<pre>' + preHtml + '</pre>';\u000a			newBlock.copyAttributes( temp.getFirst() );\u000a			newBlock = temp.getFirst().remove();\u000a		} else {\u000a			newBlock.setHtml( preHtml );\u000a		}\u000a\u000a		return newBlock;\u000a	}\u000a\u000a	// Removes a style from an element itself, don't care about its subtree.\u000a	function removeFromElement( element, keepDataAttrs ) {\u000a		var def = this._.definition,\u000a			attributes = def.attributes,\u000a			styles = def.styles,\u000a			overrides = getOverrides( this )[ element.getName() ],\u000a			// If the style is only about the element itself, we have to remove the element.\u000a			removeEmpty = CKEDITOR.tools.isEmpty( attributes ) && CKEDITOR.tools.isEmpty( styles );\u000a\u000a		// Remove definition attributes/style from the elemnt.\u000a		for ( var attName in attributes ) {\u000a			// The 'class' element value must match (#1318).\u000a			if ( ( attName == 'class' || this._.definition.fullMatch ) && element.getAttribute( attName ) != normalizeProperty( attName, attributes[ attName ] ) )\u000a				continue;\u000a\u000a			// Do not touch data-* attributes (#11011) (#11258).\u000a			if ( keepDataAttrs && attName.slice( 0, 5 ) == 'data-' )\u000a				continue;\u000a\u000a			removeEmpty = element.hasAttribute( attName );\u000a			element.removeAttribute( attName );\u000a		}\u000a\u000a		for ( var styleName in styles ) {\u000a			// Full match style insist on having fully equivalence. (#5018)\u000a			if ( this._.definition.fullMatch && element.getStyle( styleName ) != normalizeProperty( styleName, styles[ styleName ], true ) )\u000a				continue;\u000a\u000a			removeEmpty = removeEmpty || !!element.getStyle( styleName );\u000a			element.removeStyle( styleName );\u000a		}\u000a\u000a		// Remove overrides, but don't remove the element if it's a block element\u000a		removeOverrides( element, overrides, blockElements[ element.getName() ] );\u000a\u000a		if ( removeEmpty ) {\u000a			if ( this._.definition.alwaysRemoveElement )\u000a				removeNoAttribsElement( element, 1 );\u000a			else {\u000a				if ( !CKEDITOR.dtd.$block[ element.getName() ] || this._.enterMode == CKEDITOR.ENTER_BR && !element.hasAttributes() )\u000a					removeNoAttribsElement( element );\u000a				else\u000a					element.renameNode( this._.enterMode == CKEDITOR.ENTER_P ? 'p' : 'div' );\u000a			}\u000a		}\u000a	}\u000a\u000a	// Removes a style from inside an element. Called on applyStyle to make cleanup\u000a	// before apply. During clean up this function keep data-* attribute in contrast\u000a	// to removeFromElement.\u000a	function removeFromInsideElement( element ) {\u000a		var overrides = getOverrides( this ),\u000a			innerElements = element.getElementsByTag( this.element ),\u000a			innerElement;\u000a\u000a		for ( var i = innerElements.count(); --i >= 0; ) {\u000a			innerElement = innerElements.getItem( i );\u000a\u000a			// Do not remove elements which are read only (e.g. duplicates inside widgets).\u000a			if ( !innerElement.isReadOnly() )\u000a				removeFromElement.call( this, innerElement, true );\u000a		}\u000a\u000a		// Now remove any other element with different name that is\u000a		// defined to be overriden.\u000a		for ( var overrideElement in overrides ) {\u000a			if ( overrideElement != this.element ) {\u000a				innerElements = element.getElementsByTag( overrideElement );\u000a\u000a				for ( i = innerElements.count() - 1; i >= 0; i-- ) {\u000a					innerElement = innerElements.getItem( i );\u000a\u000a					// Do not remove elements which are read only (e.g. duplicates inside widgets).\u000a					if ( !innerElement.isReadOnly() )\u000a						removeOverrides( innerElement, overrides[ overrideElement ] );\u000a				}\u000a			}\u000a		}\u000a	}\u000a\u000a	// Remove overriding styles/attributes from the specific element.\u000a	// Note: Remove the element if no attributes remain.\u000a	// @param {Object} element\u000a	// @param {Object} overrides\u000a	// @param {Boolean} Don't remove the element\u000a	function removeOverrides( element, overrides, dontRemove ) {\u000a		var attributes = overrides && overrides.attributes;\u000a\u000a		if ( attributes ) {\u000a			for ( var i = 0; i < attributes.length; i++ ) {\u000a				var attName = attributes[ i ][ 0 ],\u000a					actualAttrValue;\u000a\u000a				if ( ( actualAttrValue = element.getAttribute( attName ) ) ) {\u000a					var attValue = attributes[ i ][ 1 ];\u000a\u000a					// Remove the attribute if:\u000a					//    - The override definition value is null ;\u000a					//    - The override definition valie is a string that\u000a					//      matches the attribute value exactly.\u000a					//    - The override definition value is a regex that\u000a					//      has matches in the attribute value.\u000a					if ( attValue === null || ( attValue.test && attValue.test( actualAttrValue ) ) || ( typeof attValue == 'string' && actualAttrValue == attValue ) )\u000a						element.removeAttribute( attName );\u000a				}\u000a			}\u000a		}\u000a\u000a		if ( !dontRemove )\u000a			removeNoAttribsElement( element );\u000a	}\u000a\u000a	// If the element has no more attributes, remove it.\u000a	function removeNoAttribsElement( element, forceRemove ) {\u000a		// If no more attributes remained in the element, remove it,\u000a		// leaving its children.\u000a		if ( !element.hasAttributes() || forceRemove ) {\u000a			if ( CKEDITOR.dtd.$block[ element.getName() ] ) {\u000a				var previous = element.getPrevious( nonWhitespaces ),\u000a					next = element.getNext( nonWhitespaces );\u000a\u000a				if ( previous && ( previous.type == CKEDITOR.NODE_TEXT || !previous.isBlockBoundary( { br: 1 } ) ) )\u000a					element.append( 'br', 1 );\u000a				if ( next && ( next.type == CKEDITOR.NODE_TEXT || !next.isBlockBoundary( { br: 1 } ) ) )\u000a					element.append( 'br' );\u000a\u000a				element.remove( true );\u000a			} else {\u000a				// Removing elements may open points where merging is possible,\u000a				// so let's cache the first and last nodes for later checking.\u000a				var firstChild = element.getFirst();\u000a				var lastChild = element.getLast();\u000a\u000a				element.remove( true );\u000a\u000a				if ( firstChild ) {\u000a					// Check the cached nodes for merging.\u000a					firstChild.type == CKEDITOR.NODE_ELEMENT && firstChild.mergeSiblings();\u000a\u000a					if ( lastChild && !firstChild.equals( lastChild ) && lastChild.type == CKEDITOR.NODE_ELEMENT )\u000a						lastChild.mergeSiblings();\u000a				}\u000a\u000a			}\u000a		}\u000a	}\u000a\u000a	function getElement( style, targetDocument, element ) {\u000a		var el,\u000a			elementName = style.element;\u000a\u000a		// The "*" element name will always be a span for this function.\u000a		if ( elementName == '*' )\u000a			elementName = 'span';\u000a\u000a		// Create the element.\u000a		el = new CKEDITOR.dom.element( elementName, targetDocument );\u000a\u000a		// #6226: attributes should be copied before the new ones are applied\u000a		if ( element )\u000a			element.copyAttributes( el );\u000a\u000a		el = setupElement( el, style );\u000a\u000a		// Avoid ID duplication.\u000a		if ( targetDocument.getCustomData( 'doc_processing_style' ) && el.hasAttribute( 'id' ) )\u000a			el.removeAttribute( 'id' );\u000a		else\u000a			targetDocument.setCustomData( 'doc_processing_style', 1 );\u000a\u000a		return el;\u000a	}\u000a\u000a	function setupElement( el, style ) {\u000a		var def = style._.definition,\u000a			attributes = def.attributes,\u000a			styles = CKEDITOR.style.getStyleText( def );\u000a\u000a		// Assign all defined attributes.\u000a		if ( attributes ) {\u000a			for ( var att in attributes )\u000a				el.setAttribute( att, attributes[ att ] );\u000a		}\u000a\u000a		// Assign all defined styles.\u000a		if ( styles )\u000a			el.setAttribute( 'style', styles );\u000a\u000a		return el;\u000a	}\u000a\u000a	function replaceVariables( list, variablesValues ) {\u000a		for ( var item in list ) {\u000a			list[ item ] = list[ item ].replace( varRegex, function( match, varName ) {\u000a				return variablesValues[ varName ];\u000a			} );\u000a		}\u000a	}\u000a\u000a	// Returns an object that can be used for style matching comparison.\u000a	// Attributes names and values are all lowercased, and the styles get\u000a	// merged with the style attribute.\u000a	function getAttributesForComparison( styleDefinition ) {\u000a		// If we have already computed it, just return it.\u000a		var attribs = styleDefinition._AC;\u000a		if ( attribs )\u000a			return attribs;\u000a\u000a		attribs = {};\u000a\u000a		var length = 0;\u000a\u000a		// Loop through all defined attributes.\u000a		var styleAttribs = styleDefinition.attributes;\u000a		if ( styleAttribs ) {\u000a			for ( var styleAtt in styleAttribs ) {\u000a				length++;\u000a				attribs[ styleAtt ] = styleAttribs[ styleAtt ];\u000a			}\u000a		}\u000a\u000a		// Includes the style definitions.\u000a		var styleText = CKEDITOR.style.getStyleText( styleDefinition );\u000a		if ( styleText ) {\u000a			if ( !attribs.style )\u000a				length++;\u000a			attribs.style = styleText;\u000a		}\u000a\u000a		// Appends the "length" information to the object.\u000a		attribs._length = length;\u000a\u000a		// Return it, saving it to the next request.\u000a		return ( styleDefinition._AC = attribs );\u000a	}\u000a\u000a	// Get the the collection used to compare the elements and attributes,\u000a	// defined in this style overrides, with other element. All information in\u000a	// it is lowercased.\u000a	// @param {CKEDITOR.style} style\u000a	function getOverrides( style ) {\u000a		if ( style._.overrides )\u000a			return style._.overrides;\u000a\u000a		var overrides = ( style._.overrides = {} ),\u000a			definition = style._.definition.overrides;\u000a\u000a		if ( definition ) {\u000a			// The override description can be a string, object or array.\u000a			// Internally, well handle arrays only, so transform it if needed.\u000a			if ( !CKEDITOR.tools.isArray( definition ) )\u000a				definition = [ definition ];\u000a\u000a			// Loop through all override definitions.\u000a			for ( var i = 0; i < definition.length; i++ ) {\u000a				var override = definition[ i ],\u000a					elementName,\u000a					overrideEl,\u000a					attrs;\u000a\u000a				// If can be a string with the element name.\u000a				if ( typeof override == 'string' )\u000a					elementName = override.toLowerCase();\u000a				// Or an object.\u000a				else {\u000a					elementName = override.element ? override.element.toLowerCase() : style.element;\u000a					attrs = override.attributes;\u000a				}\u000a\u000a				// We can have more than one override definition for the same\u000a				// element name, so we attempt to simply append information to\u000a				// it if it already exists.\u000a				overrideEl = overrides[ elementName ] || ( overrides[ elementName ] = {} );\u000a\u000a				if ( attrs ) {\u000a					// The returning attributes list is an array, because we\u000a					// could have different override definitions for the same\u000a					// attribute name.\u000a					var overrideAttrs = ( overrideEl.attributes = overrideEl.attributes || [] );\u000a					for ( var attName in attrs ) {\u000a						// Each item in the attributes array is also an array,\u000a						// where [0] is the attribute name and [1] is the\u000a						// override value.\u000a						overrideAttrs.push( [ attName.toLowerCase(), attrs[ attName ] ] );\u000a					}\u000a				}\u000a			}\u000a		}\u000a\u000a		return overrides;\u000a	}\u000a\u000a	// Make the comparison of attribute value easier by standardizing it.\u000a	function normalizeProperty( name, value, isStyle ) {\u000a		var temp = new CKEDITOR.dom.element( 'span' );\u000a		temp[ isStyle ? 'setStyle' : 'setAttribute' ]( name, value );\u000a		return temp[ isStyle ? 'getStyle' : 'getAttribute' ]( name );\u000a	}\u000a\u000a	// Compare two bunch of styles, with the speciality that value 'inherit'\u000a	// is treated as a wildcard which will match any value.\u000a	// @param {Object/String} source\u000a	// @param {Object/String} target\u000a	function compareCssText( source, target ) {\u000a		if ( typeof source == 'string' )\u000a			source = CKEDITOR.tools.parseCssText( source );\u000a		if ( typeof target == 'string' )\u000a			target = CKEDITOR.tools.parseCssText( target, true );\u000a\u000a		for ( var name in source ) {\u000a			if ( !( name in target && ( target[ name ] == source[ name ] || source[ name ] == 'inherit' || target[ name ] == 'inherit' ) ) )\u000a				return false;\u000a		}\u000a		return true;\u000a	}\u000a\u000a	function applyStyleOnSelection( selection, remove, editor ) {\u000a		var doc = selection.document,\u000a			ranges = selection.getRanges(),\u000a			func = remove ? this.removeFromRange : this.applyToRange,\u000a			range;\u000a\u000a		var iterator = ranges.createIterator();\u000a		while ( ( range = iterator.getNextRange() ) )\u000a			func.call( this, range, editor );\u000a\u000a		selection.selectRanges( ranges );\u000a		doc.removeCustomData( 'doc_processing_style' );\u000a	}\u000a} )();\u000a\u000a/**\u000a * Generic style command. It applies a specific style when executed.\u000a *\u000a *		var boldStyle = new CKEDITOR.style( { element: 'strong' } );\u000a *		// Register the "bold" command, which applies the bold style.\u000a *		editor.addCommand( 'bold', new CKEDITOR.dialogCommand( boldStyle ) );\u000a *\u000a * @class\u000a * @constructor Creates a styleCommand class instance.\u000a * @extends CKEDITOR.commandDefinition\u000a * @param {CKEDITOR.style} style The style to be applied when command is executed.\u000a * @param {Object} [ext] Additional command definition's properties.\u000a */\u000aCKEDITOR.styleCommand = function( style, ext ) {\u000a	this.style = style;\u000a	this.allowedContent = style;\u000a	this.requiredContent = style;\u000a\u000a	CKEDITOR.tools.extend( this, ext, true );\u000a};\u000a\u000a/**\u000a * @param {CKEDITOR.editor} editor\u000a * @todo\u000a */\u000aCKEDITOR.styleCommand.prototype.exec = function( editor ) {\u000a	editor.focus();\u000a\u000a	if ( this.state == CKEDITOR.TRISTATE_OFF )\u000a		editor.applyStyle( this.style );\u000a	else if ( this.state == CKEDITOR.TRISTATE_ON )\u000a		editor.removeStyle( this.style );\u000a};\u000a\u000a/**\u000a * Manages styles registration and loading. See also {@link CKEDITOR.config#stylesSet}.\u000a *\u000a *		// The set of styles for the <b>Styles</b> drop-down list.\u000a *		CKEDITOR.stylesSet.add( 'default', [\u000a *			// Block Styles\u000a *			{ name: 'Blue Title',		element: 'h3',		styles: { 'color': 'Blue' } },\u000a *			{ name: 'Red Title',		element: 'h3',		styles: { 'color': 'Red' } },\u000a *\u000a *			// Inline Styles\u000a *			{ name: 'Marker: Yellow',	element: 'span',	styles: { 'background-color': 'Yellow' } },\u000a *			{ name: 'Marker: Green',	element: 'span',	styles: { 'background-color': 'Lime' } },\u000a *\u000a *			// Object Styles\u000a *			{\u000a *				name: 'Image on Left',\u000a *				element: 'img',\u000a *				attributes: {\u000a *					style: 'padding: 5px; margin-right: 5px',\u000a *					border: '2',\u000a *					align: 'left'\u000a *				}\u000a *			}\u000a *		] );\u000a *\u000a * @since 3.2\u000a * @class\u000a * @singleton\u000a * @extends CKEDITOR.resourceManager\u000a */\u000aCKEDITOR.stylesSet = new CKEDITOR.resourceManager( '', 'stylesSet' );\u000a\u000a// Backward compatibility (#5025).\u000aCKEDITOR.addStylesSet = CKEDITOR.tools.bind( CKEDITOR.stylesSet.add, CKEDITOR.stylesSet );\u000aCKEDITOR.loadStylesSet = function( name, url, callback ) {\u000a	CKEDITOR.stylesSet.addExternal( name, url, '' );\u000a	CKEDITOR.stylesSet.load( name, callback );\u000a};\u000a\u000aCKEDITOR.tools.extend( CKEDITOR.editor.prototype, {\u000a	/**\u000a	 * Registers a function to be called whenever the selection position changes in the\u000a	 * editing area. The current state is passed to the function. The possible\u000a	 * states are {@link CKEDITOR#TRISTATE_ON} and {@link CKEDITOR#TRISTATE_OFF}.\u000a	 *\u000a	 *		// Create a style object for the <b> element.\u000a	 *		var style = new CKEDITOR.style( { element: 'b' } );\u000a	 *		var editor = CKEDITOR.instances.editor1;\u000a	 *		editor.attachStyleStateChange( style, function( state ) {\u000a	 *			if ( state == CKEDITOR.TRISTATE_ON )\u000a	 *				alert( 'The current state for the B element is ON' );\u000a	 *			else\u000a	 *				alert( 'The current state for the B element is OFF' );\u000a	 *		} );\u000a	 *\u000a	 * @member CKEDITOR.editor\u000a	 * @param {CKEDITOR.style} style The style to be watched.\u000a	 * @param {Function} callback The function to be called.\u000a	 */\u000a	attachStyleStateChange: function( style, callback ) {\u000a		// Try to get the list of attached callbacks.\u000a		var styleStateChangeCallbacks = this._.styleStateChangeCallbacks;\u000a\u000a		// If it doesn't exist, it means this is the first call. So, let's create\u000a		// all the structure to manage the style checks and the callback calls.\u000a		if ( !styleStateChangeCallbacks ) {\u000a			// Create the callbacks array.\u000a			styleStateChangeCallbacks = this._.styleStateChangeCallbacks = [];\u000a\u000a			// Attach to the selectionChange event, so we can check the styles at\u000a			// that point.\u000a			this.on( 'selectionChange', function( ev ) {\u000a				// Loop throw all registered callbacks.\u000a				for ( var i = 0; i < styleStateChangeCallbacks.length; i++ ) {\u000a					var callback = styleStateChangeCallbacks[ i ];\u000a\u000a					// Check the current state for the style defined for that callback.\u000a					var currentState = callback.style.checkActive( ev.data.path, this ) ?\u000a						CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF;\u000a\u000a					// Call the callback function, passing the current state to it.\u000a					callback.fn.call( this, currentState );\u000a				}\u000a			} );\u000a		}\u000a\u000a		// Save the callback info, so it can be checked on the next occurrence of\u000a		// selectionChange.\u000a		styleStateChangeCallbacks.push( { style: style, fn: callback } );\u000a	},\u000a\u000a	/**\u000a	 * Applies the style upon the editor's current selection. Shorthand for\u000a	 * {@link CKEDITOR.style#apply}.\u000a	 *\u000a	 * @member CKEDITOR.editor\u000a	 * @param {CKEDITOR.style} style\u000a	 */\u000a	applyStyle: function( style ) {\u000a		style.apply( this );\u000a	},\u000a\u000a	/**\u000a	 * Removes the style from the editor's current selection. Shorthand for\u000a	 * {@link CKEDITOR.style#remove}.\u000a	 *\u000a	 * @member CKEDITOR.editor\u000a	 * @param {CKEDITOR.style} style\u000a	 */\u000a	removeStyle: function( style ) {\u000a		style.remove( this );\u000a	},\u000a\u000a	/**\u000a	 * Gets the current `stylesSet` for this instance.\u000a	 *\u000a	 *		editor.getStylesSet( function( stylesDefinitions ) {} );\u000a	 *\u000a	 * See also {@link CKEDITOR.editor#stylesSet} event.\u000a	 *\u000a	 * @member CKEDITOR.editor\u000a	 * @param {Function} callback The function to be called with the styles data.\u000a	 */\u000a	getStylesSet: function( callback ) {\u000a		if ( !this._.stylesDefinitions ) {\u000a			var editor = this,\u000a				// Respect the backwards compatible definition entry\u000a				configStyleSet = editor.config.stylesCombo_stylesSet || editor.config.stylesSet;\u000a\u000a			// The false value means that none styles should be loaded.\u000a			if ( configStyleSet === false ) {\u000a				callback( null );\u000a				return;\u000a			}\u000a\u000a			// #5352 Allow to define the styles directly in the config object\u000a			if ( configStyleSet instanceof Array ) {\u000a				editor._.stylesDefinitions = configStyleSet;\u000a				callback( configStyleSet );\u000a				return;\u000a			}\u000a\u000a			// Default value is 'default'.\u000a			if ( !configStyleSet )\u000a				configStyleSet = 'default';\u000a\u000a			var partsStylesSet = configStyleSet.split( ':' ),\u000a				styleSetName = partsStylesSet[ 0 ],\u000a				externalPath = partsStylesSet[ 1 ];\u000a\u000a			CKEDITOR.stylesSet.addExternal( styleSetName, externalPath ? partsStylesSet.slice( 1 ).join( ':' ) : CKEDITOR.getUrl( 'styles.js' ), '' );\u000a\u000a			CKEDITOR.stylesSet.load( styleSetName, function( stylesSet ) {\u000a				editor._.stylesDefinitions = stylesSet[ styleSetName ];\u000a				callback( editor._.stylesDefinitions );\u000a			} );\u000a		} else {\u000a			callback( this._.stylesDefinitions );\u000a		}\u000a	}\u000a} );\u000a\u000a/**\u000a * Indicates that fully selected read-only elements will be included when\u000a * applying the style (for inline styles only).\u000a *\u000a * @since 3.5\u000a * @property {Boolean} [includeReadonly=false]\u000a * @member CKEDITOR.style\u000a */\u000a\u000a/**\u000a * Indicates that any matches element of this style will be eventually removed\u000a * when calling {@link CKEDITOR.editor#removeStyle}.\u000a *\u000a * @since 4.0\u000a * @property {Boolean} [alwaysRemoveElement=false]\u000a * @member CKEDITOR.style\u000a */\u000a\u000a/**\u000a * Disables inline styling on read-only elements.\u000a *\u000a * @since 3.5\u000a * @cfg {Boolean} [disableReadonlyStyling=false]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * The "styles definition set" to use in the editor. They will be used in the\u000a * styles combo and the style selector of the div container.\u000a *\u000a * The styles may be defined in the page containing the editor, or can be\u000a * loaded on demand from an external file. In the second case, if this setting\u000a * contains only a name, the `styles.js` file will be loaded from the\u000a * CKEditor root folder (what ensures backward compatibility with CKEditor 4.0).\u000a *\u000a * Otherwise, this setting has the `name:url` syntax, making it\u000a * possible to set the URL from which loading the styles file.\u000a * Note that the `name` has to be equal to the name used in\u000a * {@link CKEDITOR.stylesSet#add} while registering styles set.\u000a *\u000a * **Note**: Since 4.1 it is possible to set `stylesSet` to `false`\u000a * to prevent loading any styles set.\u000a *\u000a *		// Do not load any file. Styles set is empty.\u000a *		config.stylesSet = false;\u000a *\u000a *		// Load the 'mystyles' styles set from styles.js file.\u000a *		config.stylesSet = 'mystyles';\u000a *\u000a *		// Load the 'mystyles' styles set from a relative URL.\u000a *		config.stylesSet = 'mystyles:/editorstyles/styles.js';\u000a *\u000a *		// Load from a full URL.\u000a *		config.stylesSet = 'mystyles:http://www.example.com/editorstyles/styles.js';\u000a *\u000a *		// Load from a list of definitions.\u000a *		config.stylesSet = [\u000a *			{ name: 'Strong Emphasis', element: 'strong' },\u000a *			{ name: 'Emphasis', element: 'em' },\u000a *			...\u000a *		];\u000a *\u000a * @since 3.3\u000a * @cfg {String/Array/Boolean} [stylesSet='default']\u000a * @member CKEDITOR.config\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a// This file contains style definitions that can be used by CKEditor plugins.\u000a//\u000a// The most common use for it is the "stylescombo" plugin, which shows a combo\u000a// in the editor toolbar, containing all styles. Other plugins instead, like\u000a// the div plugin, use a subset of the styles on their feature.\u000a//\u000a// If you don't have plugins that depend on this file, you can simply ignore it.\u000a// Otherwise it is strongly recommended to customize this file to match your\u000a// website requirements and design properly.\u000a\u000aCKEDITOR.stylesSet.add( 'default', [\u000a	/* Block Styles */\u000a\u000a	// These styles are already available in the "Format" combo ("format" plugin),\u000a	// so they are not needed here by default. You may enable them to avoid\u000a	// placing the "Format" combo in the toolbar, maintaining the same features.\u000a	/*\u000a	{ name: 'Paragraph',		element: 'p' },\u000a	{ name: 'Heading 1',		element: 'h1' },\u000a	{ name: 'Heading 2',		element: 'h2' },\u000a	{ name: 'Heading 3',		element: 'h3' },\u000a	{ name: 'Heading 4',		element: 'h4' },\u000a	{ name: 'Heading 5',		element: 'h5' },\u000a	{ name: 'Heading 6',		element: 'h6' },\u000a	{ name: 'Preformatted Text',element: 'pre' },\u000a	{ name: 'Address',			element: 'address' },\u000a	*/\u000a\u000a	{ name: 'Italic Title',		element: 'h2', styles: { 'font-style': 'italic' } },\u000a	{ name: 'Subtitle',			element: 'h3', styles: { 'color': '#aaa', 'font-style': 'italic' } },\u000a	{\u000a		name: 'Special Container',\u000a		element: 'div',\u000a		styles: {\u000a			padding: '5px 10px',\u000a			background: '#eee',\u000a			border: '1px solid #ccc'\u000a		}\u000a	},\u000a\u000a	/* Inline Styles */\u000a\u000a	// These are core styles available as toolbar buttons. You may opt enabling\u000a	// some of them in the Styles combo, removing them from the toolbar.\u000a	// (This requires the "stylescombo" plugin)\u000a	/*\u000a	{ name: 'Strong',			element: 'strong', overrides: 'b' },\u000a	{ name: 'Emphasis',			element: 'em'	, overrides: 'i' },\u000a	{ name: 'Underline',		element: 'u' },\u000a	{ name: 'Strikethrough',	element: 'strike' },\u000a	{ name: 'Subscript',		element: 'sub' },\u000a	{ name: 'Superscript',		element: 'sup' },\u000a	*/\u000a\u000a	{ name: 'Marker',			element: 'span', attributes: { 'class': 'marker' } },\u000a\u000a	{ name: 'Big',				element: 'big' },\u000a	{ name: 'Small',			element: 'small' },\u000a	{ name: 'Typewriter',		element: 'tt' },\u000a\u000a	{ name: 'Computer Code',	element: 'code' },\u000a	{ name: 'Keyboard Phrase',	element: 'kbd' },\u000a	{ name: 'Sample Text',		element: 'samp' },\u000a	{ name: 'Variable',			element: 'var' },\u000a\u000a	{ name: 'Deleted Text',		element: 'del' },\u000a	{ name: 'Inserted Text',	element: 'ins' },\u000a\u000a	{ name: 'Cited Work',		element: 'cite' },\u000a	{ name: 'Inline Quotation',	element: 'q' },\u000a\u000a	{ name: 'Language: RTL',	element: 'span', attributes: { 'dir': 'rtl' } },\u000a	{ name: 'Language: LTR',	element: 'span', attributes: { 'dir': 'ltr' } },\u000a\u000a	/* Object Styles */\u000a\u000a	{\u000a		name: 'Styled image (left)',\u000a		element: 'img',\u000a		attributes: { 'class': 'left' }\u000a	},\u000a\u000a	{\u000a		name: 'Styled image (right)',\u000a		element: 'img',\u000a		attributes: { 'class': 'right' }\u000a	},\u000a\u000a	{\u000a		name: 'Compact table',\u000a		element: 'table',\u000a		attributes: {\u000a			cellpadding: '5',\u000a			cellspacing: '0',\u000a			border: '1',\u000a			bordercolor: '#ccc'\u000a		},\u000a		styles: {\u000a			'border-collapse': 'collapse'\u000a		}\u000a	},\u000a\u000a	{ name: 'Borderless Table',		element: 'table',	styles: { 'border-style': 'hidden', 'background-color': '#E6E6FA' } },\u000a	{ name: 'Square Bulleted List',	element: 'ul',		styles: { 'list-style-type': 'square' } }\u000a] );\u000a\u000a// %LEAVE_UNMINIFIED% %REMOVE_LINE%\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	/** @class CKEDITOR */\u000a\u000a	/**\u000a	 * Turns a DOM element with the `contenteditable` attribute set to `true` into a\u000a	 * CKEditor instance. Check {@link CKEDITOR.dtd#$editable} for a list of\u000a	 * allowed element names.\u000a	 *\u000a	 * **Note:** If the DOM element for which inline editing is being enabled does not have\u000a	 * the `contenteditable` attribute set to `true`, the editor will start in read-only mode.\u000a	 *\u000a	 *		<div contenteditable="true" id="content">...</div>\u000a	 *		...\u000a	 *		CKEDITOR.inline( 'content' );\u000a	 *\u000a	 * It is also possible to create an inline editor from the `<textarea>` element.\u000a	 * If you do so, an additional `<div>` element with editable content will be created\u000a	 * directly after the `<textarea>` element and the `<textarea>` element will be hidden.\u000a	 *\u000a	 * @param {Object/String} element The DOM element or its ID.\u000a	 * @param {Object} [instanceConfig] The specific configurations to apply to this editor instance.\u000a	 * See {@link CKEDITOR.config}.\u000a	 * @returns {CKEDITOR.editor} The editor instance created.\u000a	 */\u000a	CKEDITOR.inline = function( element, instanceConfig ) {\u000a		if ( !CKEDITOR.env.isCompatible )\u000a			return null;\u000a\u000a		element = CKEDITOR.dom.element.get( element );\u000a\u000a		// Avoid multiple inline editor instances on the same element.\u000a		if ( element.getEditor() )\u000a			throw 'The editor instance "' + element.getEditor().name + '" is already attached to the provided element.';\u000a\u000a		var editor = new CKEDITOR.editor( instanceConfig, element, CKEDITOR.ELEMENT_MODE_INLINE ),\u000a			textarea = element.is( 'textarea' ) ? element : null;\u000a\u000a		if ( textarea ) {\u000a			editor.setData( textarea.getValue(), null, true );\u000a\u000a			//Change element from textarea to div\u000a			element = CKEDITOR.dom.element.createFromHtml(\u000a				'<div contenteditable="' + !!editor.readOnly + '" class="cke_textarea_inline">' +\u000a					textarea.getValue() +\u000a				'</div>',\u000a				CKEDITOR.document );\u000a\u000a			element.insertAfter( textarea );\u000a			textarea.hide();\u000a\u000a			// Attaching the concrete form.\u000a			if ( textarea.$.form )\u000a				editor._attachToForm();\u000a		} else {\u000a			// Initial editor data is simply loaded from the page element content to make\u000a			// data retrieval possible immediately after the editor creation.\u000a			editor.setData( element.getHtml(), null, true );\u000a		}\u000a\u000a		// Once the editor is loaded, start the UI.\u000a		editor.on( 'loaded', function() {\u000a			editor.fire( 'uiReady' );\u000a\u000a			// Enable editing on the element.\u000a			editor.editable( element );\u000a\u000a			// Editable itself is the outermost element.\u000a			editor.container = element;\u000a\u000a			// Load and process editor data.\u000a			editor.setData( editor.getData( 1 ) );\u000a\u000a			// Clean on startup.\u000a			editor.resetDirty();\u000a\u000a			editor.fire( 'contentDom' );\u000a\u000a			// Inline editing defaults to "wysiwyg" mode, so plugins don't\u000a			// need to make special handling for this "mode-less" environment.\u000a			editor.mode = 'wysiwyg';\u000a			editor.fire( 'mode' );\u000a\u000a			// The editor is completely loaded for interaction.\u000a			editor.status = 'ready';\u000a			editor.fireOnce( 'instanceReady' );\u000a			CKEDITOR.fire( 'instanceReady', null, editor );\u000a\u000a			// give priority to plugins that relay on editor#loaded for bootstrapping.\u000a		}, null, null, 10000 );\u000a\u000a		// Handle editor destroying.\u000a		editor.on( 'destroy', function() {\u000a			// Remove container from DOM if inline-textarea editor.\u000a			// Show <textarea> back again.\u000a			if ( textarea ) {\u000a				editor.container.clearCustomData();\u000a				editor.container.remove();\u000a				textarea.show();\u000a			}\u000a\u000a			editor.element.clearCustomData();\u000a\u000a			delete editor.element;\u000a		} );\u000a\u000a		return editor;\u000a	};\u000a\u000a	/**\u000a	 * Calls {@link CKEDITOR#inline} for all page elements with\u000a	 * the `contenteditable` attribute set to `true`.\u000a	 *\u000a	 */\u000a	CKEDITOR.inlineAll = function() {\u000a		var el, data;\u000a\u000a		for ( var name in CKEDITOR.dtd.$editable ) {\u000a			var elements = CKEDITOR.document.getElementsByTag( name );\u000a\u000a			for ( var i = 0, len = elements.count(); i < len; i++ ) {\u000a				el = elements.getItem( i );\u000a\u000a				if ( el.getAttribute( 'contenteditable' ) == 'true' ) {\u000a					// Fire the "inline" event, making it possible to customize\u000a					// the instance settings and eventually cancel the creation.\u000a\u000a					data = {\u000a						element: el,\u000a						config: {}\u000a					};\u000a\u000a					if ( CKEDITOR.fire( 'inline', data ) !== false )\u000a						CKEDITOR.inline( el, data.config );\u000a				}\u000a			}\u000a		}\u000a	};\u000a\u000a	CKEDITOR.domReady( function() {\u000a		!CKEDITOR.disableAutoInline && CKEDITOR.inlineAll();\u000a	} );\u000a} )();\u000a\u000a/**\u000a * Disables creating the inline editor automatically for elements with\u000a * the `contenteditable` attribute set to `true`.\u000a *\u000a *		CKEDITOR.disableAutoInline = true;\u000a *\u000a * @cfg {Boolean} [disableAutoInline=false]\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a /** @class CKEDITOR */\u000a\u000a/**\u000a * The class name used to identify `<textarea>` elements to be replaced\u000a * by CKEditor instances. Set it to empty/`null` to disable this feature.\u000a *\u000a *		CKEDITOR.replaceClass = 'rich_editor';\u000a *\u000a * @cfg {String} [replaceClass='ckeditor']\u000a */\u000aCKEDITOR.replaceClass = 'ckeditor';\u000a\u000a( function() {\u000a	/**\u000a	 * Replaces a `<textarea>` or a DOM element (`<div>`) with a CKEditor\u000a	 * instance. For textareas, the initial value in the editor will be the\u000a	 * textarea value. For DOM elements, their `innerHTML` will be used\u000a	 * instead. We recommend using `<textarea>` and `<div>` elements only.\u000a	 *\u000a	 *		<textarea id="myfield" name="myfield"></textarea>\u000a	 *		...\u000a	 *		CKEDITOR.replace( 'myfield' );\u000a	 *\u000a	 *		var textarea = document.body.appendChild( document.createElement( 'textarea' ) );\u000a	 *		CKEDITOR.replace( textarea );\u000a	 *\u000a	 * @param {Object/String} element The DOM element (textarea), its ID, or name.\u000a	 * @param {Object} [config] The specific configuration to apply to this\u000a	 * editor instance. Configuration set here will override the global CKEditor settings\u000a	 * (see {@link CKEDITOR.config}).\u000a	 * @returns {CKEDITOR.editor} The editor instance created.\u000a	 */\u000a	CKEDITOR.replace = function( element, config ) {\u000a		return createInstance( element, config, null, CKEDITOR.ELEMENT_MODE_REPLACE );\u000a	};\u000a\u000a	/**\u000a	 * Creates a new editor instance at the end of a specific DOM element.\u000a	 *\u000a	 *		<!DOCTYPE html>\u000a	 * 		<html>\u000a	 * 			<head>\u000a	 * 				<meta charset="utf-8">\u000a	 * 				<title>CKEditor</title>\u000a	 * 				<!-- Make sure the path to CKEditor is correct. -->\u000a	 *				<script src="/ckeditor/ckeditor.js"></script>\u000a	 *			</head>\u000a	 *			<body>\u000a	 *				<div id="editorSpace"></div>\u000a	 *				<script>\u000a	 *					CKEDITOR.appendTo( 'editorSpace' );\u000a	 *				</script>\u000a	 *			</body>\u000a	 *		</html>\u000a	 *\u000a	 * @param {Object/String} element The DOM element, its ID, or name.\u000a	 * @param {Object} [config] The specific configuration to apply to this\u000a	 * editor instance. Configuration set here will override the global CKEditor settings\u000a	 * (see {@link CKEDITOR.config}).\u000a	 * @param {String} [data] Since 3.3. Initial value for the instance.\u000a	 * @returns {CKEDITOR.editor} The editor instance created.\u000a	 */\u000a	CKEDITOR.appendTo = function( element, config, data )\u000a	{\u000a		return createInstance( element, config, data, CKEDITOR.ELEMENT_MODE_APPENDTO );\u000a	};\u000a\u000a	/**\u000a	 * Replaces all `<textarea>` elements available in the document with\u000a	 * editor instances.\u000a	 *\u000a	 *		// Replace all <textarea> elements in the page.\u000a	 *		CKEDITOR.replaceAll();\u000a	 *\u000a	 *		// Replace all <textarea class="myClassName"> elements in the page.\u000a	 *		CKEDITOR.replaceAll( 'myClassName' );\u000a	 *\u000a	 *		// Selectively replace <textarea> elements, based on custom assertions.\u000a	 *		CKEDITOR.replaceAll( function( textarea, config ) {\u000a	 *			// An assertion function that needs to be evaluated for the <textarea>\u000a	 *			// to be replaced. It must explicitely return "false" to ignore a\u000a	 *			// specific <textarea>.\u000a	 *			// You can also customize the editor instance by having the function\u000a	 *			// modify the "config" parameter.\u000a	 *		} );\u000a	 *\u000a	 *		// Full page example where three <textarea> elements are replaced.\u000a	 *		<!DOCTYPE html>\u000a	 *		<html>\u000a	 *			<head>\u000a	 *				<meta charset="utf-8">\u000a	 *				<title>CKEditor</title>\u000a	 *				<!-- Make sure the path to CKEditor is correct. -->\u000a	 *				<script src="/ckeditor/ckeditor.js"></script>\u000a	 *			</head>\u000a	 *			<body>\u000a	 *				<textarea name="editor1"></textarea>\u000a	 *				<textarea name="editor2"></textarea>\u000a	 *				<textarea name="editor3"></textarea>\u000a	 *				<script>\u000a	 *					// Replace all three <textarea> elements above with CKEditor instances.\u000a	 *					CKEDITOR.replaceAll();\u000a	 *				</script>\u000a	 *			</body>\u000a	 *		</html>\u000a	 *\u000a	 * @param {String} [className] The `<textarea>` class name.\u000a	 * @param {Function} [function] An assertion function that must return `true` for a `<textarea>`\u000a	 * to be replaced with the editor. If the function returns `false`, the `<textarea>` element\u000a	 * will not be replaced.\u000a	 */\u000a	CKEDITOR.replaceAll = function() {\u000a		var textareas = document.getElementsByTagName( 'textarea' );\u000a\u000a		for ( var i = 0; i < textareas.length; i++ ) {\u000a			var config = null,\u000a				textarea = textareas[ i ];\u000a\u000a			// The "name" and/or "id" attribute must exist.\u000a			if ( !textarea.name && !textarea.id )\u000a				continue;\u000a\u000a			if ( typeof arguments[ 0 ] == 'string' ) {\u000a				// The textarea class name could be passed as the function\u000a				// parameter.\u000a\u000a				var classRegex = new RegExp( '(?:^|\u005c\u005cs)' + arguments[ 0 ] + '(?:$|\u005c\u005cs)' );\u000a\u000a				if ( !classRegex.test( textarea.className ) )\u000a					continue;\u000a			} else if ( typeof arguments[ 0 ] == 'function' ) {\u000a				// An assertion function could be passed as the function parameter.\u000a				// It must explicitly return "false" to ignore a specific <textarea>.\u000a				config = {};\u000a				if ( arguments[ 0 ]( textarea, config ) === false )\u000a					continue;\u000a			}\u000a\u000a			this.replace( textarea, config );\u000a		}\u000a	};\u000a\u000a	/** @class CKEDITOR.editor */\u000a\u000a	/**\u000a	 * Registers an editing mode. This function is to be used mainly by plugins.\u000a	 *\u000a	 * @param {String} mode The mode name.\u000a	 * @param {Function} exec The function that performs the actual mode change.\u000a	 */\u000a	CKEDITOR.editor.prototype.addMode = function( mode, exec ) {\u000a		( this._.modes || ( this._.modes = {} ) )[ mode ] = exec;\u000a	};\u000a\u000a	/**\u000a	 * Changes the editing mode of this editor instance.\u000a	 *\u000a	 * **Note:** The mode switch could be asynchronous depending on the mode provider.\u000a	 * Use the `callback` to hook subsequent code.\u000a	 *\u000a	 *		// Switch to "source" view.\u000a	 *		CKEDITOR.instances.editor1.setMode( 'source' );\u000a	 *		// Switch to "wysiwyg" view and be notified on completion.\u000a	 *		CKEDITOR.instances.editor1.setMode( 'wysiwyg', function() { alert( 'wysiwyg mode loaded!' ); } );\u000a	 *\u000a	 * @param {String} [newMode] If not specified, the {@link CKEDITOR.config#startupMode} will be used.\u000a	 * @param {Function} [callback] Optional callback function which is invoked once the mode switch has succeeded.\u000a	 */\u000a	CKEDITOR.editor.prototype.setMode = function( newMode, callback ) {\u000a		var editor = this;\u000a\u000a		var modes = this._.modes;\u000a\u000a		// Mode loading quickly fails.\u000a		if ( newMode == editor.mode || !modes || !modes[ newMode ] )\u000a			return;\u000a\u000a		editor.fire( 'beforeSetMode', newMode );\u000a\u000a		if ( editor.mode ) {\u000a			var isDirty = editor.checkDirty(),\u000a				previousModeData = editor._.previousModeData,\u000a				currentData,\u000a				unlockSnapshot = 0;\u000a\u000a			editor.fire( 'beforeModeUnload' );\u000a\u000a			// Detach the current editable. While detaching editable will set\u000a			// cached editor's data (with internal setData call). We use this\u000a			// data below to avoid two getData() calls in a row.\u000a			editor.editable( 0 );\u000a\u000a			editor._.previousMode = editor.mode;\u000a			// Get cached data, which was set while detaching editable.\u000a			editor._.previousModeData = currentData = editor.getData( 1 );\u000a\u000a			// If data has not been modified in the mode which we are currently leaving,\u000a			// avoid making snapshot right after initializing new mode.\u000a			// http://dev.ckeditor.com/ticket/5217#comment:20\u000a			// Tested by:\u000a			// 'test switch mode with unrecoreded, inner HTML specific content (boguses)'\u000a			// 'test switch mode with unrecoreded, inner HTML specific content (boguses) plus changes in source mode'\u000a			if ( editor.mode == 'source' && previousModeData == currentData ) {\u000a				// We need to make sure that unlockSnapshot will update the last snapshot\u000a				// (will not create new one) if lockSnapshot is not called on outdated snapshots stack.\u000a				// Additionally, forceUpdate prevents from making content image now, which is useless\u000a				// (because it equals editor data not inner HTML).\u000a				editor.fire( 'lockSnapshot', { forceUpdate: true } );\u000a				unlockSnapshot = 1;\u000a			}\u000a\u000a			// Clear up the mode space.\u000a			editor.ui.space( 'contents' ).setHtml( '' );\u000a\u000a			editor.mode = '';\u000a		} else {\u000a			editor._.previousModeData = editor.getData( 1 );\u000a		}\u000a\u000a		// Fire the mode handler.\u000a		this._.modes[ newMode ]( function() {\u000a			// Set the current mode.\u000a			editor.mode = newMode;\u000a\u000a			if ( isDirty !== undefined )\u000a				!isDirty && editor.resetDirty();\u000a\u000a			if ( unlockSnapshot )\u000a				editor.fire( 'unlockSnapshot' );\u000a			// Since snapshot made on dataReady (which normally catches changes done by setData)\u000a			// won't work because editor.mode was not set yet (it's set in this function), we need\u000a			// to make special snapshot for changes done in source mode here.\u000a			else if ( newMode == 'wysiwyg' )\u000a				editor.fire( 'saveSnapshot' );\u000a\u000a			// Delay to avoid race conditions (setMode inside setMode).\u000a			setTimeout( function() {\u000a				editor.fire( 'mode' );\u000a				callback && callback.call( editor );\u000a			}, 0 );\u000a		} );\u000a	};\u000a\u000a	/**\u000a	 * Resizes the editor interface.\u000a	 *\u000a	 *		editor.resize( 900, 300 );\u000a	 *\u000a	 *		editor.resize( '100%', 450, true );\u000a	 *\u000a	 * @param {Number/String} width The new width. It can be an integer denoting a value\u000a	 * in pixels or a CSS size value with unit.\u000a	 * @param {Number/String} height The new height. It can be an integer denoting a value\u000a	 * in pixels or a CSS size value with unit.\u000a	 * @param {Boolean} [isContentHeight] Indicates that the provided height is to\u000a	 * be applied to the editor content area, and not to the entire editor\u000a	 * interface. Defaults to `false`.\u000a	 * @param {Boolean} [resizeInner] Indicates that it is the inner interface\u000a	 * element that must be resized, not the outer element. The default theme\u000a	 * defines the editor interface inside a pair of `<span>` elements\u000a	 * (`<span><span>...</span></span>`). By default the first,\u000a	 * outer `<span>` element receives the sizes. If this parameter is set to\u000a	 * `true`, the second, inner `<span>` is resized instead.\u000a	 */\u000a	CKEDITOR.editor.prototype.resize = function( width, height, isContentHeight, resizeInner ) {\u000a		var container = this.container,\u000a			contents = this.ui.space( 'contents' ),\u000a			contentsFrame = CKEDITOR.env.webkit && this.document && this.document.getWindow().$.frameElement,\u000a			outer;\u000a\u000a		if ( resizeInner ) {\u000a			outer = this.container.getFirst( function( node ) {\u000a				return node.type == CKEDITOR.NODE_ELEMENT && node.hasClass( 'cke_inner' );\u000a			} );\u000a		} else {\u000a			outer = container;\u000a		}\u000a\u000a		// Set as border box width. (#5353)\u000a		outer.setSize( 'width', width, true );\u000a\u000a		// WebKit needs to refresh the iframe size to avoid rendering issues. (1/2) (#8348)\u000a		contentsFrame && ( contentsFrame.style.width = '1%' );\u000a\u000a		// Get the height delta between the outer table and the content area.\u000a		// If we're setting the content area's height, then we don't need the delta.\u000a		var delta = isContentHeight ? 0 : ( outer.$.offsetHeight || 0 ) - ( contents.$.clientHeight || 0 );\u000a		contents.setStyle( 'height', Math.max( height - delta, 0 ) + 'px' );\u000a\u000a		// WebKit needs to refresh the iframe size to avoid rendering issues. (2/2) (#8348)\u000a		contentsFrame && ( contentsFrame.style.width = '100%' );\u000a\u000a		// Emit a resize event.\u000a		this.fire( 'resize' );\u000a	};\u000a\u000a	/**\u000a	 * Gets the element that can be used to check the editor size. This method\u000a	 * is mainly used by the `resize` plugin, which adds a UI handle that can be used\u000a	 * to resize the editor.\u000a	 *\u000a	 * @param {Boolean} forContents Whether to return the "contents" part of the theme instead of the container.\u000a	 * @returns {CKEDITOR.dom.element} The resizable element.\u000a	 */\u000a	CKEDITOR.editor.prototype.getResizable = function( forContents ) {\u000a		return forContents ? this.ui.space( 'contents' ) : this.container;\u000a	};\u000a\u000a	function createInstance( element, config, data, mode ) {\u000a		if ( !CKEDITOR.env.isCompatible )\u000a			return null;\u000a\u000a		element = CKEDITOR.dom.element.get( element );\u000a\u000a		// Avoid multiple inline editor instances on the same element.\u000a		if ( element.getEditor() )\u000a			throw 'The editor instance "' + element.getEditor().name + '" is already attached to the provided element.';\u000a\u000a		// Create the editor instance.\u000a		var editor = new CKEDITOR.editor( config, element, mode );\u000a\u000a		if ( mode == CKEDITOR.ELEMENT_MODE_REPLACE ) {\u000a			// Do not replace the textarea right now, just hide it. The effective\u000a			// replacement will be done later in the editor creation lifecycle.\u000a			element.setStyle( 'visibility', 'hidden' );\u000a\u000a			// #8031 Remember if textarea was required and remove the attribute.\u000a			editor._.required = element.hasAttribute( 'required' );\u000a			element.removeAttribute( 'required' );\u000a		}\u000a\u000a		data && editor.setData( data, null, true );\u000a\u000a		// Once the editor is loaded, start the UI.\u000a		editor.on( 'loaded', function() {\u000a			loadTheme( editor );\u000a\u000a			if ( mode == CKEDITOR.ELEMENT_MODE_REPLACE && editor.config.autoUpdateElement && element.$.form )\u000a				editor._attachToForm();\u000a\u000a			editor.setMode( editor.config.startupMode, function() {\u000a				// Clean on startup.\u000a				editor.resetDirty();\u000a\u000a				// Editor is completely loaded for interaction.\u000a				editor.status = 'ready';\u000a				editor.fireOnce( 'instanceReady' );\u000a				CKEDITOR.fire( 'instanceReady', null, editor );\u000a			} );\u000a		} );\u000a\u000a		editor.on( 'destroy', destroy );\u000a		return editor;\u000a	}\u000a\u000a	function destroy() {\u000a		var editor = this,\u000a			container = editor.container,\u000a			element = editor.element;\u000a\u000a		if ( container ) {\u000a			container.clearCustomData();\u000a			container.remove();\u000a		}\u000a\u000a		if ( element ) {\u000a			element.clearCustomData();\u000a			if ( editor.elementMode == CKEDITOR.ELEMENT_MODE_REPLACE ) {\u000a				element.show();\u000a				if ( editor._.required )\u000a					element.setAttribute( 'required', 'required' );\u000a			}\u000a			delete editor.element;\u000a		}\u000a	}\u000a\u000a	function loadTheme( editor ) {\u000a		var name = editor.name,\u000a			element = editor.element,\u000a			elementMode = editor.elementMode;\u000a\u000a		// Get the HTML for the predefined spaces.\u000a		var topHtml = editor.fire( 'uiSpace', { space: 'top', html: '' } ).html;\u000a		var bottomHtml = editor.fire( 'uiSpace', { space: 'bottom', html: '' } ).html;\u000a\u000a		var themedTpl = new CKEDITOR.template(\u000a			'<{outerEl}' +\u000a				' id="cke_{name}"' +\u000a				' class="{id} cke cke_reset cke_chrome cke_editor_{name} cke_{langDir} ' + CKEDITOR.env.cssClass + '" ' +\u000a				' dir="{langDir}"' +\u000a				' lang="{langCode}"' +\u000a				' role="application"' +\u000a				( editor.title ? ' aria-labelledby="cke_{name}_arialbl"' : '' ) +\u000a				'>' +\u000a				( editor.title ? '<span id="cke_{name}_arialbl" class="cke_voice_label">{voiceLabel}</span>' : '' ) +\u000a				'<{outerEl} class="cke_inner cke_reset" role="presentation">' +\u000a					'{topHtml}' +\u000a					'<{outerEl} id="{contentId}" class="cke_contents cke_reset" role="presentation"></{outerEl}>' +\u000a					'{bottomHtml}' +\u000a				'</{outerEl}>' +\u000a			'</{outerEl}>' );\u000a\u000a		var container = CKEDITOR.dom.element.createFromHtml( themedTpl.output( {\u000a			id: editor.id,\u000a			name: name,\u000a			langDir: editor.lang.dir,\u000a			langCode: editor.langCode,\u000a			voiceLabel: editor.title,\u000a			topHtml: topHtml ? '<span id="' + editor.ui.spaceId( 'top' ) + '" class="cke_top cke_reset_all" role="presentation" style="height:auto">' + topHtml + '</span>' : '',\u000a			contentId: editor.ui.spaceId( 'contents' ),\u000a			bottomHtml: bottomHtml ? '<span id="' + editor.ui.spaceId( 'bottom' ) + '" class="cke_bottom cke_reset_all" role="presentation">' + bottomHtml + '</span>' : '',\u000a			outerEl: CKEDITOR.env.ie ? 'span' : 'div'	// #9571\u000a		} ) );\u000a\u000a		if ( elementMode == CKEDITOR.ELEMENT_MODE_REPLACE ) {\u000a			element.hide();\u000a			container.insertAfter( element );\u000a		} else {\u000a			element.append( container );\u000a		}\u000a\u000a		editor.container = container;\u000a\u000a		// Make top and bottom spaces unelectable, but not content space,\u000a		// otherwise the editable area would be affected.\u000a		topHtml && editor.ui.space( 'top' ).unselectable();\u000a		bottomHtml && editor.ui.space( 'bottom' ).unselectable();\u000a\u000a		var width = editor.config.width, height = editor.config.height;\u000a		if ( width )\u000a			container.setStyle( 'width', CKEDITOR.tools.cssLength( width ) );\u000a\u000a		// The editor height is applied to the contents space.\u000a		if ( height )\u000a			editor.ui.space( 'contents' ).setStyle( 'height', CKEDITOR.tools.cssLength( height ) );\u000a\u000a		// Disable browser context menu for editor's chrome.\u000a		container.disableContextMenu();\u000a\u000a		// Redirect the focus into editor for webkit. (#5713)\u000a		CKEDITOR.env.webkit && container.on( 'focus', function() {\u000a			editor.focus();\u000a		} );\u000a\u000a		editor.fireOnce( 'uiReady' );\u000a	}\u000a\u000a	// Replace all textareas with the default class name.\u000a	CKEDITOR.domReady( function() {\u000a		CKEDITOR.replaceClass && CKEDITOR.replaceAll( CKEDITOR.replaceClass );\u000a	} );\u000a} )();\u000a\u000a/**\u000a * The current editing mode. An editing mode basically provides\u000a * different ways of editing or viewing the contents.\u000a *\u000a *		alert( CKEDITOR.instances.editor1.mode ); // (e.g.) 'wysiwyg'\u000a *\u000a * @readonly\u000a * @property {String} mode\u000a */\u000a\u000a/**\u000a * The mode to load at the editor startup. It depends on the plugins\u000a * loaded. By default, the `wysiwyg` and `source` modes are available.\u000a *\u000a *		config.startupMode = 'source';\u000a *\u000a * @cfg {String} [startupMode='wysiwyg']\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.startupMode = 'wysiwyg';\u000a\u000a/**\u000a * Fired after the editor instance is resized through\u000a * the {@link CKEDITOR.editor#method-resize CKEDITOR.resize} method.\u000a *\u000a * @event resize\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Fired before changing the editing mode. See also\u000a * {@link #beforeSetMode} and {@link #event-mode}.\u000a *\u000a * @event beforeModeUnload\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Fired before the editor mode is set. See also\u000a * {@link #event-mode} and {@link #beforeModeUnload}.\u000a *\u000a * @since 3.5.3\u000a * @event beforeSetMode\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param {String} data The name of the mode which is about to be set.\u000a */\u000a\u000a/**\u000a * Fired after setting the editing mode. See also {@link #beforeSetMode} and {@link #beforeModeUnload}\u000a *\u000a * @event mode\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Fired when the editor (replacing a `<textarea>` which has a `required` attribute) is empty during form submission.\u000a *\u000a * This event replaces native required fields validation that the browsers cannot\u000a * perform when CKEditor replaces `<textarea>` elements.\u000a *\u000a * You can cancel this event to prevent the page from submitting data.\u000a *\u000a *		editor.on( 'required', function( evt ) {\u000a *			alert( 'Article content is required.' );\u000a *			evt.cancel();\u000a *		} );\u000a *\u000a * @event required\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.dom.comment} class, which represents\u000a *		a DOM comment node.\u000a */\u000a\u000a/**\u000a * Represents a DOM comment node.\u000a *\u000a *		var nativeNode = document.createComment( 'Example' );\u000a *		var comment = new CKEDITOR.dom.comment( nativeNode );\u000a *\u000a *		var comment = new CKEDITOR.dom.comment( 'Example' );\u000a *\u000a * @class\u000a * @extends CKEDITOR.dom.node\u000a * @constructor Creates a comment class instance.\u000a * @param {Object/String} comment A native DOM comment node or a string containing\u000a * the text to use to create a new comment node.\u000a * @param {CKEDITOR.dom.document} [ownerDocument] The document that will contain\u000a * the node in case of new node creation. Defaults to the current document.\u000a */\u000aCKEDITOR.dom.comment = function( comment, ownerDocument ) {\u000a	if ( typeof comment == 'string' )\u000a		comment = ( ownerDocument ? ownerDocument.$ : document ).createComment( comment );\u000a\u000a	CKEDITOR.dom.domObject.call( this, comment );\u000a};\u000a\u000aCKEDITOR.dom.comment.prototype = new CKEDITOR.dom.node();\u000a\u000aCKEDITOR.tools.extend( CKEDITOR.dom.comment.prototype, {\u000a	/**\u000a	 * The node type. This is a constant value set to {@link CKEDITOR#NODE_COMMENT}.\u000a	 *\u000a	 * @readonly\u000a	 * @property {Number} [=CKEDITOR.NODE_COMMENT]\u000a	 */\u000a	type: CKEDITOR.NODE_COMMENT,\u000a\u000a	/**\u000a	 * Gets the outer HTML of this comment.\u000a	 *\u000a	 * @returns {String} The HTML `<!-- comment value -->`.\u000a	 */\u000a	getOuterHtml: function() {\u000a		return '<!--' + this.$.nodeValue + '-->';\u000a	}\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a'use strict';\u000a\u000a( function() {\u000a\u000a	var pathBlockLimitElements = {},\u000a		pathBlockElements = {},\u000a		tag;\u000a\u000a	// Elements that are considered the "Block limit" in an element path.\u000a	for ( tag in CKEDITOR.dtd.$blockLimit ) {\u000a		// Exclude from list roots.\u000a		if ( !( tag in CKEDITOR.dtd.$list ) )\u000a			pathBlockLimitElements[ tag ] = 1;\u000a	}\u000a\u000a	// Elements that are considered the "End level Block" in an element path.\u000a	for ( tag in CKEDITOR.dtd.$block ) {\u000a		// Exclude block limits, and empty block element, e.g. hr.\u000a		if ( !( tag in CKEDITOR.dtd.$blockLimit || tag in CKEDITOR.dtd.$empty ) )\u000a			pathBlockElements[ tag ] = 1;\u000a	}\u000a\u000a	// Check if an element contains any block element.\u000a	function checkHasBlock( element ) {\u000a		var childNodes = element.getChildren();\u000a\u000a		for ( var i = 0, count = childNodes.count(); i < count; i++ ) {\u000a			var child = childNodes.getItem( i );\u000a\u000a			if ( child.type == CKEDITOR.NODE_ELEMENT && CKEDITOR.dtd.$block[ child.getName() ] )\u000a				return true;\u000a		}\u000a\u000a		return false;\u000a	}\u000a\u000a	/**\u000a	 * Retrieve the list of nodes walked from the start node up to the editable element of the editor.\u000a	 *\u000a	 * @class\u000a	 * @constructor Creates an element path class instance.\u000a	 * @param {CKEDITOR.dom.element} startNode From which the path should start.\u000a	 * @param {CKEDITOR.dom.element} root To which element the path should stop, defaults to the `body` element.\u000a	 */\u000a	CKEDITOR.dom.elementPath = function( startNode, root ) {\u000a		var block = null,\u000a			blockLimit = null,\u000a			elements = [],\u000a			e = startNode,\u000a			elementName;\u000a\u000a		// Backward compact.\u000a		root = root || startNode.getDocument().getBody();\u000a\u000a		do {\u000a			if ( e.type == CKEDITOR.NODE_ELEMENT ) {\u000a				elements.push( e );\u000a\u000a				if ( !this.lastElement ) {\u000a					this.lastElement = e;\u000a\u000a					// If an object or non-editable element is fully selected at the end of the element path,\u000a					// it must not become the block limit.\u000a					if ( e.is( CKEDITOR.dtd.$object ) || e.getAttribute( 'contenteditable' ) == 'false' )\u000a						continue;\u000a				}\u000a\u000a				if ( e.equals( root ) )\u000a					break;\u000a\u000a				if ( !blockLimit ) {\u000a					elementName = e.getName();\u000a\u000a					// First editable element becomes a block limit, because it cannot be split.\u000a					if ( e.getAttribute( 'contenteditable' ) == 'true' )\u000a						blockLimit = e;\u000a					// "Else" because element cannot be both - block and block levelimit.\u000a					else if ( !block && pathBlockElements[ elementName ] )\u000a						block = e;\u000a\u000a					if ( pathBlockLimitElements[ elementName ] ) {\u000a						// End level DIV is considered as the block, if no block is available. (#525)\u000a						// But it must NOT be the root element (checked above).\u000a						if ( !block && elementName == 'div' && !checkHasBlock( e ) )\u000a							block = e;\u000a						else\u000a							blockLimit = e;\u000a					}\u000a				}\u000a			}\u000a		}\u000a		while ( ( e = e.getParent() ) );\u000a\u000a		// Block limit defaults to root.\u000a		if ( !blockLimit )\u000a			blockLimit = root;\u000a\u000a		/**\u000a		 * First non-empty block element which:\u000a		 *\u000a		 * * is not a {@link CKEDITOR.dtd#$blockLimit},\u000a		 * * or is a `div` which does not contain block elements and is not a `root`.\u000a		 *\u000a		 * This means a first, splittable block in elements path.\u000a		 *\u000a		 * @readonly\u000a		 * @property {CKEDITOR.dom.element}\u000a		 */\u000a		this.block = block;\u000a\u000a		/**\u000a		 * See the {@link CKEDITOR.dtd#$blockLimit} description.\u000a		 *\u000a		 * @readonly\u000a		 * @property {CKEDITOR.dom.element}\u000a		 */\u000a		this.blockLimit = blockLimit;\u000a\u000a		/**\u000a		 * The root of the elements path - `root` argument passed to class constructor or a `body` element.\u000a		 *\u000a		 * @readonly\u000a		 * @property {CKEDITOR.dom.element}\u000a		 */\u000a		this.root = root;\u000a\u000a		/**\u000a		 * An array of elements (from `startNode` to `root`) in the path.\u000a		 *\u000a		 * @readonly\u000a		 * @property {CKEDITOR.dom.element[]}\u000a		 */\u000a		this.elements = elements;\u000a\u000a		/**\u000a		 * The last element of the elements path - `startNode` or its parent.\u000a		 *\u000a		 * @readonly\u000a		 * @property {CKEDITOR.dom.element} lastElement\u000a		 */\u000a	};\u000a\u000a} )();\u000a\u000aCKEDITOR.dom.elementPath.prototype = {\u000a	/**\u000a	 * Compares this element path with another one.\u000a	 *\u000a	 * @param {CKEDITOR.dom.elementPath} otherPath The elementPath object to be\u000a	 * compared with this one.\u000a	 * @returns {Boolean} `true` if the paths are equal, containing the same\u000a	 * number of elements and the same elements in the same order.\u000a	 */\u000a	compare: function( otherPath ) {\u000a		var thisElements = this.elements;\u000a		var otherElements = otherPath && otherPath.elements;\u000a\u000a		if ( !otherElements || thisElements.length != otherElements.length )\u000a			return false;\u000a\u000a		for ( var i = 0; i < thisElements.length; i++ ) {\u000a			if ( !thisElements[ i ].equals( otherElements[ i ] ) )\u000a				return false;\u000a		}\u000a\u000a		return true;\u000a	},\u000a\u000a	/**\u000a	 * Search the path elements that meets the specified criteria.\u000a	 *\u000a	 * @param {String/Array/Function/Object/CKEDITOR.dom.element} query The criteria that can be\u000a	 * either a tag name, list (array and object) of tag names, element or an node evaluator function.\u000a	 * @param {Boolean} [excludeRoot] Not taking path root element into consideration.\u000a	 * @param {Boolean} [fromTop] Search start from the topmost element instead of bottom.\u000a	 * @returns {CKEDITOR.dom.element} The first matched dom element or `null`.\u000a	 */\u000a	contains: function( query, excludeRoot, fromTop ) {\u000a		var evaluator;\u000a		if ( typeof query == 'string' )\u000a			evaluator = function( node ) {\u000a				return node.getName() == query;\u000a			};\u000a		if ( query instanceof CKEDITOR.dom.element )\u000a			evaluator = function( node ) {\u000a				return node.equals( query );\u000a			};\u000a		else if ( CKEDITOR.tools.isArray( query ) )\u000a			evaluator = function( node ) {\u000a				return CKEDITOR.tools.indexOf( query, node.getName() ) > -1;\u000a			};\u000a		else if ( typeof query == 'function' )\u000a			evaluator = query;\u000a		else if ( typeof query == 'object' )\u000a			evaluator = function( node ) {\u000a				return node.getName() in query;\u000a			};\u000a\u000a		var elements = this.elements,\u000a			length = elements.length;\u000a		excludeRoot && length--;\u000a\u000a		if ( fromTop ) {\u000a			elements = Array.prototype.slice.call( elements, 0 );\u000a			elements.reverse();\u000a		}\u000a\u000a		for ( var i = 0; i < length; i++ ) {\u000a			if ( evaluator( elements[ i ] ) )\u000a				return elements[ i ];\u000a		}\u000a\u000a		return null;\u000a	},\u000a\u000a	/**\u000a	 * Check whether the elements path is the proper context for the specified\u000a	 * tag name in the DTD.\u000a	 *\u000a	 * @param {String} tag The tag name.\u000a	 * @returns {Boolean}\u000a	 */\u000a	isContextFor: function( tag ) {\u000a		var holder;\u000a\u000a		// Check for block context.\u000a		if ( tag in CKEDITOR.dtd.$block ) {\u000a			// Indeterminate elements which are not subjected to be splitted or surrounded must be checked first.\u000a			var inter = this.contains( CKEDITOR.dtd.$intermediate );\u000a			holder = inter || ( this.root.equals( this.block ) && this.block ) || this.blockLimit;\u000a			return !!holder.getDtd()[ tag ];\u000a		}\u000a\u000a		return true;\u000a	},\u000a\u000a	/**\u000a	 * Retrieve the text direction for this elements path.\u000a	 *\u000a	 * @returns {'ltr'/'rtl'}\u000a	 */\u000a	direction: function() {\u000a		var directionNode = this.block || this.blockLimit || this.root;\u000a		return directionNode.getDirection( 1 );\u000a	}\u000a};\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.dom.text} class, which represents\u000a *		a DOM text node.\u000a */\u000a\u000a/**\u000a * Represents a DOM text node.\u000a *\u000a *		var nativeNode = document.createTextNode( 'Example' );\u000a *		var text = CKEDITOR.dom.text( nativeNode );\u000a *\u000a *		var text = CKEDITOR.dom.text( 'Example' );\u000a *\u000a * @class\u000a * @extends CKEDITOR.dom.node\u000a * @constructor Creates a text class instance.\u000a * @param {Object/String} text A native DOM text node or a string containing\u000a * the text to use to create a new text node.\u000a * @param {CKEDITOR.dom.document} [ownerDocument] The document that will contain\u000a * the node in case of new node creation. Defaults to the current document.\u000a */\u000aCKEDITOR.dom.text = function( text, ownerDocument ) {\u000a	if ( typeof text == 'string' )\u000a		text = ( ownerDocument ? ownerDocument.$ : document ).createTextNode( text );\u000a\u000a	// Theoretically, we should call the base constructor here\u000a	// (not CKEDITOR.dom.node though). But, IE doesn't support expando\u000a	// properties on text node, so the features provided by domObject will not\u000a	// work for text nodes (which is not a big issue for us).\u000a	//\u000a	// CKEDITOR.dom.domObject.call( this, element );\u000a\u000a	this.$ = text;\u000a};\u000a\u000aCKEDITOR.dom.text.prototype = new CKEDITOR.dom.node();\u000a\u000aCKEDITOR.tools.extend( CKEDITOR.dom.text.prototype, {\u000a	/**\u000a	 * The node type. This is a constant value set to {@link CKEDITOR#NODE_TEXT}.\u000a	 *\u000a	 * @readonly\u000a	 * @property {Number} [=CKEDITOR.NODE_TEXT]\u000a	 */\u000a	type: CKEDITOR.NODE_TEXT,\u000a\u000a	/**\u000a	 * Gets length of node's value.\u000a	 *\u000a	 * @returns {Number}\u000a	 */\u000a	getLength: function() {\u000a		return this.$.nodeValue.length;\u000a	},\u000a\u000a	/**\u000a	 * Gets node's value.\u000a	 *\u000a	 * @returns {String}\u000a	 */\u000a	getText: function() {\u000a		return this.$.nodeValue;\u000a	},\u000a\u000a	/**\u000a	 * Sets node's value.\u000a	 *\u000a	 * @param {String} text\u000a	 */\u000a	setText: function( text ) {\u000a		this.$.nodeValue = text;\u000a	},\u000a\u000a	/**\u000a	 * Breaks this text node into two nodes at the specified offset,\u000a	 * keeping both in the tree as siblings. This node then only contains\u000a	 * all the content up to the offset point. A new text node, which is\u000a	 * inserted as the next sibling of this node, contains all the content\u000a	 * at and after the offset point. When the offset is equal to the\u000a	 * length of this node, the new node has no data.\u000a	 *\u000a	 * @param {Number} The position at which to split, starting from zero.\u000a	 * @returns {CKEDITOR.dom.text} The new text node.\u000a	 */\u000a	split: function( offset ) {\u000a\u000a		// Saved the children count and text length beforehand.\u000a		var parent = this.$.parentNode,\u000a			count = parent.childNodes.length,\u000a			length = this.getLength();\u000a\u000a		var doc = this.getDocument();\u000a		var retval = new CKEDITOR.dom.text( this.$.splitText( offset ), doc );\u000a\u000a		if ( parent.childNodes.length == count )\u000a		{\u000a			// If the offset is after the last char, IE creates the text node\u000a			// on split, but don't include it into the DOM. So, we have to do\u000a			// that manually here.\u000a			if ( offset >= length )\u000a			{\u000a				retval = doc.createText( '' );\u000a				retval.insertAfter( this );\u000a			}\u000a			else\u000a			{\u000a				// IE BUG: IE8+ does not update the childNodes array in DOM after splitText(),\u000a				// we need to make some DOM changes to make it update. (#3436)\u000a				var workaround = doc.createText( '' );\u000a				workaround.insertAfter( retval );\u000a				workaround.remove();\u000a			}\u000a		}\u000a\u000a		return retval;\u000a	},\u000a\u000a	/**\u000a	 * Extracts characters from indexA up to but not including `indexB`.\u000a	 *\u000a	 * @param {Number} indexA An integer between `0` and one less than the\u000a	 * length of the text.\u000a	 * @param {Number} [indexB] An integer between `0` and the length of the\u000a	 * string. If omitted, extracts characters to the end of the text.\u000a	 */\u000a	substring: function( indexA, indexB ) {\u000a		// We need the following check due to a Firefox bug\u000a		// https://bugzilla.mozilla.org/show_bug.cgi?id=458886\u000a		if ( typeof indexB != 'number' )\u000a			return this.$.nodeValue.substr( indexA );\u000a		else\u000a			return this.$.nodeValue.substring( indexA, indexB );\u000a	}\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	/**\u000a	 * Represents a list os CKEDITOR.dom.range objects, which can be easily\u000a	 * iterated sequentially.\u000a	 *\u000a	 * @class\u000a	 * @extends Array\u000a	 * @constructor Creates a rangeList class instance.\u000a	 * @param {CKEDITOR.dom.range/CKEDITOR.dom.range[]} [ranges] The ranges contained on this list.\u000a	 * Note that, if an array of ranges is specified, the range sequence\u000a	 * should match its DOM order. This class will not help to sort them.\u000a	 */\u000a	CKEDITOR.dom.rangeList = function( ranges ) {\u000a		if ( ranges instanceof CKEDITOR.dom.rangeList )\u000a			return ranges;\u000a\u000a		if ( !ranges )\u000a			ranges = [];\u000a		else if ( ranges instanceof CKEDITOR.dom.range )\u000a			ranges = [ ranges ];\u000a\u000a		return CKEDITOR.tools.extend( ranges, mixins );\u000a	};\u000a\u000a	var mixins = {\u000a		/**\u000a		 * Creates an instance of the rangeList iterator, it should be used\u000a		 * only when the ranges processing could be DOM intrusive, which\u000a		 * means it may pollute and break other ranges in this list.\u000a		 * Otherwise, it's enough to just iterate over this array in a for loop.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.rangeListIterator}\u000a		 */\u000a		createIterator: function() {\u000a			var rangeList = this,\u000a				bookmark = CKEDITOR.dom.walker.bookmark(),\u000a				bookmarks = [],\u000a				current;\u000a\u000a			return {\u000a				/**\u000a				 * Retrieves the next range in the list.\u000a				 *\u000a				 * @member CKEDITOR.dom.rangeListIterator\u000a				 * @param {Boolean} [mergeConsequent=false] Whether join two adjacent\u000a				 * ranges into single, e.g. consequent table cells.\u000a				 */\u000a				getNextRange: function( mergeConsequent ) {\u000a					current = current === undefined ? 0 : current + 1;\u000a\u000a					var range = rangeList[ current ];\u000a\u000a					// Multiple ranges might be mangled by each other.\u000a					if ( range && rangeList.length > 1 ) {\u000a						// Bookmarking all other ranges on the first iteration,\u000a						// the range correctness after it doesn't matter since we'll\u000a						// restore them before the next iteration.\u000a						if ( !current ) {\u000a							// Make sure bookmark correctness by reverse processing.\u000a							for ( var i = rangeList.length - 1; i >= 0; i-- )\u000a								bookmarks.unshift( rangeList[ i ].createBookmark( true ) );\u000a						}\u000a\u000a						if ( mergeConsequent ) {\u000a							// Figure out how many ranges should be merged.\u000a							var mergeCount = 0;\u000a							while ( rangeList[ current + mergeCount + 1 ] ) {\u000a								var doc = range.document,\u000a									found = 0,\u000a									left = doc.getById( bookmarks[ mergeCount ].endNode ),\u000a									right = doc.getById( bookmarks[ mergeCount + 1 ].startNode ),\u000a									next;\u000a\u000a								// Check subsequent range.\u000a								while ( 1 ) {\u000a									next = left.getNextSourceNode( false );\u000a									if ( !right.equals( next ) ) {\u000a										// This could be yet another bookmark or\u000a										// walking across block boundaries.\u000a										if ( bookmark( next ) || ( next.type == CKEDITOR.NODE_ELEMENT && next.isBlockBoundary() ) ) {\u000a											left = next;\u000a											continue;\u000a										}\u000a									} else {\u000a										found = 1;\u000a									}\u000a\u000a									break;\u000a								}\u000a\u000a								if ( !found )\u000a									break;\u000a\u000a								mergeCount++;\u000a							}\u000a						}\u000a\u000a						range.moveToBookmark( bookmarks.shift() );\u000a\u000a						// Merge ranges finally after moving to bookmarks.\u000a						while ( mergeCount-- ) {\u000a							next = rangeList[ ++current ];\u000a							next.moveToBookmark( bookmarks.shift() );\u000a							range.setEnd( next.endContainer, next.endOffset );\u000a						}\u000a					}\u000a\u000a					return range;\u000a				}\u000a			};\u000a		},\u000a\u000a		/**\u000a		 * Create bookmarks for all ranges. See {@link CKEDITOR.dom.range#createBookmark}.\u000a		 *\u000a		 * @param {Boolean} [serializable=false] See {@link CKEDITOR.dom.range#createBookmark}.\u000a		 * @returns {Array} Array of bookmarks.\u000a		 */\u000a		createBookmarks: function( serializable ) {\u000a			var retval = [],\u000a				bookmark;\u000a			for ( var i = 0; i < this.length; i++ ) {\u000a				retval.push( bookmark = this[ i ].createBookmark( serializable, true ) );\u000a\u000a				// Updating the container & offset values for ranges\u000a				// that have been touched.\u000a				for ( var j = i + 1; j < this.length; j++ ) {\u000a					this[ j ] = updateDirtyRange( bookmark, this[ j ] );\u000a					this[ j ] = updateDirtyRange( bookmark, this[ j ], true );\u000a				}\u000a			}\u000a			return retval;\u000a		},\u000a\u000a		/**\u000a		 * Create "unobtrusive" bookmarks for all ranges. See {@link CKEDITOR.dom.range#createBookmark2}.\u000a		 *\u000a		 * @param {Boolean} [normalized=false] See {@link CKEDITOR.dom.range#createBookmark2}.\u000a		 * @returns {Array} Array of bookmarks.\u000a		 */\u000a		createBookmarks2: function( normalized ) {\u000a			var bookmarks = [];\u000a\u000a			for ( var i = 0; i < this.length; i++ )\u000a				bookmarks.push( this[ i ].createBookmark2( normalized ) );\u000a\u000a			return bookmarks;\u000a		},\u000a\u000a		/**\u000a		 * Move each range in the list to the position specified by a list of bookmarks.\u000a		 *\u000a		 * @param {Array} bookmarks The list of bookmarks, each one matching a range in the list.\u000a		 */\u000a		moveToBookmarks: function( bookmarks ) {\u000a			for ( var i = 0; i < this.length; i++ )\u000a				this[ i ].moveToBookmark( bookmarks[ i ] );\u000a		}\u000a	};\u000a\u000a	// Update the specified range which has been mangled by previous insertion of\u000a	// range bookmark nodes.(#3256)\u000a	function updateDirtyRange( bookmark, dirtyRange, checkEnd ) {\u000a		var serializable = bookmark.serializable,\u000a			container = dirtyRange[ checkEnd ? 'endContainer' : 'startContainer' ],\u000a			offset = checkEnd ? 'endOffset' : 'startOffset';\u000a\u000a		var bookmarkStart = serializable ? dirtyRange.document.getById( bookmark.startNode ) : bookmark.startNode;\u000a\u000a		var bookmarkEnd = serializable ? dirtyRange.document.getById( bookmark.endNode ) : bookmark.endNode;\u000a\u000a		if ( container.equals( bookmarkStart.getPrevious() ) ) {\u000a			dirtyRange.startOffset = dirtyRange.startOffset - container.getLength() - bookmarkEnd.getPrevious().getLength();\u000a			container = bookmarkEnd.getNext();\u000a		} else if ( container.equals( bookmarkEnd.getPrevious() ) ) {\u000a			dirtyRange.startOffset = dirtyRange.startOffset - container.getLength();\u000a			container = bookmarkEnd.getNext();\u000a		}\u000a\u000a		container.equals( bookmarkStart.getParent() ) && dirtyRange[ offset ]++;\u000a		container.equals( bookmarkEnd.getParent() ) && dirtyRange[ offset ]++;\u000a\u000a		// Update and return this range.\u000a		dirtyRange[ checkEnd ? 'endContainer' : 'startContainer' ] = container;\u000a		return dirtyRange;\u000a	}\u000a} )();\u000a\u000a/**\u000a * (Virtual Class) Do not call this constructor. This class is not really part\u000a * of the API. It just describes the return type of {@link CKEDITOR.dom.rangeList#createIterator}.\u000a *\u000a * @class CKEDITOR.dom.rangeListIterator\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Defines the {@link CKEDITOR.skin} class that is used to manage skin parts.\u000a */\u000a\u000a( function() {\u000a	var cssLoaded = {};\u000a\u000a	function getName() {\u000a		return CKEDITOR.skinName.split( ',' )[ 0 ];\u000a	}\u000a\u000a	function getConfigPath() {\u000a		return CKEDITOR.getUrl( CKEDITOR.skinName.split( ',' )[ 1 ] || ( 'skins/' + getName() + '/' ) );\u000a	}\u000a\u000a	/**\u000a	 * Manages the loading of skin parts among all editor instances.\u000a	 *\u000a	 * @class\u000a	 * @singleton\u000a	 */\u000a	CKEDITOR.skin = {\u000a		/**\u000a		 * Returns the root path to the skin directory.\u000a		 *\u000a		 * @method\u000a		 * @todo\u000a		 */\u000a		path: getConfigPath,\u000a\u000a		/**\u000a		 * Loads a skin part into the page. Does nothing if the part has already been loaded.\u000a		 *\u000a		 * **Note:** The "editor" part is always auto loaded upon instance creation,\u000a		 * thus this function is mainly used to **lazy load** other parts of the skin\u000a		 * that do not have to be displayed until requested.\u000a		 *\u000a		 *		// Load the dialog part.\u000a		 *		editor.skin.loadPart( 'dialog' );\u000a		 *\u000a		 * @param {String} part The name of the skin part CSS file that resides in the skin directory.\u000a		 * @param {Function} fn The provided callback function which is invoked after the part is loaded.\u000a		 */\u000a		loadPart: function( part, fn ) {\u000a			if ( CKEDITOR.skin.name != getName() ) {\u000a				CKEDITOR.scriptLoader.load( CKEDITOR.getUrl( getConfigPath() + 'skin.js' ), function() {\u000a					loadCss( part, fn );\u000a				} );\u000a			} else {\u000a				loadCss( part, fn );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Retrieves the real URL of a (CSS) skin part.\u000a		 *\u000a		 * @param {String} part\u000a		 */\u000a		getPath: function( part ) {\u000a			return CKEDITOR.getUrl( getCssPath( part ) );\u000a		},\u000a\u000a		/**\u000a		 * The list of registered icons. To add new icons to this list, use {@link #addIcon}.\u000a		 */\u000a		icons: {},\u000a\u000a		/**\u000a		 * Registers an icon.\u000a		 *\u000a		 * @param {String} name The icon name.\u000a		 * @param {String} path The path to the icon image file.\u000a		 * @param {Number} [offset] The vertical offset position of the icon, if\u000a		 * available inside a strip image.\u000a		 * @param {String} [bgsize] The value of the CSS "background-size" property to\u000a		 * use for this icon\u000a		 */\u000a		addIcon: function( name, path, offset, bgsize ) {\u000a			name = name.toLowerCase();\u000a			if ( !this.icons[ name ] ) {\u000a				this.icons[ name ] = {\u000a					path: path,\u000a					offset: offset || 0,\u000a					bgsize: bgsize || '16px'\u000a				};\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Gets the CSS background styles to be used to render a specific icon.\u000a		 *\u000a		 * @param {String} name The icon name, as registered with {@link #addIcon}.\u000a		 * @param {Boolean} [rtl] Indicates that the RTL version of the icon is\u000a		 * to be used, if available.\u000a		 * @param {String} [overridePath] The path to the icon image file. It\u000a		 * overrides the path defined by the named icon, if available, and is\u000a		 * used if the named icon was not registered.\u000a		 * @param {Number} [overrideOffset] The vertical offset position of the\u000a		 * icon. It overrides the offset defined by the named icon, if\u000a		 * available, and is used if the named icon was not registered.\u000a		 * @param {String} [overrideBgsize] The value of the CSS "background-size" property\u000a		 * to use for the icon. It overrides the value defined by the named icon,\u000a		 * if available, and is used if the named icon was not registered.\u000a		 */\u000a		getIconStyle: function( name, rtl, overridePath, overrideOffset, overrideBgsize ) {\u000a			var icon, path, offset, bgsize;\u000a\u000a			if ( name ) {\u000a				name = name.toLowerCase();\u000a				// If we're in RTL, try to get the RTL version of the icon.\u000a				if ( rtl )\u000a					icon = this.icons[ name + '-rtl' ];\u000a\u000a				// If not in LTR or no RTL version available, get the generic one.\u000a				if ( !icon )\u000a					icon = this.icons[ name ];\u000a			}\u000a\u000a			path = overridePath || ( icon && icon.path ) || '';\u000a			offset = overrideOffset || ( icon && icon.offset );\u000a			bgsize = overrideBgsize || ( icon && icon.bgsize ) || '16px';\u000a\u000a			return path &&\u000a				( 'background-image:url(' + CKEDITOR.getUrl( path ) + ');background-position:0 ' + offset + 'px;background-size:' + bgsize + ';' );\u000a		}\u000a	};\u000a\u000a	function getCssPath( part ) {\u000a		// Check for ua-specific version of skin part.\u000a		var uas = CKEDITOR.skin[ 'ua_' + part ], env = CKEDITOR.env;\u000a		if ( uas ) {\u000a\u000a			// Having versioned UA checked first.\u000a			uas = uas.split( ',' ).sort( function( a, b ) {\u000a				return a > b ? -1 : 1;\u000a			} );\u000a\u000a			// Loop through all ua entries, checking is any of them match the current ua.\u000a			for ( var i = 0, ua; i < uas.length; i++ ) {\u000a				ua = uas[ i ];\u000a\u000a				if ( env.ie ) {\u000a					if ( ( ua.replace( /^ie/, '' ) == env.version ) || ( env.quirks && ua == 'iequirks' ) )\u000a						ua = 'ie';\u000a				}\u000a\u000a				if ( env[ ua ] ) {\u000a					part += '_' + uas[ i ];\u000a					break;\u000a				}\u000a			}\u000a		}\u000a		return CKEDITOR_CSS[part] && CKEDITOR.getUrl( CKEDITOR_CSS[part] );\u000a	}\u000a\u000a	function loadCss( part, callback ) {\u000a		// Avoid reload.\u000a		if ( !cssLoaded[ part ] ) {\u000a			var url = getCssPath( part );\u000a			if ( url ) CKEDITOR.document.appendStyleSheet( url );\u000a			cssLoaded[ part ] = 1;\u000a		}\u000a\u000a		// CSS loading should not be blocking.\u000a		callback && callback();\u000a	}\u000a\u000a	CKEDITOR.tools.extend( CKEDITOR.editor.prototype, {\u000a		/** Gets the color of the editor user interface.\u000a		 *\u000a		 *		CKEDITOR.instances.editor1.getUiColor();\u000a		 *\u000a		 * @method\u000a		 * @member CKEDITOR.editor\u000a		 * @returns {String} uiColor The editor UI color or `undefined` if the UI color is not set.\u000a		 */\u000a		getUiColor: function() {\u000a			return this.uiColor;\u000a		},\u000a\u000a		/** Sets the color of the editor user interface. This method accepts a color value in\u000a		 * hexadecimal notation, with a `#` character (e.g. #ffffff).\u000a		 *\u000a		 * 		CKEDITOR.instances.editor1.setUiColor( '#ff00ff' );\u000a		 *\u000a		 * @method\u000a		 * @member CKEDITOR.editor\u000a		 * @param {String} color The desired editor UI color in hexadecimal notation.\u000a		 */\u000a		setUiColor: function( color ) {\u000a			var uiStyle = getStylesheet( CKEDITOR.document );\u000a\u000a			return ( this.setUiColor = function( color ) {\u000a				var chameleon = CKEDITOR.skin.chameleon;\u000a\u000a				var replace = [ [ uiColorRegexp, color ] ];\u000a				this.uiColor = color;\u000a\u000a				// Update general style.\u000a				updateStylesheets( [ uiStyle ], chameleon( this, 'editor' ), replace );\u000a\u000a				// Update panel styles.\u000a				updateStylesheets( uiColorMenus, chameleon( this, 'panel' ), replace );\u000a			} ).call( this, color );\u000a		}\u000a	} );\u000a\u000a	var uiColorStylesheetId = 'cke_ui_color',\u000a		uiColorMenus = [],\u000a		uiColorRegexp = /\u005c$color/g;\u000a\u000a	function getStylesheet( document ) {\u000a		var node = document.getById( uiColorStylesheetId );\u000a		if ( !node ) {\u000a			node = document.getHead().append( 'style' );\u000a			node.setAttribute( 'id', uiColorStylesheetId );\u000a			node.setAttribute( 'type', 'text/css' );\u000a		}\u000a		return node;\u000a	}\u000a\u000a	function updateStylesheets( styleNodes, styleContent, replace ) {\u000a		var r, i, content;\u000a\u000a		// We have to split CSS declarations for webkit.\u000a		if ( CKEDITOR.env.webkit ) {\u000a			styleContent = styleContent.split( '}' ).slice( 0, -1 );\u000a			for ( i = 0; i < styleContent.length; i++ )\u000a				styleContent[ i ] = styleContent[ i ].split( '{' );\u000a		}\u000a\u000a		for ( var id = 0; id < styleNodes.length; id++ ) {\u000a			if ( CKEDITOR.env.webkit ) {\u000a				for ( i = 0; i < styleContent.length; i++ ) {\u000a					content = styleContent[ i ][ 1 ];\u000a					for ( r = 0; r < replace.length; r++ )\u000a						content = content.replace( replace[ r ][ 0 ], replace[ r ][ 1 ] );\u000a\u000a					styleNodes[ id ].$.sheet.addRule( styleContent[ i ][ 0 ], content );\u000a				}\u000a			} else {\u000a				content = styleContent;\u000a				for ( r = 0; r < replace.length; r++ )\u000a					content = content.replace( replace[ r ][ 0 ], replace[ r ][ 1 ] );\u000a\u000a				if ( CKEDITOR.env.ie && CKEDITOR.env.version < 11 )\u000a					styleNodes[ id ].$.styleSheet.cssText += content;\u000a				else\u000a					styleNodes[ id ].$.innerHTML += content;\u000a			}\u000a		}\u000a	}\u000a\u000a	CKEDITOR.on( 'instanceLoaded', function( evt ) {\u000a		// The chameleon feature is not for IE quirks.\u000a		if ( CKEDITOR.env.ie && CKEDITOR.env.quirks )\u000a			return;\u000a\u000a		var editor = evt.editor,\u000a			showCallback = function( event ) {\u000a				var panel = event.data[ 0 ] || event.data;\u000a				var iframe = panel.element.getElementsByTag( 'iframe' ).getItem( 0 ).getFrameDocument();\u000a\u000a				// Add stylesheet if missing.\u000a				if ( !iframe.getById( 'cke_ui_color' ) ) {\u000a					var node = getStylesheet( iframe );\u000a					uiColorMenus.push( node );\u000a\u000a					var color = editor.getUiColor();\u000a					// Set uiColor for new panel.\u000a					if ( color )\u000a						updateStylesheets( [ node ], CKEDITOR.skin.chameleon( editor, 'panel' ), [ [ uiColorRegexp, color ] ] );\u000a\u000a				}\u000a			};\u000a\u000a		editor.on( 'panelShow', showCallback );\u000a		editor.on( 'menuShow', showCallback );\u000a\u000a		// Apply UI color if specified in config.\u000a		if ( editor.config.uiColor )\u000a			editor.setUiColor( editor.config.uiColor );\u000a	} );\u000a} )();\u000a\u000a/**\u000a * The list of file names matching the browser user agent string from\u000a * {@link CKEDITOR.env}. This is used to load the skin part file in addition\u000a * to the "main" skin file for a particular browser.\u000a *\u000a * **Note:** For each of the defined skin parts the corresponding\u000a * CSS file with the same name as the user agent must exist inside\u000a * the skin directory.\u000a *\u000a * @property ua\u000a * @todo type?\u000a */\u000a\u000a/**\u000a * The name of the skin that is currently used.\u000a *\u000a * @property {String} name\u000a * @todo\u000a */\u000a\u000a/**\u000a * The editor skin name. Note that it is not possible to have editors with\u000a * different skin settings in the same page. In such case just one of the\u000a * skins will be used for all editors.\u000a *\u000a * This is a shortcut to {@link CKEDITOR#skinName}.\u000a *\u000a * It is possible to install skins outside the default `skin` folder in the\u000a * editor installation. In that case, the absolute URL path to that folder\u000a * should be provided, separated by a comma (`'skin_name,skin_path'`).\u000a *\u000a *		config.skin = 'moono';\u000a *\u000a *		config.skin = 'myskin,/customstuff/myskin/';\u000a *\u000a * @cfg {String} skin\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * A function that supports the chameleon (skin color switch) feature, providing\u000a * the skin color style updates to be applied in runtime.\u000a *\u000a * **Note:** The embedded `$color` variable is to be substituted with a specific UI color.\u000a *\u000a * @method chameleon\u000a * @param {String} editor The editor instance that the color changes apply to.\u000a * @param {String} part The name of the skin part where the color changes take place.\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/*\u000askin.js\u000a=========\u000a\u000aIn this file we interact with the CKEditor JavaScript API to register the skin\u000aand enable additional skin related features.\u000a\u000aThe level of complexity of this file depends on the features available in the\u000askin. There is only one mandatory line of code to be included here, which is\u000asetting CKEDITOR.skin.name. All the rest is optional, but recommended to be\u000aimplemented as they make higher quality skins.\u000a\u000aFor this skin, the following tasks are achieved in this file:\u000a\u000a	1. Register the skin.\u000a	2. Register browser specific skin files.\u000a	3. Define the "Chameleon" feature.\u000a	4. Register the skin icons, to have them used on the development version of\u000a	  the skin.\u000a*/\u000a\u000a// 1. Register the skin\u000a// ----------------------\u000a// The CKEDITOR.skin.name property must be set to the skin name. This is a\u000a// lower-cased name, which must match the skin folder name as well as the value\u000a// used on config.skin to tell the editor to use the skin.\u000a//\u000a// This is the only mandatory property to be defined in this file.\u000aCKEDITOR.skin.name = 'bootstrapck';\u000a\u000a// 2. Register browser specific skin files\u000a// -----------------------------------------\u000a// (http://docs.cksource.com/CKEditor_4.x/Skin_SDK/Browser_Hacks)\u000a//\u000a// To help implementing browser specific "hacks" to the skin files and have it\u000a// easy to maintain, it is possible to have dedicated files for such browsers,\u000a// for both the main skin CSS files: editor.css and dialog.css.\u000a//\u000a// The browser files must be named after the main file names, appended by an\u000a// underscore and the browser name (e.g. editor_ie.css, dialog_ie8.css).\u000a//\u000a// The accepted browser names must match the CKEDITOR.env properties. The most\u000a// common names are: ie, opera, webkit and gecko. Check the documentation for\u000a// the complete list:\u000a// http://docs.ckeditor.com/#!/api/CKEDITOR.env\u000a//\u000a// Internet explorer is an expection and the browser version is also accepted\u000a// (ie7, ie8, ie9, ie10), as well as a special name for IE in Quirks mode (iequirks).\u000a//\u000a// The available browser specific files must be set separately for editor.css\u000a// and dialog.css.\u000aCKEDITOR.skin.ua_editor = 'ie,iequirks,ie7,ie8,gecko';\u000aCKEDITOR.skin.ua_dialog = 'ie,iequirks,ie7,ie8,opera';\u000a\u000a// 3. Define the "Chameleon" feature\u000a// -----------------------------------\u000a// (http://docs.cksource.com/CKEditor_4.x/Skin_SDK/Chameleon)\u000a//\u000a// "Chameleon" is a unique feature available in CKEditor. It makes it possible\u000a// to end users to specify which color to use as the basis for the editor UI.\u000a// It is enough to set config.uiColor to any color value and voila, the UI is\u000a// colored.\u000a//\u000a// The only detail here is that the skin itself must be compatible with the\u000a// Chameleon feature. That's because the skin CSS files are the responsible to\u000a// apply colors in the UI and each skin do that in different way and on\u000a// different places.\u000a//\u000a// Implementing the Chameleon feature requires a bit of JavaScript programming.\u000a// The CKEDITOR.skin.chameleon function must be defined. It must return the CSS\u000a// "template" to be used to change the color of a specific CKEditor instance\u000a// available in the page. When a color change is required, this template is\u000a// appended to the page holding the editor, overriding styles defined in the\u000a// skin files.\u000a//\u000a// The "$color" placeholder can be used in the returned string. It'll be\u000a// replaced with the desired color.\u000aCKEDITOR.skin.chameleon = ( function() {\u000a	// This method can be used to adjust colour brightness of various element.\u000a	// Colours are accepted in 7-byte hex format, for example: #00ff00.\u000a	// Brightness ratio must be a float number within [-1, 1],\u000a	// where -1 is black, 1 is white and 0 is the original colour.\u000a	var colorBrightness = ( function() {\u000a		function channelBrightness( channel, ratio ) {\u000a			return ( '0' + ( ratio < 0 ?\u000a					0 | channel * ( 1 + ratio )\u000a				:\u000a					0 | channel + ( 255 - channel ) * ratio ).toString( 16 )\u000a				).slice( -2 );\u000a		}\u000a\u000a		return function( hexColor, ratio ) {\u000a			var channels = hexColor.match( /[^#]./g );\u000a\u000a			for ( var i = 0 ; i < 3 ; i++ )\u000a				channels[ i ] = channelBrightness( parseInt( channels[ i ], 16 ), ratio );\u000a\u000a			return '#' + channels.join( '' );\u000a		};\u000a	} )(),\u000a\u000a	// Use this function just to avoid having to repeat all these rules on\u000a	// several places of our template.\u000a	verticalGradient = ( function() {\u000a		var template = new CKEDITOR.template( 'background:#{to};'+\u000a			'background-image:-webkit-gradient(linear,lefttop,leftbottom,from({from}),to({to}));'+\u000a			'background-image:-moz-linear-gradient(top,{from},{to});'+\u000a			'background-image:-webkit-linear-gradient(top,{from},{to});'+\u000a			'background-image:-o-linear-gradient(top,{from},{to});'+\u000a			'background-image:-ms-linear-gradient(top,{from},{to});'+\u000a			'background-image:linear-gradient(top,{from},{to});'+\u000a			'filter:progid:DXImageTransform.Microsoft.gradient(gradientType=0,startColorstr=\u005c'{from}\u005c',endColorstr=\u005c'{to}\u005c');' );\u000a\u000a		return function( from, to ) {\u000a			return template.output( { from: from, to: to } );\u000a		};\u000a	} )(),\u000a\u000a	// Style templates for various user interface parts:\u000a	// 	* Default editor template.\u000a	// 	* Default panel template.\u000a	templates = {\u000a		editor: new CKEDITOR.template(\u000a			'{id}.cke_chrome [border-color:{defaultBorder};] ' +\u000a			'{id} .cke_top [ ' +\u000a					'{defaultGradient}' +\u000a					'border-bottom-color:{defaultBorder};' +\u000a				'] ' +\u000a			'{id} .cke_bottom [' +\u000a					'{defaultGradient}' +\u000a					'border-top-color:{defaultBorder};' +\u000a				'] ' +\u000a			'{id} .cke_resizer [border-right-color:{ckeResizer}] ' +\u000a\u000a			// Dialogs.\u000a			'{id} .cke_dialog_title [' +\u000a					'{defaultGradient}' +\u000a					'border-bottom-color:{defaultBorder};' +\u000a				'] ' +\u000a			'{id} .cke_dialog_footer [' +\u000a					'{defaultGradient}' +\u000a					'outline-color:{defaultBorder};' +\u000a					'border-top-color:{defaultBorder};' +	// IE7 doesn't use outline.\u000a				'] ' +\u000a			'{id} .cke_dialog_tab [' +\u000a					'{lightGradient}' +\u000a					'border-color:{defaultBorder};' +\u000a				'] ' +\u000a			'{id} .cke_dialog_tab:hover [' +\u000a					'{mediumGradient}' +\u000a				'] ' +\u000a			'{id} .cke_dialog_contents [' +\u000a					'border-top-color:{defaultBorder};' +\u000a				'] ' +\u000a			'{id} .cke_dialog_tab_selected, {id} .cke_dialog_tab_selected:hover [' +\u000a					'background:{dialogTabSelected};' +\u000a					'border-bottom-color:{dialogTabSelectedBorder};' +\u000a				'] ' +\u000a			'{id} .cke_dialog_body [' +\u000a					'background:{dialogBody};' +\u000a					'border-color:{defaultBorder};' +\u000a				'] ' +\u000a\u000a			// Toolbars, buttons.\u000a			'{id} .cke_toolgroup [' +\u000a					'{lightGradient}' +\u000a					'border-color:{defaultBorder};' +\u000a				'] ' +\u000a			'{id} a.cke_button_off:hover, {id} a.cke_button_off:focus, {id} a.cke_button_off:active [' +\u000a					'{mediumGradient}' +\u000a				'] ' +\u000a			'{id} .cke_button_on [' +\u000a					'{ckeButtonOn}' +\u000a				'] ' +\u000a			'{id} .cke_toolbar_separator [' +\u000a					'background-color: {ckeToolbarSeparator};' +\u000a				'] ' +\u000a\u000a			// Combo buttons.\u000a			'{id} .cke_combo_button [' +\u000a					'border-color:{defaultBorder};' +\u000a					'{lightGradient}' +\u000a				'] ' +\u000a			'{id} a.cke_combo_button:hover, {id} a.cke_combo_button:focus, {id} .cke_combo_on a.cke_combo_button [' +\u000a					'border-color:{defaultBorder};' +\u000a					'{mediumGradient}' +\u000a				'] ' +\u000a\u000a			// Elementspath.\u000a			'{id} .cke_path_item [' +\u000a					'color:{elementsPathColor};' +\u000a				'] ' +\u000a			'{id} a.cke_path_item:hover, {id} a.cke_path_item:focus, {id} a.cke_path_item:active [' +\u000a					'background-color:{elementsPathBg};' +\u000a				'] ' +\u000a\u000a			'{id}.cke_panel [' +\u000a				'border-color:{defaultBorder};' +\u000a			'] '\u000a		),\u000a		panel: new CKEDITOR.template(\u000a			// Panel drop-downs.\u000a			'.cke_panel_grouptitle [' +\u000a					'{lightGradient}' +\u000a					'border-color:{defaultBorder};' +\u000a				'] ' +\u000a\u000a			// Context menus.\u000a			'.cke_menubutton_icon [' +\u000a					'background-color:{menubuttonIcon};' +\u000a				'] ' +\u000a			'.cke_menubutton:hover .cke_menubutton_icon, .cke_menubutton:focus .cke_menubutton_icon, .cke_menubutton:active .cke_menubutton_icon [' +\u000a					'background-color:{menubuttonIconHover};' +\u000a				'] ' +\u000a			'.cke_menuseparator [' +\u000a					'background-color:{menubuttonIcon};' +\u000a				'] ' +\u000a\u000a			// Color boxes.\u000a			'a:hover.cke_colorbox, a:focus.cke_colorbox, a:active.cke_colorbox [' +\u000a					'border-color:{defaultBorder};' +\u000a				'] ' +\u000a			'a:hover.cke_colorauto, a:hover.cke_colormore, a:focus.cke_colorauto, a:focus.cke_colormore, a:active.cke_colorauto, a:active.cke_colormore [' +\u000a					'background-color:{ckeColorauto};' +\u000a					'border-color:{defaultBorder};' +\u000a				'] '\u000a		)\u000a	};\u000a\u000a	return function( editor, part ) {\u000a		var uiColor = editor.uiColor,\u000a			// The following are CSS styles used in templates.\u000a			// Styles are generated according to current editor.uiColor.\u000a			templateStyles = {\u000a				// CKEditor instances have a unique ID, which is used as class name into\u000a				// the outer container of the editor UI (e.g. ".cke_1").\u000a				//\u000a				// The Chameleon feature is available for each CKEditor instance,\u000a				// independently. Because of this, we need to prefix all CSS selectors with\u000a				// the unique class name of the instance.\u000a				id: '.' + editor.id,\u000a\u000a				// These styles are used by various UI elements.\u000a				defaultBorder: colorBrightness( uiColor, -0.1 ),\u000a				defaultGradient: verticalGradient( colorBrightness( uiColor, 0.9 ), uiColor ),\u000a				lightGradient: verticalGradient( colorBrightness( uiColor, 1 ), colorBrightness( uiColor, 0.7 ) ),\u000a				mediumGradient: verticalGradient( colorBrightness( uiColor, 0.8 ), colorBrightness( uiColor, 0.5 ) ),\u000a\u000a				// These are for specific UI elements.\u000a				ckeButtonOn: verticalGradient( colorBrightness( uiColor, 0.6 ), colorBrightness( uiColor, 0.7 ) ),\u000a				ckeResizer: colorBrightness( uiColor, -0.4 ),\u000a				ckeToolbarSeparator: colorBrightness( uiColor, 0.5 ),\u000a				ckeColorauto: colorBrightness( uiColor, 0.8 ),\u000a				dialogBody: colorBrightness( uiColor, 0.7 ),\u000a				// Use gradient instead of simple hex to avoid further filter resetting in IE.\u000a				dialogTabSelected: verticalGradient( '#FFFFFF', '#FFFFFF' ),\u000a				dialogTabSelectedBorder: '#FFF',\u000a				elementsPathColor: colorBrightness( uiColor, -0.6 ),\u000a				elementsPathBg: uiColor,\u000a				menubuttonIcon: colorBrightness( uiColor, 0.5 ),\u000a				menubuttonIconHover: colorBrightness( uiColor, 0.3 )\u000a			};\u000a\u000a		return templates[ part ]\u000a			.output( templateStyles )\u000a			.replace( /\u005c[/g, '{' )				// Replace brackets with braces.\u000a			.replace( /\u005c]/g, '}' );\u000a	};\u000a} )();\u000a\u000a// // %REMOVE_START%\u000a\u000a// // 4. Register the skin icons for development purposes only\u000a// // ----------------------------------------------------------\u000a// // (http://docs.cksource.com/CKEditor_4.x/Skin_SDK/Icons)\u000a// //\u000a// // Note: As "moono" is the default CKEditor skin, it provides no custom icons,\u000a// // thus this code is commented out.\u000a// //\u000a// // This code is here just to make the skin work fully when using its "source"\u000a// // version. Without this, the skin will still work, but its icons will not be\u000a// // used (again, on source version only).\u000a// //\u000a// // This block of code is not necessary on the release version of the skin.\u000a// // Because of this it is very important to include it inside the REMOVE_START\u000a// // and REMOVE_END comment markers, so the skin builder will properly clean\u000a// // things up.\u000a// //\u000a// // If a required icon is not available here, the plugin defined icon will be\u000a// // used instead. This means that a skin is not required to provide all icons.\u000a// // Actually, it is not required to provide icons at all.\u000a// //\u000a// (function() {\u000a// 		// The available icons. This list must match the file names (without\u000a// 		// extension) available inside the "icons" folder.\u000a// 		var icons = ( 'about,anchor-rtl,anchor,bgcolor,bidiltr,bidirtl,blockquote,' +\u000a// 			'bold,bulletedlist-rtl,bulletedlist,button,checkbox,copy-rtl,copy,' +\u000a// 			'creatediv,cut-rtl,cut,docprops-rtl,docprops,find-rtl,find,flash,form,' +\u000a// 			'hiddenfield,horizontalrule,icons,iframe,image,imagebutton,indent-rtl,' +\u000a// 			'indent,italic,justifyblock,justifycenter,justifyleft,justifyright,' +\u000a// 			'link,maximize,newpage-rtl,newpage,numberedlist-rtl,numberedlist,' +\u000a// 			'outdent-rtl,outdent,pagebreak-rtl,pagebreak,paste-rtl,paste,' +\u000a// 			'pastefromword-rtl,pastefromword,pastetext-rtl,pastetext,preview-rtl,' +\u000a// 			'preview,print,radio,redo-rtl,redo,removeformat,replace,save,scayt,' +\u000a// 			'select-rtl,select,selectall,showblocks-rtl,showblocks,smiley,' +\u000a// 			'source-rtl,source,specialchar,spellchecker,strike,subscript,' +\u000a// 			'superscript,table,templates-rtl,templates,textarea-rtl,textarea,' +\u000a// 			'textcolor,textfield-rtl,textfield,uicolor,underline,undo-rtl,undo,unlink' ).split( ',' );\u000a\u000a// 		var iconsFolder = CKEDITOR.getUrl( CKEDITOR.skin.path() + 'icons/' + ( CKEDITOR.env.hidpi ? 'hidpi/' : '' ) );\u000a\u000a// 		for ( var i = 0; i < icons.length; i++ ) {\u000a// 			CKEDITOR.skin.addIcon( icons[ i ], iconsFolder + icons[ i ] + '.png' );\u000a// 		}\u000a// })();\u000a\u000a// // %REMOVE_END%\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview API initialization code.\u000a */\u000a\u000a( function() {\u000a	// Disable HC detection in WebKit. (#5429)\u000a	if ( CKEDITOR.env.webkit )\u000a		CKEDITOR.env.hc = false;\u000a	else {\u000a		// Check whether high contrast is active by creating a colored border.\u000a		var hcDetect = CKEDITOR.dom.element.createFromHtml( '<div style="width:0;height:0;position:absolute;left:-10000px;' +\u000a			'border:1px solid;border-color:red blue"></div>', CKEDITOR.document );\u000a\u000a		hcDetect.appendTo( CKEDITOR.document.getHead() );\u000a\u000a		// Update CKEDITOR.env.\u000a		// Catch exception needed sometimes for FF. (#4230)\u000a		try {\u000a			var top = hcDetect.getComputedStyle( 'border-top-color' ),\u000a				right = hcDetect.getComputedStyle( 'border-right-color' );\u000a\u000a			// We need to check if getComputedStyle returned any value, because on FF\u000a			// it returnes empty string if CKEditor is loaded in hidden iframe. (#11121)\u000a			CKEDITOR.env.hc = !!( top && top == right );\u000a		} catch ( e ) {\u000a			CKEDITOR.env.hc = false;\u000a		}\u000a\u000a		hcDetect.remove();\u000a	}\u000a\u000a	if ( CKEDITOR.env.hc )\u000a		CKEDITOR.env.cssClass += ' cke_hc';\u000a\u000a	// Initially hide UI spaces when relevant skins are loading, later restored by skin css.\u000a	CKEDITOR.document.appendStyleText( '.cke{visibility:hidden;}' );\u000a\u000a	// Mark the editor as fully loaded.\u000a	CKEDITOR.status = 'loaded';\u000a	CKEDITOR.fireOnce( 'loaded' );\u000a\u000a	// Process all instances created by the "basic" implementation.\u000a	var pending = CKEDITOR._.pending;\u000a	if ( pending ) {\u000a		delete CKEDITOR._.pending;\u000a\u000a		for ( var i = 0; i < pending.length; i++ ) {\u000a			CKEDITOR.editor.prototype.constructor.apply( pending[ i ][ 0 ], pending[ i ][ 1 ] );\u000a			CKEDITOR.add( pending[ i ][ 0 ] );\u000a		}\u000a	}\u000a} )();\u000a\u000a/**\u000a * Indicates that CKEditor is running on a High Contrast environment.\u000a *\u000a *		if ( CKEDITOR.env.hc )\u000a *			alert( 'You\u005c're running on High Contrast mode. The editor interface will get adapted to provide you a better experience.' );\u000a *\u000a * @property {Boolean} hc\u000a * @member CKEDITOR.env\u000a */\u000a\u000a/**\u000a * Fired when a CKEDITOR core object is fully loaded and ready for interaction.\u000a *\u000a * @event loaded\u000a * @member CKEDITOR\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview The Dialog User Interface plugin.\u000a */\u000a\u000aCKEDITOR.plugins.add( 'dialogui', {\u000a	onLoad: function() {\u000a\u000a		var initPrivateObject = function( elementDefinition ) {\u000a				this._ || ( this._ = {} );\u000a				this._[ 'default' ] = this._.initValue = elementDefinition[ 'default' ] || '';\u000a				this._.required = elementDefinition[ 'required' ] || false;\u000a				var args = [ this._ ];\u000a				for ( var i = 1; i < arguments.length; i++ )\u000a					args.push( arguments[ i ] );\u000a				args.push( true );\u000a				CKEDITOR.tools.extend.apply( CKEDITOR.tools, args );\u000a				return this._;\u000a			},\u000a			textBuilder = {\u000a				build: function( dialog, elementDefinition, output ) {\u000a					return new CKEDITOR.ui.dialog.textInput( dialog, elementDefinition, output );\u000a				}\u000a			},\u000a			commonBuilder = {\u000a				build: function( dialog, elementDefinition, output ) {\u000a					return new CKEDITOR.ui.dialog[ elementDefinition.type ]( dialog, elementDefinition, output );\u000a				}\u000a			},\u000a			containerBuilder = {\u000a				build: function( dialog, elementDefinition, output ) {\u000a					var children = elementDefinition.children,\u000a						child,\u000a						childHtmlList = [],\u000a						childObjList = [];\u000a					for ( var i = 0;\u000a					( i < children.length && ( child = children[ i ] ) ); i++ ) {\u000a						var childHtml = [];\u000a						childHtmlList.push( childHtml );\u000a						childObjList.push( CKEDITOR.dialog._.uiElementBuilders[ child.type ].build( dialog, child, childHtml ) );\u000a					}\u000a					return new CKEDITOR.ui.dialog[ elementDefinition.type ]( dialog, childObjList, childHtmlList, output, elementDefinition );\u000a				}\u000a			},\u000a			commonPrototype = {\u000a				isChanged: function() {\u000a					return this.getValue() != this.getInitValue();\u000a				},\u000a\u000a				reset: function( noChangeEvent ) {\u000a					this.setValue( this.getInitValue(), noChangeEvent );\u000a				},\u000a\u000a				setInitValue: function() {\u000a					this._.initValue = this.getValue();\u000a				},\u000a\u000a				resetInitValue: function() {\u000a					this._.initValue = this._[ 'default' ];\u000a				},\u000a\u000a				getInitValue: function() {\u000a					return this._.initValue;\u000a				}\u000a			},\u000a			commonEventProcessors = CKEDITOR.tools.extend( {}, CKEDITOR.ui.dialog.uiElement.prototype.eventProcessors, {\u000a				onChange: function( dialog, func ) {\u000a					if ( !this._.domOnChangeRegistered ) {\u000a						dialog.on( 'load', function() {\u000a							this.getInputElement().on( 'change', function() {\u000a								// Make sure 'onchange' doesn't get fired after dialog closed. (#5719)\u000a								if ( !dialog.parts.dialog.isVisible() )\u000a									return;\u000a\u000a								this.fire( 'change', { value: this.getValue() } );\u000a							}, this );\u000a						}, this );\u000a						this._.domOnChangeRegistered = true;\u000a					}\u000a\u000a					this.on( 'change', func );\u000a				}\u000a			}, true ),\u000a			eventRegex = /^on([A-Z]\u005cw+)/,\u000a			cleanInnerDefinition = function( def ) {\u000a				// An inner UI element should not have the parent's type, title or events.\u000a				for ( var i in def ) {\u000a					if ( eventRegex.test( i ) || i == 'title' || i == 'type' )\u000a						delete def[ i ];\u000a				}\u000a				return def;\u000a			};\u000a\u000a		CKEDITOR.tools.extend( CKEDITOR.ui.dialog, {\u000a			/**\u000a			 * Base class for all dialog window elements with a textual label on the left.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.labeledElement\u000a			 * @extends CKEDITOR.ui.dialog.uiElement\u000a			 * @constructor Creates a labeledElement class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition\u000a			 * The element definition. Accepted fields:\u000a			 *\u000a			 * * `label` (Required) The label string.\u000a			 * * `labelLayout` (Optional) Put 'horizontal' here if the\u000a			 *     label element is to be laid out horizontally. Otherwise a vertical\u000a			 *     layout will be used.\u000a			 * * `widths` (Optional) This applies only to horizontal\u000a			 *     layouts &mdash; a two-element array of lengths to specify the widths of the\u000a			 *     label and the content element.\u000a			 * * `role` (Optional) Value for the `role` attribute.\u000a			 * * `includeLabel` (Optional) If set to `true`, the `aria-labelledby` attribute\u000a			 *     will be included.\u000a			 *\u000a			 * @param {Array} htmlList The list of HTML code to output to.\u000a			 * @param {Function} contentHtml\u000a			 * A function returning the HTML code string to be added inside the content\u000a			 * cell.\u000a			 */\u000a			labeledElement: function( dialog, elementDefinition, htmlList, contentHtml ) {\u000a				if ( arguments.length < 4 )\u000a					return;\u000a\u000a				var _ = initPrivateObject.call( this, elementDefinition );\u000a				_.labelId = CKEDITOR.tools.getNextId() + '_label';\u000a				var children = this._.children = [];\u000a\u000a				var innerHTML = function() {\u000a						var html = [],\u000a							requiredClass = elementDefinition.required ? ' cke_required' : '';\u000a						if ( elementDefinition.labelLayout != 'horizontal' ) {\u000a							html.push(\u000a								'<label class="cke_dialog_ui_labeled_label' + requiredClass + '" ', ' id="' + _.labelId + '"',\u000a									( _.inputId ? ' for="' + _.inputId + '"' : '' ),\u000a									( elementDefinition.labelStyle ? ' style="' + elementDefinition.labelStyle + '"' : '' ) + '>',\u000a									elementDefinition.label,\u000a								'</label>',\u000a								'<div class="cke_dialog_ui_labeled_content"',\u000a									( elementDefinition.controlStyle ? ' style="' + elementDefinition.controlStyle + '"' : '' ),\u000a									' role="presentation">',\u000a									contentHtml.call( this, dialog, elementDefinition ),\u000a								'</div>' );\u000a						} else {\u000a							var hboxDefinition = {\u000a								type: 'hbox',\u000a								widths: elementDefinition.widths,\u000a								padding: 0,\u000a								children: [\u000a									{\u000a									type: 'html',\u000a									html: '<label class="cke_dialog_ui_labeled_label' + requiredClass + '"' +\u000a										' id="' + _.labelId + '"' +\u000a										' for="' + _.inputId + '"' +\u000a										( elementDefinition.labelStyle ? ' style="' + elementDefinition.labelStyle + '"' : '' ) + '>' +\u000a											CKEDITOR.tools.htmlEncode( elementDefinition.label ) +\u000a										'</span>'\u000a								},\u000a									{\u000a									type: 'html',\u000a									html: '<span class="cke_dialog_ui_labeled_content"' + ( elementDefinition.controlStyle ? ' style="' + elementDefinition.controlStyle + '"' : '' ) + '>' +\u000a										contentHtml.call( this, dialog, elementDefinition ) +\u000a										'</span>'\u000a								}\u000a								]\u000a							};\u000a							CKEDITOR.dialog._.uiElementBuilders.hbox.build( dialog, hboxDefinition, html );\u000a						}\u000a						return html.join( '' );\u000a					};\u000a				var attributes = { role: elementDefinition.role || 'presentation' };\u000a\u000a				if ( elementDefinition.includeLabel )\u000a					attributes[ 'aria-labelledby' ] = _.labelId;\u000a\u000a				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition, htmlList, 'div', null, attributes, innerHTML );\u000a			},\u000a\u000a			/**\u000a			 * A text input with a label. This UI element class represents both the\u000a			 * single-line text inputs and password inputs in dialog boxes.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.textInput\u000a			 * @extends CKEDITOR.ui.dialog.labeledElement\u000a			 * @constructor Creates a textInput class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition\u000a			 * The element definition. Accepted fields:\u000a			 *\u000a			 * * `default` (Optional) The default value.\u000a			 * * `validate` (Optional) The validation function.\u000a			 * * `maxLength` (Optional) The maximum length of text box contents.\u000a			 * * `size` (Optional) The size of the text box. This is\u000a			 *     usually overridden by the size defined by the skin, though.\u000a			 *\u000a			 * @param {Array} htmlList List of HTML code to output to.\u000a			 */\u000a			textInput: function( dialog, elementDefinition, htmlList ) {\u000a				if ( arguments.length < 3 )\u000a					return;\u000a\u000a				initPrivateObject.call( this, elementDefinition );\u000a				var domId = this._.inputId = CKEDITOR.tools.getNextId() + '_textInput',\u000a					attributes = { 'class': 'cke_dialog_ui_input_' + elementDefinition.type, id: domId, type: elementDefinition.type },\u000a					i;\u000a\u000a				// Set the validator, if any.\u000a				if ( elementDefinition.validate )\u000a					this.validate = elementDefinition.validate;\u000a\u000a				// Set the max length and size.\u000a				if ( elementDefinition.maxLength )\u000a					attributes.maxlength = elementDefinition.maxLength;\u000a				if ( elementDefinition.size )\u000a					attributes.size = elementDefinition.size;\u000a\u000a				if ( elementDefinition.inputStyle )\u000a					attributes.style = elementDefinition.inputStyle;\u000a\u000a				// If user presses Enter in a text box, it implies clicking OK for the dialog.\u000a				var me = this,\u000a					keyPressedOnMe = false;\u000a				dialog.on( 'load', function() {\u000a					me.getInputElement().on( 'keydown', function( evt ) {\u000a						if ( evt.data.getKeystroke() == 13 )\u000a							keyPressedOnMe = true;\u000a					} );\u000a\u000a					// Lower the priority this 'keyup' since 'ok' will close the dialog.(#3749)\u000a					me.getInputElement().on( 'keyup', function( evt ) {\u000a						if ( evt.data.getKeystroke() == 13 && keyPressedOnMe ) {\u000a							dialog.getButton( 'ok' ) && setTimeout( function() {\u000a								dialog.getButton( 'ok' ).click();\u000a							}, 0 );\u000a							keyPressedOnMe = false;\u000a						}\u000a					}, null, null, 1000 );\u000a				} );\u000a\u000a				var innerHTML = function() {\u000a						// IE BUG: Text input fields in IE at 100% would exceed a <td> or inline\u000a						// container's width, so need to wrap it inside a <div>.\u000a						var html = [ '<div class="cke_dialog_ui_input_', elementDefinition.type, '" role="presentation"' ];\u000a\u000a						if ( elementDefinition.width )\u000a							html.push( 'style="width:' + elementDefinition.width + '" ' );\u000a\u000a						html.push( '><input ' );\u000a\u000a						attributes[ 'aria-labelledby' ] = this._.labelId;\u000a						this._.required && ( attributes[ 'aria-required' ] = this._.required );\u000a						for ( var i in attributes )\u000a							html.push( i + '="' + attributes[ i ] + '" ' );\u000a						html.push( ' /></div>' );\u000a						return html.join( '' );\u000a					};\u000a				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );\u000a			},\u000a\u000a			/**\u000a			 * A text area with a label at the top or on the left.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.textarea\u000a			 * @extends CKEDITOR.ui.dialog.labeledElement\u000a			 * @constructor Creates a textarea class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition\u000a			 *\u000a			 * The element definition. Accepted fields:\u000a			 *\u000a			 * * `rows` (Optional) The number of rows displayed.\u000a			 *     Defaults to 5 if not defined.\u000a			 * * `cols` (Optional) The number of cols displayed.\u000a			 *     Defaults to 20 if not defined. Usually overridden by skins.\u000a			 * * `default` (Optional) The default value.\u000a			 * * `validate` (Optional) The validation function.\u000a			 *\u000a			 * @param {Array} htmlList List of HTML code to output to.\u000a			 */\u000a			textarea: function( dialog, elementDefinition, htmlList ) {\u000a				if ( arguments.length < 3 )\u000a					return;\u000a\u000a				initPrivateObject.call( this, elementDefinition );\u000a				var me = this,\u000a					domId = this._.inputId = CKEDITOR.tools.getNextId() + '_textarea',\u000a					attributes = {};\u000a\u000a				if ( elementDefinition.validate )\u000a					this.validate = elementDefinition.validate;\u000a\u000a				// Generates the essential attributes for the textarea tag.\u000a				attributes.rows = elementDefinition.rows || 5;\u000a				attributes.cols = elementDefinition.cols || 20;\u000a\u000a				attributes[ 'class' ] = 'cke_dialog_ui_input_textarea ' + ( elementDefinition[ 'class' ] || '' );\u000a\u000a				if ( typeof elementDefinition.inputStyle != 'undefined' )\u000a					attributes.style = elementDefinition.inputStyle;\u000a\u000a				if ( elementDefinition.dir )\u000a					attributes.dir = elementDefinition.dir;\u000a\u000a				var innerHTML = function() {\u000a						attributes[ 'aria-labelledby' ] = this._.labelId;\u000a						this._.required && ( attributes[ 'aria-required' ] = this._.required );\u000a						var html = [ '<div class="cke_dialog_ui_input_textarea" role="presentation"><textarea id="', domId, '" ' ];\u000a						for ( var i in attributes )\u000a							html.push( i + '="' + CKEDITOR.tools.htmlEncode( attributes[ i ] ) + '" ' );\u000a						html.push( '>', CKEDITOR.tools.htmlEncode( me._[ 'default' ] ), '</textarea></div>' );\u000a						return html.join( '' );\u000a					};\u000a				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );\u000a			},\u000a\u000a			/**\u000a			 * A single checkbox with a label on the right.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.checkbox\u000a			 * @extends CKEDITOR.ui.dialog.uiElement\u000a			 * @constructor Creates a checkbox class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition\u000a			 * The element definition. Accepted fields:\u000a			 *\u000a			 * * `checked` (Optional) Whether the checkbox is checked\u000a			 *     on instantiation. Defaults to `false`.\u000a			 * * `validate` (Optional) The validation function.\u000a			 * * `label` (Optional) The checkbox label.\u000a			 *\u000a			 * @param {Array} htmlList List of HTML code to output to.\u000a			 */\u000a			checkbox: function( dialog, elementDefinition, htmlList ) {\u000a				if ( arguments.length < 3 )\u000a					return;\u000a\u000a				var _ = initPrivateObject.call( this, elementDefinition, { 'default': !!elementDefinition[ 'default' ] } );\u000a\u000a				if ( elementDefinition.validate )\u000a					this.validate = elementDefinition.validate;\u000a\u000a				var innerHTML = function() {\u000a						var myDefinition = CKEDITOR.tools.extend( {}, elementDefinition, {\u000a							id: elementDefinition.id ? elementDefinition.id + '_checkbox' : CKEDITOR.tools.getNextId() + '_checkbox'\u000a						}, true ),\u000a							html = [];\u000a\u000a						var labelId = CKEDITOR.tools.getNextId() + '_label';\u000a						var attributes = { 'class': 'cke_dialog_ui_checkbox_input', type: 'checkbox', 'aria-labelledby': labelId };\u000a						cleanInnerDefinition( myDefinition );\u000a						if ( elementDefinition[ 'default' ] )\u000a							attributes.checked = 'checked';\u000a\u000a						if ( typeof myDefinition.inputStyle != 'undefined' )\u000a							myDefinition.style = myDefinition.inputStyle;\u000a\u000a						_.checkbox = new CKEDITOR.ui.dialog.uiElement( dialog, myDefinition, html, 'input', null, attributes );\u000a						html.push( ' <label id="', labelId, '" for="', attributes.id, '"' + ( elementDefinition.labelStyle ? ' style="' + elementDefinition.labelStyle + '"' : '' ) + '>', CKEDITOR.tools.htmlEncode( elementDefinition.label ), '</label>' );\u000a						return html.join( '' );\u000a					};\u000a\u000a				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition, htmlList, 'span', null, null, innerHTML );\u000a			},\u000a\u000a			/**\u000a			 * A group of radio buttons.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.radio\u000a			 * @extends CKEDITOR.ui.dialog.labeledElement\u000a			 * @constructor Creates a radio class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition\u000a			 * The element definition. Accepted fields:\u000a			 *\u000a			 * * `default` (Required) The default value.\u000a			 * * `validate` (Optional) The validation function.\u000a			 * * `items` (Required) An array of options. Each option\u000a			 *     is a one- or two-item array of format `[ 'Description', 'Value' ]`. If `'Value'`\u000a			 *     is missing, then the value would be assumed to be the same as the description.\u000a			 *\u000a			 * @param {Array} htmlList List of HTML code to output to.\u000a			 */\u000a			radio: function( dialog, elementDefinition, htmlList ) {\u000a				if ( arguments.length < 3 )\u000a					return;\u000a\u000a				initPrivateObject.call( this, elementDefinition );\u000a\u000a				if ( !this._[ 'default' ] )\u000a					this._[ 'default' ] = this._.initValue = elementDefinition.items[ 0 ][ 1 ];\u000a\u000a				if ( elementDefinition.validate )\u000a					this.validate = elementDefinition.valdiate;\u000a\u000a				var children = [],\u000a					me = this;\u000a\u000a				var innerHTML = function() {\u000a					var inputHtmlList = [],\u000a						html = [],\u000a						commonName = ( elementDefinition.id ? elementDefinition.id : CKEDITOR.tools.getNextId() ) + '_radio';\u000a\u000a					for ( var i = 0; i < elementDefinition.items.length; i++ ) {\u000a						var item = elementDefinition.items[ i ],\u000a							title = item[ 2 ] !== undefined ? item[ 2 ] : item[ 0 ],\u000a							value = item[ 1 ] !== undefined ? item[ 1 ] : item[ 0 ],\u000a							inputId = CKEDITOR.tools.getNextId() + '_radio_input',\u000a							labelId = inputId + '_label',\u000a\u000a							inputDefinition = CKEDITOR.tools.extend( {}, elementDefinition, {\u000a								id: inputId,\u000a								title: null,\u000a								type: null\u000a							}, true ),\u000a\u000a							labelDefinition = CKEDITOR.tools.extend( {}, inputDefinition, {\u000a								title: title\u000a							}, true ),\u000a\u000a							inputAttributes = {\u000a								type: 'radio',\u000a								'class': 'cke_dialog_ui_radio_input',\u000a								name: commonName,\u000a								value: value,\u000a								'aria-labelledby': labelId\u000a							},\u000a\u000a							inputHtml = [];\u000a\u000a						if ( me._[ 'default' ] == value )\u000a							inputAttributes.checked = 'checked';\u000a\u000a						cleanInnerDefinition( inputDefinition );\u000a						cleanInnerDefinition( labelDefinition );\u000a\u000a						if ( typeof inputDefinition.inputStyle != 'undefined' )\u000a							inputDefinition.style = inputDefinition.inputStyle;\u000a\u000a						// Make inputs of radio type focusable (#10866).\u000a						inputDefinition.keyboardFocusable = true;\u000a\u000a						children.push( new CKEDITOR.ui.dialog.uiElement( dialog, inputDefinition, inputHtml, 'input', null, inputAttributes ) );\u000a\u000a						inputHtml.push( ' ' );\u000a\u000a						new CKEDITOR.ui.dialog.uiElement( dialog, labelDefinition, inputHtml, 'label', null, {\u000a							id: labelId,\u000a							'for': inputAttributes.id\u000a						}, item[ 0 ] );\u000a\u000a						inputHtmlList.push( inputHtml.join( '' ) );\u000a					}\u000a\u000a					new CKEDITOR.ui.dialog.hbox( dialog, children, inputHtmlList, html );\u000a\u000a					return html.join( '' );\u000a				};\u000a\u000a				// Adding a role="radiogroup" to definition used for wrapper.\u000a				elementDefinition.role = 'radiogroup';\u000a				elementDefinition.includeLabel = true;\u000a\u000a				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );\u000a				this._.children = children;\u000a			},\u000a\u000a			/**\u000a			 * A button with a label inside.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.button\u000a			 * @extends CKEDITOR.ui.dialog.uiElement\u000a			 * @constructor Creates a button class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition\u000a			 * The element definition. Accepted fields:\u000a			 *\u000a			 * * `label` (Required) The button label.\u000a			 * * `disabled` (Optional) Set to `true` if you want the\u000a			 *     button to appear in the disabled state.\u000a			 *\u000a			 * @param {Array} htmlList List of HTML code to output to.\u000a			 */\u000a			button: function( dialog, elementDefinition, htmlList ) {\u000a				if ( !arguments.length )\u000a					return;\u000a\u000a				if ( typeof elementDefinition == 'function' )\u000a					elementDefinition = elementDefinition( dialog.getParentEditor() );\u000a\u000a				initPrivateObject.call( this, elementDefinition, { disabled: elementDefinition.disabled || false } );\u000a\u000a				// Add OnClick event to this input.\u000a				CKEDITOR.event.implementOn( this );\u000a\u000a				var me = this;\u000a\u000a				// Register an event handler for processing button clicks.\u000a				dialog.on( 'load', function( eventInfo ) {\u000a					var element = this.getElement();\u000a\u000a					( function() {\u000a						element.on( 'click', function( evt ) {\u000a							me.click();\u000a							// #9958\u000a							evt.data.preventDefault();\u000a						} );\u000a\u000a						element.on( 'keydown', function( evt ) {\u000a							if ( evt.data.getKeystroke() in { 32: 1 } ) {\u000a								me.click();\u000a								evt.data.preventDefault();\u000a							}\u000a						} );\u000a					} )();\u000a\u000a					element.unselectable();\u000a				}, this );\u000a\u000a				var outerDefinition = CKEDITOR.tools.extend( {}, elementDefinition );\u000a				delete outerDefinition.style;\u000a\u000a				var labelId = CKEDITOR.tools.getNextId() + '_label';\u000a				CKEDITOR.ui.dialog.uiElement.call( this, dialog, outerDefinition, htmlList, 'a', null, {\u000a					style: elementDefinition.style,\u000a					href: 'javascript:void(0)',\u000a					title: elementDefinition.label,\u000a					hidefocus: 'true',\u000a					'class': elementDefinition[ 'class' ],\u000a					role: 'button',\u000a					'aria-labelledby': labelId\u000a				}, '<span id="' + labelId + '" class="cke_dialog_ui_button">' +\u000a											CKEDITOR.tools.htmlEncode( elementDefinition.label ) +\u000a										'</span>' );\u000a			},\u000a\u000a			/**\u000a			 * A select box.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.select\u000a			 * @extends CKEDITOR.ui.dialog.uiElement\u000a			 * @constructor Creates a button class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition\u000a			 * The element definition. Accepted fields:\u000a			 *\u000a			 * * `default` (Required) The default value.\u000a			 * * `validate` (Optional) The validation function.\u000a			 * * `items` (Required) An array of options. Each option\u000a			 *     is a one- or two-item array of format `[ 'Description', 'Value' ]`. If `'Value'`\u000a			 *     is missing, then the value would be assumed to be the same as the\u000a			 *     description.\u000a			 * * `multiple` (Optional) Set this to `true` if you would like\u000a			 *     to have a multiple-choice select box.\u000a			 * * `size` (Optional) The number of items to display in\u000a			 *     the select box.\u000a			 *\u000a			 * @param {Array} htmlList List of HTML code to output to.\u000a			 */\u000a			select: function( dialog, elementDefinition, htmlList ) {\u000a				if ( arguments.length < 3 )\u000a					return;\u000a\u000a				var _ = initPrivateObject.call( this, elementDefinition );\u000a\u000a				if ( elementDefinition.validate )\u000a					this.validate = elementDefinition.validate;\u000a\u000a				_.inputId = CKEDITOR.tools.getNextId() + '_select';\u000a\u000a				var innerHTML = function() {\u000a						var myDefinition = CKEDITOR.tools.extend( {}, elementDefinition, {\u000a							id: elementDefinition.id ? elementDefinition.id + '_select' : CKEDITOR.tools.getNextId() + '_select'\u000a						}, true ),\u000a							html = [],\u000a							innerHTML = [],\u000a							attributes = { 'id': _.inputId, 'class': 'cke_dialog_ui_input_select', 'aria-labelledby': this._.labelId };\u000a\u000a						html.push( '<div class="cke_dialog_ui_input_', elementDefinition.type, '" role="presentation"' );\u000a						if ( elementDefinition.width )\u000a							html.push( 'style="width:' + elementDefinition.width + '" ' );\u000a						html.push( '>' );\u000a\u000a						// Add multiple and size attributes from element definition.\u000a						if ( elementDefinition.size != undefined )\u000a							attributes.size = elementDefinition.size;\u000a						if ( elementDefinition.multiple != undefined )\u000a							attributes.multiple = elementDefinition.multiple;\u000a\u000a						cleanInnerDefinition( myDefinition );\u000a						for ( var i = 0, item; i < elementDefinition.items.length && ( item = elementDefinition.items[ i ] ); i++ ) {\u000a							innerHTML.push( '<option value="', CKEDITOR.tools.htmlEncode( item[ 1 ] !== undefined ? item[ 1 ] : item[ 0 ] ).replace( /"/g, '&quot;' ), '" /> ', CKEDITOR.tools.htmlEncode( item[ 0 ] ) );\u000a						}\u000a\u000a						if ( typeof myDefinition.inputStyle != 'undefined' )\u000a							myDefinition.style = myDefinition.inputStyle;\u000a\u000a						_.select = new CKEDITOR.ui.dialog.uiElement( dialog, myDefinition, html, 'select', null, attributes, innerHTML.join( '' ) );\u000a\u000a						html.push( '</div>' );\u000a\u000a						return html.join( '' );\u000a					};\u000a\u000a				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );\u000a			},\u000a\u000a			/**\u000a			 * A file upload input.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.file\u000a			 * @extends CKEDITOR.ui.dialog.labeledElement\u000a			 * @constructor Creates a file class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition\u000a			 * The element definition. Accepted fields:\u000a			 *\u000a			 * * `validate` (Optional) The validation function.\u000a			 *\u000a			 * @param {Array} htmlList List of HTML code to output to.\u000a			 */\u000a			file: function( dialog, elementDefinition, htmlList ) {\u000a				if ( arguments.length < 3 )\u000a					return;\u000a\u000a				if ( elementDefinition[ 'default' ] === undefined )\u000a					elementDefinition[ 'default' ] = '';\u000a\u000a				var _ = CKEDITOR.tools.extend( initPrivateObject.call( this, elementDefinition ), { definition: elementDefinition, buttons: [] } );\u000a\u000a				if ( elementDefinition.validate )\u000a					this.validate = elementDefinition.validate;\u000a\u000a				/** @ignore */\u000a				var innerHTML = function() {\u000a						_.frameId = CKEDITOR.tools.getNextId() + '_fileInput';\u000a\u000a						var html = [\u000a							'<iframe' +\u000a								' frameborder="0"' +\u000a								' allowtransparency="0"' +\u000a								' class="cke_dialog_ui_input_file"' +\u000a								' role="presentation"' +\u000a								' id="', _.frameId, '"' +\u000a								' title="', elementDefinition.label, '"' +\u000a								' src="javascript:void(' ];\u000a\u000a						// Support for custom document.domain on IE. (#10165)\u000a						html.push( CKEDITOR.env.ie ?\u000a							'(function(){' + encodeURIComponent(\u000a								'document.open();' +\u000a								'(' + CKEDITOR.tools.fixDomain + ')();' +\u000a								'document.close();'\u000a							) + '})()'\u000a							:\u000a							'0' );\u000a\u000a						html.push( ')">' +\u000a							'</iframe>' );\u000a\u000a						return html.join( '' );\u000a					};\u000a\u000a				// IE BUG: Parent container does not resize to contain the iframe automatically.\u000a				dialog.on( 'load', function() {\u000a					var iframe = CKEDITOR.document.getById( _.frameId ),\u000a						contentDiv = iframe.getParent();\u000a					contentDiv.addClass( 'cke_dialog_ui_input_file' );\u000a				} );\u000a\u000a				CKEDITOR.ui.dialog.labeledElement.call( this, dialog, elementDefinition, htmlList, innerHTML );\u000a			},\u000a\u000a			/**\u000a			 * A button for submitting the file in a file upload input.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.fileButton\u000a			 * @extends CKEDITOR.ui.dialog.button\u000a			 * @constructor Creates a fileButton class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition\u000a			 * The element definition. Accepted fields:\u000a			 *\u000a			 * * `for` (Required) The file input's page and element ID\u000a			 *     to associate with, in a two-item array format: `[ 'page_id', 'element_id' ]`.\u000a			 * * `validate` (Optional) The validation function.\u000a			 *\u000a			 * @param {Array} htmlList List of HTML code to output to.\u000a			 */\u000a			fileButton: function( dialog, elementDefinition, htmlList ) {\u000a				if ( arguments.length < 3 )\u000a					return;\u000a\u000a				var _ = initPrivateObject.call( this, elementDefinition ),\u000a					me = this;\u000a\u000a				if ( elementDefinition.validate )\u000a					this.validate = elementDefinition.validate;\u000a\u000a				var myDefinition = CKEDITOR.tools.extend( {}, elementDefinition );\u000a				var onClick = myDefinition.onClick;\u000a				myDefinition.className = ( myDefinition.className ? myDefinition.className + ' ' : '' ) + 'cke_dialog_ui_button';\u000a				myDefinition.onClick = function( evt ) {\u000a					var target = elementDefinition[ 'for' ]; // [ pageId, elementId ]\u000a					if ( !onClick || onClick.call( this, evt ) !== false ) {\u000a						dialog.getContentElement( target[ 0 ], target[ 1 ] ).submit();\u000a						this.disable();\u000a					}\u000a				};\u000a\u000a				dialog.on( 'load', function() {\u000a					dialog.getContentElement( elementDefinition[ 'for' ][ 0 ], elementDefinition[ 'for' ][ 1 ] )._.buttons.push( me );\u000a				} );\u000a\u000a				CKEDITOR.ui.dialog.button.call( this, dialog, myDefinition, htmlList );\u000a			},\u000a\u000a			html: ( function() {\u000a				var myHtmlRe = /^\u005cs*<[\u005cw:]+\u005cs+([^>]*)?>/,\u000a					theirHtmlRe = /^(\u005cs*<[\u005cw:]+(?:\u005cs+[^>]*)?)((?:.|\u005cr|\u005cn)+)$/,\u000a					emptyTagRe = /\u005c/$/;\u000a				/**\u000a				 * A dialog window element made from raw HTML code.\u000a				 *\u000a				 * @class CKEDITOR.ui.dialog.html\u000a				 * @extends CKEDITOR.ui.dialog.uiElement\u000a				 * @constructor Creates a html class instance.\u000a				 * @param {CKEDITOR.dialog} dialog Parent dialog window object.\u000a				 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition Element definition.\u000a				 * Accepted fields:\u000a				 *\u000a				 * * `html` (Required) HTML code of this element.\u000a				 *\u000a				 * @param {Array} htmlList List of HTML code to be added to the dialog's content area.\u000a				 */\u000a				return function( dialog, elementDefinition, htmlList ) {\u000a					if ( arguments.length < 3 )\u000a						return;\u000a\u000a					var myHtmlList = [],\u000a						myHtml,\u000a						theirHtml = elementDefinition.html,\u000a						myMatch, theirMatch;\u000a\u000a					// If the HTML input doesn't contain any tags at the beginning, add a <span> tag around it.\u000a					if ( theirHtml.charAt( 0 ) != '<' )\u000a						theirHtml = '<span>' + theirHtml + '</span>';\u000a\u000a					// Look for focus function in definition.\u000a					var focus = elementDefinition.focus;\u000a					if ( focus ) {\u000a						var oldFocus = this.focus;\u000a						this.focus = function() {\u000a							( typeof focus == 'function' ? focus : oldFocus ).call( this );\u000a							this.fire( 'focus' );\u000a						};\u000a						if ( elementDefinition.isFocusable ) {\u000a							var oldIsFocusable = this.isFocusable;\u000a							this.isFocusable = oldIsFocusable;\u000a						}\u000a						this.keyboardFocusable = true;\u000a					}\u000a\u000a					CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition, myHtmlList, 'span', null, null, '' );\u000a\u000a					// Append the attributes created by the uiElement call to the real HTML.\u000a					myHtml = myHtmlList.join( '' );\u000a					myMatch = myHtml.match( myHtmlRe );\u000a					theirMatch = theirHtml.match( theirHtmlRe ) || [ '', '', '' ];\u000a\u000a					if ( emptyTagRe.test( theirMatch[ 1 ] ) ) {\u000a						theirMatch[ 1 ] = theirMatch[ 1 ].slice( 0, -1 );\u000a						theirMatch[ 2 ] = '/' + theirMatch[ 2 ];\u000a					}\u000a\u000a					htmlList.push( [ theirMatch[ 1 ], ' ', myMatch[ 1 ] || '', theirMatch[ 2 ] ].join( '' ) );\u000a				};\u000a			} )(),\u000a\u000a			/**\u000a			 * Form fieldset for grouping dialog UI elements.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.fieldset\u000a			 * @extends CKEDITOR.ui.dialog.uiElement\u000a			 * @constructor Creates a fieldset class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog window object.\u000a			 * @param {Array} childObjList\u000a			 * Array of {@link CKEDITOR.ui.dialog.uiElement} objects inside this container.\u000a			 * @param {Array} childHtmlList Array of HTML code that corresponds to the HTML output of all the\u000a			 * objects in childObjList.\u000a			 * @param {Array} htmlList Array of HTML code that this element will output to.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition\u000a			 * The element definition. Accepted fields:\u000a			 *\u000a			 * * `label` (Optional) The legend of the this fieldset.\u000a			 * * `children` (Required) An array of dialog window field definitions which will be grouped inside this fieldset.\u000a			 *\u000a			 */\u000a			fieldset: function( dialog, childObjList, childHtmlList, htmlList, elementDefinition ) {\u000a				var legendLabel = elementDefinition.label;\u000a				/** @ignore */\u000a				var innerHTML = function() {\u000a						var html = [];\u000a						legendLabel && html.push( '<legend' +\u000a							( elementDefinition.labelStyle ? ' style="' + elementDefinition.labelStyle + '"' : '' ) +\u000a							'>' + legendLabel + '</legend>' );\u000a						for ( var i = 0; i < childHtmlList.length; i++ )\u000a							html.push( childHtmlList[ i ] );\u000a						return html.join( '' );\u000a					};\u000a\u000a				this._ = { children: childObjList };\u000a				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition, htmlList, 'fieldset', null, null, innerHTML );\u000a			}\u000a\u000a		}, true );\u000a\u000a		CKEDITOR.ui.dialog.html.prototype = new CKEDITOR.ui.dialog.uiElement;\u000a\u000a		/** @class CKEDITOR.ui.dialog.labeledElement */\u000a		CKEDITOR.ui.dialog.labeledElement.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement, {\u000a			/**\u000a			 * Sets the label text of the element.\u000a			 *\u000a			 * @param {String} label The new label text.\u000a			 * @returns {CKEDITOR.ui.dialog.labeledElement} The current labeled element.\u000a			 */\u000a			setLabel: function( label ) {\u000a				var node = CKEDITOR.document.getById( this._.labelId );\u000a				if ( node.getChildCount() < 1 )\u000a				( new CKEDITOR.dom.text( label, CKEDITOR.document ) ).appendTo( node );\u000a				else\u000a					node.getChild( 0 ).$.nodeValue = label;\u000a				return this;\u000a			},\u000a\u000a			/**\u000a			 * Retrieves the current label text of the elment.\u000a			 *\u000a			 * @returns {String} The current label text.\u000a			 */\u000a			getLabel: function() {\u000a				var node = CKEDITOR.document.getById( this._.labelId );\u000a				if ( !node || node.getChildCount() < 1 )\u000a					return '';\u000a				else\u000a					return node.getChild( 0 ).getText();\u000a			},\u000a\u000a			/**\u000a			 * Defines the `onChange` event for UI element definitions.\u000a			 * @property {Object}\u000a			 */\u000a			eventProcessors: commonEventProcessors\u000a		}, true );\u000a\u000a		/** @class CKEDITOR.ui.dialog.button */\u000a		CKEDITOR.ui.dialog.button.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement, {\u000a			/**\u000a			 * Simulates a click to the button.\u000a			 *\u000a			 * @returns {Object} Return value of the `click` event.\u000a			 */\u000a			click: function() {\u000a				if ( !this._.disabled )\u000a					return this.fire( 'click', { dialog: this._.dialog } );\u000a				return false;\u000a			},\u000a\u000a			/**\u000a			 * Enables the button.\u000a			 */\u000a			enable: function() {\u000a				this._.disabled = false;\u000a				var element = this.getElement();\u000a				element && element.removeClass( 'cke_disabled' );\u000a			},\u000a\u000a			/**\u000a			 * Disables the button.\u000a			 */\u000a			disable: function() {\u000a				this._.disabled = true;\u000a				this.getElement().addClass( 'cke_disabled' );\u000a			},\u000a\u000a			/**\u000a			 * Checks whether a field is visible.\u000a			 *\u000a			 * @returns {Boolean}\u000a			 */\u000a			isVisible: function() {\u000a				return this.getElement().getFirst().isVisible();\u000a			},\u000a\u000a			/**\u000a			 * Checks whether a field is enabled. Fields can be disabled by using the\u000a			 * {@link #disable} method and enabled by using the {@link #enable} method.\u000a			 *\u000a			 * @returns {Boolean}\u000a			 */\u000a			isEnabled: function() {\u000a				return !this._.disabled;\u000a			},\u000a\u000a			/**\u000a			 * Defines the `onChange` event and `onClick` for button element definitions.\u000a			 *\u000a			 * @property {Object}\u000a			 */\u000a			eventProcessors: CKEDITOR.tools.extend( {}, CKEDITOR.ui.dialog.uiElement.prototype.eventProcessors, {\u000a				onClick: function( dialog, func ) {\u000a					this.on( 'click', function() {\u000a						func.apply( this, arguments );\u000a					} );\u000a				}\u000a			}, true ),\u000a\u000a			/**\u000a			 * Handler for the element's access key up event. Simulates a click to\u000a			 * the button.\u000a			 */\u000a			accessKeyUp: function() {\u000a				this.click();\u000a			},\u000a\u000a			/**\u000a			 * Handler for the element's access key down event. Simulates a mouse\u000a			 * down to the button.\u000a			 */\u000a			accessKeyDown: function() {\u000a				this.focus();\u000a			},\u000a\u000a			keyboardFocusable: true\u000a		}, true );\u000a\u000a		/** @class CKEDITOR.ui.dialog.textInput */\u000a		CKEDITOR.ui.dialog.textInput.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.labeledElement, {\u000a			/**\u000a			 * Gets the text input DOM element under this UI object.\u000a			 *\u000a			 * @returns {CKEDITOR.dom.element} The DOM element of the text input.\u000a			 */\u000a			getInputElement: function() {\u000a				return CKEDITOR.document.getById( this._.inputId );\u000a			},\u000a\u000a			/**\u000a			 * Puts focus into the text input.\u000a			 */\u000a			focus: function() {\u000a				var me = this.selectParentTab();\u000a\u000a				// GECKO BUG: setTimeout() is needed to workaround invisible selections.\u000a				setTimeout( function() {\u000a					var element = me.getInputElement();\u000a					element && element.$.focus();\u000a				}, 0 );\u000a			},\u000a\u000a			/**\u000a			 * Selects all the text in the text input.\u000a			 */\u000a			select: function() {\u000a				var me = this.selectParentTab();\u000a\u000a				// GECKO BUG: setTimeout() is needed to workaround invisible selections.\u000a				setTimeout( function() {\u000a					var e = me.getInputElement();\u000a					if ( e ) {\u000a						e.$.focus();\u000a						e.$.select();\u000a					}\u000a				}, 0 );\u000a			},\u000a\u000a			/**\u000a			 * Handler for the text input's access key up event. Makes a `select()`\u000a			 * call to the text input.\u000a			 */\u000a			accessKeyUp: function() {\u000a				this.select();\u000a			},\u000a\u000a			/**\u000a			 * Sets the value of this text input object.\u000a			 *\u000a			 *		uiElement.setValue( 'Blamo' );\u000a			 *\u000a			 * @param {Object} value The new value.\u000a			 * @returns {CKEDITOR.ui.dialog.textInput} The current UI element.\u000a			 */\u000a			setValue: function( value ) {\u000a				!value && ( value = '' );\u000a				return CKEDITOR.ui.dialog.uiElement.prototype.setValue.apply( this, arguments );\u000a			},\u000a\u000a			keyboardFocusable: true\u000a		}, commonPrototype, true );\u000a\u000a		CKEDITOR.ui.dialog.textarea.prototype = new CKEDITOR.ui.dialog.textInput();\u000a\u000a		/** @class CKEDITOR.ui.dialog.select */\u000a		CKEDITOR.ui.dialog.select.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.labeledElement, {\u000a			/**\u000a			 * Gets the DOM element of the select box.\u000a			 *\u000a			 * @returns {CKEDITOR.dom.element} The `<select>` element of this UI element.\u000a			 */\u000a			getInputElement: function() {\u000a				return this._.select.getElement();\u000a			},\u000a\u000a			/**\u000a			 * Adds an option to the select box.\u000a			 *\u000a			 * @param {String} label Option label.\u000a			 * @param {String} value (Optional) Option value, if not defined it will be\u000a			 * assumed to be the same as the label.\u000a			 * @param {Number} index (Optional) Position of the option to be inserted\u000a			 * to. If not defined, the new option will be inserted to the end of list.\u000a			 * @returns {CKEDITOR.ui.dialog.select} The current select UI element.\u000a			 */\u000a			add: function( label, value, index ) {\u000a				var option = new CKEDITOR.dom.element( 'option', this.getDialog().getParentEditor().document ),\u000a					selectElement = this.getInputElement().$;\u000a				option.$.text = label;\u000a				option.$.value = ( value === undefined || value === null ) ? label : value;\u000a				if ( index === undefined || index === null ) {\u000a					if ( CKEDITOR.env.ie )\u000a						selectElement.add( option.$ );\u000a					else\u000a						selectElement.add( option.$, null );\u000a				} else\u000a					selectElement.add( option.$, index );\u000a				return this;\u000a			},\u000a\u000a			/**\u000a			 * Removes an option from the selection list.\u000a			 *\u000a			 * @param {Number} index Index of the option to be removed.\u000a			 * @returns {CKEDITOR.ui.dialog.select} The current select UI element.\u000a			 */\u000a			remove: function( index ) {\u000a				var selectElement = this.getInputElement().$;\u000a				selectElement.remove( index );\u000a				return this;\u000a			},\u000a\u000a			/**\u000a			 * Clears all options out of the selection list.\u000a			 *\u000a			 * @returns {CKEDITOR.ui.dialog.select} The current select UI element.\u000a			 */\u000a			clear: function() {\u000a				var selectElement = this.getInputElement().$;\u000a				while ( selectElement.length > 0 )\u000a					selectElement.remove( 0 );\u000a				return this;\u000a			},\u000a\u000a			keyboardFocusable: true\u000a		}, commonPrototype, true );\u000a\u000a		/** @class CKEDITOR.ui.dialog.checkbox */\u000a		CKEDITOR.ui.dialog.checkbox.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement, {\u000a			/**\u000a			 * Gets the checkbox DOM element.\u000a			 *\u000a			 * @returns {CKEDITOR.dom.element} The DOM element of the checkbox.\u000a			 */\u000a			getInputElement: function() {\u000a				return this._.checkbox.getElement();\u000a			},\u000a\u000a			/**\u000a			 * Sets the state of the checkbox.\u000a			 *\u000a			 * @param {Boolean} checked `true` to tick the checkbox, `false` to untick it.\u000a			 * @param {Boolean} noChangeEvent Internal commit, to supress `change` event on this element.\u000a			 */\u000a			setValue: function( checked, noChangeEvent ) {\u000a				this.getInputElement().$.checked = checked;\u000a				!noChangeEvent && this.fire( 'change', { value: checked } );\u000a			},\u000a\u000a			/**\u000a			 * Gets the state of the checkbox.\u000a			 *\u000a			 * @returns {Boolean} `true` means that the checkbox is ticked, `false` means it is not ticked.\u000a			 */\u000a			getValue: function() {\u000a				return this.getInputElement().$.checked;\u000a			},\u000a\u000a			/**\u000a			 * Handler for the access key up event. Toggles the checkbox.\u000a			 */\u000a			accessKeyUp: function() {\u000a				this.setValue( !this.getValue() );\u000a			},\u000a\u000a			/**\u000a			 * Defines the `onChange` event for UI element definitions.\u000a			 *\u000a			 * @property {Object}\u000a			 */\u000a			eventProcessors: {\u000a				onChange: function( dialog, func ) {\u000a					if ( !CKEDITOR.env.ie || ( CKEDITOR.env.version > 8 ) )\u000a						return commonEventProcessors.onChange.apply( this, arguments );\u000a					else {\u000a						dialog.on( 'load', function() {\u000a							var element = this._.checkbox.getElement();\u000a							element.on( 'propertychange', function( evt ) {\u000a								evt = evt.data.$;\u000a								if ( evt.propertyName == 'checked' )\u000a									this.fire( 'change', { value: element.$.checked } );\u000a							}, this );\u000a						}, this );\u000a						this.on( 'change', func );\u000a					}\u000a					return null;\u000a				}\u000a			},\u000a\u000a			keyboardFocusable: true\u000a		}, commonPrototype, true );\u000a\u000a		/** @class CKEDITOR.ui.dialog.radio */\u000a		CKEDITOR.ui.dialog.radio.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement, {\u000a			/**\u000a			 * Selects one of the radio buttons in this button group.\u000a			 *\u000a			 * @param {String} value The value of the button to be chcked.\u000a			 * @param {Boolean} noChangeEvent Internal commit, to supress the `change` event on this element.\u000a			 */\u000a			setValue: function( value, noChangeEvent ) {\u000a				var children = this._.children,\u000a					item;\u000a				for ( var i = 0;\u000a				( i < children.length ) && ( item = children[ i ] ); i++ )\u000a					item.getElement().$.checked = ( item.getValue() == value );\u000a				!noChangeEvent && this.fire( 'change', { value: value } );\u000a			},\u000a\u000a			/**\u000a			 * Gets the value of the currently selected radio button.\u000a			 *\u000a			 * @returns {String} The currently selected button's value.\u000a			 */\u000a			getValue: function() {\u000a				var children = this._.children;\u000a				for ( var i = 0; i < children.length; i++ ) {\u000a					if ( children[ i ].getElement().$.checked )\u000a						return children[ i ].getValue();\u000a				}\u000a				return null;\u000a			},\u000a\u000a			/**\u000a			 * Handler for the access key up event. Focuses the currently\u000a			 * selected radio button, or the first radio button if none is selected.\u000a			 */\u000a			accessKeyUp: function() {\u000a				var children = this._.children,\u000a					i;\u000a				for ( i = 0; i < children.length; i++ ) {\u000a					if ( children[ i ].getElement().$.checked ) {\u000a						children[ i ].getElement().focus();\u000a						return;\u000a					}\u000a				}\u000a				children[ 0 ].getElement().focus();\u000a			},\u000a\u000a			/**\u000a			 * Defines the `onChange` event for UI element definitions.\u000a			 *\u000a			 * @property {Object}\u000a			 */\u000a			eventProcessors: {\u000a				onChange: function( dialog, func ) {\u000a					if ( !CKEDITOR.env.ie )\u000a						return commonEventProcessors.onChange.apply( this, arguments );\u000a					else {\u000a						dialog.on( 'load', function() {\u000a							var children = this._.children,\u000a								me = this;\u000a							for ( var i = 0; i < children.length; i++ ) {\u000a								var element = children[ i ].getElement();\u000a								element.on( 'propertychange', function( evt ) {\u000a									evt = evt.data.$;\u000a									if ( evt.propertyName == 'checked' && this.$.checked )\u000a										me.fire( 'change', { value: this.getAttribute( 'value' ) } );\u000a								} );\u000a							}\u000a						}, this );\u000a						this.on( 'change', func );\u000a					}\u000a					return null;\u000a				}\u000a			}\u000a		}, commonPrototype, true );\u000a\u000a		/** @class CKEDITOR.ui.dialog.file */\u000a		CKEDITOR.ui.dialog.file.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.labeledElement, commonPrototype, {\u000a			/**\u000a			 * Gets the `<input>` element of this file input.\u000a			 *\u000a			 * @returns {CKEDITOR.dom.element} The file input element.\u000a			 */\u000a			getInputElement: function() {\u000a				var frameDocument = CKEDITOR.document.getById( this._.frameId ).getFrameDocument();\u000a				return frameDocument.$.forms.length > 0 ? new CKEDITOR.dom.element( frameDocument.$.forms[ 0 ].elements[ 0 ] ) : this.getElement();\u000a			},\u000a\u000a			/**\u000a			 * Uploads the file in the file input.\u000a			 *\u000a			 * @returns {CKEDITOR.ui.dialog.file} This object.\u000a			 */\u000a			submit: function() {\u000a				this.getInputElement().getParent().$.submit();\u000a				return this;\u000a			},\u000a\u000a			/**\u000a			 * Gets the action assigned to the form.\u000a			 *\u000a			 * @returns {String} The value of the action.\u000a			 */\u000a			getAction: function() {\u000a				return this.getInputElement().getParent().$.action;\u000a			},\u000a\u000a			/**\u000a			 * The events must be applied to the inner input element, and\u000a			 * this must be done when the iframe and form have been loaded.\u000a			 */\u000a			registerEvents: function( definition ) {\u000a				var regex = /^on([A-Z]\u005cw+)/,\u000a					match;\u000a\u000a				var registerDomEvent = function( uiElement, dialog, eventName, func ) {\u000a						uiElement.on( 'formLoaded', function() {\u000a							uiElement.getInputElement().on( eventName, func, uiElement );\u000a						} );\u000a					};\u000a\u000a				for ( var i in definition ) {\u000a					if ( !( match = i.match( regex ) ) )\u000a						continue;\u000a\u000a					if ( this.eventProcessors[ i ] )\u000a						this.eventProcessors[ i ].call( this, this._.dialog, definition[ i ] );\u000a					else\u000a						registerDomEvent( this, this._.dialog, match[ 1 ].toLowerCase(), definition[ i ] );\u000a				}\u000a\u000a				return this;\u000a			},\u000a\u000a			/**\u000a			 * Redraws the file input and resets the file path in the file input.\u000a			 * The redrawing logic is necessary because non-IE browsers tend to clear\u000a			 * the `<iframe>` containing the file input after closing the dialog window.\u000a			 */\u000a			reset: function() {\u000a				var _ = this._,\u000a					frameElement = CKEDITOR.document.getById( _.frameId ),\u000a					frameDocument = frameElement.getFrameDocument(),\u000a					elementDefinition = _.definition,\u000a					buttons = _.buttons,\u000a					callNumber = this.formLoadedNumber,\u000a					unloadNumber = this.formUnloadNumber,\u000a					langDir = _.dialog._.editor.lang.dir,\u000a					langCode = _.dialog._.editor.langCode;\u000a\u000a				// The callback function for the iframe, but we must call tools.addFunction only once\u000a				// so we store the function number in this.formLoadedNumber\u000a				if ( !callNumber ) {\u000a					callNumber = this.formLoadedNumber = CKEDITOR.tools.addFunction( function() {\u000a						// Now we can apply the events to the input type=file\u000a						this.fire( 'formLoaded' );\u000a					}, this );\u000a\u000a					// Remove listeners attached to the content of the iframe (the file input)\u000a					unloadNumber = this.formUnloadNumber = CKEDITOR.tools.addFunction( function() {\u000a						this.getInputElement().clearCustomData();\u000a					}, this );\u000a\u000a					this.getDialog()._.editor.on( 'destroy', function() {\u000a						CKEDITOR.tools.removeFunction( callNumber );\u000a						CKEDITOR.tools.removeFunction( unloadNumber );\u000a					} );\u000a				}\u000a\u000a				function generateFormField() {\u000a					frameDocument.$.open();\u000a\u000a					var size = '';\u000a					if ( elementDefinition.size )\u000a						size = elementDefinition.size - ( CKEDITOR.env.ie ? 7 : 0 ); // "Browse" button is bigger in IE.\u000a\u000a					var inputId = _.frameId + '_input';\u000a\u000a					frameDocument.$.write( [\u000a						'<html dir="' + langDir + '" lang="' + langCode + '"><head><title></title></head><body style="margin: 0; overflow: hidden; background: transparent;">',\u000a							'<form enctype="multipart/form-data" method="POST" dir="' + langDir + '" lang="' + langCode + '" action="',\u000a								CKEDITOR.tools.htmlEncode( elementDefinition.action ),\u000a							'">',\u000a								// Replicate the field label inside of iframe.\u000a								'<label id="', _.labelId, '" for="', inputId, '" style="display:none">',\u000a									CKEDITOR.tools.htmlEncode( elementDefinition.label ),\u000a								'</label>',\u000a								// Set width to make sure that input is not clipped by the iframe (#11253).\u000a								'<input style="width:100%" id="', inputId, '" aria-labelledby="', _.labelId, '" type="file" name="',\u000a									CKEDITOR.tools.htmlEncode( elementDefinition.id || 'cke_upload' ),\u000a									'" size="',\u000a									CKEDITOR.tools.htmlEncode( size > 0 ? size : "" ),\u000a								'" />',\u000a							'</form>',\u000a						'</body></html>',\u000a						'<script>',\u000a							// Support for custom document.domain in IE.\u000a							CKEDITOR.env.ie ? '(' + CKEDITOR.tools.fixDomain + ')();' : '',\u000a\u000a							'window.parent.CKEDITOR.tools.callFunction(' + callNumber + ');',\u000a							'window.onbeforeunload = function() {window.parent.CKEDITOR.tools.callFunction(' + unloadNumber + ')}',\u000a						'</script>'\u000a					].join( '' ) );\u000a\u000a					frameDocument.$.close();\u000a\u000a					for ( var i = 0; i < buttons.length; i++ )\u000a						buttons[ i ].enable();\u000a				}\u000a\u000a				// #3465: Wait for the browser to finish rendering the dialog first.\u000a				if ( CKEDITOR.env.gecko )\u000a					setTimeout( generateFormField, 500 );\u000a				else\u000a					generateFormField();\u000a			},\u000a\u000a			getValue: function() {\u000a				return this.getInputElement().$.value || '';\u000a			},\u000a\u000a			/**\u000a			 * The default value of input `type="file"` is an empty string, but during the initialization\u000a			 * of this UI element, the iframe still is not ready so it cannot be read from that object.\u000a			 * Setting it manually prevents later issues with the current value (`''`) being different\u000a			 * than the initial value (undefined as it asked for `.value` of a div).\u000a			 */\u000a			setInitValue: function() {\u000a				this._.initValue = '';\u000a			},\u000a\u000a			/**\u000a			 * Defines the `onChange` event for UI element definitions.\u000a			 *\u000a			 * @property {Object}\u000a			 */\u000a			eventProcessors: {\u000a				onChange: function( dialog, func ) {\u000a					// If this method is called several times (I'm not sure about how this can happen but the default\u000a					// onChange processor includes this protection)\u000a					// In order to reapply to the new element, the property is deleted at the beggining of the registerEvents method\u000a					if ( !this._.domOnChangeRegistered ) {\u000a						// By listening for the formLoaded event, this handler will get reapplied when a new\u000a						// form is created\u000a						this.on( 'formLoaded', function() {\u000a							this.getInputElement().on( 'change', function() {\u000a								this.fire( 'change', { value: this.getValue() } );\u000a							}, this );\u000a						}, this );\u000a						this._.domOnChangeRegistered = true;\u000a					}\u000a\u000a					this.on( 'change', func );\u000a				}\u000a			},\u000a\u000a			keyboardFocusable: true\u000a		}, true );\u000a\u000a		CKEDITOR.ui.dialog.fileButton.prototype = new CKEDITOR.ui.dialog.button;\u000a\u000a		CKEDITOR.ui.dialog.fieldset.prototype = CKEDITOR.tools.clone( CKEDITOR.ui.dialog.hbox.prototype );\u000a\u000a		CKEDITOR.dialog.addUIElement( 'text', textBuilder );\u000a		CKEDITOR.dialog.addUIElement( 'password', textBuilder );\u000a		CKEDITOR.dialog.addUIElement( 'textarea', commonBuilder );\u000a		CKEDITOR.dialog.addUIElement( 'checkbox', commonBuilder );\u000a		CKEDITOR.dialog.addUIElement( 'radio', commonBuilder );\u000a		CKEDITOR.dialog.addUIElement( 'button', commonBuilder );\u000a		CKEDITOR.dialog.addUIElement( 'select', commonBuilder );\u000a		CKEDITOR.dialog.addUIElement( 'file', commonBuilder );\u000a		CKEDITOR.dialog.addUIElement( 'fileButton', commonBuilder );\u000a		CKEDITOR.dialog.addUIElement( 'html', commonBuilder );\u000a		CKEDITOR.dialog.addUIElement( 'fieldset', containerBuilder );\u000a	}\u000a} );\u000a\u000a/**\u000a * Fired when the value of the uiElement is changed.\u000a *\u000a * @event change\u000a * @member CKEDITOR.ui.dialog.uiElement\u000a */\u000a\u000a/**\u000a * Fired when the inner frame created by the element is ready.\u000a * Each time the button is used or the dialog window is loaded, a new\u000a * form might be created.\u000a *\u000a * @event formLoaded\u000a * @member CKEDITOR.ui.dialog.fileButton\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview The floating dialog plugin.\u000a */\u000a\u000a/**\u000a * No resize for this dialog.\u000a *\u000a * @readonly\u000a * @property {Number} [=0]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.DIALOG_RESIZE_NONE = 0;\u000a\u000a/**\u000a * Only allow horizontal resizing for this dialog, disable vertical resizing.\u000a *\u000a * @readonly\u000a * @property {Number} [=1]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.DIALOG_RESIZE_WIDTH = 1;\u000a\u000a/**\u000a * Only allow vertical resizing for this dialog, disable horizontal resizing.\u000a *\u000a * @readonly\u000a * @property {Number} [=2]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.DIALOG_RESIZE_HEIGHT = 2;\u000a\u000a/**\u000a * Allow the dialog to be resized in both directions.\u000a *\u000a * @readonly\u000a * @property {Number} [=3]\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.DIALOG_RESIZE_BOTH = 3;\u000a\u000a( function() {\u000a	var cssLength = CKEDITOR.tools.cssLength;\u000a\u000a	function isTabVisible( tabId ) {\u000a		return !!this._.tabs[ tabId ][ 0 ].$.offsetHeight;\u000a	}\u000a\u000a	function getPreviousVisibleTab() {\u000a		var tabId = this._.currentTabId,\u000a			length = this._.tabIdList.length,\u000a			tabIndex = CKEDITOR.tools.indexOf( this._.tabIdList, tabId ) + length;\u000a\u000a		for ( var i = tabIndex - 1; i > tabIndex - length; i-- ) {\u000a			if ( isTabVisible.call( this, this._.tabIdList[ i % length ] ) )\u000a				return this._.tabIdList[ i % length ];\u000a		}\u000a\u000a		return null;\u000a	}\u000a\u000a	function getNextVisibleTab() {\u000a		var tabId = this._.currentTabId,\u000a			length = this._.tabIdList.length,\u000a			tabIndex = CKEDITOR.tools.indexOf( this._.tabIdList, tabId );\u000a\u000a		for ( var i = tabIndex + 1; i < tabIndex + length; i++ ) {\u000a			if ( isTabVisible.call( this, this._.tabIdList[ i % length ] ) )\u000a				return this._.tabIdList[ i % length ];\u000a		}\u000a\u000a		return null;\u000a	}\u000a\u000a\u000a	function clearOrRecoverTextInputValue( container, isRecover ) {\u000a		var inputs = container.$.getElementsByTagName( 'input' );\u000a		for ( var i = 0, length = inputs.length; i < length; i++ ) {\u000a			var item = new CKEDITOR.dom.element( inputs[ i ] );\u000a\u000a			if ( item.getAttribute( 'type' ).toLowerCase() == 'text' ) {\u000a				if ( isRecover ) {\u000a					item.setAttribute( 'value', item.getCustomData( 'fake_value' ) || '' );\u000a					item.removeCustomData( 'fake_value' );\u000a				} else {\u000a					item.setCustomData( 'fake_value', item.getAttribute( 'value' ) );\u000a					item.setAttribute( 'value', '' );\u000a				}\u000a			}\u000a		}\u000a	}\u000a\u000a	// Handle dialog element validation state UI changes.\u000a	function handleFieldValidated( isValid, msg ) {\u000a		var input = this.getInputElement();\u000a		if ( input )\u000a			isValid ? input.removeAttribute( 'aria-invalid' ) : input.setAttribute( 'aria-invalid', true );\u000a\u000a		if ( !isValid ) {\u000a			if ( this.select )\u000a				this.select();\u000a			else\u000a				this.focus();\u000a		}\u000a\u000a		msg && alert( msg );\u000a\u000a		this.fire( 'validated', { valid: isValid, msg: msg } );\u000a	}\u000a\u000a	function resetField() {\u000a		var input = this.getInputElement();\u000a		input && input.removeAttribute( 'aria-invalid' );\u000a	}\u000a\u000a	var templateSource = '<div class="cke_reset_all {editorId} {editorDialogClass} {hidpi}' +\u000a		'" dir="{langDir}"' +\u000a		' lang="{langCode}"' +\u000a		' role="dialog"' +\u000a		' aria-labelledby="cke_dialog_title_{id}"' +\u000a		'>' +\u000a		'<table class="cke_dialog ' + CKEDITOR.env.cssClass + ' cke_{langDir}"' +\u000a			' style="position:absolute" role="presentation">' +\u000a			'<tr><td role="presentation">' +\u000a			'<div class="cke_dialog_body" role="presentation">' +\u000a				'<div id="cke_dialog_title_{id}" class="cke_dialog_title" role="presentation"></div>' +\u000a				'<a id="cke_dialog_close_button_{id}" class="cke_dialog_close_button" href="javascript:void(0)" title="{closeTitle}" role="button"><i class="fa fa-close"></i></a>' +\u000a				'<div id="cke_dialog_tabs_{id}" class="cke_dialog_tabs" role="tablist"></div>' +\u000a				'<table class="cke_dialog_contents" role="presentation">' +\u000a				'<tr>' +\u000a					'<td id="cke_dialog_contents_{id}" class="cke_dialog_contents_body" role="presentation"></td>' +\u000a				'</tr>' +\u000a				'<tr>' +\u000a					'<td id="cke_dialog_footer_{id}" class="cke_dialog_footer" role="presentation"></td>' +\u000a				'</tr>' +\u000a				'</table>' +\u000a			'</div>' +\u000a			'</td></tr>' +\u000a		'</table>' +\u000a		'</div>';\u000a\u000a	function buildDialog( editor ) {\u000a		var element = CKEDITOR.dom.element.createFromHtml( CKEDITOR.addTemplate( 'dialog', templateSource ).output( {\u000a			id: CKEDITOR.tools.getNextNumber(),\u000a			editorId: editor.id,\u000a			langDir: editor.lang.dir,\u000a			langCode: editor.langCode,\u000a			editorDialogClass: 'cke_editor_' + editor.name.replace( /\u005c./g, '\u005c\u005c.' ) + '_dialog',\u000a			closeTitle: editor.lang.common.close,\u000a			hidpi: CKEDITOR.env.hidpi ? 'cke_hidpi' : ''\u000a		} ) );\u000a\u000a		// TODO: Change this to getById(), so it'll support custom templates.\u000a		var body = element.getChild( [ 0, 0, 0, 0, 0 ] ),\u000a			title = body.getChild( 0 ),\u000a			close = body.getChild( 1 );\u000a\u000a		// IFrame shim for dialog that masks activeX in IE. (#7619)\u000a		if ( CKEDITOR.env.ie && !CKEDITOR.env.quirks ) {\u000a			var src = 'javascript:void(function(){' + encodeURIComponent( 'document.open();(' + CKEDITOR.tools.fixDomain + ')();document.close();' ) + '}())',\u000a				iframe = CKEDITOR.dom.element.createFromHtml( '<iframe' +\u000a					' frameBorder="0"' +\u000a					' class="cke_iframe_shim"' +\u000a					' src="' + src + '"' +\u000a					' tabIndex="-1"' +\u000a					'></iframe>' );\u000a			iframe.appendTo( body.getParent() );\u000a		}\u000a\u000a		// Make the Title and Close Button unselectable.\u000a		title.unselectable();\u000a		close.unselectable();\u000a\u000a		return {\u000a			element: element,\u000a			parts: {\u000a				dialog: element.getChild( 0 ),\u000a				title: title,\u000a				close: close,\u000a				tabs: body.getChild( 2 ),\u000a				contents: body.getChild( [ 3, 0, 0, 0 ] ),\u000a				footer: body.getChild( [ 3, 0, 1, 0 ] )\u000a			}\u000a		};\u000a	}\u000a\u000a	/**\u000a	 * This is the base class for runtime dialog objects. An instance of this\u000a	 * class represents a single named dialog for a single editor instance.\u000a	 *\u000a	 *		var dialogObj = new CKEDITOR.dialog( editor, 'smiley' );\u000a	 *\u000a	 * @class\u000a	 * @constructor Creates a dialog class instance.\u000a	 * @param {Object} editor The editor which created the dialog.\u000a	 * @param {String} dialogName The dialog's registered name.\u000a	 */\u000a	CKEDITOR.dialog = function( editor, dialogName ) {\u000a		// Load the dialog definition.\u000a		var definition = CKEDITOR.dialog._.dialogDefinitions[ dialogName ],\u000a			defaultDefinition = CKEDITOR.tools.clone( defaultDialogDefinition ),\u000a			buttonsOrder = editor.config.dialog_buttonsOrder || 'OS',\u000a			dir = editor.lang.dir,\u000a			tabsToRemove = {},\u000a			i, processed, stopPropagation;\u000a\u000a		if ( ( buttonsOrder == 'OS' && CKEDITOR.env.mac ) || // The buttons in MacOS Apps are in reverse order (#4750)\u000a		( buttonsOrder == 'rtl' && dir == 'ltr' ) || ( buttonsOrder == 'ltr' && dir == 'rtl' ) )\u000a			defaultDefinition.buttons.reverse();\u000a\u000a\u000a		// Completes the definition with the default values.\u000a		definition = CKEDITOR.tools.extend( definition( editor ), defaultDefinition );\u000a\u000a		// Clone a functionally independent copy for this dialog.\u000a		definition = CKEDITOR.tools.clone( definition );\u000a\u000a		// Create a complex definition object, extending it with the API\u000a		// functions.\u000a		definition = new definitionObject( this, definition );\u000a\u000a		var doc = CKEDITOR.document;\u000a\u000a		var themeBuilt = buildDialog( editor );\u000a\u000a		// Initialize some basic parameters.\u000a		this._ = {\u000a			editor: editor,\u000a			element: themeBuilt.element,\u000a			name: dialogName,\u000a			contentSize: { width: 0, height: 0 },\u000a			size: { width: 0, height: 0 },\u000a			contents: {},\u000a			buttons: {},\u000a			accessKeyMap: {},\u000a\u000a			// Initialize the tab and page map.\u000a			tabs: {},\u000a			tabIdList: [],\u000a			currentTabId: null,\u000a			currentTabIndex: null,\u000a			pageCount: 0,\u000a			lastTab: null,\u000a			tabBarMode: false,\u000a\u000a			// Initialize the tab order array for input widgets.\u000a			focusList: [],\u000a			currentFocusIndex: 0,\u000a			hasFocus: false\u000a		};\u000a\u000a		this.parts = themeBuilt.parts;\u000a\u000a		CKEDITOR.tools.setTimeout( function() {\u000a			editor.fire( 'ariaWidget', this.parts.contents );\u000a		}, 0, this );\u000a\u000a		// Set the startup styles for the dialog, avoiding it enlarging the\u000a		// page size on the dialog creation.\u000a		var startStyles = {\u000a			position: CKEDITOR.env.ie6Compat ? 'absolute' : 'fixed',\u000a			top: 0,\u000a			visibility: 'hidden'\u000a		};\u000a\u000a		startStyles[ dir == 'rtl' ? 'right' : 'left' ] = 0;\u000a		this.parts.dialog.setStyles( startStyles );\u000a\u000a\u000a		// Call the CKEDITOR.event constructor to initialize this instance.\u000a		CKEDITOR.event.call( this );\u000a\u000a		// Fire the "dialogDefinition" event, making it possible to customize\u000a		// the dialog definition.\u000a		this.definition = definition = CKEDITOR.fire( 'dialogDefinition', {\u000a			name: dialogName,\u000a			definition: definition\u000a		}, editor ).definition;\u000a\u000a		// Cache tabs that should be removed.\u000a		if ( !( 'removeDialogTabs' in editor._ ) && editor.config.removeDialogTabs ) {\u000a			var removeContents = editor.config.removeDialogTabs.split( ';' );\u000a\u000a			for ( i = 0; i < removeContents.length; i++ ) {\u000a				var parts = removeContents[ i ].split( ':' );\u000a				if ( parts.length == 2 ) {\u000a					var removeDialogName = parts[ 0 ];\u000a					if ( !tabsToRemove[ removeDialogName ] )\u000a						tabsToRemove[ removeDialogName ] = [];\u000a					tabsToRemove[ removeDialogName ].push( parts[ 1 ] );\u000a				}\u000a			}\u000a			editor._.removeDialogTabs = tabsToRemove;\u000a		}\u000a\u000a		// Remove tabs of this dialog.\u000a		if ( editor._.removeDialogTabs && ( tabsToRemove = editor._.removeDialogTabs[ dialogName ] ) ) {\u000a			for ( i = 0; i < tabsToRemove.length; i++ )\u000a				definition.removeContents( tabsToRemove[ i ] );\u000a		}\u000a\u000a		// Initialize load, show, hide, ok and cancel events.\u000a		if ( definition.onLoad )\u000a			this.on( 'load', definition.onLoad );\u000a\u000a		if ( definition.onShow )\u000a			this.on( 'show', definition.onShow );\u000a\u000a		if ( definition.onHide )\u000a			this.on( 'hide', definition.onHide );\u000a\u000a		if ( definition.onOk ) {\u000a			this.on( 'ok', function( evt ) {\u000a				// Dialog confirm might probably introduce content changes (#5415).\u000a				editor.fire( 'saveSnapshot' );\u000a				setTimeout( function() {\u000a					editor.fire( 'saveSnapshot' );\u000a				}, 0 );\u000a				if ( definition.onOk.call( this, evt ) === false )\u000a					evt.data.hide = false;\u000a			} );\u000a		}\u000a\u000a		if ( definition.onCancel ) {\u000a			this.on( 'cancel', function( evt ) {\u000a				if ( definition.onCancel.call( this, evt ) === false )\u000a					evt.data.hide = false;\u000a			} );\u000a		}\u000a\u000a		var me = this;\u000a\u000a		// Iterates over all items inside all content in the dialog, calling a\u000a		// function for each of them.\u000a		var iterContents = function( func ) {\u000a				var contents = me._.contents,\u000a					stop = false;\u000a\u000a				for ( var i in contents ) {\u000a					for ( var j in contents[ i ] ) {\u000a						stop = func.call( this, contents[ i ][ j ] );\u000a						if ( stop )\u000a							return;\u000a					}\u000a				}\u000a			};\u000a\u000a		this.on( 'ok', function( evt ) {\u000a			iterContents( function( item ) {\u000a				if ( item.validate ) {\u000a					var retval = item.validate( this ),\u000a						invalid = typeof( retval ) == 'string' || retval === false;\u000a\u000a					if ( invalid ) {\u000a						evt.data.hide = false;\u000a						evt.stop();\u000a					}\u000a\u000a					handleFieldValidated.call( item, !invalid, typeof retval == 'string' ? retval : undefined );\u000a					return invalid;\u000a				}\u000a			} );\u000a		}, this, null, 0 );\u000a\u000a		this.on( 'cancel', function( evt ) {\u000a			iterContents( function( item ) {\u000a				if ( item.isChanged() ) {\u000a					if ( !editor.config.dialog_noConfirmCancel && !confirm( editor.lang.common.confirmCancel ) )\u000a						evt.data.hide = false;\u000a					return true;\u000a				}\u000a			} );\u000a		}, this, null, 0 );\u000a\u000a		this.parts.close.on( 'click', function( evt ) {\u000a			if ( this.fire( 'cancel', { hide: true } ).hide !== false )\u000a				this.hide();\u000a			evt.data.preventDefault();\u000a		}, this );\u000a\u000a		// Sort focus list according to tab order definitions.\u000a		function setupFocus() {\u000a			var focusList = me._.focusList;\u000a			focusList.sort( function( a, b ) {\u000a				// Mimics browser tab order logics;\u000a				if ( a.tabIndex != b.tabIndex )\u000a					return b.tabIndex - a.tabIndex;\u000a				//  Sort is not stable in some browsers,\u000a				// fall-back the comparator to 'focusIndex';\u000a				else\u000a					return a.focusIndex - b.focusIndex;\u000a			} );\u000a\u000a			var size = focusList.length;\u000a			for ( var i = 0; i < size; i++ )\u000a				focusList[ i ].focusIndex = i;\u000a		}\u000a\u000a		function changeFocus( offset ) {\u000a			var focusList = me._.focusList;\u000a			offset = offset || 0;\u000a\u000a			if ( focusList.length < 1 )\u000a				return;\u000a\u000a			var current = me._.currentFocusIndex;\u000a\u000a			// Trigger the 'blur' event of  any input element before anything,\u000a			// since certain UI updates may depend on it.\u000a			try {\u000a				focusList[ current ].getInputElement().$.blur();\u000a			} catch ( e ) {}\u000a\u000a			var startIndex = ( current + offset + focusList.length ) % focusList.length,\u000a				currentIndex = startIndex;\u000a			while ( offset && !focusList[ currentIndex ].isFocusable() ) {\u000a				currentIndex = ( currentIndex + offset + focusList.length ) % focusList.length;\u000a				if ( currentIndex == startIndex )\u000a					break;\u000a			}\u000a\u000a			focusList[ currentIndex ].focus();\u000a\u000a			// Select whole field content.\u000a			if ( focusList[ currentIndex ].type == 'text' )\u000a				focusList[ currentIndex ].select();\u000a		}\u000a\u000a		this.changeFocus = changeFocus;\u000a\u000a\u000a		function keydownHandler( evt ) {\u000a			// If I'm not the top dialog, ignore.\u000a			if ( me != CKEDITOR.dialog._.currentTop )\u000a				return;\u000a\u000a			var keystroke = evt.data.getKeystroke(),\u000a				rtl = editor.lang.dir == 'rtl',\u000a				button;\u000a\u000a			processed = stopPropagation = 0;\u000a\u000a			if ( keystroke == 9 || keystroke == CKEDITOR.SHIFT + 9 ) {\u000a				var shiftPressed = ( keystroke == CKEDITOR.SHIFT + 9 );\u000a\u000a				// Handling Tab and Shift-Tab.\u000a				if ( me._.tabBarMode ) {\u000a					// Change tabs.\u000a					var nextId = shiftPressed ? getPreviousVisibleTab.call( me ) : getNextVisibleTab.call( me );\u000a					me.selectPage( nextId );\u000a					me._.tabs[ nextId ][ 0 ].focus();\u000a				} else {\u000a					// Change the focus of inputs.\u000a					changeFocus( shiftPressed ? -1 : 1 );\u000a				}\u000a\u000a				processed = 1;\u000a			} else if ( keystroke == CKEDITOR.ALT + 121 && !me._.tabBarMode && me.getPageCount() > 1 ) {\u000a				// Alt-F10 puts focus into the current tab item in the tab bar.\u000a				me._.tabBarMode = true;\u000a				me._.tabs[ me._.currentTabId ][ 0 ].focus();\u000a				processed = 1;\u000a			} else if ( ( keystroke == 37 || keystroke == 39 ) && me._.tabBarMode ) {\u000a				// Arrow keys - used for changing tabs.\u000a				nextId = ( keystroke == ( rtl ? 39 : 37 ) ? getPreviousVisibleTab.call( me ) : getNextVisibleTab.call( me ) );\u000a				me.selectPage( nextId );\u000a				me._.tabs[ nextId ][ 0 ].focus();\u000a				processed = 1;\u000a			} else if ( ( keystroke == 13 || keystroke == 32 ) && me._.tabBarMode ) {\u000a				this.selectPage( this._.currentTabId );\u000a				this._.tabBarMode = false;\u000a				this._.currentFocusIndex = -1;\u000a				changeFocus( 1 );\u000a				processed = 1;\u000a			}\u000a			// If user presses enter key in a text box, it implies clicking OK for the dialog.\u000a			else if ( keystroke == 13 /*ENTER*/ ) {\u000a				// Don't do that for a target that handles ENTER.\u000a				var target = evt.data.getTarget();\u000a				if ( !target.is( 'a', 'button', 'select', 'textarea' ) && ( !target.is( 'input' ) || target.$.type != 'button' ) ) {\u000a					button = this.getButton( 'ok' );\u000a					button && CKEDITOR.tools.setTimeout( button.click, 0, button );\u000a					processed = 1;\u000a				}\u000a				stopPropagation = 1; // Always block the propagation (#4269)\u000a			} else if ( keystroke == 27 /*ESC*/ ) {\u000a				button = this.getButton( 'cancel' );\u000a\u000a				// If there's a Cancel button, click it, else just fire the cancel event and hide the dialog.\u000a				if ( button )\u000a					CKEDITOR.tools.setTimeout( button.click, 0, button );\u000a				else {\u000a					if ( this.fire( 'cancel', { hide: true } ).hide !== false )\u000a						this.hide();\u000a				}\u000a				stopPropagation = 1; // Always block the propagation (#4269)\u000a			} else\u000a				return;\u000a\u000a			keypressHandler( evt );\u000a		}\u000a\u000a		function keypressHandler( evt ) {\u000a			if ( processed )\u000a				evt.data.preventDefault( 1 );\u000a			else if ( stopPropagation )\u000a				evt.data.stopPropagation();\u000a		}\u000a\u000a		var dialogElement = this._.element;\u000a\u000a		editor.focusManager.add( dialogElement, 1 );\u000a\u000a		// Add the dialog keyboard handlers.\u000a		this.on( 'show', function() {\u000a			dialogElement.on( 'keydown', keydownHandler, this );\u000a\u000a			// Some browsers instead, don't cancel key events in the keydown, but in the\u000a			// keypress. So we must do a longer trip in those cases. (#4531,#8985)\u000a			if ( CKEDITOR.env.gecko )\u000a				dialogElement.on( 'keypress', keypressHandler, this );\u000a\u000a		} );\u000a		this.on( 'hide', function() {\u000a			dialogElement.removeListener( 'keydown', keydownHandler );\u000a			if ( CKEDITOR.env.gecko )\u000a				dialogElement.removeListener( 'keypress', keypressHandler );\u000a\u000a			// Reset fields state when closing dialog.\u000a			iterContents( function( item ) {\u000a				resetField.apply( item );\u000a			} );\u000a		} );\u000a		this.on( 'iframeAdded', function( evt ) {\u000a			var doc = new CKEDITOR.dom.document( evt.data.iframe.$.contentWindow.document );\u000a			doc.on( 'keydown', keydownHandler, this, null, 0 );\u000a		} );\u000a\u000a		// Auto-focus logic in dialog.\u000a		this.on( 'show', function() {\u000a			// Setup tabIndex on showing the dialog instead of on loading\u000a			// to allow dynamic tab order happen in dialog definition.\u000a			setupFocus();\u000a\u000a			if ( editor.config.dialog_startupFocusTab && me._.pageCount > 1 ) {\u000a				me._.tabBarMode = true;\u000a				me._.tabs[ me._.currentTabId ][ 0 ].focus();\u000a			} else if ( !this._.hasFocus ) {\u000a				this._.currentFocusIndex = -1;\u000a\u000a				// Decide where to put the initial focus.\u000a				if ( definition.onFocus ) {\u000a					var initialFocus = definition.onFocus.call( this );\u000a					// Focus the field that the user specified.\u000a					initialFocus && initialFocus.focus();\u000a				}\u000a				// Focus the first field in layout order.\u000a				else\u000a					changeFocus( 1 );\u000a			}\u000a		}, this, null, 0xffffffff );\u000a\u000a		// IE6 BUG: Text fields and text areas are only half-rendered the first time the dialog appears in IE6 (#2661).\u000a		// This is still needed after [2708] and [2709] because text fields in hidden TR tags are still broken.\u000a		if ( CKEDITOR.env.ie6Compat ) {\u000a			this.on( 'load', function( evt ) {\u000a				var outer = this.getElement(),\u000a					inner = outer.getFirst();\u000a				inner.remove();\u000a				inner.appendTo( outer );\u000a			}, this );\u000a		}\u000a\u000a		initDragAndDrop( this );\u000a		initResizeHandles( this );\u000a\u000a		// Insert the title.\u000a		( new CKEDITOR.dom.text( definition.title, CKEDITOR.document ) ).appendTo( this.parts.title );\u000a\u000a		// Insert the tabs and contents.\u000a		for ( i = 0; i < definition.contents.length; i++ ) {\u000a			var page = definition.contents[ i ];\u000a			page && this.addPage( page );\u000a		}\u000a\u000a		this.parts[ 'tabs' ].on( 'click', function( evt ) {\u000a			var target = evt.data.getTarget();\u000a			// If we aren't inside a tab, bail out.\u000a			if ( target.hasClass( 'cke_dialog_tab' ) ) {\u000a				// Get the ID of the tab, without the 'cke_' prefix and the unique number suffix.\u000a				var id = target.$.id;\u000a				this.selectPage( id.substring( 4, id.lastIndexOf( '_' ) ) );\u000a\u000a				if ( this._.tabBarMode ) {\u000a					this._.tabBarMode = false;\u000a					this._.currentFocusIndex = -1;\u000a					changeFocus( 1 );\u000a				}\u000a				evt.data.preventDefault();\u000a			}\u000a		}, this );\u000a\u000a		// Insert buttons.\u000a		var buttonsHtml = [],\u000a			buttons = CKEDITOR.dialog._.uiElementBuilders.hbox.build( this, {\u000a				type: 'hbox',\u000a				className: 'cke_dialog_footer_buttons',\u000a				widths: [],\u000a				children: definition.buttons\u000a			}, buttonsHtml ).getChild();\u000a		this.parts.footer.setHtml( buttonsHtml.join( '' ) );\u000a\u000a		for ( i = 0; i < buttons.length; i++ )\u000a			this._.buttons[ buttons[ i ].id ] = buttons[ i ];\u000a	};\u000a\u000a	// Focusable interface. Use it via dialog.addFocusable.\u000a	function Focusable( dialog, element, index ) {\u000a		this.element = element;\u000a		this.focusIndex = index;\u000a		// TODO: support tabIndex for focusables.\u000a		this.tabIndex = 0;\u000a		this.isFocusable = function() {\u000a			return !element.getAttribute( 'disabled' ) && element.isVisible();\u000a		};\u000a		this.focus = function() {\u000a			dialog._.currentFocusIndex = this.focusIndex;\u000a			this.element.focus();\u000a		};\u000a		// Bind events\u000a		element.on( 'keydown', function( e ) {\u000a			if ( e.data.getKeystroke() in { 32: 1, 13: 1 } )\u000a				this.fire( 'click' );\u000a		} );\u000a		element.on( 'focus', function() {\u000a			this.fire( 'mouseover' );\u000a		} );\u000a		element.on( 'blur', function() {\u000a			this.fire( 'mouseout' );\u000a		} );\u000a	}\u000a\u000a	// Re-layout the dialog on window resize.\u000a	function resizeWithWindow( dialog ) {\u000a		var win = CKEDITOR.document.getWindow();\u000a		function resizeHandler() { dialog.layout(); }\u000a		win.on( 'resize', resizeHandler );\u000a		dialog.on( 'hide', function() { win.removeListener( 'resize', resizeHandler ); } );\u000a	}\u000a\u000a	CKEDITOR.dialog.prototype = {\u000a		destroy: function() {\u000a			this.hide();\u000a			this._.element.remove();\u000a		},\u000a\u000a		/**\u000a		 * Resizes the dialog.\u000a		 *\u000a		 *		dialogObj.resize( 800, 640 );\u000a		 *\u000a		 * @method\u000a		 * @param {Number} width The width of the dialog in pixels.\u000a		 * @param {Number} height The height of the dialog in pixels.\u000a		 */\u000a		resize: ( function() {\u000a			return function( width, height ) {\u000a				if ( this._.contentSize && this._.contentSize.width == width && this._.contentSize.height == height )\u000a					return;\u000a\u000a				CKEDITOR.dialog.fire( 'resize', {\u000a					dialog: this,\u000a					width: width,\u000a					height: height\u000a				}, this._.editor );\u000a\u000a				this.fire( 'resize', {\u000a					width: width,\u000a					height: height\u000a				}, this._.editor );\u000a\u000a				var contents = this.parts.contents;\u000a				contents.setStyles( {\u000a					width: width + 'px',\u000a					height: height + 'px'\u000a				} );\u000a\u000a				// Update dialog position when dimension get changed in RTL.\u000a				if ( this._.editor.lang.dir == 'rtl' && this._.position )\u000a					this._.position.x = CKEDITOR.document.getWindow().getViewPaneSize().width - this._.contentSize.width - parseInt( this._.element.getFirst().getStyle( 'right' ), 10 );\u000a\u000a				this._.contentSize = { width: width, height: height };\u000a			};\u000a		} )(),\u000a\u000a		/**\u000a		 * Gets the current size of the dialog in pixels.\u000a		 *\u000a		 * var width = dialogObj.getSize().width;\u000a		 *\u000a		 * @returns {Object}\u000a		 * @returns {Number} return.width\u000a		 * @returns {Number} return.height\u000a		 */\u000a		getSize: function() {\u000a			var element = this._.element.getFirst();\u000a			return { width: element.$.offsetWidth || 0, height: element.$.offsetHeight || 0 };\u000a		},\u000a\u000a		/**\u000a		 * Moves the dialog to an `(x, y)` coordinate relative to the window.\u000a		 *\u000a		 * dialogObj.move( 10, 40 );\u000a		 *\u000a		 * @method\u000a		 * @param {Number} x The target x-coordinate.\u000a		 * @param {Number} y The target y-coordinate.\u000a		 * @param {Boolean} save Flag indicate whether the dialog position should be remembered on next open up.\u000a		 */\u000a		move: function( x, y, save ) {\u000a\u000a			// The dialog may be fixed positioned or absolute positioned. Ask the\u000a			// browser what is the current situation first.\u000a			var element = this._.element.getFirst(), rtl = this._.editor.lang.dir == 'rtl';\u000a			var isFixed = element.getComputedStyle( 'position' ) == 'fixed';\u000a\u000a			// (#8888) In some cases of a very small viewport, dialog is incorrectly\u000a			// positioned in IE7. It also happens that it remains sticky and user cannot\u000a			// scroll down/up to reveal dialog's content below/above the viewport; this is\u000a			// cumbersome.\u000a			// The only way to fix this is to move mouse out of the browser and\u000a			// go back to see that dialog position is automagically fixed. No events,\u000a			// no style change - pure magic. This is a IE7 rendering issue, which can be\u000a			// fixed with dummy style redraw on each move.\u000a			if ( CKEDITOR.env.ie )\u000a				element.setStyle( 'zoom', '100%' );\u000a\u000a			if ( isFixed && this._.position && this._.position.x == x && this._.position.y == y )\u000a				return;\u000a\u000a			// Save the current position.\u000a			this._.position = { x: x, y: y };\u000a\u000a			// If not fixed positioned, add scroll position to the coordinates.\u000a			if ( !isFixed ) {\u000a				var scrollPosition = CKEDITOR.document.getWindow().getScrollPosition();\u000a				x += scrollPosition.x;\u000a				y += scrollPosition.y;\u000a			}\u000a\u000a			// Translate coordinate for RTL.\u000a			if ( rtl ) {\u000a				var dialogSize = this.getSize(), viewPaneSize = CKEDITOR.document.getWindow().getViewPaneSize();\u000a				x = viewPaneSize.width - dialogSize.width - x;\u000a			}\u000a\u000a			var styles = { 'top': ( y > 0 ? y : 0 ) + 'px' };\u000a			styles[ rtl ? 'right' : 'left' ] = ( x > 0 ? x : 0 ) + 'px';\u000a\u000a			element.setStyles( styles );\u000a\u000a			save && ( this._.moved = 1 );\u000a		},\u000a\u000a		/**\u000a		 * Gets the dialog's position in the window.\u000a		 *\u000a		 *		var dialogX = dialogObj.getPosition().x;\u000a		 *\u000a		 * @returns {Object}\u000a		 * @returns {Number} return.x\u000a		 * @returns {Number} return.y\u000a		 */\u000a		getPosition: function() {\u000a			return CKEDITOR.tools.extend( {}, this._.position );\u000a		},\u000a\u000a		/**\u000a		 * Shows the dialog box.\u000a		 *\u000a		 *		dialogObj.show();\u000a		 */\u000a		show: function() {\u000a			// Insert the dialog's element to the root document.\u000a			var element = this._.element;\u000a			var definition = this.definition;\u000a			if ( !( element.getParent() && element.getParent().equals( CKEDITOR.document.getBody() ) ) )\u000a				element.appendTo( CKEDITOR.document.getBody() );\u000a			else\u000a				element.setStyle( 'display', 'block' );\u000a\u000a			// First, set the dialog to an appropriate size.\u000a			this.resize( this._.contentSize && this._.contentSize.width || definition.width || definition.minWidth, this._.contentSize && this._.contentSize.height || definition.height || definition.minHeight );\u000a\u000a			// Reset all inputs back to their default value.\u000a			this.reset();\u000a\u000a			// Select the first tab by default.\u000a			this.selectPage( this.definition.contents[ 0 ].id );\u000a\u000a			// Set z-index.\u000a			if ( CKEDITOR.dialog._.currentZIndex === null )\u000a				CKEDITOR.dialog._.currentZIndex = this._.editor.config.baseFloatZIndex;\u000a			this._.element.getFirst().setStyle( 'z-index', CKEDITOR.dialog._.currentZIndex += 10 );\u000a\u000a			// Maintain the dialog ordering and dialog cover.\u000a			if ( CKEDITOR.dialog._.currentTop === null ) {\u000a				CKEDITOR.dialog._.currentTop = this;\u000a				this._.parentDialog = null;\u000a				showCover( this._.editor );\u000a\u000a			} else {\u000a				this._.parentDialog = CKEDITOR.dialog._.currentTop;\u000a				var parentElement = this._.parentDialog.getElement().getFirst();\u000a				parentElement.$.style.zIndex -= Math.floor( this._.editor.config.baseFloatZIndex / 2 );\u000a				CKEDITOR.dialog._.currentTop = this;\u000a			}\u000a\u000a			element.on( 'keydown', accessKeyDownHandler );\u000a			element.on( 'keyup', accessKeyUpHandler );\u000a\u000a			// Reset the hasFocus state.\u000a			this._.hasFocus = false;\u000a\u000a			for ( var i in definition.contents ) {\u000a				if ( !definition.contents[ i ] )\u000a					continue;\u000a\u000a				var content = definition.contents[ i ],\u000a					tab = this._.tabs[ content.id ],\u000a					requiredContent = content.requiredContent,\u000a					enableElements = 0;\u000a\u000a				if ( !tab )\u000a					continue;\u000a\u000a				for ( var j in this._.contents[ content.id ] ) {\u000a					var elem = this._.contents[ content.id ][ j ];\u000a\u000a					if ( elem.type == 'hbox' || elem.type == 'vbox' || !elem.getInputElement() )\u000a						continue;\u000a\u000a					if ( elem.requiredContent && !this._.editor.activeFilter.check( elem.requiredContent ) )\u000a						elem.disable();\u000a					else {\u000a						elem.enable();\u000a						enableElements++;\u000a					}\u000a				}\u000a\u000a				if ( !enableElements || ( requiredContent && !this._.editor.activeFilter.check( requiredContent ) ) )\u000a					tab[ 0 ].addClass( 'cke_dialog_tab_disabled' );\u000a				else\u000a					tab[ 0 ].removeClass( 'cke_dialog_tab_disabled' );\u000a			}\u000a\u000a			CKEDITOR.tools.setTimeout( function() {\u000a				this.layout();\u000a				resizeWithWindow( this );\u000a\u000a				this.parts.dialog.setStyle( 'visibility', '' );\u000a\u000a				// Execute onLoad for the first show.\u000a				this.fireOnce( 'load', {} );\u000a				CKEDITOR.ui.fire( 'ready', this );\u000a\u000a				this.fire( 'show', {} );\u000a				this._.editor.fire( 'dialogShow', this );\u000a\u000a				if ( !this._.parentDialog )\u000a					this._.editor.focusManager.lock();\u000a\u000a				// Save the initial values of the dialog.\u000a				this.foreach( function( contentObj ) {\u000a					contentObj.setInitValue && contentObj.setInitValue();\u000a				} );\u000a\u000a			}, 100, this );\u000a		},\u000a\u000a		/**\u000a		 * Rearrange the dialog to its previous position or the middle of the window.\u000a		 *\u000a		 * @since 3.5\u000a		 */\u000a		layout: function() {\u000a			var el = this.parts.dialog;\u000a			var dialogSize = this.getSize();\u000a			var win = CKEDITOR.document.getWindow(),\u000a					viewSize = win.getViewPaneSize();\u000a\u000a			var posX = ( viewSize.width - dialogSize.width ) / 2,\u000a				posY = ( viewSize.height - dialogSize.height ) / 2;\u000a\u000a			// Switch to absolute position when viewport is smaller than dialog size.\u000a			if ( !CKEDITOR.env.ie6Compat ) {\u000a				if ( dialogSize.height + ( posY > 0 ? posY : 0 ) > viewSize.height ||\u000a						 dialogSize.width + ( posX > 0 ? posX : 0 ) > viewSize.width )\u000a					el.setStyle( 'position', 'absolute' );\u000a				else\u000a					el.setStyle( 'position', 'fixed' );\u000a			}\u000a\u000a			this.move( this._.moved ? this._.position.x : posX,\u000a					this._.moved ? this._.position.y : posY );\u000a		},\u000a\u000a		/**\u000a		 * Executes a function for each UI element.\u000a		 *\u000a		 * @param {Function} fn Function to execute for each UI element.\u000a		 * @returns {CKEDITOR.dialog} The current dialog object.\u000a		 */\u000a		foreach: function( fn ) {\u000a			for ( var i in this._.contents ) {\u000a				for ( var j in this._.contents[ i ] )\u000a					fn.call( this, this._.contents[ i ][ j ] );\u000a			}\u000a			return this;\u000a		},\u000a\u000a		/**\u000a		 * Resets all input values in the dialog.\u000a		 *\u000a		 *		dialogObj.reset();\u000a		 *\u000a		 * @method\u000a		 * @chainable\u000a		 */\u000a		reset: ( function() {\u000a			var fn = function( widget ) {\u000a					if ( widget.reset )\u000a						widget.reset( 1 );\u000a				};\u000a			return function() {\u000a				this.foreach( fn );\u000a				return this;\u000a			};\u000a		} )(),\u000a\u000a\u000a		/**\u000a		 * Calls the {@link CKEDITOR.dialog.definition.uiElement#setup} method of each\u000a		 * of the UI elements, with the arguments passed through it.\u000a		 * It is usually being called when the dialog is opened, to put the initial value inside the field.\u000a		 *\u000a		 *		dialogObj.setupContent();\u000a		 *\u000a		 *		var timestamp = ( new Date() ).valueOf();\u000a		 *		dialogObj.setupContent( timestamp );\u000a		 */\u000a		setupContent: function() {\u000a			var args = arguments;\u000a			this.foreach( function( widget ) {\u000a				if ( widget.setup )\u000a					widget.setup.apply( widget, args );\u000a			} );\u000a		},\u000a\u000a		/**\u000a		 * Calls the {@link CKEDITOR.dialog.definition.uiElement#commit} method of each\u000a		 * of the UI elements, with the arguments passed through it.\u000a		 * It is usually being called when the user confirms the dialog, to process the values.\u000a		 *\u000a		 *		dialogObj.commitContent();\u000a		 *\u000a		 *		var timestamp = ( new Date() ).valueOf();\u000a		 *		dialogObj.commitContent( timestamp );\u000a		 */\u000a		commitContent: function() {\u000a			var args = arguments;\u000a			this.foreach( function( widget ) {\u000a				// Make sure IE triggers "change" event on last focused input before closing the dialog. (#7915)\u000a				if ( CKEDITOR.env.ie && this._.currentFocusIndex == widget.focusIndex )\u000a					widget.getInputElement().$.blur();\u000a\u000a				if ( widget.commit )\u000a					widget.commit.apply( widget, args );\u000a			} );\u000a		},\u000a\u000a		/**\u000a		 * Hides the dialog box.\u000a		 *\u000a		 *		dialogObj.hide();\u000a		 */\u000a		hide: function() {\u000a			if ( !this.parts.dialog.isVisible() )\u000a				return;\u000a\u000a			this.fire( 'hide', {} );\u000a			this._.editor.fire( 'dialogHide', this );\u000a			// Reset the tab page.\u000a			this.selectPage( this._.tabIdList[ 0 ] );\u000a			var element = this._.element;\u000a			element.setStyle( 'display', 'none' );\u000a			this.parts.dialog.setStyle( 'visibility', 'hidden' );\u000a			// Unregister all access keys associated with this dialog.\u000a			unregisterAccessKey( this );\u000a\u000a			// Close any child(top) dialogs first.\u000a			while ( CKEDITOR.dialog._.currentTop != this )\u000a				CKEDITOR.dialog._.currentTop.hide();\u000a\u000a			// Maintain dialog ordering and remove cover if needed.\u000a			if ( !this._.parentDialog )\u000a				hideCover( this._.editor );\u000a			else {\u000a				var parentElement = this._.parentDialog.getElement().getFirst();\u000a				parentElement.setStyle( 'z-index', parseInt( parentElement.$.style.zIndex, 10 ) + Math.floor( this._.editor.config.baseFloatZIndex / 2 ) );\u000a			}\u000a			CKEDITOR.dialog._.currentTop = this._.parentDialog;\u000a\u000a			// Deduct or clear the z-index.\u000a			if ( !this._.parentDialog ) {\u000a				CKEDITOR.dialog._.currentZIndex = null;\u000a\u000a				// Remove access key handlers.\u000a				element.removeListener( 'keydown', accessKeyDownHandler );\u000a				element.removeListener( 'keyup', accessKeyUpHandler );\u000a\u000a				var editor = this._.editor;\u000a				editor.focus();\u000a\u000a				// Give a while before unlock, waiting for focus to return to the editable. (#172)\u000a				setTimeout( function() {\u000a					editor.focusManager.unlock();\u000a\u000a					// Fixed iOS focus issue (#12381).\u000a					// Keep in mind that editor.focus() does not work in this case.\u000a					if ( CKEDITOR.env.iOS ) {\u000a						editor.window.focus();\u000a					}\u000a				}, 0 );\u000a\u000a			} else\u000a				CKEDITOR.dialog._.currentZIndex -= 10;\u000a\u000a			delete this._.parentDialog;\u000a			// Reset the initial values of the dialog.\u000a			this.foreach( function( contentObj ) {\u000a				contentObj.resetInitValue && contentObj.resetInitValue();\u000a			} );\u000a		},\u000a\u000a		/**\u000a		 * Adds a tabbed page into the dialog.\u000a		 *\u000a		 * @param {Object} contents Content definition.\u000a		 */\u000a		addPage: function( contents ) {\u000a			if ( contents.requiredContent && !this._.editor.filter.check( contents.requiredContent ) )\u000a				return;\u000a\u000a			var pageHtml = [],\u000a				titleHtml = contents.label ? ' title="' + CKEDITOR.tools.htmlEncode( contents.label ) + '"' : '',\u000a				elements = contents.elements,\u000a				vbox = CKEDITOR.dialog._.uiElementBuilders.vbox.build( this, {\u000a					type: 'vbox',\u000a					className: 'cke_dialog_page_contents',\u000a					children: contents.elements,\u000a					expand: !!contents.expand,\u000a					padding: contents.padding,\u000a					style: contents.style || 'width: 100%;'\u000a				}, pageHtml );\u000a\u000a			var contentMap = this._.contents[ contents.id ] = {},\u000a				cursor,\u000a				children = vbox.getChild(),\u000a				enabledFields = 0;\u000a\u000a			while ( ( cursor = children.shift() ) ) {\u000a				// Count all allowed fields.\u000a				if ( !cursor.notAllowed && cursor.type != 'hbox' && cursor.type != 'vbox' )\u000a					enabledFields++;\u000a\u000a				contentMap[ cursor.id ] = cursor;\u000a				if ( typeof( cursor.getChild ) == 'function' )\u000a					children.push.apply( children, cursor.getChild() );\u000a			}\u000a\u000a			// If all fields are disabled (because they are not allowed) hide this tab.\u000a			if ( !enabledFields )\u000a				contents.hidden = true;\u000a\u000a			// Create the HTML for the tab and the content block.\u000a			var page = CKEDITOR.dom.element.createFromHtml( pageHtml.join( '' ) );\u000a			page.setAttribute( 'role', 'tabpanel' );\u000a\u000a			var env = CKEDITOR.env;\u000a			var tabId = 'cke_' + contents.id + '_' + CKEDITOR.tools.getNextNumber(),\u000a				tab = CKEDITOR.dom.element.createFromHtml( [\u000a					'<a class="cke_dialog_tab"',\u000a						( this._.pageCount > 0 ? ' cke_last' : 'cke_first' ),\u000a						titleHtml,\u000a						( !!contents.hidden ? ' style="display:none"' : '' ),\u000a						' id="', tabId, '"',\u000a						env.gecko && !env.hc ? '' : ' href="javascript:void(0)"',\u000a						' tabIndex="-1"',\u000a						' hidefocus="true"',\u000a						' role="tab">',\u000a							contents.label,\u000a					'</a>'\u000a					].join( '' ) );\u000a\u000a			page.setAttribute( 'aria-labelledby', tabId );\u000a\u000a			// Take records for the tabs and elements created.\u000a			this._.tabs[ contents.id ] = [ tab, page ];\u000a			this._.tabIdList.push( contents.id );\u000a			!contents.hidden && this._.pageCount++;\u000a			this._.lastTab = tab;\u000a			this.updateStyle();\u000a\u000a			// Attach the DOM nodes.\u000a\u000a			page.setAttribute( 'name', contents.id );\u000a			page.appendTo( this.parts.contents );\u000a\u000a			tab.unselectable();\u000a			this.parts.tabs.append( tab );\u000a\u000a			// Add access key handlers if access key is defined.\u000a			if ( contents.accessKey ) {\u000a				registerAccessKey( this, this, 'CTRL+' + contents.accessKey, tabAccessKeyDown, tabAccessKeyUp );\u000a				this._.accessKeyMap[ 'CTRL+' + contents.accessKey ] = contents.id;\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Activates a tab page in the dialog by its id.\u000a		 *\u000a		 *		dialogObj.selectPage( 'tab_1' );\u000a		 *\u000a		 * @param {String} id The id of the dialog tab to be activated.\u000a		 */\u000a		selectPage: function( id ) {\u000a			if ( this._.currentTabId == id )\u000a				return;\u000a\u000a			if ( this._.tabs[ id ][ 0 ].hasClass( 'cke_dialog_tab_disabled' ) )\u000a				return;\u000a\u000a			// If event was canceled - do nothing.\u000a			if ( this.fire( 'selectPage', { page: id, currentPage: this._.currentTabId } ) === false )\u000a				return;\u000a\u000a			// Hide the non-selected tabs and pages.\u000a			for ( var i in this._.tabs ) {\u000a				var tab = this._.tabs[ i ][ 0 ],\u000a					page = this._.tabs[ i ][ 1 ];\u000a				if ( i != id ) {\u000a					tab.removeClass( 'cke_dialog_tab_selected' );\u000a					page.hide();\u000a				}\u000a				page.setAttribute( 'aria-hidden', i != id );\u000a			}\u000a\u000a			var selected = this._.tabs[ id ];\u000a			selected[ 0 ].addClass( 'cke_dialog_tab_selected' );\u000a\u000a			// [IE] an invisible input[type='text'] will enlarge it's width\u000a			// if it's value is long when it shows, so we clear it's value\u000a			// before it shows and then recover it (#5649)\u000a			if ( CKEDITOR.env.ie6Compat || CKEDITOR.env.ie7Compat ) {\u000a				clearOrRecoverTextInputValue( selected[ 1 ] );\u000a				selected[ 1 ].show();\u000a				setTimeout( function() {\u000a					clearOrRecoverTextInputValue( selected[ 1 ], 1 );\u000a				}, 0 );\u000a			} else\u000a				selected[ 1 ].show();\u000a\u000a			this._.currentTabId = id;\u000a			this._.currentTabIndex = CKEDITOR.tools.indexOf( this._.tabIdList, id );\u000a		},\u000a\u000a		/**\u000a		 * Dialog state-specific style updates.\u000a		 */\u000a		updateStyle: function() {\u000a			// If only a single page shown, a different style is used in the central pane.\u000a			this.parts.dialog[ ( this._.pageCount === 1 ? 'add' : 'remove' ) + 'Class' ]( 'cke_single_page' );\u000a		},\u000a\u000a		/**\u000a		 * Hides a page's tab away from the dialog.\u000a		 *\u000a		 *		dialog.hidePage( 'tab_3' );\u000a		 *\u000a		 * @param {String} id The page's Id.\u000a		 */\u000a		hidePage: function( id ) {\u000a			var tab = this._.tabs[ id ] && this._.tabs[ id ][ 0 ];\u000a			if ( !tab || this._.pageCount == 1 || !tab.isVisible() )\u000a				return;\u000a			// Switch to other tab first when we're hiding the active tab.\u000a			else if ( id == this._.currentTabId )\u000a				this.selectPage( getPreviousVisibleTab.call( this ) );\u000a\u000a			tab.hide();\u000a			this._.pageCount--;\u000a			this.updateStyle();\u000a		},\u000a\u000a		/**\u000a		 * Unhides a page's tab.\u000a		 *\u000a		 *		dialog.showPage( 'tab_2' );\u000a		 *\u000a		 * @param {String} id The page's Id.\u000a		 */\u000a		showPage: function( id ) {\u000a			var tab = this._.tabs[ id ] && this._.tabs[ id ][ 0 ];\u000a			if ( !tab )\u000a				return;\u000a			tab.show();\u000a			this._.pageCount++;\u000a			this.updateStyle();\u000a		},\u000a\u000a		/**\u000a		 * Gets the root DOM element of the dialog.\u000a		 *\u000a		 *		var dialogElement = dialogObj.getElement().getFirst();\u000a		 *		dialogElement.setStyle( 'padding', '5px' );\u000a		 *\u000a		 * @returns {CKEDITOR.dom.element} The `<span>` element containing this dialog.\u000a		 */\u000a		getElement: function() {\u000a			return this._.element;\u000a		},\u000a\u000a		/**\u000a		 * Gets the name of the dialog.\u000a		 *\u000a		 *		var dialogName = dialogObj.getName();\u000a		 *\u000a		 * @returns {String} The name of this dialog.\u000a		 */\u000a		getName: function() {\u000a			return this._.name;\u000a		},\u000a\u000a		/**\u000a		 * Gets a dialog UI element object from a dialog page.\u000a		 *\u000a		 *		dialogObj.getContentElement( 'tabId', 'elementId' ).setValue( 'Example' );\u000a		 *\u000a		 * @param {String} pageId id of dialog page.\u000a		 * @param {String} elementId id of UI element.\u000a		 * @returns {CKEDITOR.ui.dialog.uiElement} The dialog UI element.\u000a		 */\u000a		getContentElement: function( pageId, elementId ) {\u000a			var page = this._.contents[ pageId ];\u000a			return page && page[ elementId ];\u000a		},\u000a\u000a		/**\u000a		 * Gets the value of a dialog UI element.\u000a		 *\u000a		 *		alert( dialogObj.getValueOf( 'tabId', 'elementId' ) );\u000a		 *\u000a		 * @param {String} pageId id of dialog page.\u000a		 * @param {String} elementId id of UI element.\u000a		 * @returns {Object} The value of the UI element.\u000a		 */\u000a		getValueOf: function( pageId, elementId ) {\u000a			return this.getContentElement( pageId, elementId ).getValue();\u000a		},\u000a\u000a		/**\u000a		 * Sets the value of a dialog UI element.\u000a		 *\u000a		 *		dialogObj.setValueOf( 'tabId', 'elementId', 'Example' );\u000a		 *\u000a		 * @param {String} pageId id of the dialog page.\u000a		 * @param {String} elementId id of the UI element.\u000a		 * @param {Object} value The new value of the UI element.\u000a		 */\u000a		setValueOf: function( pageId, elementId, value ) {\u000a			return this.getContentElement( pageId, elementId ).setValue( value );\u000a		},\u000a\u000a		/**\u000a		 * Gets the UI element of a button in the dialog's button row.\u000a		 *\u000a		 *		@returns {CKEDITOR.ui.dialog.button} The button object.\u000a		 *\u000a		 * @param {String} id The id of the button.\u000a		 */\u000a		getButton: function( id ) {\u000a			return this._.buttons[ id ];\u000a		},\u000a\u000a		/**\u000a		 * Simulates a click to a dialog button in the dialog's button row.\u000a		 *\u000a		 * @returns The return value of the dialog's `click` event.\u000a		 *\u000a		 * @param {String} id The id of the button.\u000a		 */\u000a		click: function( id ) {\u000a			return this._.buttons[ id ].click();\u000a		},\u000a\u000a		/**\u000a		 * Disables a dialog button.\u000a		 *\u000a		 * @param {String} id The id of the button.\u000a		 */\u000a		disableButton: function( id ) {\u000a			return this._.buttons[ id ].disable();\u000a		},\u000a\u000a		/**\u000a		 * Enables a dialog button.\u000a		 *\u000a		 * @param {String} id The id of the button.\u000a		 */\u000a		enableButton: function( id ) {\u000a			return this._.buttons[ id ].enable();\u000a		},\u000a\u000a		/**\u000a		 * Gets the number of pages in the dialog.\u000a		 *\u000a		 * @returns {Number} Page count.\u000a		 */\u000a		getPageCount: function() {\u000a			return this._.pageCount;\u000a		},\u000a\u000a		/**\u000a		 * Gets the editor instance which opened this dialog.\u000a		 *\u000a		 * @returns {CKEDITOR.editor} Parent editor instances.\u000a		 */\u000a		getParentEditor: function() {\u000a			return this._.editor;\u000a		},\u000a\u000a		/**\u000a		 * Gets the element that was selected when opening the dialog, if any.\u000a		 *\u000a		 * @returns {CKEDITOR.dom.element} The element that was selected, or `null`.\u000a		 */\u000a		getSelectedElement: function() {\u000a			return this.getParentEditor().getSelection().getSelectedElement();\u000a		},\u000a\u000a		/**\u000a		 * Adds element to dialog's focusable list.\u000a		 *\u000a		 * @param {CKEDITOR.dom.element} element\u000a		 * @param {Number} [index]\u000a		 */\u000a		addFocusable: function( element, index ) {\u000a			if ( typeof index == 'undefined' ) {\u000a				index = this._.focusList.length;\u000a				this._.focusList.push( new Focusable( this, element, index ) );\u000a			} else {\u000a				this._.focusList.splice( index, 0, new Focusable( this, element, index ) );\u000a				for ( var i = index + 1; i < this._.focusList.length; i++ )\u000a					this._.focusList[ i ].focusIndex++;\u000a			}\u000a		}\u000a	};\u000a\u000a	CKEDITOR.tools.extend( CKEDITOR.dialog, {\u000a		/**\u000a		 * Registers a dialog.\u000a		 *\u000a		 *		// Full sample plugin, which does not only register a dialog window but also adds an item to the context menu.\u000a		 *		// To open the dialog window, choose "Open dialog" in the context menu.\u000a		 *		CKEDITOR.plugins.add( 'myplugin', {\u000a		 *			init: function( editor ) {\u000a		 *				editor.addCommand( 'mydialog',new CKEDITOR.dialogCommand( 'mydialog' ) );\u000a		 *\u000a		 *				if ( editor.contextMenu ) {\u000a		 *					editor.addMenuGroup( 'mygroup', 10 );\u000a		 *					editor.addMenuItem( 'My Dialog', {\u000a		 *						label: 'Open dialog',\u000a		 *						command: 'mydialog',\u000a		 *						group: 'mygroup'\u000a		 *					} );\u000a		 *					editor.contextMenu.addListener( function( element ) {\u000a		 *						return { 'My Dialog': CKEDITOR.TRISTATE_OFF };\u000a		 *					} );\u000a		 *				}\u000a		 *\u000a		 *				CKEDITOR.dialog.add( 'mydialog', function( api ) {\u000a		 *					// CKEDITOR.dialog.definition\u000a		 *					var dialogDefinition = {\u000a		 *						title: 'Sample dialog',\u000a		 *						minWidth: 390,\u000a		 *						minHeight: 130,\u000a		 *						contents: [\u000a		 *							{\u000a		 *								id: 'tab1',\u000a		 *								label: 'Label',\u000a		 *								title: 'Title',\u000a		 *								expand: true,\u000a		 *								padding: 0,\u000a		 *								elements: [\u000a		 *									{\u000a		 *										type: 'html',\u000a		 *										html: '<p>This is some sample HTML content.</p>'\u000a		 *									},\u000a		 *									{\u000a		 *										type: 'textarea',\u000a		 *										id: 'textareaId',\u000a		 *										rows: 4,\u000a		 *										cols: 40\u000a		 *									}\u000a		 *								]\u000a		 *							}\u000a		 *						],\u000a		 *						buttons: [ CKEDITOR.dialog.okButton, CKEDITOR.dialog.cancelButton ],\u000a		 *						onOk: function() {\u000a		 *							// "this" is now a CKEDITOR.dialog object.\u000a		 *							// Accessing dialog elements:\u000a		 *							var textareaObj = this.getContentElement( 'tab1', 'textareaId' );\u000a		 *							alert( "You have entered: " + textareaObj.getValue() );\u000a		 *						}\u000a		 *					};\u000a		 *\u000a		 *					return dialogDefinition;\u000a		 *				} );\u000a		 *			}\u000a		 *		} );\u000a		 *\u000a		 *		CKEDITOR.replace( 'editor1', { extraPlugins: 'myplugin' } );\u000a		 *\u000a		 * @static\u000a		 * @param {String} name The dialog's name.\u000a		 * @param {Function/String} dialogDefinition\u000a		 * A function returning the dialog's definition, or the URL to the `.js` file holding the function.\u000a		 * The function should accept an argument `editor` which is the current editor instance, and\u000a		 * return an object conforming to {@link CKEDITOR.dialog.definition}.\u000a		 * @see CKEDITOR.dialog.definition\u000a		 */\u000a		add: function( name, dialogDefinition ) {\u000a			// Avoid path registration from multiple instances override definition.\u000a			if ( !this._.dialogDefinitions[ name ] || typeof dialogDefinition == 'function' )\u000a				this._.dialogDefinitions[ name ] = dialogDefinition;\u000a		},\u000a\u000a		/**\u000a		 * @static\u000a		 * @todo\u000a		 */\u000a		exists: function( name ) {\u000a			return !!this._.dialogDefinitions[ name ];\u000a		},\u000a\u000a		/**\u000a		 * @static\u000a		 * @todo\u000a		 */\u000a		getCurrent: function() {\u000a			return CKEDITOR.dialog._.currentTop;\u000a		},\u000a\u000a		/**\u000a		 * Check whether tab wasn't removed by {@link CKEDITOR.config#removeDialogTabs}.\u000a		 *\u000a		 * @since 4.1\u000a		 * @static\u000a		 * @param {CKEDITOR.editor} editor\u000a		 * @param {String} dialogName\u000a		 * @param {String} tabName\u000a		 * @returns {Boolean}\u000a		 */\u000a		isTabEnabled: function( editor, dialogName, tabName ) {\u000a			var cfg = editor.config.removeDialogTabs;\u000a\u000a			return !( cfg && cfg.match( new RegExp( '(?:^|;)' + dialogName + ':' + tabName + '(?:$|;)', 'i' ) ) );\u000a		},\u000a\u000a		/**\u000a		 * The default OK button for dialogs. Fires the `ok` event and closes the dialog if the event succeeds.\u000a		 *\u000a		 * @static\u000a		 * @method\u000a		 */\u000a		okButton: ( function() {\u000a			var retval = function( editor, override ) {\u000a					override = override || {};\u000a					return CKEDITOR.tools.extend( {\u000a						id: 'ok',\u000a						type: 'button',\u000a						label: editor.lang.common.ok,\u000a						'class': 'cke_dialog_ui_button_ok',\u000a						onClick: function( evt ) {\u000a							var dialog = evt.data.dialog;\u000a							if ( dialog.fire( 'ok', { hide: true } ).hide !== false )\u000a								dialog.hide();\u000a						}\u000a					}, override, true );\u000a				};\u000a			retval.type = 'button';\u000a			retval.override = function( override ) {\u000a				return CKEDITOR.tools.extend( function( editor ) {\u000a					return retval( editor, override );\u000a				}, { type: 'button' }, true );\u000a			};\u000a			return retval;\u000a		} )(),\u000a\u000a		/**\u000a		 * The default cancel button for dialogs. Fires the `cancel` event and\u000a		 * closes the dialog if no UI element value changed.\u000a		 *\u000a		 * @static\u000a		 * @method\u000a		 */\u000a		cancelButton: ( function() {\u000a			var retval = function( editor, override ) {\u000a					override = override || {};\u000a					return CKEDITOR.tools.extend( {\u000a						id: 'cancel',\u000a						type: 'button',\u000a						label: editor.lang.common.cancel,\u000a						'class': 'cke_dialog_ui_button_cancel',\u000a						onClick: function( evt ) {\u000a							var dialog = evt.data.dialog;\u000a							if ( dialog.fire( 'cancel', { hide: true } ).hide !== false )\u000a								dialog.hide();\u000a						}\u000a					}, override, true );\u000a				};\u000a			retval.type = 'button';\u000a			retval.override = function( override ) {\u000a				return CKEDITOR.tools.extend( function( editor ) {\u000a					return retval( editor, override );\u000a				}, { type: 'button' }, true );\u000a			};\u000a			return retval;\u000a		} )(),\u000a\u000a		/**\u000a		 * Registers a dialog UI element.\u000a		 *\u000a		 * @static\u000a		 * @param {String} typeName The name of the UI element.\u000a		 * @param {Function} builder The function to build the UI element.\u000a		 */\u000a		addUIElement: function( typeName, builder ) {\u000a			this._.uiElementBuilders[ typeName ] = builder;\u000a		}\u000a	} );\u000a\u000a	CKEDITOR.dialog._ = {\u000a		uiElementBuilders: {},\u000a\u000a		dialogDefinitions: {},\u000a\u000a		currentTop: null,\u000a\u000a		currentZIndex: null\u000a	};\u000a\u000a	// "Inherit" (copy actually) from CKEDITOR.event.\u000a	CKEDITOR.event.implementOn( CKEDITOR.dialog );\u000a	CKEDITOR.event.implementOn( CKEDITOR.dialog.prototype );\u000a\u000a	var defaultDialogDefinition = {\u000a		resizable: CKEDITOR.DIALOG_RESIZE_BOTH,\u000a		minWidth: 600,\u000a		minHeight: 400,\u000a		buttons: [ CKEDITOR.dialog.okButton, CKEDITOR.dialog.cancelButton ]\u000a	};\u000a\u000a	// Tool function used to return an item from an array based on its id\u000a	// property.\u000a	var getById = function( array, id, recurse ) {\u000a			for ( var i = 0, item;\u000a			( item = array[ i ] ); i++ ) {\u000a				if ( item.id == id )\u000a					return item;\u000a				if ( recurse && item[ recurse ] ) {\u000a					var retval = getById( item[ recurse ], id, recurse );\u000a					if ( retval )\u000a						return retval;\u000a				}\u000a			}\u000a			return null;\u000a		};\u000a\u000a	// Tool function used to add an item into an array.\u000a	var addById = function( array, newItem, nextSiblingId, recurse, nullIfNotFound ) {\u000a			if ( nextSiblingId ) {\u000a				for ( var i = 0, item;\u000a				( item = array[ i ] ); i++ ) {\u000a					if ( item.id == nextSiblingId ) {\u000a						array.splice( i, 0, newItem );\u000a						return newItem;\u000a					}\u000a\u000a					if ( recurse && item[ recurse ] ) {\u000a						var retval = addById( item[ recurse ], newItem, nextSiblingId, recurse, true );\u000a						if ( retval )\u000a							return retval;\u000a					}\u000a				}\u000a\u000a				if ( nullIfNotFound )\u000a					return null;\u000a			}\u000a\u000a			array.push( newItem );\u000a			return newItem;\u000a		};\u000a\u000a	// Tool function used to remove an item from an array based on its id.\u000a	var removeById = function( array, id, recurse ) {\u000a			for ( var i = 0, item;\u000a			( item = array[ i ] ); i++ ) {\u000a				if ( item.id == id )\u000a					return array.splice( i, 1 );\u000a				if ( recurse && item[ recurse ] ) {\u000a					var retval = removeById( item[ recurse ], id, recurse );\u000a					if ( retval )\u000a						return retval;\u000a				}\u000a			}\u000a			return null;\u000a		};\u000a\u000a	/**\u000a	 * This class is not really part of the API. It is the `definition` property value\u000a	 * passed to `dialogDefinition` event handlers.\u000a	 *\u000a	 *		CKEDITOR.on( 'dialogDefinition', function( evt ) {\u000a	 *			var definition = evt.data.definition;\u000a	 *			var content = definition.getContents( 'page1' );\u000a	 * 			// ...\u000a	 *		} );\u000a	 *\u000a	 * @private\u000a	 * @class CKEDITOR.dialog.definitionObject\u000a	 * @extends CKEDITOR.dialog.definition\u000a	 * @constructor Creates a definitionObject class instance.\u000a	 */\u000a	var definitionObject = function( dialog, dialogDefinition ) {\u000a			// TODO : Check if needed.\u000a			this.dialog = dialog;\u000a\u000a			// Transform the contents entries in contentObjects.\u000a			var contents = dialogDefinition.contents;\u000a			for ( var i = 0, content;\u000a			( content = contents[ i ] ); i++ )\u000a				contents[ i ] = content && new contentObject( dialog, content );\u000a\u000a			CKEDITOR.tools.extend( this, dialogDefinition );\u000a		};\u000a\u000a	definitionObject.prototype = {\u000a		/**\u000a		 * Gets a content definition.\u000a		 *\u000a		 * @param {String} id The id of the content definition.\u000a		 * @returns {CKEDITOR.dialog.definition.content} The content definition matching id.\u000a		 */\u000a		getContents: function( id ) {\u000a			return getById( this.contents, id );\u000a		},\u000a\u000a		/**\u000a		 * Gets a button definition.\u000a		 *\u000a		 * @param {String} id The id of the button definition.\u000a		 * @returns {CKEDITOR.dialog.definition.button} The button definition matching id.\u000a		 */\u000a		getButton: function( id ) {\u000a			return getById( this.buttons, id );\u000a		},\u000a\u000a		/**\u000a		 * Adds a content definition object under this dialog definition.\u000a		 *\u000a		 * @param {CKEDITOR.dialog.definition.content} contentDefinition The\u000a		 * content definition.\u000a		 * @param {String} [nextSiblingId] The id of an existing content\u000a		 * definition which the new content definition will be inserted\u000a		 * before. Omit if the new content definition is to be inserted as\u000a		 * the last item.\u000a		 * @returns {CKEDITOR.dialog.definition.content} The inserted content definition.\u000a		 */\u000a		addContents: function( contentDefinition, nextSiblingId ) {\u000a			return addById( this.contents, contentDefinition, nextSiblingId );\u000a		},\u000a\u000a		/**\u000a		 * Adds a button definition object under this dialog definition.\u000a		 *\u000a		 * @param {CKEDITOR.dialog.definition.button} buttonDefinition The\u000a		 * button definition.\u000a		 * @param {String} [nextSiblingId] The id of an existing button\u000a		 * definition which the new button definition will be inserted\u000a		 * before. Omit if the new button definition is to be inserted as\u000a		 * the last item.\u000a		 * @returns {CKEDITOR.dialog.definition.button} The inserted button definition.\u000a		 */\u000a		addButton: function( buttonDefinition, nextSiblingId ) {\u000a			return addById( this.buttons, buttonDefinition, nextSiblingId );\u000a		},\u000a\u000a		/**\u000a		 * Removes a content definition from this dialog definition.\u000a		 *\u000a		 * @param {String} id The id of the content definition to be removed.\u000a		 * @returns {CKEDITOR.dialog.definition.content} The removed content definition.\u000a		 */\u000a		removeContents: function( id ) {\u000a			removeById( this.contents, id );\u000a		},\u000a\u000a		/**\u000a		 * Removes a button definition from the dialog definition.\u000a		 *\u000a		 * @param {String} id The id of the button definition to be removed.\u000a		 * @returns {CKEDITOR.dialog.definition.button} The removed button definition.\u000a		 */\u000a		removeButton: function( id ) {\u000a			removeById( this.buttons, id );\u000a		}\u000a	};\u000a\u000a	/**\u000a	 * This class is not really part of the API. It is the template of the\u000a	 * objects representing content pages inside the\u000a	 * CKEDITOR.dialog.definitionObject.\u000a	 *\u000a	 *		CKEDITOR.on( 'dialogDefinition', function( evt ) {\u000a	 *			var definition = evt.data.definition;\u000a	 *			var content = definition.getContents( 'page1' );\u000a	 *			content.remove( 'textInput1' );\u000a	 *			// ...\u000a	 *		} );\u000a	 *\u000a	 * @private\u000a	 * @class CKEDITOR.dialog.definition.contentObject\u000a	 * @constructor Creates a contentObject class instance.\u000a	 */\u000a	function contentObject( dialog, contentDefinition ) {\u000a		this._ = {\u000a			dialog: dialog\u000a		};\u000a\u000a		CKEDITOR.tools.extend( this, contentDefinition );\u000a	}\u000a\u000a	contentObject.prototype = {\u000a		/**\u000a		 * Gets a UI element definition under the content definition.\u000a		 *\u000a		 * @param {String} id The id of the UI element definition.\u000a		 * @returns {CKEDITOR.dialog.definition.uiElement}\u000a		 */\u000a		get: function( id ) {\u000a			return getById( this.elements, id, 'children' );\u000a		},\u000a\u000a		/**\u000a		 * Adds a UI element definition to the content definition.\u000a		 *\u000a		 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition The\u000a		 * UI elemnet definition to be added.\u000a		 * @param {String} nextSiblingId The id of an existing UI element\u000a		 * definition which the new UI element definition will be inserted\u000a		 * before. Omit if the new button definition is to be inserted as\u000a		 * the last item.\u000a		 * @returns {CKEDITOR.dialog.definition.uiElement} The element definition inserted.\u000a		 */\u000a		add: function( elementDefinition, nextSiblingId ) {\u000a			return addById( this.elements, elementDefinition, nextSiblingId, 'children' );\u000a		},\u000a\u000a		/**\u000a		 * Removes a UI element definition from the content definition.\u000a		 *\u000a		 * @param {String} id The id of the UI element definition to be removed.\u000a		 * @returns {CKEDITOR.dialog.definition.uiElement} The element definition removed.\u000a		 */\u000a		remove: function( id ) {\u000a			removeById( this.elements, id, 'children' );\u000a		}\u000a	};\u000a\u000a	function initDragAndDrop( dialog ) {\u000a		var lastCoords = null,\u000a			abstractDialogCoords = null,\u000a			element = dialog.getElement().getFirst(),\u000a			editor = dialog.getParentEditor(),\u000a			magnetDistance = editor.config.dialog_magnetDistance,\u000a			margins = CKEDITOR.skin.margins || [ 0, 0, 0, 0 ];\u000a\u000a		if ( typeof magnetDistance == 'undefined' )\u000a			magnetDistance = 20;\u000a\u000a		function mouseMoveHandler( evt ) {\u000a			var dialogSize = dialog.getSize(),\u000a				viewPaneSize = CKEDITOR.document.getWindow().getViewPaneSize(),\u000a				x = evt.data.$.screenX,\u000a				y = evt.data.$.screenY,\u000a				dx = x - lastCoords.x,\u000a				dy = y - lastCoords.y,\u000a				realX, realY;\u000a\u000a			lastCoords = { x: x, y: y };\u000a			abstractDialogCoords.x += dx;\u000a			abstractDialogCoords.y += dy;\u000a\u000a			if ( abstractDialogCoords.x + margins[ 3 ] < magnetDistance )\u000a				realX = -margins[ 3 ];\u000a			else if ( abstractDialogCoords.x - margins[ 1 ] > viewPaneSize.width - dialogSize.width - magnetDistance )\u000a				realX = viewPaneSize.width - dialogSize.width + ( editor.lang.dir == 'rtl' ? 0 : margins[ 1 ] );\u000a			else\u000a				realX = abstractDialogCoords.x;\u000a\u000a			if ( abstractDialogCoords.y + margins[ 0 ] < magnetDistance )\u000a				realY = -margins[ 0 ];\u000a			else if ( abstractDialogCoords.y - margins[ 2 ] > viewPaneSize.height - dialogSize.height - magnetDistance )\u000a				realY = viewPaneSize.height - dialogSize.height + margins[ 2 ];\u000a			else\u000a				realY = abstractDialogCoords.y;\u000a\u000a			dialog.move( realX, realY, 1 );\u000a\u000a			evt.data.preventDefault();\u000a		}\u000a\u000a		function mouseUpHandler( evt ) {\u000a			CKEDITOR.document.removeListener( 'mousemove', mouseMoveHandler );\u000a			CKEDITOR.document.removeListener( 'mouseup', mouseUpHandler );\u000a\u000a			if ( CKEDITOR.env.ie6Compat ) {\u000a				var coverDoc = currentCover.getChild( 0 ).getFrameDocument();\u000a				coverDoc.removeListener( 'mousemove', mouseMoveHandler );\u000a				coverDoc.removeListener( 'mouseup', mouseUpHandler );\u000a			}\u000a		}\u000a\u000a		dialog.parts.title.on( 'mousedown', function( evt ) {\u000a			lastCoords = { x: evt.data.$.screenX, y: evt.data.$.screenY };\u000a\u000a			CKEDITOR.document.on( 'mousemove', mouseMoveHandler );\u000a			CKEDITOR.document.on( 'mouseup', mouseUpHandler );\u000a			abstractDialogCoords = dialog.getPosition();\u000a\u000a			if ( CKEDITOR.env.ie6Compat ) {\u000a				var coverDoc = currentCover.getChild( 0 ).getFrameDocument();\u000a				coverDoc.on( 'mousemove', mouseMoveHandler );\u000a				coverDoc.on( 'mouseup', mouseUpHandler );\u000a			}\u000a\u000a			evt.data.preventDefault();\u000a		}, dialog );\u000a	}\u000a\u000a	function initResizeHandles( dialog ) {\u000a		var def = dialog.definition,\u000a			resizable = def.resizable;\u000a\u000a		if ( resizable == CKEDITOR.DIALOG_RESIZE_NONE )\u000a			return;\u000a\u000a		var editor = dialog.getParentEditor();\u000a		var wrapperWidth, wrapperHeight, viewSize, origin, startSize, dialogCover;\u000a\u000a		var mouseDownFn = CKEDITOR.tools.addFunction( function( $event ) {\u000a			startSize = dialog.getSize();\u000a\u000a			var content = dialog.parts.contents,\u000a				iframeDialog = content.$.getElementsByTagName( 'iframe' ).length;\u000a\u000a			// Shim to help capturing "mousemove" over iframe.\u000a			if ( iframeDialog ) {\u000a				dialogCover = CKEDITOR.dom.element.createFromHtml( '<div class="cke_dialog_resize_cover" style="height: 100%; position: absolute; width: 100%;"></div>' );\u000a				content.append( dialogCover );\u000a			}\u000a\u000a			// Calculate the offset between content and chrome size.\u000a			wrapperHeight = startSize.height - dialog.parts.contents.getSize( 'height', !( CKEDITOR.env.gecko || CKEDITOR.env.ie && CKEDITOR.env.quirks ) );\u000a			wrapperWidth = startSize.width - dialog.parts.contents.getSize( 'width', 1 );\u000a\u000a			origin = { x: $event.screenX, y: $event.screenY };\u000a\u000a			viewSize = CKEDITOR.document.getWindow().getViewPaneSize();\u000a\u000a			CKEDITOR.document.on( 'mousemove', mouseMoveHandler );\u000a			CKEDITOR.document.on( 'mouseup', mouseUpHandler );\u000a\u000a			if ( CKEDITOR.env.ie6Compat ) {\u000a				var coverDoc = currentCover.getChild( 0 ).getFrameDocument();\u000a				coverDoc.on( 'mousemove', mouseMoveHandler );\u000a				coverDoc.on( 'mouseup', mouseUpHandler );\u000a			}\u000a\u000a			$event.preventDefault && $event.preventDefault();\u000a		} );\u000a\u000a		// Prepend the grip to the dialog.\u000a		dialog.on( 'load', function() {\u000a			var direction = '';\u000a			if ( resizable == CKEDITOR.DIALOG_RESIZE_WIDTH )\u000a				direction = ' cke_resizer_horizontal';\u000a			else if ( resizable == CKEDITOR.DIALOG_RESIZE_HEIGHT )\u000a				direction = ' cke_resizer_vertical';\u000a			var resizer = CKEDITOR.dom.element.createFromHtml(\u000a				'<div' +\u000a				' class="cke_resizer' + direction + ' cke_resizer_' + editor.lang.dir + '"' +\u000a				' title="' + CKEDITOR.tools.htmlEncode( editor.lang.common.resize ) + '"' +\u000a				' onmousedown="CKEDITOR.tools.callFunction(' + mouseDownFn + ', event )">' +\u000a				// BLACK LOWER RIGHT TRIANGLE (ltr)\u000a				// BLACK LOWER LEFT TRIANGLE (rtl)\u000a				( editor.lang.dir == 'ltr' ? '\u005cu25E2' : '\u005cu25E3' ) +\u000a				'</div>' );\u000a			dialog.parts.footer.append( resizer, 1 );\u000a		} );\u000a		editor.on( 'destroy', function() {\u000a			CKEDITOR.tools.removeFunction( mouseDownFn );\u000a		} );\u000a\u000a		function mouseMoveHandler( evt ) {\u000a			var rtl = editor.lang.dir == 'rtl',\u000a				dx = ( evt.data.$.screenX - origin.x ) * ( rtl ? -1 : 1 ),\u000a				dy = evt.data.$.screenY - origin.y,\u000a				width = startSize.width,\u000a				height = startSize.height,\u000a				internalWidth = width + dx * ( dialog._.moved ? 1 : 2 ),\u000a				internalHeight = height + dy * ( dialog._.moved ? 1 : 2 ),\u000a				element = dialog._.element.getFirst(),\u000a				right = rtl && element.getComputedStyle( 'right' ),\u000a				position = dialog.getPosition();\u000a\u000a			if ( position.y + internalHeight > viewSize.height )\u000a				internalHeight = viewSize.height - position.y;\u000a\u000a			if ( ( rtl ? right : position.x ) + internalWidth > viewSize.width )\u000a				internalWidth = viewSize.width - ( rtl ? right : position.x );\u000a\u000a			// Make sure the dialog will not be resized to the wrong side when it's in the leftmost position for RTL.\u000a			if ( ( resizable == CKEDITOR.DIALOG_RESIZE_WIDTH || resizable == CKEDITOR.DIALOG_RESIZE_BOTH ) )\u000a				width = Math.max( def.minWidth || 0, internalWidth - wrapperWidth );\u000a\u000a			if ( resizable == CKEDITOR.DIALOG_RESIZE_HEIGHT || resizable == CKEDITOR.DIALOG_RESIZE_BOTH )\u000a				height = Math.max( def.minHeight || 0, internalHeight - wrapperHeight );\u000a\u000a			dialog.resize( width, height );\u000a\u000a			if ( !dialog._.moved )\u000a				dialog.layout();\u000a\u000a			evt.data.preventDefault();\u000a		}\u000a\u000a		function mouseUpHandler() {\u000a			CKEDITOR.document.removeListener( 'mouseup', mouseUpHandler );\u000a			CKEDITOR.document.removeListener( 'mousemove', mouseMoveHandler );\u000a\u000a			if ( dialogCover ) {\u000a				dialogCover.remove();\u000a				dialogCover = null;\u000a			}\u000a\u000a			if ( CKEDITOR.env.ie6Compat ) {\u000a				var coverDoc = currentCover.getChild( 0 ).getFrameDocument();\u000a				coverDoc.removeListener( 'mouseup', mouseUpHandler );\u000a				coverDoc.removeListener( 'mousemove', mouseMoveHandler );\u000a			}\u000a		}\u000a	}\u000a\u000a	var resizeCover;\u000a	// Caching resuable covers and allowing only one cover\u000a	// on screen.\u000a	var covers = {},\u000a		currentCover;\u000a\u000a	function cancelEvent( ev ) {\u000a		ev.data.preventDefault( 1 );\u000a	}\u000a\u000a	function showCover( editor ) {\u000a		var win = CKEDITOR.document.getWindow();\u000a		var config = editor.config,\u000a			backgroundColorStyle = config.dialog_backgroundCoverColor || 'white',\u000a			backgroundCoverOpacity = config.dialog_backgroundCoverOpacity,\u000a			baseFloatZIndex = config.baseFloatZIndex,\u000a			coverKey = CKEDITOR.tools.genKey( backgroundColorStyle, backgroundCoverOpacity, baseFloatZIndex ),\u000a			coverElement = covers[ coverKey ];\u000a\u000a		if ( !coverElement ) {\u000a			var html = [\u000a				'<div tabIndex="-1" style="position: ', ( CKEDITOR.env.ie6Compat ? 'absolute' : 'fixed' ),\u000a				'; z-index: ', baseFloatZIndex,\u000a				'; top: 0px; left: 0px; ',\u000a				( !CKEDITOR.env.ie6Compat ? 'background-color: ' + backgroundColorStyle : '' ),\u000a				'" class="cke_dialog_background_cover">'\u000a				];\u000a\u000a			if ( CKEDITOR.env.ie6Compat ) {\u000a				// Support for custom document.domain in IE.\u000a				var iframeHtml = '<html><body style=\u005c\u005c\u005c'background-color:' + backgroundColorStyle + ';\u005c\u005c\u005c'></body></html>';\u000a\u000a				html.push( '<iframe' +\u000a					' hidefocus="true"' +\u000a					' frameborder="0"' +\u000a					' id="cke_dialog_background_iframe"' +\u000a					' src="javascript:' );\u000a\u000a				html.push( 'void((function(){' + encodeURIComponent(\u000a					'document.open();' +\u000a					// Support for custom document.domain in IE.\u000a					'(' + CKEDITOR.tools.fixDomain + ')();' +\u000a					'document.write( \u005c'' + iframeHtml + '\u005c' );' +\u000a					'document.close();'\u000a				) + '})())' );\u000a\u000a				html.push( '"' +\u000a					' style="' +\u000a						'position:absolute;' +\u000a						'left:0;' +\u000a						'top:0;' +\u000a						'width:100%;' +\u000a						'height: 100%;' +\u000a						'filter: progid:DXImageTransform.Microsoft.Alpha(opacity=0)">' +\u000a					'</iframe>' );\u000a			}\u000a\u000a			html.push( '</div>' );\u000a\u000a			coverElement = CKEDITOR.dom.element.createFromHtml( html.join( '' ) );\u000a			coverElement.setOpacity( backgroundCoverOpacity != undefined ? backgroundCoverOpacity : 0.5 );\u000a\u000a			coverElement.on( 'keydown', cancelEvent );\u000a			coverElement.on( 'keypress', cancelEvent );\u000a			coverElement.on( 'keyup', cancelEvent );\u000a\u000a			coverElement.appendTo( CKEDITOR.document.getBody() );\u000a			covers[ coverKey ] = coverElement;\u000a		} else\u000a			coverElement.show();\u000a\u000a		// Makes the dialog cover a focus holder as well.\u000a		editor.focusManager.add( coverElement );\u000a\u000a		currentCover = coverElement;\u000a		var resizeFunc = function() {\u000a				var size = win.getViewPaneSize();\u000a				coverElement.setStyles( {\u000a					width: size.width + 'px',\u000a					height: size.height + 'px'\u000a				} );\u000a			};\u000a\u000a		var scrollFunc = function() {\u000a				var pos = win.getScrollPosition(),\u000a					cursor = CKEDITOR.dialog._.currentTop;\u000a				coverElement.setStyles( {\u000a					left: pos.x + 'px',\u000a					top: pos.y + 'px'\u000a				} );\u000a\u000a				if ( cursor ) {\u000a					do {\u000a						var dialogPos = cursor.getPosition();\u000a						cursor.move( dialogPos.x, dialogPos.y );\u000a					} while ( ( cursor = cursor._.parentDialog ) );\u000a				}\u000a			};\u000a\u000a		resizeCover = resizeFunc;\u000a		win.on( 'resize', resizeFunc );\u000a		resizeFunc();\u000a		// Using Safari/Mac, focus must be kept where it is (#7027)\u000a		if ( !( CKEDITOR.env.mac && CKEDITOR.env.webkit ) )\u000a			coverElement.focus();\u000a\u000a		if ( CKEDITOR.env.ie6Compat ) {\u000a			// IE BUG: win.$.onscroll assignment doesn't work.. it must be window.onscroll.\u000a			// So we need to invent a really funny way to make it work.\u000a			var myScrollHandler = function() {\u000a					scrollFunc();\u000a					arguments.callee.prevScrollHandler.apply( this, arguments );\u000a				};\u000a			win.$.setTimeout( function() {\u000a				myScrollHandler.prevScrollHandler = window.onscroll ||\u000a				function() {};\u000a				window.onscroll = myScrollHandler;\u000a			}, 0 );\u000a			scrollFunc();\u000a		}\u000a	}\u000a\u000a	function hideCover( editor ) {\u000a		if ( !currentCover )\u000a			return;\u000a\u000a		editor.focusManager.remove( currentCover );\u000a		var win = CKEDITOR.document.getWindow();\u000a		currentCover.hide();\u000a		win.removeListener( 'resize', resizeCover );\u000a\u000a		if ( CKEDITOR.env.ie6Compat ) {\u000a			win.$.setTimeout( function() {\u000a				var prevScrollHandler = window.onscroll && window.onscroll.prevScrollHandler;\u000a				window.onscroll = prevScrollHandler || null;\u000a			}, 0 );\u000a		}\u000a		resizeCover = null;\u000a	}\u000a\u000a	function removeCovers() {\u000a		for ( var coverId in covers )\u000a			covers[ coverId ].remove();\u000a		covers = {};\u000a	}\u000a\u000a	var accessKeyProcessors = {};\u000a\u000a	var accessKeyDownHandler = function( evt ) {\u000a			var ctrl = evt.data.$.ctrlKey || evt.data.$.metaKey,\u000a				alt = evt.data.$.altKey,\u000a				shift = evt.data.$.shiftKey,\u000a				key = String.fromCharCode( evt.data.$.keyCode ),\u000a				keyProcessor = accessKeyProcessors[ ( ctrl ? 'CTRL+' : '' ) + ( alt ? 'ALT+' : '' ) + ( shift ? 'SHIFT+' : '' ) + key ];\u000a\u000a			if ( !keyProcessor || !keyProcessor.length )\u000a				return;\u000a\u000a			keyProcessor = keyProcessor[ keyProcessor.length - 1 ];\u000a			keyProcessor.keydown && keyProcessor.keydown.call( keyProcessor.uiElement, keyProcessor.dialog, keyProcessor.key );\u000a			evt.data.preventDefault();\u000a		};\u000a\u000a	var accessKeyUpHandler = function( evt ) {\u000a			var ctrl = evt.data.$.ctrlKey || evt.data.$.metaKey,\u000a				alt = evt.data.$.altKey,\u000a				shift = evt.data.$.shiftKey,\u000a				key = String.fromCharCode( evt.data.$.keyCode ),\u000a				keyProcessor = accessKeyProcessors[ ( ctrl ? 'CTRL+' : '' ) + ( alt ? 'ALT+' : '' ) + ( shift ? 'SHIFT+' : '' ) + key ];\u000a\u000a			if ( !keyProcessor || !keyProcessor.length )\u000a				return;\u000a\u000a			keyProcessor = keyProcessor[ keyProcessor.length - 1 ];\u000a			if ( keyProcessor.keyup ) {\u000a				keyProcessor.keyup.call( keyProcessor.uiElement, keyProcessor.dialog, keyProcessor.key );\u000a				evt.data.preventDefault();\u000a			}\u000a		};\u000a\u000a	var registerAccessKey = function( uiElement, dialog, key, downFunc, upFunc ) {\u000a			var procList = accessKeyProcessors[ key ] || ( accessKeyProcessors[ key ] = [] );\u000a			procList.push( {\u000a				uiElement: uiElement,\u000a				dialog: dialog,\u000a				key: key,\u000a				keyup: upFunc || uiElement.accessKeyUp,\u000a				keydown: downFunc || uiElement.accessKeyDown\u000a			} );\u000a		};\u000a\u000a	var unregisterAccessKey = function( obj ) {\u000a			for ( var i in accessKeyProcessors ) {\u000a				var list = accessKeyProcessors[ i ];\u000a				for ( var j = list.length - 1; j >= 0; j-- ) {\u000a					if ( list[ j ].dialog == obj || list[ j ].uiElement == obj )\u000a						list.splice( j, 1 );\u000a				}\u000a				if ( list.length === 0 )\u000a					delete accessKeyProcessors[ i ];\u000a			}\u000a		};\u000a\u000a	var tabAccessKeyUp = function( dialog, key ) {\u000a			if ( dialog._.accessKeyMap[ key ] )\u000a				dialog.selectPage( dialog._.accessKeyMap[ key ] );\u000a		};\u000a\u000a	var tabAccessKeyDown = function( dialog, key ) {};\u000a\u000a	( function() {\u000a		CKEDITOR.ui.dialog = {\u000a			/**\u000a			 * The base class of all dialog UI elements.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.uiElement\u000a			 * @constructor Creates a uiElement class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog object.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition Element\u000a			 * definition.\u000a			 *\u000a			 * Accepted fields:\u000a			 *\u000a			 * * `id` (Required) The id of the UI element. See {@link CKEDITOR.dialog#getContentElement}.\u000a			 * * `type` (Required) The type of the UI element. The\u000a			 *     value to this field specifies which UI element class will be used to\u000a			 *     generate the final widget.\u000a			 * * `title` (Optional) The popup tooltip for the UI\u000a			 *     element.\u000a			 * * `hidden` (Optional) A flag that tells if the element\u000a			 *     should be initially visible.\u000a			 * * `className` (Optional) Additional CSS class names\u000a			 *     to add to the UI element. Separated by space.\u000a			 * * `style` (Optional) Additional CSS inline styles\u000a			 *     to add to the UI element. A semicolon (;) is required after the last\u000a			 *     style declaration.\u000a			 * * `accessKey` (Optional) The alphanumeric access key\u000a			 *     for this element. Access keys are automatically prefixed by CTRL.\u000a			 * * `on*` (Optional) Any UI element definition field that\u000a			 *     starts with `on` followed immediately by a capital letter and\u000a			 *     probably more letters is an event handler. Event handlers may be further\u000a			 *     divided into registered event handlers and DOM event handlers. Please\u000a			 *     refer to {@link CKEDITOR.ui.dialog.uiElement#registerEvents} and\u000a			 *     {@link CKEDITOR.ui.dialog.uiElement#eventProcessors} for more information.\u000a			 *\u000a			 * @param {Array} htmlList\u000a			 * List of HTML code to be added to the dialog's content area.\u000a			 * @param {Function/String} [nodeNameArg='div']\u000a			 * A function returning a string, or a simple string for the node name for\u000a			 * the root DOM node.\u000a			 * @param {Function/Object} [stylesArg={}]\u000a			 * A function returning an object, or a simple object for CSS styles applied\u000a			 * to the DOM node.\u000a			 * @param {Function/Object} [attributesArg={}]\u000a			 * A fucntion returning an object, or a simple object for attributes applied\u000a			 * to the DOM node.\u000a			 * @param {Function/String} [contentsArg='']\u000a			 * A function returning a string, or a simple string for the HTML code inside\u000a			 * the root DOM node. Default is empty string.\u000a			 */\u000a			uiElement: function( dialog, elementDefinition, htmlList, nodeNameArg, stylesArg, attributesArg, contentsArg ) {\u000a				if ( arguments.length < 4 )\u000a					return;\u000a\u000a				var nodeName = ( nodeNameArg.call ? nodeNameArg( elementDefinition ) : nodeNameArg ) || 'div',\u000a					html = [ '<', nodeName, ' ' ],\u000a					styles = ( stylesArg && stylesArg.call ? stylesArg( elementDefinition ) : stylesArg ) || {},\u000a					attributes = ( attributesArg && attributesArg.call ? attributesArg( elementDefinition ) : attributesArg ) || {},\u000a					innerHTML = ( contentsArg && contentsArg.call ? contentsArg.call( this, dialog, elementDefinition ) : contentsArg ) || '',\u000a					domId = this.domId = attributes.id || CKEDITOR.tools.getNextId() + '_uiElement',\u000a					id = this.id = elementDefinition.id,\u000a					i;\u000a\u000a				if ( elementDefinition.requiredContent && !dialog.getParentEditor().filter.check( elementDefinition.requiredContent ) ) {\u000a					styles.display = 'none';\u000a					this.notAllowed = true;\u000a				}\u000a\u000a				// Set the id, a unique id is required for getElement() to work.\u000a				attributes.id = domId;\u000a\u000a				// Set the type and definition CSS class names.\u000a				var classes = {};\u000a				if ( elementDefinition.type )\u000a					classes[ 'cke_dialog_ui_' + elementDefinition.type ] = 1;\u000a				if ( elementDefinition.className )\u000a					classes[ elementDefinition.className ] = 1;\u000a				if ( elementDefinition.disabled )\u000a					classes[ 'cke_disabled' ] = 1;\u000a\u000a				var attributeClasses = ( attributes[ 'class' ] && attributes[ 'class' ].split ) ? attributes[ 'class' ].split( ' ' ) : [];\u000a				for ( i = 0; i < attributeClasses.length; i++ ) {\u000a					if ( attributeClasses[ i ] )\u000a						classes[ attributeClasses[ i ] ] = 1;\u000a				}\u000a				var finalClasses = [];\u000a				for ( i in classes )\u000a					finalClasses.push( i );\u000a				attributes[ 'class' ] = finalClasses.join( ' ' );\u000a\u000a				// Set the popup tooltop.\u000a				if ( elementDefinition.title )\u000a					attributes.title = elementDefinition.title;\u000a\u000a				// Write the inline CSS styles.\u000a				var styleStr = ( elementDefinition.style || '' ).split( ';' );\u000a\u000a				// Element alignment support.\u000a				if ( elementDefinition.align ) {\u000a					var align = elementDefinition.align;\u000a					styles[ 'margin-left' ] = align == 'left' ? 0 : 'auto';\u000a					styles[ 'margin-right' ] = align == 'right' ? 0 : 'auto';\u000a				}\u000a\u000a				for ( i in styles )\u000a					styleStr.push( i + ':' + styles[ i ] );\u000a				if ( elementDefinition.hidden )\u000a					styleStr.push( 'display:none' );\u000a				for ( i = styleStr.length - 1; i >= 0; i-- ) {\u000a					if ( styleStr[ i ] === '' )\u000a						styleStr.splice( i, 1 );\u000a				}\u000a				if ( styleStr.length > 0 )\u000a					attributes.style = ( attributes.style ? ( attributes.style + '; ' ) : '' ) + styleStr.join( '; ' );\u000a\u000a				// Write the attributes.\u000a				for ( i in attributes )\u000a					html.push( i + '="' + CKEDITOR.tools.htmlEncode( attributes[ i ] ) + '" ' );\u000a\u000a				// Write the content HTML.\u000a				html.push( '>', innerHTML, '</', nodeName, '>' );\u000a\u000a				// Add contents to the parent HTML array.\u000a				htmlList.push( html.join( '' ) );\u000a\u000a				( this._ || ( this._ = {} ) ).dialog = dialog;\u000a\u000a				// Override isChanged if it is defined in element definition.\u000a				if ( typeof( elementDefinition.isChanged ) == 'boolean' )\u000a					this.isChanged = function() {\u000a					return elementDefinition.isChanged;\u000a				};\u000a				if ( typeof( elementDefinition.isChanged ) == 'function' )\u000a					this.isChanged = elementDefinition.isChanged;\u000a\u000a				// Overload 'get(set)Value' on definition.\u000a				if ( typeof( elementDefinition.setValue ) == 'function' ) {\u000a					this.setValue = CKEDITOR.tools.override( this.setValue, function( org ) {\u000a						return function( val ) {\u000a							org.call( this, elementDefinition.setValue.call( this, val ) );\u000a						};\u000a					} );\u000a				}\u000a\u000a				if ( typeof( elementDefinition.getValue ) == 'function' ) {\u000a					this.getValue = CKEDITOR.tools.override( this.getValue, function( org ) {\u000a						return function() {\u000a							return elementDefinition.getValue.call( this, org.call( this ) );\u000a						};\u000a					} );\u000a				}\u000a\u000a				// Add events.\u000a				CKEDITOR.event.implementOn( this );\u000a\u000a				this.registerEvents( elementDefinition );\u000a				if ( this.accessKeyUp && this.accessKeyDown && elementDefinition.accessKey )\u000a					registerAccessKey( this, dialog, 'CTRL+' + elementDefinition.accessKey );\u000a\u000a				var me = this;\u000a				dialog.on( 'load', function() {\u000a					var input = me.getInputElement();\u000a					if ( input ) {\u000a						var focusClass = me.type in { 'checkbox': 1, 'ratio': 1 } && CKEDITOR.env.ie && CKEDITOR.env.version < 8 ? 'cke_dialog_ui_focused' : '';\u000a						input.on( 'focus', function() {\u000a							dialog._.tabBarMode = false;\u000a							dialog._.hasFocus = true;\u000a							me.fire( 'focus' );\u000a							focusClass && this.addClass( focusClass );\u000a\u000a						} );\u000a\u000a						input.on( 'blur', function() {\u000a							me.fire( 'blur' );\u000a							focusClass && this.removeClass( focusClass );\u000a						} );\u000a					}\u000a				} );\u000a\u000a				// Completes this object with everything we have in the\u000a				// definition.\u000a				CKEDITOR.tools.extend( this, elementDefinition );\u000a\u000a				// Register the object as a tab focus if it can be included.\u000a				if ( this.keyboardFocusable ) {\u000a					this.tabIndex = elementDefinition.tabIndex || 0;\u000a\u000a					this.focusIndex = dialog._.focusList.push( this ) - 1;\u000a					this.on( 'focus', function() {\u000a						dialog._.currentFocusIndex = me.focusIndex;\u000a					} );\u000a				}\u000a			},\u000a\u000a			/**\u000a			 * Horizontal layout box for dialog UI elements, auto-expends to available width of container.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.hbox\u000a			 * @extends CKEDITOR.ui.dialog.uiElement\u000a			 * @constructor Creates a hbox class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog object.\u000a			 * @param {Array} childObjList\u000a			 * Array of {@link CKEDITOR.ui.dialog.uiElement} objects inside this container.\u000a			 * @param {Array} childHtmlList\u000a			 * Array of HTML code that correspond to the HTML output of all the\u000a			 * objects in childObjList.\u000a			 * @param {Array} htmlList\u000a			 * Array of HTML code that this element will output to.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition\u000a			 * The element definition. Accepted fields:\u000a			 *\u000a			 * * `widths` (Optional) The widths of child cells.\u000a			 * * `height` (Optional) The height of the layout.\u000a			 * * `padding` (Optional) The padding width inside child cells.\u000a			 * * `align` (Optional) The alignment of the whole layout.\u000a			 */\u000a			hbox: function( dialog, childObjList, childHtmlList, htmlList, elementDefinition ) {\u000a				if ( arguments.length < 4 )\u000a					return;\u000a\u000a				this._ || ( this._ = {} );\u000a\u000a				var children = this._.children = childObjList,\u000a					widths = elementDefinition && elementDefinition.widths || null,\u000a					height = elementDefinition && elementDefinition.height || null,\u000a					styles = {},\u000a					i;\u000a				/** @ignore */\u000a				var innerHTML = function() {\u000a						var html = [ '<tbody><tr class="cke_dialog_ui_hbox">' ];\u000a						for ( i = 0; i < childHtmlList.length; i++ ) {\u000a							var className = 'cke_dialog_ui_hbox_child',\u000a								styles = [];\u000a							if ( i === 0 )\u000a								className = 'cke_dialog_ui_hbox_first';\u000a							if ( i == childHtmlList.length - 1 )\u000a								className = 'cke_dialog_ui_hbox_last';\u000a							html.push( '<td class="', className, '" role="presentation" ' );\u000a							if ( widths ) {\u000a								if ( widths[ i ] )\u000a									styles.push( 'width:' + cssLength( widths[ i ] ) );\u000a							} else\u000a								styles.push( 'width:' + Math.floor( 100 / childHtmlList.length ) + '%' );\u000a							if ( height )\u000a								styles.push( 'height:' + cssLength( height ) );\u000a							if ( elementDefinition && elementDefinition.padding != undefined )\u000a								styles.push( 'padding:' + cssLength( elementDefinition.padding ) );\u000a							// In IE Quirks alignment has to be done on table cells. (#7324)\u000a							if ( CKEDITOR.env.ie && CKEDITOR.env.quirks && children[ i ].align )\u000a								styles.push( 'text-align:' + children[ i ].align );\u000a							if ( styles.length > 0 )\u000a								html.push( 'style="' + styles.join( '; ' ) + '" ' );\u000a							html.push( '>', childHtmlList[ i ], '</td>' );\u000a						}\u000a						html.push( '</tr></tbody>' );\u000a						return html.join( '' );\u000a					};\u000a\u000a				var attribs = { role: 'presentation' };\u000a				elementDefinition && elementDefinition.align && ( attribs.align = elementDefinition.align );\u000a\u000a				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition || { type: 'hbox' }, htmlList, 'table', styles, attribs, innerHTML );\u000a			},\u000a\u000a			/**\u000a			 * Vertical layout box for dialog UI elements.\u000a			 *\u000a			 * @class CKEDITOR.ui.dialog.vbox\u000a			 * @extends CKEDITOR.ui.dialog.hbox\u000a			 * @constructor Creates a vbox class instance.\u000a			 * @param {CKEDITOR.dialog} dialog Parent dialog object.\u000a			 * @param {Array} childObjList\u000a			 * Array of {@link CKEDITOR.ui.dialog.uiElement} objects inside this container.\u000a			 * @param {Array} childHtmlList\u000a			 * Array of HTML code that correspond to the HTML output of all the\u000a			 * objects in childObjList.\u000a			 * @param {Array} htmlList Array of HTML code that this element will output to.\u000a			 * @param {CKEDITOR.dialog.definition.uiElement} elementDefinition\u000a			 * The element definition. Accepted fields:\u000a			 *\u000a			 * * `width` (Optional) The width of the layout.\u000a			 * * `heights` (Optional) The heights of individual cells.\u000a			 * * `align` (Optional) The alignment of the layout.\u000a			 * * `padding` (Optional) The padding width inside child cells.\u000a			 * * `expand` (Optional) Whether the layout should expand\u000a			 *     vertically to fill its container.\u000a			 */\u000a			vbox: function( dialog, childObjList, childHtmlList, htmlList, elementDefinition ) {\u000a				if ( arguments.length < 3 )\u000a					return;\u000a\u000a				this._ || ( this._ = {} );\u000a\u000a				var children = this._.children = childObjList,\u000a					width = elementDefinition && elementDefinition.width || null,\u000a					heights = elementDefinition && elementDefinition.heights || null;\u000a				/** @ignore */\u000a				var innerHTML = function() {\u000a						var html = [ '<table role="presentation" cellspacing="0" border="0" ' ];\u000a						html.push( 'style="' );\u000a						if ( elementDefinition && elementDefinition.expand )\u000a							html.push( 'height:100%;' );\u000a						html.push( 'width:' + cssLength( width || '100%' ), ';' );\u000a\u000a						// (#10123) Temp fix for dialog broken layout in latest webkit.\u000a						if ( CKEDITOR.env.webkit )\u000a							html.push( 'float:none;' );\u000a\u000a						html.push( '"' );\u000a						html.push( 'align="', CKEDITOR.tools.htmlEncode(\u000a						( elementDefinition && elementDefinition.align ) || ( dialog.getParentEditor().lang.dir == 'ltr' ? 'left' : 'right' ) ), '" ' );\u000a\u000a						html.push( '><tbody>' );\u000a						for ( var i = 0; i < childHtmlList.length; i++ ) {\u000a							var styles = [];\u000a							html.push( '<tr><td role="presentation" ' );\u000a							if ( width )\u000a								styles.push( 'width:' + cssLength( width || '100%' ) );\u000a							if ( heights )\u000a								styles.push( 'height:' + cssLength( heights[ i ] ) );\u000a							else if ( elementDefinition && elementDefinition.expand )\u000a								styles.push( 'height:' + Math.floor( 100 / childHtmlList.length ) + '%' );\u000a							if ( elementDefinition && elementDefinition.padding != undefined )\u000a								styles.push( 'padding:' + cssLength( elementDefinition.padding ) );\u000a							// In IE Quirks alignment has to be done on table cells. (#7324)\u000a							if ( CKEDITOR.env.ie && CKEDITOR.env.quirks && children[ i ].align )\u000a								styles.push( 'text-align:' + children[ i ].align );\u000a							if ( styles.length > 0 )\u000a								html.push( 'style="', styles.join( '; ' ), '" ' );\u000a							html.push( ' class="cke_dialog_ui_vbox_child">', childHtmlList[ i ], '</td></tr>' );\u000a						}\u000a						html.push( '</tbody></table>' );\u000a						return html.join( '' );\u000a					};\u000a				CKEDITOR.ui.dialog.uiElement.call( this, dialog, elementDefinition || { type: 'vbox' }, htmlList, 'div', null, { role: 'presentation' }, innerHTML );\u000a			}\u000a		};\u000a	} )();\u000a\u000a	/** @class CKEDITOR.ui.dialog.uiElement */\u000a	CKEDITOR.ui.dialog.uiElement.prototype = {\u000a		/**\u000a		 * Gets the root DOM element of this dialog UI object.\u000a		 *\u000a		 *		uiElement.getElement().hide();\u000a		 *\u000a		 * @returns {CKEDITOR.dom.element} Root DOM element of UI object.\u000a		 */\u000a		getElement: function() {\u000a			return CKEDITOR.document.getById( this.domId );\u000a		},\u000a\u000a		/**\u000a		 * Gets the DOM element that the user inputs values.\u000a		 *\u000a		 * This function is used by {@link #setValue}, {@link #getValue} and {@link #focus}. It should\u000a		 * be overrided in child classes where the input element isn't the root\u000a		 * element.\u000a		 *\u000a		 *		var rawValue = textInput.getInputElement().$.value;\u000a		 *\u000a		 * @returns {CKEDITOR.dom.element} The element where the user input values.\u000a		 */\u000a		getInputElement: function() {\u000a			return this.getElement();\u000a		},\u000a\u000a		/**\u000a		 * Gets the parent dialog object containing this UI element.\u000a		 *\u000a		 *		var dialog = uiElement.getDialog();\u000a		 *\u000a		 * @returns {CKEDITOR.dialog} Parent dialog object.\u000a		 */\u000a		getDialog: function() {\u000a			return this._.dialog;\u000a		},\u000a\u000a		/**\u000a		 * Sets the value of this dialog UI object.\u000a		 *\u000a		 *		uiElement.setValue( 'Dingo' );\u000a		 *\u000a		 * @chainable\u000a		 * @param {Object} value The new value.\u000a		 * @param {Boolean} noChangeEvent Internal commit, to supress `change` event on this element.\u000a		 */\u000a		setValue: function( value, noChangeEvent ) {\u000a			this.getInputElement().setValue( value );\u000a			!noChangeEvent && this.fire( 'change', { value: value } );\u000a			return this;\u000a		},\u000a\u000a		/**\u000a		 * Gets the current value of this dialog UI object.\u000a		 *\u000a		 *		var myValue = uiElement.getValue();\u000a		 *\u000a		 * @returns {Object} The current value.\u000a		 */\u000a		getValue: function() {\u000a			return this.getInputElement().getValue();\u000a		},\u000a\u000a		/**\u000a		 * Tells whether the UI object's value has changed.\u000a		 *\u000a		 *		if ( uiElement.isChanged() )\u000a		 *			confirm( 'Value changed! Continue?' );\u000a		 *\u000a		 * @returns {Boolean} `true` if changed, `false` if not changed.\u000a		 */\u000a		isChanged: function() {\u000a			// Override in input classes.\u000a			return false;\u000a		},\u000a\u000a		/**\u000a		 * Selects the parent tab of this element. Usually called by focus() or overridden focus() methods.\u000a		 *\u000a		 *		focus : function() {\u000a		 *			this.selectParentTab();\u000a		 *			// do something else.\u000a		 *		}\u000a		 *\u000a		 * @chainable\u000a		 */\u000a		selectParentTab: function() {\u000a			var element = this.getInputElement(),\u000a				cursor = element,\u000a				tabId;\u000a			while ( ( cursor = cursor.getParent() ) && cursor.$.className.search( 'cke_dialog_page_contents' ) == -1 ) {\u000a\u000a			}\u000a\u000a			// Some widgets don't have parent tabs (e.g. OK and Cancel buttons).\u000a			if ( !cursor )\u000a				return this;\u000a\u000a			tabId = cursor.getAttribute( 'name' );\u000a			// Avoid duplicate select.\u000a			if ( this._.dialog._.currentTabId != tabId )\u000a				this._.dialog.selectPage( tabId );\u000a			return this;\u000a		},\u000a\u000a		/**\u000a		 * Puts the focus to the UI object. Switches tabs if the UI object isn't in the active tab page.\u000a		 *\u000a		 *		uiElement.focus();\u000a		 *\u000a		 * @chainable\u000a		 */\u000a		focus: function() {\u000a			this.selectParentTab().getInputElement().focus();\u000a			return this;\u000a		},\u000a\u000a		/**\u000a		 * Registers the `on*` event handlers defined in the element definition.\u000a		 *\u000a		 * The default behavior of this function is:\u000a		 *\u000a		 * 1. If the on* event is defined in the class's eventProcesors list,\u000a		 *     then the registration is delegated to the corresponding function\u000a		 *     in the eventProcessors list.\u000a		 * 2. If the on* event is not defined in the eventProcessors list, then\u000a		 *     register the event handler under the corresponding DOM event of\u000a		 *     the UI element's input DOM element (as defined by the return value\u000a		 *     of {@link #getInputElement}).\u000a		 *\u000a		 * This function is only called at UI element instantiation, but can\u000a		 * be overridded in child classes if they require more flexibility.\u000a		 *\u000a		 * @chainable\u000a		 * @param {CKEDITOR.dialog.definition.uiElement} definition The UI element\u000a		 * definition.\u000a		 */\u000a		registerEvents: function( definition ) {\u000a			var regex = /^on([A-Z]\u005cw+)/,\u000a				match;\u000a\u000a			var registerDomEvent = function( uiElement, dialog, eventName, func ) {\u000a					dialog.on( 'load', function() {\u000a						uiElement.getInputElement().on( eventName, func, uiElement );\u000a					} );\u000a				};\u000a\u000a			for ( var i in definition ) {\u000a				if ( !( match = i.match( regex ) ) )\u000a					continue;\u000a				if ( this.eventProcessors[ i ] )\u000a					this.eventProcessors[ i ].call( this, this._.dialog, definition[ i ] );\u000a				else\u000a					registerDomEvent( this, this._.dialog, match[ 1 ].toLowerCase(), definition[ i ] );\u000a			}\u000a\u000a			return this;\u000a		},\u000a\u000a		/**\u000a		 * The event processor list used by\u000a		 * {@link CKEDITOR.ui.dialog.uiElement#getInputElement} at UI element\u000a		 * instantiation. The default list defines three `on*` events:\u000a		 *\u000a		 * 1. `onLoad` - Called when the element's parent dialog opens for the\u000a		 *     first time.\u000a		 * 2. `onShow` - Called whenever the element's parent dialog opens.\u000a		 * 3. `onHide` - Called whenever the element's parent dialog closes.\u000a		 *\u000a		 *		// This connects the 'click' event in CKEDITOR.ui.dialog.button to onClick\u000a		 *		// handlers in the UI element's definitions.\u000a		 *		CKEDITOR.ui.dialog.button.eventProcessors = CKEDITOR.tools.extend( {},\u000a		 *			CKEDITOR.ui.dialog.uiElement.prototype.eventProcessors,\u000a		 *			{ onClick : function( dialog, func ) { this.on( 'click', func ); } },\u000a		 *			true\u000a		 *		);\u000a		 *\u000a		 * @property {Object}\u000a		 */\u000a		eventProcessors: {\u000a			onLoad: function( dialog, func ) {\u000a				dialog.on( 'load', func, this );\u000a			},\u000a\u000a			onShow: function( dialog, func ) {\u000a				dialog.on( 'show', func, this );\u000a			},\u000a\u000a			onHide: function( dialog, func ) {\u000a				dialog.on( 'hide', func, this );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * The default handler for a UI element's access key down event, which\u000a		 * tries to put focus to the UI element.\u000a		 *\u000a		 * Can be overridded in child classes for more sophisticaed behavior.\u000a		 *\u000a		 * @param {CKEDITOR.dialog} dialog The parent dialog object.\u000a		 * @param {String} key The key combination pressed. Since access keys\u000a		 * are defined to always include the `CTRL` key, its value should always\u000a		 * include a `'CTRL+'` prefix.\u000a		 */\u000a		accessKeyDown: function( dialog, key ) {\u000a			this.focus();\u000a		},\u000a\u000a		/**\u000a		 * The default handler for a UI element's access key up event, which\u000a		 * does nothing.\u000a		 *\u000a		 * Can be overridded in child classes for more sophisticated behavior.\u000a		 *\u000a		 * @param {CKEDITOR.dialog} dialog The parent dialog object.\u000a		 * @param {String} key The key combination pressed. Since access keys\u000a		 * are defined to always include the `CTRL` key, its value should always\u000a		 * include a `'CTRL+'` prefix.\u000a		 */\u000a		accessKeyUp: function( dialog, key ) {},\u000a\u000a		/**\u000a		 * Disables a UI element.\u000a		 */\u000a		disable: function() {\u000a			var element = this.getElement(),\u000a				input = this.getInputElement();\u000a			input.setAttribute( 'disabled', 'true' );\u000a			element.addClass( 'cke_disabled' );\u000a		},\u000a\u000a		/**\u000a		 * Enables a UI element.\u000a		 */\u000a		enable: function() {\u000a			var element = this.getElement(),\u000a				input = this.getInputElement();\u000a			input.removeAttribute( 'disabled' );\u000a			element.removeClass( 'cke_disabled' );\u000a		},\u000a\u000a		/**\u000a		 * Determines whether an UI element is enabled or not.\u000a		 *\u000a		 * @returns {Boolean} Whether the UI element is enabled.\u000a		 */\u000a		isEnabled: function() {\u000a			return !this.getElement().hasClass( 'cke_disabled' );\u000a		},\u000a\u000a		/**\u000a		 * Determines whether an UI element is visible or not.\u000a		 *\u000a		 * @returns {Boolean} Whether the UI element is visible.\u000a		 */\u000a		isVisible: function() {\u000a			return this.getInputElement().isVisible();\u000a		},\u000a\u000a		/**\u000a		 * Determines whether an UI element is focus-able or not.\u000a		 * Focus-able is defined as being both visible and enabled.\u000a		 *\u000a		 * @returns {Boolean} Whether the UI element can be focused.\u000a		 */\u000a		isFocusable: function() {\u000a			if ( !this.isEnabled() || !this.isVisible() )\u000a				return false;\u000a			return true;\u000a		}\u000a	};\u000a\u000a	/** @class CKEDITOR.ui.dialog.hbox */\u000a	CKEDITOR.ui.dialog.hbox.prototype = CKEDITOR.tools.extend( new CKEDITOR.ui.dialog.uiElement, {\u000a		/**\u000a		 * Gets a child UI element inside this container.\u000a		 *\u000a		 *		var checkbox = hbox.getChild( [0,1] );\u000a		 *		checkbox.setValue( true );\u000a		 *\u000a		 * @param {Array/Number} indices An array or a single number to indicate the child's\u000a		 * position in the container's descendant tree. Omit to get all the children in an array.\u000a		 * @returns {Array/CKEDITOR.ui.dialog.uiElement} Array of all UI elements in the container\u000a		 * if no argument given, or the specified UI element if indices is given.\u000a		 */\u000a		getChild: function( indices ) {\u000a			// If no arguments, return a clone of the children array.\u000a			if ( arguments.length < 1 )\u000a				return this._.children.concat();\u000a\u000a			// If indices isn't array, make it one.\u000a			if ( !indices.splice )\u000a				indices = [ indices ];\u000a\u000a			// Retrieve the child element according to tree position.\u000a			if ( indices.length < 2 )\u000a				return this._.children[ indices[ 0 ] ];\u000a			else\u000a				return ( this._.children[ indices[ 0 ] ] && this._.children[ indices[ 0 ] ].getChild ) ? this._.children[ indices[ 0 ] ].getChild( indices.slice( 1, indices.length ) ) : null;\u000a		}\u000a	}, true );\u000a\u000a	CKEDITOR.ui.dialog.vbox.prototype = new CKEDITOR.ui.dialog.hbox();\u000a\u000a	( function() {\u000a		var commonBuilder = {\u000a			build: function( dialog, elementDefinition, output ) {\u000a				var children = elementDefinition.children,\u000a					child,\u000a					childHtmlList = [],\u000a					childObjList = [];\u000a				for ( var i = 0;\u000a				( i < children.length && ( child = children[ i ] ) ); i++ ) {\u000a					var childHtml = [];\u000a					childHtmlList.push( childHtml );\u000a					childObjList.push( CKEDITOR.dialog._.uiElementBuilders[ child.type ].build( dialog, child, childHtml ) );\u000a				}\u000a				return new CKEDITOR.ui.dialog[ elementDefinition.type ]( dialog, childObjList, childHtmlList, output, elementDefinition );\u000a			}\u000a		};\u000a\u000a		CKEDITOR.dialog.addUIElement( 'hbox', commonBuilder );\u000a		CKEDITOR.dialog.addUIElement( 'vbox', commonBuilder );\u000a	} )();\u000a\u000a	/**\u000a	 * Generic dialog command. It opens a specific dialog when executed.\u000a	 *\u000a	 *		// Register the "link" command, which opens the "link" dialog.\u000a	 *		editor.addCommand( 'link', new CKEDITOR.dialogCommand( 'link' ) );\u000a	 *\u000a	 * @class\u000a	 * @constructor Creates a dialogCommand class instance.\u000a	 * @extends CKEDITOR.commandDefinition\u000a	 * @param {String} dialogName The name of the dialog to open when executing\u000a	 * this command.\u000a	 * @param {Object} [ext] Additional command definition's properties.\u000a	 */\u000a	CKEDITOR.dialogCommand = function( dialogName, ext ) {\u000a		this.dialogName = dialogName;\u000a		CKEDITOR.tools.extend( this, ext, true );\u000a	};\u000a\u000a	CKEDITOR.dialogCommand.prototype = {\u000a		exec: function( editor ) {\u000a			editor.openDialog( this.dialogName );\u000a		},\u000a\u000a		// Dialog commands just open a dialog ui, thus require no undo logic,\u000a		// undo support should dedicate to specific dialog implementation.\u000a		canUndo: false,\u000a\u000a		editorFocus: 1\u000a	};\u000a\u000a	( function() {\u000a		var notEmptyRegex = /^([a]|[^a])+$/,\u000a			integerRegex = /^\u005cd*$/,\u000a			numberRegex = /^\u005cd*(?:\u005c.\u005cd+)?$/,\u000a			htmlLengthRegex = /^(((\u005cd*(\u005c.\u005cd+))|(\u005cd*))(px|\u005c%)?)?$/,\u000a			cssLengthRegex = /^(((\u005cd*(\u005c.\u005cd+))|(\u005cd*))(px|em|ex|in|cm|mm|pt|pc|\u005c%)?)?$/i,\u000a			inlineStyleRegex = /^(\u005cs*[\u005cw-]+\u005cs*:\u005cs*[^:;]+(?:;|$))*$/;\u000a\u000a		CKEDITOR.VALIDATE_OR = 1;\u000a		CKEDITOR.VALIDATE_AND = 2;\u000a\u000a		CKEDITOR.dialog.validate = {\u000a			functions: function() {\u000a				var args = arguments;\u000a				return function() {\u000a					/**\u000a					 * It's important for validate functions to be able to accept the value\u000a					 * as argument in addition to this.getValue(), so that it is possible to\u000a					 * combine validate functions together to make more sophisticated\u000a					 * validators.\u000a					 */\u000a					var value = this && this.getValue ? this.getValue() : args[ 0 ];\u000a\u000a					var msg = undefined,\u000a						relation = CKEDITOR.VALIDATE_AND,\u000a						functions = [],\u000a						i;\u000a\u000a					for ( i = 0; i < args.length; i++ ) {\u000a						if ( typeof( args[ i ] ) == 'function' )\u000a							functions.push( args[ i ] );\u000a						else\u000a							break;\u000a					}\u000a\u000a					if ( i < args.length && typeof( args[ i ] ) == 'string' ) {\u000a						msg = args[ i ];\u000a						i++;\u000a					}\u000a\u000a					if ( i < args.length && typeof( args[ i ] ) == 'number' )\u000a						relation = args[ i ];\u000a\u000a					var passed = ( relation == CKEDITOR.VALIDATE_AND ? true : false );\u000a					for ( i = 0; i < functions.length; i++ ) {\u000a						if ( relation == CKEDITOR.VALIDATE_AND )\u000a							passed = passed && functions[ i ]( value );\u000a						else\u000a							passed = passed || functions[ i ]( value );\u000a					}\u000a\u000a					return !passed ? msg : true;\u000a				};\u000a			},\u000a\u000a			regex: function( regex, msg ) {\u000a				/*\u000a				 * Can be greatly shortened by deriving from functions validator if code size\u000a				 * turns out to be more important than performance.\u000a				 */\u000a				return function() {\u000a					var value = this && this.getValue ? this.getValue() : arguments[ 0 ];\u000a					return !regex.test( value ) ? msg : true;\u000a				};\u000a			},\u000a\u000a			notEmpty: function( msg ) {\u000a				return this.regex( notEmptyRegex, msg );\u000a			},\u000a\u000a			integer: function( msg ) {\u000a				return this.regex( integerRegex, msg );\u000a			},\u000a\u000a			'number': function( msg ) {\u000a				return this.regex( numberRegex, msg );\u000a			},\u000a\u000a			'cssLength': function( msg ) {\u000a				return this.functions( function( val ) {\u000a					return cssLengthRegex.test( CKEDITOR.tools.trim( val ) );\u000a				}, msg );\u000a			},\u000a\u000a			'htmlLength': function( msg ) {\u000a				return this.functions( function( val ) {\u000a					return htmlLengthRegex.test( CKEDITOR.tools.trim( val ) );\u000a				}, msg );\u000a			},\u000a\u000a			'inlineStyle': function( msg ) {\u000a				return this.functions( function( val ) {\u000a					return inlineStyleRegex.test( CKEDITOR.tools.trim( val ) );\u000a				}, msg );\u000a			},\u000a\u000a			equals: function( value, msg ) {\u000a				return this.functions( function( val ) {\u000a					return val == value;\u000a				}, msg );\u000a			},\u000a\u000a			notEqual: function( value, msg ) {\u000a				return this.functions( function( val ) {\u000a					return val != value;\u000a				}, msg );\u000a			}\u000a		};\u000a\u000a		CKEDITOR.on( 'instanceDestroyed', function( evt ) {\u000a			// Remove dialog cover on last instance destroy.\u000a			if ( CKEDITOR.tools.isEmpty( CKEDITOR.instances ) ) {\u000a				var currentTopDialog;\u000a				while ( ( currentTopDialog = CKEDITOR.dialog._.currentTop ) )\u000a					currentTopDialog.hide();\u000a				removeCovers();\u000a			}\u000a\u000a			var dialogs = evt.editor._.storedDialogs;\u000a			for ( var name in dialogs )\u000a				dialogs[ name ].destroy();\u000a\u000a		} );\u000a\u000a	} )();\u000a\u000a	// Extend the CKEDITOR.editor class with dialog specific functions.\u000a	CKEDITOR.tools.extend( CKEDITOR.editor.prototype, {\u000a		/**\u000a		 * Loads and opens a registered dialog.\u000a		 *\u000a		 *		CKEDITOR.instances.editor1.openDialog( 'smiley' );\u000a		 *\u000a		 * @member CKEDITOR.editor\u000a		 * @param {String} dialogName The registered name of the dialog.\u000a		 * @param {Function} callback The function to be invoked after dialog instance created.\u000a		 * @returns {CKEDITOR.dialog} The dialog object corresponding to the dialog displayed.\u000a		 * `null` if the dialog name is not registered.\u000a		 * @see CKEDITOR.dialog#add\u000a		 */\u000a		openDialog: function( dialogName, callback ) {\u000a			var dialog = null, dialogDefinitions = CKEDITOR.dialog._.dialogDefinitions[ dialogName ];\u000a\u000a			if ( CKEDITOR.dialog._.currentTop === null )\u000a				showCover( this );\u000a\u000a			// If the dialogDefinition is already loaded, open it immediately.\u000a			if ( typeof dialogDefinitions == 'function' ) {\u000a				var storedDialogs = this._.storedDialogs || ( this._.storedDialogs = {} );\u000a\u000a				dialog = storedDialogs[ dialogName ] || ( storedDialogs[ dialogName ] = new CKEDITOR.dialog( this, dialogName ) );\u000a\u000a				callback && callback.call( dialog, dialog );\u000a				dialog.show();\u000a\u000a			} else if ( dialogDefinitions == 'failed' ) {\u000a				hideCover( this );\u000a				throw new Error( '[CKEDITOR.dialog.openDialog] Dialog "' + dialogName + '" failed when loading definition.' );\u000a			} else if ( typeof dialogDefinitions == 'string' ) {\u000a\u000a				CKEDITOR.scriptLoader.load( CKEDITOR.getUrl( dialogDefinitions ),\u000a					function() {\u000a						var dialogDefinition = CKEDITOR.dialog._.dialogDefinitions[ dialogName ];\u000a						// In case of plugin error, mark it as loading failed.\u000a						if ( typeof dialogDefinition != 'function' )\u000a							CKEDITOR.dialog._.dialogDefinitions[ dialogName ] = 'failed';\u000a\u000a						this.openDialog( dialogName, callback );\u000a					}, this, 0, 1 );\u000a			}\u000a\u000a			CKEDITOR.skin.loadPart( 'dialog' );\u000a\u000a			return dialog;\u000a		}\u000a	} );\u000a} )();\u000a\u000aCKEDITOR.plugins.add( 'dialog', {\u000a	requires: 'dialogui',\u000a	init: function( editor ) {\u000a		editor.on( 'doubleclick', function( evt ) {\u000a			if ( evt.data.dialog )\u000a				editor.openDialog( evt.data.dialog );\u000a		}, null, null, 999 );\u000a	}\u000a} );\u000a\u000a// Dialog related configurations.\u000a\u000a/**\u000a * The color of the dialog background cover. It should be a valid CSS color string.\u000a *\u000a *		config.dialog_backgroundCoverColor = 'rgb(255, 254, 253)';\u000a *\u000a * @cfg {String} [dialog_backgroundCoverColor='white']\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * The opacity of the dialog background cover. It should be a number within the\u000a * range `[0.0, 1.0]`.\u000a *\u000a *		config.dialog_backgroundCoverOpacity = 0.7;\u000a *\u000a * @cfg {Number} [dialog_backgroundCoverOpacity=0.5]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * If the dialog has more than one tab, put focus into the first tab as soon as dialog is opened.\u000a *\u000a *		config.dialog_startupFocusTab = true;\u000a *\u000a * @cfg {Boolean} [dialog_startupFocusTab=false]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * The distance of magnetic borders used in moving and resizing dialogs,\u000a * measured in pixels.\u000a *\u000a *		config.dialog_magnetDistance = 30;\u000a *\u000a * @cfg {Number} [dialog_magnetDistance=20]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * The guideline to follow when generating the dialog buttons. There are 3 possible options:\u000a *\u000a * * `'OS'` - the buttons will be displayed in the default order of the user's OS;\u000a * * `'ltr'` - for Left-To-Right order;\u000a * * `'rtl'` - for Right-To-Left order.\u000a *\u000a * Example:\u000a *\u000a *		config.dialog_buttonsOrder = 'rtl';\u000a *\u000a * @since 3.5\u000a * @cfg {String} [dialog_buttonsOrder='OS']\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * The dialog contents to removed. It's a string composed by dialog name and tab name with a colon between them.\u000a *\u000a * Separate each pair with semicolon (see example).\u000a *\u000a * **Note:** All names are case-sensitive.\u000a *\u000a * **Note:** Be cautious when specifying dialog tabs that are mandatory,\u000a * like `'info'`, dialog functionality might be broken because of this!\u000a *\u000a *		config.removeDialogTabs = 'flash:advanced;image:Link';\u000a *\u000a * @since 3.5\u000a * @cfg {String} [removeDialogTabs='']\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * Tells if user should not be asked to confirm close, if any dialog field was modified.\u000a * By default it is set to `false` meaning that the confirmation dialog will be shown.\u000a *\u000a *		config.dialog_noConfirmCancel = true;\u000a *\u000a * @since 4.3\u000a * @cfg {Boolean} [dialog_noConfirmCancel=false]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * Fired when a dialog definition is about to be used to create a dialog into\u000a * an editor instance. This event makes it possible to customize the definition\u000a * before creating it.\u000a *\u000a * Note that this event is called only the first time a specific dialog is\u000a * opened. Successive openings will use the cached dialog, and this event will\u000a * not get fired.\u000a *\u000a * @event dialogDefinition\u000a * @member CKEDITOR\u000a * @param {CKEDITOR.dialog.definition} data The dialog defination that\u000a * is being loaded.\u000a * @param {CKEDITOR.editor} editor The editor instance that will use the dialog.\u000a */\u000a\u000a/**\u000a * Fired when a tab is going to be selected in a dialog.\u000a *\u000a * @event selectPage\u000a * @member CKEDITOR.dialog\u000a * @param data\u000a * @param {String} data.page The id of the page that it's gonna be selected.\u000a * @param {String} data.currentPage The id of the current page.\u000a */\u000a\u000a/**\u000a * Fired when the user tries to dismiss a dialog.\u000a *\u000a * @event cancel\u000a * @member CKEDITOR.dialog\u000a * @param data\u000a * @param {Boolean} data.hide Whether the event should proceed or not.\u000a */\u000a\u000a/**\u000a * Fired when the user tries to confirm a dialog.\u000a *\u000a * @event ok\u000a * @member CKEDITOR.dialog\u000a * @param data\u000a * @param {Boolean} data.hide Whether the event should proceed or not.\u000a */\u000a\u000a/**\u000a * Fired when a dialog is shown.\u000a *\u000a * @event show\u000a * @member CKEDITOR.dialog\u000a */\u000a\u000a/**\u000a * Fired when a dialog is shown.\u000a *\u000a * @event dialogShow\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param {CKEDITOR.dialog} data The opened dialog instance.\u000a */\u000a\u000a/**\u000a * Fired when a dialog is hidden.\u000a *\u000a * @event hide\u000a * @member CKEDITOR.dialog\u000a */\u000a\u000a/**\u000a * Fired when a dialog is hidden.\u000a *\u000a * @event dialogHide\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param {CKEDITOR.dialog} data The hidden dialog instance.\u000a */\u000a\u000a/**\u000a * Fired when a dialog is being resized. The event is fired on\u000a * both the {@link CKEDITOR.dialog} object and the dialog instance\u000a * since 3.5.3, previously it's available only in the global object.\u000a *\u000a * @static\u000a * @event resize\u000a * @member CKEDITOR.dialog\u000a * @param data\u000a * @param {CKEDITOR.dialog} data.dialog The dialog being resized (if\u000a * it's fired on the dialog itself, this parameter isn't sent).\u000a * @param {String} data.skin The skin name.\u000a * @param {Number} data.width The new width.\u000a * @param {Number} data.height The new height.\u000a */\u000a\u000a/**\u000a * Fired when a dialog is being resized. The event is fired on\u000a * both the {@link CKEDITOR.dialog} object and the dialog instance\u000a * since 3.5.3, previously it's available only in the global object.\u000a *\u000a * @since 3.5\u000a * @event resize\u000a * @member CKEDITOR.dialog\u000a * @param data\u000a * @param {Number} data.width The new width.\u000a * @param {Number} data.height The new height.\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	var cssStyle = CKEDITOR.htmlParser.cssStyle,\u000a		cssLength = CKEDITOR.tools.cssLength;\u000a\u000a	var cssLengthRegex = /^((?:\u005cd*(?:\u005c.\u005cd+))|(?:\u005cd+))(.*)?$/i;\u000a\u000a	// Replacing the former CSS length value with the later one, with\u000a	// adjustment to the length  unit.\u000a	function replaceCssLength( length1, length2 ) {\u000a		var parts1 = cssLengthRegex.exec( length1 ),\u000a			parts2 = cssLengthRegex.exec( length2 );\u000a\u000a		// Omit pixel length unit when necessary,\u000a		// e.g. replaceCssLength( 10, '20px' ) -> 20\u000a		if ( parts1 ) {\u000a			if ( !parts1[ 2 ] && parts2[ 2 ] == 'px' )\u000a				return parts2[ 1 ];\u000a			if ( parts1[ 2 ] == 'px' && !parts2[ 2 ] )\u000a				return parts2[ 1 ] + 'px';\u000a		}\u000a\u000a		return length2;\u000a	}\u000a\u000a	var htmlFilterRules = {\u000a		elements: {\u000a			$: function( element ) {\u000a				var attributes = element.attributes,\u000a					realHtml = attributes && attributes[ 'data-cke-realelement' ],\u000a					realFragment = realHtml && new CKEDITOR.htmlParser.fragment.fromHtml( decodeURIComponent( realHtml ) ),\u000a					realElement = realFragment && realFragment.children[ 0 ];\u000a\u000a				// Width/height in the fake object are subjected to clone into the real element.\u000a				if ( realElement && element.attributes[ 'data-cke-resizable' ] ) {\u000a					var styles = new cssStyle( element ).rules,\u000a						realAttrs = realElement.attributes,\u000a						width = styles.width,\u000a						height = styles.height;\u000a\u000a					width && ( realAttrs.width = replaceCssLength( realAttrs.width, width ) );\u000a					height && ( realAttrs.height = replaceCssLength( realAttrs.height, height ) );\u000a				}\u000a\u000a				return realElement;\u000a			}\u000a		}\u000a	};\u000a\u000a	var plugin = CKEDITOR.plugins.add( 'fakeobjects', {\u000a		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en,en-au,en-ca,en-gb,eo,es,et,eu,fa,fi,fo,fr,fr-ca,gl,gu,he,hi,hr,hu,id,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt,pt-br,ro,ru,si,sk,sl,sq,sr,sr-latn,sv,th,tr,tt,ug,uk,vi,zh,zh-cn', // %REMOVE_LINE_CORE%\u000a\u000a		init: function( editor ) {\u000a			// Allow image with all styles and classes plus src, alt and title attributes.\u000a			// We need them when fakeobject is pasted.\u000a			editor.filter.allow( 'img[!data-cke-realelement,src,alt,title](*){*}', 'fakeobjects' );\u000a		},\u000a\u000a		afterInit: function( editor ) {\u000a			var dataProcessor = editor.dataProcessor,\u000a				htmlFilter = dataProcessor && dataProcessor.htmlFilter;\u000a\u000a			if ( htmlFilter ) {\u000a				htmlFilter.addRules( htmlFilterRules, {\u000a					applyToAll: true\u000a				} );\u000a			}\u000a		}\u000a	} );\u000a\u000a	/**\u000a	 * @member CKEDITOR.editor\u000a	 * @todo\u000a	 */\u000a	CKEDITOR.editor.prototype.createFakeElement = function( realElement, className, realElementType, isResizable ) {\u000a		var lang = this.lang.fakeobjects,\u000a			label = lang[ realElementType ] || lang.unknown;\u000a\u000a		var attributes = {\u000a			'class': className,\u000a			'data-cke-realelement': encodeURIComponent( realElement.getOuterHtml() ),\u000a			'data-cke-real-node-type': realElement.type,\u000a			alt: label,\u000a			title: label,\u000a			align: realElement.getAttribute( 'align' ) || ''\u000a		};\u000a\u000a		// Do not set "src" on high-contrast so the alt text is displayed. (#8945)\u000a		if ( !CKEDITOR.env.hc )\u000a			attributes.src = CKEDITOR.tools.transparentImageData;\u000a\u000a		if ( realElementType )\u000a			attributes[ 'data-cke-real-element-type' ] = realElementType;\u000a\u000a		if ( isResizable ) {\u000a			attributes[ 'data-cke-resizable' ] = isResizable;\u000a\u000a			var fakeStyle = new cssStyle();\u000a\u000a			var width = realElement.getAttribute( 'width' ),\u000a				height = realElement.getAttribute( 'height' );\u000a\u000a			width && ( fakeStyle.rules.width = cssLength( width ) );\u000a			height && ( fakeStyle.rules.height = cssLength( height ) );\u000a			fakeStyle.populate( attributes );\u000a		}\u000a\u000a		return this.document.createElement( 'img', { attributes: attributes } );\u000a	};\u000a\u000a	/**\u000a	 * @member CKEDITOR.editor\u000a	 * @todo\u000a	 */\u000a	CKEDITOR.editor.prototype.createFakeParserElement = function( realElement, className, realElementType, isResizable ) {\u000a		var lang = this.lang.fakeobjects,\u000a			label = lang[ realElementType ] || lang.unknown,\u000a			html;\u000a\u000a		var writer = new CKEDITOR.htmlParser.basicWriter();\u000a		realElement.writeHtml( writer );\u000a		html = writer.getHtml();\u000a\u000a		var attributes = {\u000a			'class': className,\u000a			'data-cke-realelement': encodeURIComponent( html ),\u000a			'data-cke-real-node-type': realElement.type,\u000a			alt: label,\u000a			title: label,\u000a			align: realElement.attributes.align || ''\u000a		};\u000a\u000a		// Do not set "src" on high-contrast so the alt text is displayed. (#8945)\u000a		if ( !CKEDITOR.env.hc )\u000a			attributes.src = CKEDITOR.tools.transparentImageData;\u000a\u000a		if ( realElementType )\u000a			attributes[ 'data-cke-real-element-type' ] = realElementType;\u000a\u000a		if ( isResizable ) {\u000a			attributes[ 'data-cke-resizable' ] = isResizable;\u000a			var realAttrs = realElement.attributes,\u000a				fakeStyle = new cssStyle();\u000a\u000a			var width = realAttrs.width,\u000a				height = realAttrs.height;\u000a\u000a			width != undefined && ( fakeStyle.rules.width = cssLength( width ) );\u000a			height != undefined && ( fakeStyle.rules.height = cssLength( height ) );\u000a			fakeStyle.populate( attributes );\u000a		}\u000a\u000a		return new CKEDITOR.htmlParser.element( 'img', attributes );\u000a	};\u000a\u000a	/**\u000a	 * @member CKEDITOR.editor\u000a	 * @todo\u000a	 */\u000a	CKEDITOR.editor.prototype.restoreRealElement = function( fakeElement ) {\u000a		if ( fakeElement.data( 'cke-real-node-type' ) != CKEDITOR.NODE_ELEMENT )\u000a			return null;\u000a\u000a		var element = CKEDITOR.dom.element.createFromHtml( decodeURIComponent( fakeElement.data( 'cke-realelement' ) ), this.document );\u000a\u000a		if ( fakeElement.data( 'cke-resizable' ) ) {\u000a			var width = fakeElement.getStyle( 'width' ),\u000a				height = fakeElement.getStyle( 'height' );\u000a\u000a			width && element.setAttribute( 'width', replaceCssLength( element.getAttribute( 'width' ), width ) );\u000a			height && element.setAttribute( 'height', replaceCssLength( element.getAttribute( 'height' ), height ) );\u000a		}\u000a\u000a		return element;\u000a	};\u000a\u000a} )();\u000a\u000a\ufeff/*\u000aCopyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000aFor licensing, see LICENSE.md or http://ckeditor.com/license\u000a*/\u000aCKEDITOR.plugins.setLang( 'fakeobjects', 'en', {\u000a	anchor: 'Anchor',\u000a	flash: 'Flash Animation',\u000a	hiddenfield: 'Hidden Field',\u000a	iframe: 'IFrame',\u000a	unknown: 'Unknown Object'\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Increase and Decrease Indent commands.\u000a */\u000a\u000a( function() {\u000a	'use strict';\u000a\u000a	var TRISTATE_DISABLED = CKEDITOR.TRISTATE_DISABLED,\u000a		TRISTATE_OFF = CKEDITOR.TRISTATE_OFF;\u000a\u000a	CKEDITOR.plugins.add( 'indent', {\u000a		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en,en-au,en-ca,en-gb,eo,es,et,eu,fa,fi,fo,fr,fr-ca,gl,gu,he,hi,hr,hu,id,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt,pt-br,ro,ru,si,sk,sl,sq,sr,sr-latn,sv,th,tr,tt,ug,uk,vi,zh,zh-cn', // %REMOVE_LINE_CORE%\u000a		// icons: 'indent,indent-rtl,outdent,outdent-rtl', // %REMOVE_LINE_CORE%\u000a		// hidpi: true, // %REMOVE_LINE_CORE%\u000a\u000a		init: function( editor ) {\u000a			var genericDefinition = CKEDITOR.plugins.indent.genericDefinition;\u000a\u000a			// Register generic commands.\u000a			setupGenericListeners( editor, editor.addCommand( 'indent', new genericDefinition( true ) ) );\u000a			setupGenericListeners( editor, editor.addCommand( 'outdent', new genericDefinition() ) );\u000a\u000a			// Create and register toolbar button if possible.\u000a			if ( editor.ui.addButton ) {\u000a				editor.ui.addButton( 'Indent', {\u000a					icon: 'indent fa fa-indent indent',\u000a					label: editor.lang.indent.indent,\u000a					command: 'indent',\u000a					directional: true,\u000a					toolbar: 'indent,20'\u000a				} );\u000a\u000a				editor.ui.addButton( 'Outdent', {\u000a					icon: 'outdent fa fa-outdent outdent',\u000a					label: editor.lang.indent.outdent,\u000a					command: 'outdent',\u000a					directional: true,\u000a					toolbar: 'indent,10'\u000a				} );\u000a			}\u000a\u000a			// Register dirChanged listener.\u000a			editor.on( 'dirChanged', function( evt ) {\u000a				var range = editor.createRange(),\u000a					dataNode = evt.data.node;\u000a\u000a				range.setStartBefore( dataNode );\u000a				range.setEndAfter( dataNode );\u000a\u000a				var walker = new CKEDITOR.dom.walker( range ),\u000a					node;\u000a\u000a				while ( ( node = walker.next() ) ) {\u000a					if ( node.type == CKEDITOR.NODE_ELEMENT ) {\u000a						// A child with the defined dir is to be ignored.\u000a						if ( !node.equals( dataNode ) && node.getDirection() ) {\u000a							range.setStartAfter( node );\u000a							walker = new CKEDITOR.dom.walker( range );\u000a							continue;\u000a						}\u000a\u000a						// Switch alignment classes.\u000a						var classes = editor.config.indentClasses;\u000a						if ( classes ) {\u000a							var suffix = ( evt.data.dir == 'ltr' ) ? [ '_rtl', '' ] : [ '', '_rtl' ];\u000a							for ( var i = 0; i < classes.length; i++ ) {\u000a								if ( node.hasClass( classes[ i ] + suffix[ 0 ] ) ) {\u000a									node.removeClass( classes[ i ] + suffix[ 0 ] );\u000a									node.addClass( classes[ i ] + suffix[ 1 ] );\u000a								}\u000a							}\u000a						}\u000a\u000a						// Switch the margins.\u000a						var marginLeft = node.getStyle( 'margin-right' ),\u000a							marginRight = node.getStyle( 'margin-left' );\u000a\u000a						marginLeft ? node.setStyle( 'margin-left', marginLeft ) : node.removeStyle( 'margin-left' );\u000a						marginRight ? node.setStyle( 'margin-right', marginRight ) : node.removeStyle( 'margin-right' );\u000a					}\u000a				}\u000a			} );\u000a		}\u000a	} );\u000a\u000a	/**\u000a	 * Global command class definitions and global helpers.\u000a	 *\u000a	 * @class\u000a	 * @singleton\u000a	 */\u000a	CKEDITOR.plugins.indent = {\u000a		/**\u000a		 * A base class for a generic command definition, responsible mainly for creating\u000a		 * Increase Indent and Decrease Indent toolbar buttons as well as for refreshing\u000a		 * UI states.\u000a		 *\u000a		 * Commands of this class do not perform any indentation by themselves. They\u000a		 * delegate this job to content-specific indentation commands (i.e. indentlist).\u000a		 *\u000a		 * @class CKEDITOR.plugins.indent.genericDefinition\u000a		 * @extends CKEDITOR.commandDefinition\u000a		 * @param {CKEDITOR.editor} editor The editor instance this command will be\u000a		 * applied to.\u000a		 * @param {String} name The name of the command.\u000a		 * @param {Boolean} [isIndent] Defines the command as indenting or outdenting.\u000a		 */\u000a		genericDefinition: function( isIndent ) {\u000a			/**\u000a			 * Determines whether the command belongs to the indentation family.\u000a			 * Otherwise it is assumed to be an outdenting command.\u000a			 *\u000a			 * @readonly\u000a			 * @property {Boolean} [=false]\u000a			 */\u000a			this.isIndent = !!isIndent;\u000a\u000a			// Mimic naive startDisabled behavior for outdent.\u000a			this.startDisabled = !this.isIndent;\u000a		},\u000a\u000a		/**\u000a		 * A base class for specific indentation command definitions responsible for\u000a		 * handling a pre-defined set of elements i.e. indentlist for lists or\u000a		 * indentblock for text block elements.\u000a		 *\u000a		 * Commands of this class perform indentation operations and modify the DOM structure.\u000a		 * They listen for events fired by {@link CKEDITOR.plugins.indent.genericDefinition}\u000a		 * and execute defined actions.\u000a		 *\u000a		 * **NOTE**: This is not an {@link CKEDITOR.command editor command}.\u000a		 * Context-specific commands are internal, for indentation system only.\u000a		 *\u000a		 * @class CKEDITOR.plugins.indent.specificDefinition\u000a		 * @param {CKEDITOR.editor} editor The editor instance this command will be\u000a		 * applied to.\u000a		 * @param {String} name The name of the command.\u000a		 * @param {Boolean} [isIndent] Defines the command as indenting or outdenting.\u000a		 */\u000a		specificDefinition: function( editor, name, isIndent ) {\u000a			this.name = name;\u000a			this.editor = editor;\u000a\u000a			/**\u000a			 * An object of jobs handled by the command. Each job consists\u000a			 * of two functions: `refresh` and `exec` as well as the execution priority.\u000a			 *\u000a			 *	* The `refresh` function determines whether a job is doable for\u000a			 *	  a particular context. These functions are executed in the\u000a			 *	  order of priorities, one by one, for all plugins that registered\u000a			 *	  jobs. As jobs are related to generic commands, refreshing\u000a			 *	  occurs when the global command is firing the `refresh` event.\u000a			 *\u000a			 *	  **Note**: This function must return either {@link CKEDITOR#TRISTATE_DISABLED}\u000a			 *	  or {@link CKEDITOR#TRISTATE_OFF}.\u000a			 *\u000a			 *	* The `exec` function modifies the DOM if possible. Just like\u000a			 *	  `refresh`, `exec` functions are executed in the order of priorities\u000a			 *	  while the generic command is executed. This function is not executed\u000a			 *	  if `refresh` for this job returned {@link CKEDITOR#TRISTATE_DISABLED}.\u000a			 *\u000a			 *	  **Note**: This function must return a Boolean value, indicating whether it\u000a			 *	  was successful. If a job was successful, then no other jobs are being executed.\u000a			 *\u000a			 * Sample definition:\u000a			 *\u000a			 *		command.jobs = {\u000a			 *			// Priority = 20.\u000a			 *			'20': {\u000a			 *				refresh( editor, path ) {\u000a			 *					if ( condition )\u000a			 *						return CKEDITOR.TRISTATE_OFF;\u000a			 *					else\u000a			 *						return CKEDITOR.TRISTATE_DISABLED;\u000a			 *				},\u000a			 *				exec( editor ) {\u000a			 *					// DOM modified! This was OK.\u000a			 *					return true;\u000a			 *				}\u000a			 *			},\u000a			 *			// Priority = 60. This job is done later.\u000a			 *			'60': {\u000a			 *				// Another job.\u000a			 *			}\u000a			 *		};\u000a			 *\u000a			 * For additional information, please check comments for\u000a			 * the `setupGenericListeners` function.\u000a			 *\u000a			 * @readonly\u000a			 * @property {Object} [={}]\u000a			 */\u000a			this.jobs = {};\u000a\u000a			/**\u000a			 * Determines whether the editor that the command belongs to has\u000a			 * {@link CKEDITOR.config#enterMode config.enterMode} set to {@link CKEDITOR#ENTER_BR}.\u000a			 *\u000a			 * @readonly\u000a			 * @see CKEDITOR.config#enterMode\u000a			 * @property {Boolean} [=false]\u000a			 */\u000a			this.enterBr = editor.config.enterMode == CKEDITOR.ENTER_BR;\u000a\u000a			/**\u000a			 * Determines whether the command belongs to the indentation family.\u000a			 * Otherwise it is assumed to be an outdenting command.\u000a			 *\u000a			 * @readonly\u000a			 * @property {Boolean} [=false]\u000a			 */\u000a			this.isIndent = !!isIndent;\u000a\u000a			/**\u000a			 * The name of the global command related to this one.\u000a			 *\u000a			 * @readonly\u000a			 */\u000a			this.relatedGlobal = isIndent ? 'indent' : 'outdent';\u000a\u000a			/**\u000a			 * A keystroke associated with this command (*Tab* or *Shift+Tab*).\u000a			 *\u000a			 * @readonly\u000a			 */\u000a			this.indentKey = isIndent ? 9 : CKEDITOR.SHIFT + 9;\u000a\u000a			/**\u000a			 * Stores created markers for the command so they can eventually be\u000a			 * purged after the `exec` function is run.\u000a			 */\u000a			this.database = {};\u000a		},\u000a\u000a		/**\u000a		 * Registers content-specific commands as a part of the indentation system\u000a		 * directed by generic commands. Once a command is registered,\u000a		 * it listens for events of a related generic command.\u000a		 *\u000a		 *		CKEDITOR.plugins.indent.registerCommands( editor, {\u000a		 *			'indentlist': new indentListCommand( editor, 'indentlist' ),\u000a		 *			'outdentlist': new indentListCommand( editor, 'outdentlist' )\u000a		 *		} );\u000a		 *\u000a		 * Content-specific commands listen for the generic command's `exec` and\u000a		 * try to execute their own jobs, one after another. If some execution is\u000a		 * successful, `evt.data.done` is set so no more jobs (commands) are involved.\u000a		 *\u000a		 * Content-specific commands also listen for the generic command's `refresh`\u000a		 * and fill the `evt.data.states` object with states of jobs. A generic command\u000a		 * uses this data to determine its own state and to update the UI.\u000a		 *\u000a		 * @member CKEDITOR.plugins.indent\u000a		 * @param {CKEDITOR.editor} editor The editor instance this command is\u000a		 * applied to.\u000a		 * @param {Object} commands An object of {@link CKEDITOR.command}.\u000a		 */\u000a		registerCommands: function( editor, commands ) {\u000a			editor.on( 'pluginsLoaded', function() {\u000a				for ( var name in commands ) {\u000a					( function( editor, command ) {\u000a						var relatedGlobal = editor.getCommand( command.relatedGlobal );\u000a\u000a						for ( var priority in command.jobs ) {\u000a							// Observe generic exec event and execute command when necessary.\u000a							// If the command was successfully handled by the command and\u000a							// DOM has been modified, stop event propagation so no other plugin\u000a							// will bother. Job is done.\u000a							relatedGlobal.on( 'exec', function( evt ) {\u000a								if ( evt.data.done )\u000a									return;\u000a\u000a								// Make sure that anything this command will do is invisible\u000a								// for undoManager. What undoManager only can see and\u000a								// remember is the execution of the global command (relatedGlobal).\u000a								editor.fire( 'lockSnapshot' );\u000a\u000a								if ( command.execJob( editor, priority ) )\u000a									evt.data.done = true;\u000a\u000a								editor.fire( 'unlockSnapshot' );\u000a\u000a								// Clean up the markers.\u000a								CKEDITOR.dom.element.clearAllMarkers( command.database );\u000a							}, this, null, priority );\u000a\u000a							// Observe generic refresh event and force command refresh.\u000a							// Once refreshed, save command state in event data\u000a							// so generic command plugin can update its own state and UI.\u000a							relatedGlobal.on( 'refresh', function( evt ) {\u000a								if ( !evt.data.states )\u000a									evt.data.states = {};\u000a\u000a								evt.data.states[ command.name + '@' + priority ] =\u000a									command.refreshJob( editor, priority, evt.data.path );\u000a							}, this, null, priority );\u000a						}\u000a\u000a						// Since specific indent commands have no UI elements,\u000a						// they need to be manually registered as a editor feature.\u000a						editor.addFeature( command );\u000a					} )( this, commands[ name ] );\u000a				}\u000a			} );\u000a		}\u000a	};\u000a\u000a	CKEDITOR.plugins.indent.genericDefinition.prototype = {\u000a		context: 'p',\u000a\u000a		exec: function() {}\u000a	};\u000a\u000a	CKEDITOR.plugins.indent.specificDefinition.prototype = {\u000a		/**\u000a		 * Executes the content-specific procedure if the context is correct.\u000a		 * It calls the `exec` function of a job of the given `priority`\u000a		 * that modifies the DOM.\u000a		 *\u000a		 * @param {CKEDITOR.editor} editor The editor instance this command\u000a		 * will be applied to.\u000a		 * @param {Number} priority The priority of the job to be executed.\u000a		 * @returns {Boolean} Indicates whether the job was successful.\u000a		 */\u000a		execJob: function( editor, priority ) {\u000a			var job = this.jobs[ priority ];\u000a\u000a			if ( job.state != TRISTATE_DISABLED )\u000a				return job.exec.call( this, editor );\u000a		},\u000a\u000a		/**\u000a		 * Calls the `refresh` function of a job of the given `priority`.\u000a		 * The function returns the state of the job which can be either\u000a		 * {@link CKEDITOR#TRISTATE_DISABLED} or {@link CKEDITOR#TRISTATE_OFF}.\u000a		 *\u000a		 * @param {CKEDITOR.editor} editor The editor instance this command\u000a		 * will be applied to.\u000a		 * @param {Number} priority The priority of the job to be executed.\u000a		 * @returns {Number} The state of the job.\u000a		 */\u000a		refreshJob: function( editor, priority, path ) {\u000a			var job = this.jobs[ priority ];\u000a\u000a			if ( !editor.activeFilter.checkFeature( this ) )\u000a				job.state = TRISTATE_DISABLED;\u000a			else\u000a				job.state = job.refresh.call( this, editor, path );\u000a\u000a			return job.state;\u000a		},\u000a\u000a		/**\u000a		 * Checks if the element path contains the element handled\u000a		 * by this indentation command.\u000a		 *\u000a		 * @param {CKEDITOR.dom.elementPath} node A path to be checked.\u000a		 * @returns {CKEDITOR.dom.element}\u000a		 */\u000a		getContext: function( path ) {\u000a			return path.contains( this.context );\u000a		}\u000a	};\u000a\u000a	/**\u000a	 * Attaches event listeners for this generic command. Since the indentation\u000a	 * system is event-oriented, generic commands communicate with\u000a	 * content-specific commands using the `exec` and `refresh` events.\u000a	 *\u000a	 * Listener priorities are crucial. Different indentation phases\u000a	 * are executed with different priorities.\u000a	 *\u000a	 * For the `exec` event:\u000a	 *\u000a	 *	* 0: Selection and bookmarks are saved by the generic command.\u000a	 *	* 1-99: Content-specific commands try to indent the code by executing\u000a	 *	  their own jobs ({@link CKEDITOR.plugins.indent.specificDefinition#jobs}).\u000a	 *	* 100: Bookmarks are re-selected by the generic command.\u000a	 *\u000a	 * The visual interpretation looks as follows:\u000a	 *\u000a	 *		  +------------------+\u000a	 *		  | Exec event fired |\u000a	 *		  +------ + ---------+\u000a	 *		          |\u000a	 *		        0 -<----------+ Selection and bookmarks saved.\u000a	 *		          |\u000a	 *		          |\u000a	 *		       25 -<---+ Exec 1st job of plugin#1 (return false, continuing...).\u000a	 *		          |\u000a	 *		          |\u000a	 *		       50 -<---+ Exec 1st job of plugin#2 (return false, continuing...).\u000a	 *		          |\u000a	 *		          |\u000a	 *		       75 -<---+ Exec 2nd job of plugin#1 (only if plugin#2 failed).\u000a	 *		          |\u000a	 *		          |\u000a	 *		      100 -<-----------+ Re-select bookmarks, clean-up.\u000a	 *		          |\u000a	 *		+-------- v ----------+\u000a	 *		| Exec event finished |\u000a	 *		+---------------------+\u000a	 *\u000a	 * For the `refresh` event:\u000a	 *\u000a	 *	* <100: Content-specific commands refresh their job states according\u000a	 *	  to the given path. Jobs save their states in the `evt.data.states` object\u000a	 *	  passed along with the event. This can be either {@link CKEDITOR#TRISTATE_DISABLED}\u000a	 *	  or {@link CKEDITOR#TRISTATE_OFF}.\u000a	 *	* 100: Command state is determined according to what states\u000a	 *	  have been returned by content-specific jobs (`evt.data.states`).\u000a	 *	  UI elements are updated at this stage.\u000a	 *\u000a	 *	  **Note**: If there is at least one job with the {@link CKEDITOR#TRISTATE_OFF} state,\u000a	 *	  then the generic command state is also {@link CKEDITOR#TRISTATE_OFF}. Otherwise,\u000a	 *	  the command state is {@link CKEDITOR#TRISTATE_DISABLED}.\u000a	 *\u000a	 * @param {CKEDITOR.command} command The command to be set up.\u000a	 * @private\u000a	 */\u000a	function setupGenericListeners( editor, command ) {\u000a		var selection, bookmarks;\u000a\u000a		// Set the command state according to content-specific\u000a		// command states.\u000a		command.on( 'refresh', function( evt ) {\u000a			// If no state comes with event data, disable command.\u000a			var states = [ TRISTATE_DISABLED ];\u000a\u000a			for ( var s in evt.data.states )\u000a				states.push( evt.data.states[ s ] );\u000a\u000a			this.setState( CKEDITOR.tools.search( states, TRISTATE_OFF ) ?\u000a					TRISTATE_OFF\u000a				:\u000a					TRISTATE_DISABLED );\u000a		}, command, null, 100 );\u000a\u000a		// Initialization. Save bookmarks and mark event as not handled\u000a		// by any plugin (command) yet.\u000a		command.on( 'exec', function( evt ) {\u000a			selection = editor.getSelection();\u000a			bookmarks = selection.createBookmarks( 1 );\u000a\u000a			// Mark execution as not handled yet.\u000a			if ( !evt.data )\u000a				evt.data = {};\u000a\u000a			evt.data.done = false;\u000a		}, command, null, 0 );\u000a\u000a		// Housekeeping. Make sure selectionChange will be called.\u000a		// Also re-select previously saved bookmarks.\u000a		command.on( 'exec', function( evt ) {\u000a			editor.forceNextSelectionCheck();\u000a			selection.selectBookmarks( bookmarks );\u000a		}, command, null, 100 );\u000a	}\u000a} )();\u000a\ufeff/*\u000aCopyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000aFor licensing, see LICENSE.md or http://ckeditor.com/license\u000a*/\u000aCKEDITOR.plugins.setLang( 'indent', 'en', {\u000a	indent: 'Increase Indent',\u000a	outdent: 'Decrease Indent'\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	var template = '<a id="{id}"' +\u000a		' class="cke_button cke_button__{name} cke_button_{state} {cls}"' +\u000a		( CKEDITOR.env.gecko && !CKEDITOR.env.hc ? '' : ' href="javascript:void(\u005c'{titleJs}\u005c')"' ) +\u000a		' title="{title}"' +\u000a		' tabindex="-1"' +\u000a		' hidefocus="true"' +\u000a		' role="button"' +\u000a		' aria-labelledby="{id}_label"' +\u000a		' aria-haspopup="{hasArrow}"' +\u000a		' aria-disabled="{ariaDisabled}"';\u000a\u000a	// Some browsers don't cancel key events in the keydown but in the\u000a	// keypress.\u000a	// TODO: Check if really needed.\u000a	if ( CKEDITOR.env.gecko && CKEDITOR.env.mac )\u000a		template += ' onkeypress="return false;"';\u000a\u000a	// With Firefox, we need to force the button to redraw, otherwise it\u000a	// will remain in the focus state.\u000a	if ( CKEDITOR.env.gecko )\u000a		template += ' onblur="this.style.cssText = this.style.cssText;"';\u000a\u000a	template += ' onkeydown="return CKEDITOR.tools.callFunction({keydownFn},event);"' +\u000a		' onfocus="return CKEDITOR.tools.callFunction({focusFn},event);" ' +\u000a		( CKEDITOR.env.ie ? 'onclick="return false;" onmouseup' : 'onclick' ) + // #188\u000a			'="CKEDITOR.tools.callFunction({clickFn},this);return false;">' +\u000a		'<span class="cke_button_icon cke_button__{iconName}_icon" style="{style}"';\u000a\u000a\u000a	template += '>&nbsp;</span>' +\u000a		'<span id="{id}_label" class="cke_button_label cke_button__{name}_label" aria-hidden="false">{label}</span>' +\u000a		'{arrowHtml}' +\u000a		'</a>';\u000a\u000a	var templateArrow = '<span class="cke_button_arrow">' +\u000a		// BLACK DOWN-POINTING TRIANGLE\u000a	( CKEDITOR.env.hc ? '&#9660;' : '' ) +\u000a		'</span>';\u000a\u000a	var btnArrowTpl = CKEDITOR.addTemplate( 'buttonArrow', templateArrow ),\u000a		btnTpl = CKEDITOR.addTemplate( 'button', template );\u000a\u000a	CKEDITOR.plugins.add( 'button', {\u000a		lang: 'ca,cs,de,el,en,en-gb,eo,fa,fi,fr,gl,he,hu,it,ja,km,nb,nl,pl,pt,pt-br,ro,ru,sk,sl,sv,tr,tt,uk,vi,zh-cn', // %REMOVE_LINE_CORE%\u000a		beforeInit: function( editor ) {\u000a			editor.ui.addHandler( CKEDITOR.UI_BUTTON, CKEDITOR.ui.button.handler );\u000a		}\u000a	} );\u000a\u000a	/**\u000a	 * Button UI element.\u000a	 *\u000a	 * @readonly\u000a	 * @property {String} [='button']\u000a	 * @member CKEDITOR\u000a	 */\u000a	CKEDITOR.UI_BUTTON = 'button';\u000a\u000a	/**\u000a	 * Represents a button UI element. This class should not be called directly. To\u000a	 * create new buttons use {@link CKEDITOR.ui#addButton} instead.\u000a	 *\u000a	 * @class\u000a	 * @constructor Creates a button class instance.\u000a	 * @param {Object} definition The button definition.\u000a	 */\u000a	CKEDITOR.ui.button = function( definition ) {\u000a		CKEDITOR.tools.extend( this, definition,\u000a		// Set defaults.\u000a		{\u000a			title: definition.label,\u000a			click: definition.click ||\u000a			function( editor ) {\u000a				editor.execCommand( definition.command );\u000a			}\u000a		} );\u000a\u000a		this._ = {};\u000a	};\u000a\u000a	/**\u000a	 * Represents the button handler object.\u000a	 *\u000a	 * @class\u000a	 * @singleton\u000a	 * @extends CKEDITOR.ui.handlerDefinition\u000a	 */\u000a	CKEDITOR.ui.button.handler = {\u000a		/**\u000a		 * Transforms a button definition in a {@link CKEDITOR.ui.button} instance.\u000a		 *\u000a		 * @member CKEDITOR.ui.button.handler\u000a		 * @param {Object} definition\u000a		 * @returns {CKEDITOR.ui.button}\u000a		 */\u000a		create: function( definition ) {\u000a			return new CKEDITOR.ui.button( definition );\u000a		}\u000a	};\u000a\u000a	/** @class CKEDITOR.ui.button */\u000a	CKEDITOR.ui.button.prototype = {\u000a		/**\u000a		 * Renders the button.\u000a		 *\u000a		 * @param {CKEDITOR.editor} editor The editor instance which this button is\u000a		 * to be used by.\u000a		 * @param {Array} output The output array to which the HTML code related to\u000a		 * this button should be appended.\u000a		 */\u000a		render: function( editor, output ) {\u000a			var env = CKEDITOR.env,\u000a				id = this._.id = CKEDITOR.tools.getNextId(),\u000a				stateName = '',\u000a				command = this.command,\u000a				// Get the command name.\u000a				clickFn;\u000a\u000a			this._.editor = editor;\u000a\u000a			var instance = {\u000a				id: id,\u000a				button: this,\u000a				editor: editor,\u000a				focus: function() {\u000a					var element = CKEDITOR.document.getById( id );\u000a					element.focus();\u000a				},\u000a				execute: function() {\u000a					this.button.click( editor );\u000a				},\u000a				attach: function( editor ) {\u000a					this.button.attach( editor );\u000a				}\u000a			};\u000a\u000a			var keydownFn = CKEDITOR.tools.addFunction( function( ev ) {\u000a				if ( instance.onkey ) {\u000a					ev = new CKEDITOR.dom.event( ev );\u000a					return ( instance.onkey( instance, ev.getKeystroke() ) !== false );\u000a				}\u000a			} );\u000a\u000a			var focusFn = CKEDITOR.tools.addFunction( function( ev ) {\u000a				var retVal;\u000a\u000a				if ( instance.onfocus )\u000a					retVal = ( instance.onfocus( instance, new CKEDITOR.dom.event( ev ) ) !== false );\u000a\u000a				return retVal;\u000a			} );\u000a\u000a			var selLocked = 0;\u000a\u000a			instance.clickFn = clickFn = CKEDITOR.tools.addFunction( function() {\u000a\u000a				// Restore locked selection in Opera.\u000a				if ( selLocked ) {\u000a					editor.unlockSelection( 1 );\u000a					selLocked = 0;\u000a				}\u000a				instance.execute();\u000a\u000a				// Fixed iOS focus issue when your press disabled button (#12381).\u000a				if ( env.iOS ) {\u000a					editor.focus();\u000a				}\u000a			} );\u000a\u000a\u000a			// Indicate a mode sensitive button.\u000a			if ( this.modes ) {\u000a				var modeStates = {};\u000a\u000a				function updateState() {\u000a					// "this" is a CKEDITOR.ui.button instance.\u000a\u000a					var mode = editor.mode;\u000a\u000a					if ( mode ) {\u000a						// Restore saved button state.\u000a						var state = this.modes[ mode ] ? modeStates[ mode ] != undefined ? modeStates[ mode ] : CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED;\u000a\u000a						state = editor.readOnly && !this.readOnly ? CKEDITOR.TRISTATE_DISABLED : state;\u000a\u000a						this.setState( state );\u000a\u000a						// Let plugin to disable button.\u000a						if ( this.refresh )\u000a							this.refresh();\u000a					}\u000a				}\u000a\u000a				editor.on( 'beforeModeUnload', function() {\u000a					if ( editor.mode && this._.state != CKEDITOR.TRISTATE_DISABLED )\u000a						modeStates[ editor.mode ] = this._.state;\u000a				}, this );\u000a\u000a				// Update status when activeFilter, mode or readOnly changes.\u000a				editor.on( 'activeFilterChange', updateState, this );\u000a				editor.on( 'mode', updateState, this );\u000a				// If this button is sensitive to readOnly state, update it accordingly.\u000a				!this.readOnly && editor.on( 'readOnly', updateState, this );\u000a\u000a			} else if ( command ) {\u000a				// Get the command instance.\u000a				command = editor.getCommand( command );\u000a\u000a				if ( command ) {\u000a					command.on( 'state', function() {\u000a						this.setState( command.state );\u000a					}, this );\u000a\u000a					stateName += ( command.state == CKEDITOR.TRISTATE_ON ? 'on' : command.state == CKEDITOR.TRISTATE_DISABLED ? 'disabled' : 'off' );\u000a				}\u000a			}\u000a\u000a			// For button that has text-direction awareness on selection path.\u000a			if ( this.directional ) {\u000a				editor.on( 'contentDirChanged', function( evt ) {\u000a					var el = CKEDITOR.document.getById( this._.id ),\u000a						icon = el.getFirst();\u000a\u000a					var pathDir = evt.data;\u000a\u000a					// Make a minor direction change to become style-able for the skin icon.\u000a					if ( pathDir !=  editor.lang.dir )\u000a						el.addClass( 'cke_' + pathDir );\u000a					else\u000a						el.removeClass( 'cke_ltr' ).removeClass( 'cke_rtl' );\u000a\u000a					// Inline style update for the plugin icon.\u000a					icon.setAttribute( 'style', CKEDITOR.skin.getIconStyle( iconName, pathDir == 'rtl', this.icon, this.iconOffset ) );\u000a				}, this );\u000a			}\u000a\u000a			if ( !command )\u000a				stateName += 'off';\u000a\u000a			var name = this.name || this.command,\u000a				iconName = name;\u000a\u000a			// Check if we're pointing to an icon defined by another command. (#9555)\u000a			if ( this.icon && !( /\u005c./ ).test( this.icon ) ) {\u000a				iconName = this.icon;\u000a				this.icon = null;\u000a			}\u000a\u000a			var params = {\u000a				id: id,\u000a				name: name,\u000a				iconName: iconName,\u000a				label: this.label,\u000a				cls: this.className || '',\u000a				state: stateName,\u000a				ariaDisabled: stateName == 'disabled' ? 'true' : 'false',\u000a				title: this.title,\u000a				titleJs: env.gecko && !env.hc ? '' : ( this.title || '' ).replace( "'", '' ),\u000a				hasArrow: this.hasArrow ? 'true' : 'false',\u000a				keydownFn: keydownFn,\u000a				focusFn: focusFn,\u000a				clickFn: clickFn,\u000a				style: CKEDITOR.skin.getIconStyle( iconName, ( editor.lang.dir == 'rtl' ), this.icon, this.iconOffset ),\u000a				arrowHtml: this.hasArrow ? btnArrowTpl.output() : ''\u000a			};\u000a\u000a			btnTpl.output( params, output );\u000a\u000a			if ( this.onRender )\u000a				this.onRender();\u000a\u000a			return instance;\u000a		},\u000a\u000a		/**\u000a		 * Sets the button state.\u000a		 *\u000a		 * @param {Number} state Indicates the button state. One of {@link CKEDITOR#TRISTATE_ON},\u000a		 * {@link CKEDITOR#TRISTATE_OFF}, or {@link CKEDITOR#TRISTATE_DISABLED}.\u000a		 */\u000a		setState: function( state ) {\u000a			if ( this._.state == state )\u000a				return false;\u000a\u000a			this._.state = state;\u000a\u000a			var element = CKEDITOR.document.getById( this._.id );\u000a\u000a			if ( element ) {\u000a				element.setState( state, 'cke_button' );\u000a\u000a				state == CKEDITOR.TRISTATE_DISABLED ?\u000a					element.setAttribute( 'aria-disabled', true ) :\u000a					element.removeAttribute( 'aria-disabled' );\u000a\u000a				if ( !this.hasArrow ) {\u000a					// Note: aria-pressed attribute should not be added to menuButton instances. (#11331)\u000a					state == CKEDITOR.TRISTATE_ON ?\u000a						element.setAttribute( 'aria-pressed', true ) :\u000a						element.removeAttribute( 'aria-pressed' );\u000a				} else {\u000a					var newLabel = state == CKEDITOR.TRISTATE_ON ?\u000a						this._.editor.lang.button.selectedLabel.replace( /%1/g, this.label ) : this.label;\u000a					CKEDITOR.document.getById( this._.id + '_label' ).setText( newLabel );\u000a				}\u000a\u000a				return true;\u000a			} else\u000a				return false;\u000a		},\u000a\u000a		/**\u000a		 * Gets the button state.\u000a		 *\u000a		 * @returns {Number} The button state. One of {@link CKEDITOR#TRISTATE_ON},\u000a		 * {@link CKEDITOR#TRISTATE_OFF}, or {@link CKEDITOR#TRISTATE_DISABLED}.\u000a		 */\u000a		getState: function( state ) {\u000a			return this._.state;\u000a		},\u000a\u000a		/**\u000a		 * Returns this button's {@link CKEDITOR.feature} instance.\u000a		 *\u000a		 * It may be this button instance if it has at least one of\u000a		 * `allowedContent` and `requiredContent` properties. Otherwise,\u000a		 * if a command is bound to this button by the `command` property, then\u000a		 * that command will be returned.\u000a		 *\u000a		 * This method implements the {@link CKEDITOR.feature#toFeature} interface method.\u000a		 *\u000a		 * @since 4.1\u000a		 * @param {CKEDITOR.editor} Editor instance.\u000a		 * @returns {CKEDITOR.feature} The feature.\u000a		 */\u000a		toFeature: function( editor ) {\u000a			if ( this._.feature )\u000a				return this._.feature;\u000a\u000a			var feature = this;\u000a\u000a			// If button isn't a feature, return command if is bound.\u000a			if ( !this.allowedContent && !this.requiredContent && this.command )\u000a				feature = editor.getCommand( this.command ) || feature;\u000a\u000a			return this._.feature = feature;\u000a		}\u000a	};\u000a\u000a	/**\u000a	 * Adds a button definition to the UI elements list.\u000a	 *\u000a	 *		editorInstance.ui.addButton( 'MyBold', {\u000a	 *			label: 'My Bold',\u000a	 *			command: 'bold',\u000a	 *			toolbar: 'basicstyles,1'\u000a	 *		} );\u000a	 *\u000a	 * @member CKEDITOR.ui\u000a	 * @param {String} name The button name.\u000a	 * @param {Object} definition The button definition.\u000a	 * @param {String} definition.label The textual part of the button (if visible) and its tooltip.\u000a	 * @param {String} definition.command The command to be executed once the button is activated.\u000a	 * @param {String} definition.toolbar The {@link CKEDITOR.config#toolbarGroups toolbar group} into which\u000a	 * the button will be added. An optional index value (separated by a comma) determines the button position within the group.\u000a	 */\u000a	CKEDITOR.ui.prototype.addButton = function( name, definition ) {\u000a		this.add( name, CKEDITOR.UI_BUTTON, definition );\u000a	};\u000a\u000a} )();\u000a\u000a/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000aCKEDITOR.plugins.setLang( 'button', 'en', {\u000a	selectedLabel: '%1 (Selected)'\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	CKEDITOR.plugins.add( 'panel', {\u000a		beforeInit: function( editor ) {\u000a			editor.ui.addHandler( CKEDITOR.UI_PANEL, CKEDITOR.ui.panel.handler );\u000a		}\u000a	} );\u000a\u000a	/**\u000a	 * Panel UI element.\u000a	 *\u000a	 * @readonly\u000a	 * @property {String} [='panel']\u000a	 * @member CKEDITOR\u000a	 */\u000a	CKEDITOR.UI_PANEL = 'panel';\u000a\u000a	/**\u000a	 * @class\u000a	 * @constructor Creates a panel class instance.\u000a	 * @param {CKEDITOR.dom.document} document\u000a	 * @param {Object} definition\u000a	 */\u000a	CKEDITOR.ui.panel = function( document, definition ) {\u000a		// Copy all definition properties to this object.\u000a		if ( definition )\u000a			CKEDITOR.tools.extend( this, definition );\u000a\u000a		// Set defaults.\u000a		CKEDITOR.tools.extend( this, {\u000a			className: '',\u000a			css: []\u000a		} );\u000a\u000a		this.id = CKEDITOR.tools.getNextId();\u000a		this.document = document;\u000a		this.isFramed = this.forceIFrame || this.css.length;\u000a\u000a		this._ = {\u000a			blocks: {}\u000a		};\u000a	};\u000a\u000a	/**\u000a	 * Represents panel handler object.\u000a	 *\u000a	 * @class\u000a	 * @singleton\u000a	 * @extends CKEDITOR.ui.handlerDefinition\u000a	 */\u000a	CKEDITOR.ui.panel.handler = {\u000a		/**\u000a		 * Transforms a panel definition in a {@link CKEDITOR.ui.panel} instance.\u000a		 *\u000a		 * @param {Object} definition\u000a		 * @returns {CKEDITOR.ui.panel}\u000a		 */\u000a		create: function( definition ) {\u000a			return new CKEDITOR.ui.panel( definition );\u000a		}\u000a	};\u000a\u000a	var panelTpl = CKEDITOR.addTemplate( 'panel', '<div lang="{langCode}" id="{id}" dir={dir}' +\u000a		' class="cke cke_reset_all {editorId} cke_panel cke_panel {cls} cke_{dir}"' +\u000a		' style="z-index:{z-index}" role="presentation">' +\u000a		'{frame}' +\u000a		'</div>' );\u000a\u000a	var frameTpl = CKEDITOR.addTemplate( 'panel-frame', '<iframe id="{id}" class="cke_panel_frame" role="presentation" frameborder="0" src="{src}"></iframe>' );\u000a\u000a	var frameDocTpl = CKEDITOR.addTemplate( 'panel-frame-inner', '<!DOCTYPE html>' +\u000a		'<html class="cke_panel_container {env}" dir="{dir}" lang="{langCode}">' +\u000a			'<head>{css}</head>' +\u000a			'<body class="cke_{dir}"' +\u000a				' style="margin:0;padding:0" onload="{onload}"></body>' +\u000a		'<\u005c/html>' );\u000a\u000a	/** @class CKEDITOR.ui.panel */\u000a	CKEDITOR.ui.panel.prototype = {\u000a		/**\u000a		 * Renders the combo.\u000a		 *\u000a		 * @param {CKEDITOR.editor} editor The editor instance which this button is\u000a		 * to be used by.\u000a		 * @param {Array} [output] The output array to which append the HTML relative\u000a		 * to this button.\u000a		 */\u000a		render: function( editor, output ) {\u000a			this.getHolderElement = function() {\u000a				var holder = this._.holder;\u000a\u000a				if ( !holder ) {\u000a					if ( this.isFramed ) {\u000a						var iframe = this.document.getById( this.id + '_frame' ),\u000a							parentDiv = iframe.getParent(),\u000a							doc = iframe.getFrameDocument();\u000a\u000a						// Make it scrollable on iOS. (#8308)\u000a						CKEDITOR.env.iOS && parentDiv.setStyles( {\u000a							'overflow': 'scroll',\u000a							'-webkit-overflow-scrolling': 'touch'\u000a						} );\u000a\u000a						var onLoad = CKEDITOR.tools.addFunction( CKEDITOR.tools.bind( function( ev ) {\u000a							this.isLoaded = true;\u000a							if ( this.onLoad )\u000a								this.onLoad();\u000a						}, this ) );\u000a\u000a						doc.write( frameDocTpl.output( CKEDITOR.tools.extend( {\u000a							css: CKEDITOR.tools.buildStyleHtml( this.css ),\u000a							onload: 'window.parent.CKEDITOR.tools.callFunction(' + onLoad + ');'\u000a						}, data ) ) );\u000a\u000a						var win = doc.getWindow();\u000a\u000a						// Register the CKEDITOR global.\u000a						win.$.CKEDITOR = CKEDITOR;\u000a\u000a						// Arrow keys for scrolling is only preventable with 'keypress' event in Opera (#4534).\u000a						doc.on( 'keydown', function( evt ) {\u000a							var keystroke = evt.data.getKeystroke(),\u000a								dir = this.document.getById( this.id ).getAttribute( 'dir' );\u000a\u000a							// Delegate key processing to block.\u000a							if ( this._.onKeyDown && this._.onKeyDown( keystroke ) === false ) {\u000a								evt.data.preventDefault();\u000a								return;\u000a							}\u000a\u000a							// ESC/ARROW-LEFT(ltr) OR ARROW-RIGHT(rtl)\u000a							if ( keystroke == 27 || keystroke == ( dir == 'rtl' ? 39 : 37 ) ) {\u000a								if ( this.onEscape && this.onEscape( keystroke ) === false )\u000a									evt.data.preventDefault();\u000a							}\u000a						}, this );\u000a\u000a						holder = doc.getBody();\u000a						holder.unselectable();\u000a						CKEDITOR.env.air && CKEDITOR.tools.callFunction( onLoad );\u000a					} else\u000a						holder = this.document.getById( this.id );\u000a\u000a					this._.holder = holder;\u000a				}\u000a\u000a				return holder;\u000a			};\u000a\u000a			var data = {\u000a				editorId: editor.id,\u000a				id: this.id,\u000a				langCode: editor.langCode,\u000a				dir: editor.lang.dir,\u000a				cls: this.className,\u000a				frame: '',\u000a				env: CKEDITOR.env.cssClass,\u000a				'z-index': editor.config.baseFloatZIndex + 1\u000a			};\u000a\u000a			if ( this.isFramed ) {\u000a				// With IE, the custom domain has to be taken care at first,\u000a				// for other browers, the 'src' attribute should be left empty to\u000a				// trigger iframe's 'load' event.\u000a				var src =\u000a					CKEDITOR.env.air ? 'javascript:void(0)' :\u000a					CKEDITOR.env.ie ? 'javascript:void(function(){' + encodeURIComponent(\u000a						'document.open();' +\u000a						// In IE, the document domain must be set any time we call document.open().\u000a						'(' + CKEDITOR.tools.fixDomain + ')();' +\u000a						'document.close();'\u000a					) + '}())' :\u000a					'';\u000a\u000a				data.frame = frameTpl.output( {\u000a					id: this.id + '_frame',\u000a					src: src\u000a				} );\u000a			}\u000a\u000a			var html = panelTpl.output( data );\u000a\u000a			if ( output )\u000a				output.push( html );\u000a\u000a			return html;\u000a		},\u000a\u000a		/**\u000a		 * @todo\u000a		 */\u000a		addBlock: function( name, block ) {\u000a			block = this._.blocks[ name ] = block instanceof CKEDITOR.ui.panel.block ? block : new CKEDITOR.ui.panel.block( this.getHolderElement(), block );\u000a\u000a			if ( !this._.currentBlock )\u000a				this.showBlock( name );\u000a\u000a			return block;\u000a		},\u000a\u000a		/**\u000a		 * @todo\u000a		 */\u000a		getBlock: function( name ) {\u000a			return this._.blocks[ name ];\u000a		},\u000a\u000a		/**\u000a		 * @todo\u000a		 */\u000a		showBlock: function( name ) {\u000a			var blocks = this._.blocks,\u000a				block = blocks[ name ],\u000a				current = this._.currentBlock;\u000a\u000a			// ARIA role works better in IE on the body element, while on the iframe\u000a			// for FF. (#8864)\u000a			var holder = !this.forceIFrame || CKEDITOR.env.ie ? this._.holder : this.document.getById( this.id + '_frame' );\u000a\u000a			if ( current )\u000a				current.hide();\u000a\u000a			this._.currentBlock = block;\u000a\u000a			CKEDITOR.fire( 'ariaWidget', holder );\u000a\u000a			// Reset the focus index, so it will always go into the first one.\u000a			block._.focusIndex = -1;\u000a\u000a			this._.onKeyDown = block.onKeyDown && CKEDITOR.tools.bind( block.onKeyDown, block );\u000a\u000a			block.show();\u000a\u000a			return block;\u000a		},\u000a\u000a		/**\u000a		 * @todo\u000a		 */\u000a		destroy: function() {\u000a			this.element && this.element.remove();\u000a		}\u000a	};\u000a\u000a	/**\u000a	 * @class\u000a	 *\u000a	 * @todo class and all methods\u000a	 */\u000a	CKEDITOR.ui.panel.block = CKEDITOR.tools.createClass( {\u000a		/**\u000a		 * Creates a block class instances.\u000a		 *\u000a		 * @constructor\u000a		 * @todo\u000a		 */\u000a		$: function( blockHolder, blockDefinition ) {\u000a			this.element = blockHolder.append( blockHolder.getDocument().createElement( 'div', {\u000a				attributes: {\u000a					'tabindex': -1,\u000a					'class': 'cke_panel_block'\u000a				},\u000a				styles: {\u000a					display: 'none'\u000a				}\u000a			} ) );\u000a\u000a			// Copy all definition properties to this object.\u000a			if ( blockDefinition )\u000a				CKEDITOR.tools.extend( this, blockDefinition );\u000a\u000a			// Set the a11y attributes of this element ...\u000a			this.element.setAttributes( {\u000a				'role': this.attributes.role || 'presentation',\u000a				'aria-label': this.attributes[ 'aria-label' ],\u000a				'title': this.attributes.title || this.attributes[ 'aria-label' ]\u000a			} );\u000a\u000a			this.keys = {};\u000a\u000a			this._.focusIndex = -1;\u000a\u000a			// Disable context menu for panels.\u000a			this.element.disableContextMenu();\u000a		},\u000a\u000a		_: {\u000a\u000a			/**\u000a			 * Mark the item specified by the index as current activated.\u000a			 */\u000a			markItem: function( index ) {\u000a				if ( index == -1 )\u000a					return;\u000a				var links = this.element.getElementsByTag( 'a' );\u000a				var item = links.getItem( this._.focusIndex = index );\u000a\u000a				// Safari need focus on the iframe window first(#3389), but we need\u000a				// lock the blur to avoid hiding the panel.\u000a				if ( CKEDITOR.env.webkit )\u000a					item.getDocument().getWindow().focus();\u000a				item.focus();\u000a\u000a				this.onMark && this.onMark( item );\u000a			}\u000a		},\u000a\u000a		proto: {\u000a			show: function() {\u000a				this.element.setStyle( 'display', '' );\u000a			},\u000a\u000a			hide: function() {\u000a				if ( !this.onHide || this.onHide.call( this ) !== true )\u000a					this.element.setStyle( 'display', 'none' );\u000a			},\u000a\u000a			onKeyDown: function( keystroke, noCycle ) {\u000a				var keyAction = this.keys[ keystroke ];\u000a				switch ( keyAction ) {\u000a					// Move forward.\u000a					case 'next':\u000a						var index = this._.focusIndex,\u000a							links = this.element.getElementsByTag( 'a' ),\u000a							link;\u000a\u000a						while ( ( link = links.getItem( ++index ) ) ) {\u000a							// Move the focus only if the element is marked with\u000a							// the _cke_focus and it it's visible (check if it has\u000a							// width).\u000a							if ( link.getAttribute( '_cke_focus' ) && link.$.offsetWidth ) {\u000a								this._.focusIndex = index;\u000a								link.focus();\u000a								break;\u000a							}\u000a						}\u000a\u000a						// If no link was found, cycle and restart from the top. (#11125)\u000a						if ( !link && !noCycle ) {\u000a							this._.focusIndex = -1;\u000a							return this.onKeyDown( keystroke, 1 );\u000a						}\u000a\u000a						return false;\u000a\u000a						// Move backward.\u000a					case 'prev':\u000a						index = this._.focusIndex;\u000a						links = this.element.getElementsByTag( 'a' );\u000a\u000a						while ( index > 0 && ( link = links.getItem( --index ) ) ) {\u000a							// Move the focus only if the element is marked with\u000a							// the _cke_focus and it it's visible (check if it has\u000a							// width).\u000a							if ( link.getAttribute( '_cke_focus' ) && link.$.offsetWidth ) {\u000a								this._.focusIndex = index;\u000a								link.focus();\u000a								break;\u000a							}\u000a\u000a							// Make sure link is null when the loop ends and nothing was\u000a							// found (#11125).\u000a							link = null;\u000a						}\u000a\u000a						// If no link was found, cycle and restart from the bottom. (#11125)\u000a						if ( !link && !noCycle ) {\u000a							this._.focusIndex = links.count();\u000a							return this.onKeyDown( keystroke, 1 );\u000a						}\u000a\u000a						return false;\u000a\u000a					case 'click':\u000a					case 'mouseup':\u000a						index = this._.focusIndex;\u000a						link = index >= 0 && this.element.getElementsByTag( 'a' ).getItem( index );\u000a\u000a						if ( link )\u000a							link.$[ keyAction ] ? link.$[ keyAction ]() : link.$[ 'on' + keyAction ]();\u000a\u000a						return false;\u000a				}\u000a\u000a				return true;\u000a			}\u000a		}\u000a	} );\u000a\u000a} )();\u000a\u000a/**\u000a * Fired when a panel is added to the document.\u000a *\u000a * @event ariaWidget\u000a * @member CKEDITOR\u000a * @param {Object} data The element wrapping the panel.\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000aCKEDITOR.plugins.add( 'floatpanel', {\u000a	requires: 'panel'\u000a} );\u000a\u000a( function() {\u000a	var panels = {};\u000a\u000a	function getPanel( editor, doc, parentElement, definition, level ) {\u000a		// Generates the panel key: docId-eleId-skinName-langDir[-uiColor][-CSSs][-level]\u000a		var key = CKEDITOR.tools.genKey( doc.getUniqueId(), parentElement.getUniqueId(), editor.lang.dir, editor.uiColor || '', definition.css || '', level || '' ),\u000a			panel = panels[ key ];\u000a\u000a		if ( !panel ) {\u000a			panel = panels[ key ] = new CKEDITOR.ui.panel( doc, definition );\u000a			panel.element = parentElement.append( CKEDITOR.dom.element.createFromHtml( panel.render( editor ), doc ) );\u000a\u000a			panel.element.setStyles( {\u000a				display: 'none',\u000a				position: 'absolute'\u000a			} );\u000a		}\u000a\u000a		return panel;\u000a	}\u000a\u000a	/**\u000a	 * Represents a floating panel UI element.\u000a	 *\u000a	 * It's reused by rich combos, color combos, menus, etc.\u000a	 * and it renders its content using {@link CKEDITOR.ui.panel}.\u000a	 *\u000a	 * @class\u000a	 * @todo\u000a	 */\u000a	CKEDITOR.ui.floatPanel = CKEDITOR.tools.createClass( {\u000a		/**\u000a		 * Creates a floatPanel class instance.\u000a		 *\u000a		 * @constructor\u000a		 * @param {CKEDITOR.editor} editor\u000a		 * @param {CKEDITOR.dom.element} parentElement\u000a		 * @param {Object} definition Definition of the panel that will be floating.\u000a		 * @param {Number} level\u000a		 */\u000a		$: function( editor, parentElement, definition, level ) {\u000a			definition.forceIFrame = 1;\u000a\u000a			// In case of editor with floating toolbar append panels that should float\u000a			// to the main UI element.\u000a			if ( definition.toolbarRelated && editor.elementMode == CKEDITOR.ELEMENT_MODE_INLINE )\u000a				parentElement = CKEDITOR.document.getById( 'cke_' + editor.name );\u000a\u000a			var doc = parentElement.getDocument(),\u000a				panel = getPanel( editor, doc, parentElement, definition, level || 0 ),\u000a				element = panel.element,\u000a				iframe = element.getFirst(),\u000a				that = this;\u000a\u000a			// Disable native browser menu. (#4825)\u000a			element.disableContextMenu();\u000a\u000a			this.element = element;\u000a\u000a			this._ = {\u000a				editor: editor,\u000a				// The panel that will be floating.\u000a				panel: panel,\u000a				parentElement: parentElement,\u000a				definition: definition,\u000a				document: doc,\u000a				iframe: iframe,\u000a				children: [],\u000a				dir: editor.lang.dir\u000a			};\u000a\u000a			editor.on( 'mode', hide );\u000a			editor.on( 'resize', hide );\u000a\u000a			// Window resize doesn't cause hide on blur. (#9800)\u000a			// [iOS] Poping up keyboard triggers window resize\u000a			// which leads to undesired panel hides.\u000a			if ( !CKEDITOR.env.iOS )\u000a				doc.getWindow().on( 'resize', hide );\u000a\u000a			// We need a wrapper because events implementation doesn't allow to attach\u000a			// one listener more than once for the same event on the same object.\u000a			// Remember that floatPanel#hide is shared between all instances.\u000a			function hide() {\u000a				that.hide();\u000a			}\u000a		},\u000a\u000a		proto: {\u000a			/**\u000a			 * @todo\u000a			 */\u000a			addBlock: function( name, block ) {\u000a				return this._.panel.addBlock( name, block );\u000a			},\u000a\u000a			/**\u000a			 * @todo\u000a			 */\u000a			addListBlock: function( name, multiSelect ) {\u000a				return this._.panel.addListBlock( name, multiSelect );\u000a			},\u000a\u000a			/**\u000a			 * @todo\u000a			 */\u000a			getBlock: function( name ) {\u000a				return this._.panel.getBlock( name );\u000a			},\u000a\u000a			/**\u000a			 * Shows panel block.\u000a			 *\u000a			 * @param {String} name\u000a			 * @param {CKEDITOR.dom.element} offsetParent Positioned parent.\u000a			 * @param {Number} corner\u000a			 *\u000a			 * * For LTR (left to right) oriented editor:\u000a			 *      * `1` = top-left\u000a			 *      * `2` = top-right\u000a			 *      * `3` = bottom-right\u000a			 *      * `4` = bottom-left\u000a			 * * For RTL (right to left):\u000a			 *      * `1` = top-right\u000a			 *      * `2` = top-left\u000a			 *      * `3` = bottom-left\u000a			 *      * `4` = bottom-right\u000a			 *\u000a			 * @param {Number} [offsetX=0]\u000a			 * @param {Number} [offsetY=0]\u000a			 * @param {Function} [callback] A callback function executed when block positioning is done.\u000a			 * @todo what do exactly these params mean (especially corner)?\u000a			 */\u000a			showBlock: function( name, offsetParent, corner, offsetX, offsetY, callback ) {\u000a				var panel = this._.panel,\u000a					block = panel.showBlock( name );\u000a\u000a				this.allowBlur( false );\u000a\u000a				// Record from where the focus is when open panel.\u000a				var editable = this._.editor.editable();\u000a				this._.returnFocus = editable.hasFocus ? editable : new CKEDITOR.dom.element( CKEDITOR.document.$.activeElement );\u000a				this._.hideTimeout = 0;\u000a\u000a				var element = this.element,\u000a					iframe = this._.iframe,\u000a					// Non IE prefer the event into a window object.\u000a					focused = CKEDITOR.env.ie ? iframe : new CKEDITOR.dom.window( iframe.$.contentWindow ),\u000a					doc = element.getDocument(),\u000a					positionedAncestor = this._.parentElement.getPositionedAncestor(),\u000a					position = offsetParent.getDocumentPosition( doc ),\u000a					positionedAncestorPosition = positionedAncestor ? positionedAncestor.getDocumentPosition( doc ) : { x: 0, y: 0 },\u000a					rtl = this._.dir == 'rtl',\u000a					left = position.x + ( offsetX || 0 ) - positionedAncestorPosition.x,\u000a					top = position.y + ( offsetY || 0 ) - positionedAncestorPosition.y;\u000a\u000a				// Floating panels are off by (-1px, 0px) in RTL mode. (#3438)\u000a				if ( rtl && ( corner == 1 || corner == 4 ) )\u000a					left += offsetParent.$.offsetWidth;\u000a				else if ( !rtl && ( corner == 2 || corner == 3 ) )\u000a					left += offsetParent.$.offsetWidth - 1;\u000a\u000a				if ( corner == 3 || corner == 4 )\u000a					top += offsetParent.$.offsetHeight - 1;\u000a\u000a				// Memorize offsetParent by it's ID.\u000a				this._.panel._.offsetParentId = offsetParent.getId();\u000a\u000a				element.setStyles( {\u000a					top: top + 'px',\u000a					left: 0,\u000a					display: ''\u000a				} );\u000a\u000a				// Don't use display or visibility style because we need to\u000a				// calculate the rendering layout later and focus the element.\u000a				element.setOpacity( 0 );\u000a\u000a				// To allow the context menu to decrease back their width\u000a				element.getFirst().removeStyle( 'width' );\u000a\u000a				// Report to focus manager.\u000a				this._.editor.focusManager.add( focused );\u000a\u000a				// Configure the IFrame blur event. Do that only once.\u000a				if ( !this._.blurSet ) {\u000a\u000a					// With addEventListener compatible browsers, we must\u000a					// useCapture when registering the focus/blur events to\u000a					// guarantee they will be firing in all situations. (#3068, #3222 )\u000a					CKEDITOR.event.useCapture = true;\u000a\u000a					focused.on( 'blur', function( ev ) {\u000a						// As we are using capture to register the listener,\u000a						// the blur event may get fired even when focusing\u000a						// inside the window itself, so we must ensure the\u000a						// target is out of it.\u000a						if ( !this.allowBlur() || ev.data.getPhase() != CKEDITOR.EVENT_PHASE_AT_TARGET )\u000a							return;\u000a\u000a						if ( this.visible && !this._.activeChild ) {\u000a							// [iOS] Allow hide to be prevented if touch is bound\u000a							// to any parent of the iframe blur happens before touch (#10714).\u000a							if ( CKEDITOR.env.iOS ) {\u000a								if ( !this._.hideTimeout )\u000a									this._.hideTimeout = CKEDITOR.tools.setTimeout( doHide, 0, this );\u000a							} else\u000a								doHide.call( this );\u000a						}\u000a\u000a						function doHide() {\u000a							// Panel close is caused by user's navigating away the focus, e.g. click outside the panel.\u000a							// DO NOT restore focus in this case.\u000a							delete this._.returnFocus;\u000a							this.hide();\u000a						}\u000a					}, this );\u000a\u000a					focused.on( 'focus', function() {\u000a						this._.focused = true;\u000a						this.hideChild();\u000a						this.allowBlur( true );\u000a					}, this );\u000a\u000a					// [iOS] if touch is bound to any parent of the iframe blur\u000a					// happens twice before touchstart and before touchend (#10714).\u000a					if ( CKEDITOR.env.iOS ) {\u000a						// Prevent false hiding on blur.\u000a						// We don't need to return focus here because touchend will fire anyway.\u000a						// If user scrolls and pointer gets out of the panel area touchend will also fire.\u000a						focused.on( 'touchstart', function() {\u000a							clearTimeout( this._.hideTimeout );\u000a						}, this );\u000a\u000a						// Set focus back to handle blur and hide panel when needed.\u000a						focused.on( 'touchend', function() {\u000a							this._.hideTimeout = 0;\u000a							this.focus();\u000a						}, this );\u000a					}\u000a\u000a					CKEDITOR.event.useCapture = false;\u000a\u000a					this._.blurSet = 1;\u000a				}\u000a\u000a				panel.onEscape = CKEDITOR.tools.bind( function( keystroke ) {\u000a					if ( this.onEscape && this.onEscape( keystroke ) === false )\u000a						return false;\u000a				}, this );\u000a\u000a				CKEDITOR.tools.setTimeout( function() {\u000a					var panelLoad = CKEDITOR.tools.bind( function() {\u000a						var target = element;\u000a\u000a						// Reset panel width as the new content can be narrower\u000a						// than the old one. (#9355)\u000a						target.removeStyle( 'width' );\u000a\u000a						if ( block.autoSize ) {\u000a							var panelDoc = block.element.getDocument();\u000a							var width = ( CKEDITOR.env.webkit? block.element : panelDoc.getBody() )[ '$' ].scrollWidth;\u000a\u000a							// Account for extra height needed due to IE quirks box model bug:\u000a							// http://en.wikipedia.org/wiki/Internet_Explorer_box_model_bug\u000a							// (#3426)\u000a							if ( CKEDITOR.env.ie && CKEDITOR.env.quirks && width > 0 )\u000a								width += ( target.$.offsetWidth || 0 ) - ( target.$.clientWidth || 0 ) + 3;\u000a\u000a							// Add some extra pixels to improve the appearance.\u000a							width += 10;\u000a\u000a							target.setStyle( 'width', width + 'px' );\u000a\u000a							var height = block.element.$.scrollHeight;\u000a\u000a							// Account for extra height needed due to IE quirks box model bug:\u000a							// http://en.wikipedia.org/wiki/Internet_Explorer_box_model_bug\u000a							// (#3426)\u000a							if ( CKEDITOR.env.ie && CKEDITOR.env.quirks && height > 0 )\u000a								height += ( target.$.offsetHeight || 0 ) - ( target.$.clientHeight || 0 ) + 3;\u000a\u000a							target.setStyle( 'height', height + 'px' );\u000a\u000a							// Fix IE < 8 visibility.\u000a							panel._.currentBlock.element.setStyle( 'display', 'none' ).removeStyle( 'display' );\u000a						} else\u000a							target.removeStyle( 'height' );\u000a\u000a						// Flip panel layout horizontally in RTL with known width.\u000a						if ( rtl )\u000a							left -= element.$.offsetWidth;\u000a\u000a						// Pop the style now for measurement.\u000a						element.setStyle( 'left', left + 'px' );\u000a\u000a						/* panel layout smartly fit the viewport size. */\u000a						var panelElement = panel.element,\u000a							panelWindow = panelElement.getWindow(),\u000a							rect = element.$.getBoundingClientRect(),\u000a							viewportSize = panelWindow.getViewPaneSize();\u000a\u000a						// Compensation for browsers that dont support "width" and "height".\u000a						var rectWidth = rect.width || rect.right - rect.left,\u000a							rectHeight = rect.height || rect.bottom - rect.top;\u000a\u000a						// Check if default horizontal layout is impossible.\u000a						var spaceAfter = rtl ? rect.right : viewportSize.width - rect.left,\u000a							spaceBefore = rtl ? viewportSize.width - rect.right : rect.left;\u000a\u000a						if ( rtl ) {\u000a							if ( spaceAfter < rectWidth ) {\u000a								// Flip to show on right.\u000a								if ( spaceBefore > rectWidth )\u000a									left += rectWidth;\u000a								// Align to window left.\u000a								else if ( viewportSize.width > rectWidth )\u000a									left = left - rect.left;\u000a								// Align to window right, never cutting the panel at right.\u000a								else\u000a									left = left - rect.right + viewportSize.width;\u000a							}\u000a						} else if ( spaceAfter < rectWidth ) {\u000a							// Flip to show on left.\u000a							if ( spaceBefore > rectWidth )\u000a								left -= rectWidth;\u000a							// Align to window right.\u000a							else if ( viewportSize.width > rectWidth )\u000a								left = left - rect.right + viewportSize.width;\u000a							// Align to window left, never cutting the panel at left.\u000a							else\u000a								left = left - rect.left;\u000a						}\u000a\u000a\u000a						// Check if the default vertical layout is possible.\u000a						var spaceBelow = viewportSize.height - rect.top,\u000a							spaceAbove = rect.top;\u000a\u000a						if ( spaceBelow < rectHeight ) {\u000a							// Flip to show above.\u000a							if ( spaceAbove > rectHeight )\u000a								top -= rectHeight;\u000a							// Align to window bottom.\u000a							else if ( viewportSize.height > rectHeight )\u000a								top = top - rect.bottom + viewportSize.height;\u000a							// Align to top, never cutting the panel at top.\u000a							else\u000a								top = top - rect.top;\u000a						}\u000a\u000a						// If IE is in RTL, we have troubles with absolute\u000a						// position and horizontal scrolls. Here we have a\u000a						// series of hacks to workaround it. (#6146)\u000a						if ( CKEDITOR.env.ie ) {\u000a							var offsetParent = new CKEDITOR.dom.element( element.$.offsetParent ),\u000a								scrollParent = offsetParent;\u000a\u000a							// Quirks returns <body>, but standards returns <html>.\u000a							if ( scrollParent.getName() == 'html' )\u000a								scrollParent = scrollParent.getDocument().getBody();\u000a\u000a							if ( scrollParent.getComputedStyle( 'direction' ) == 'rtl' ) {\u000a								// For IE8, there is not much logic on this, but it works.\u000a								if ( CKEDITOR.env.ie8Compat )\u000a									left -= element.getDocument().getDocumentElement().$.scrollLeft * 2;\u000a								else\u000a									left -= ( offsetParent.$.scrollWidth - offsetParent.$.clientWidth );\u000a							}\u000a						}\u000a\u000a						// Trigger the onHide event of the previously active panel to prevent\u000a						// incorrect styles from being applied (#6170)\u000a						var innerElement = element.getFirst(),\u000a							activePanel;\u000a						if ( ( activePanel = innerElement.getCustomData( 'activePanel' ) ) )\u000a							activePanel.onHide && activePanel.onHide.call( this, 1 );\u000a						innerElement.setCustomData( 'activePanel', this );\u000a\u000a						element.setStyles( {\u000a							top: top + 'px',\u000a							left: left + 'px'\u000a						} );\u000a						element.setOpacity( 1 );\u000a\u000a						callback && callback();\u000a					}, this );\u000a\u000a					panel.isLoaded ? panelLoad() : panel.onLoad = panelLoad;\u000a\u000a					CKEDITOR.tools.setTimeout( function() {\u000a						var scrollTop = CKEDITOR.env.webkit && CKEDITOR.document.getWindow().getScrollPosition().y;\u000a\u000a						// Focus the panel frame first, so blur gets fired.\u000a						this.focus();\u000a\u000a						// Focus the block now.\u000a						block.element.focus();\u000a\u000a						// #10623, #10951 - restore the viewport's scroll position after focusing list element.\u000a						if ( CKEDITOR.env.webkit )\u000a							CKEDITOR.document.getBody().$.scrollTop = scrollTop;\u000a\u000a						// We need this get fired manually because of unfired focus() function.\u000a						this.allowBlur( true );\u000a						this._.editor.fire( 'panelShow', this );\u000a					}, 0, this );\u000a				}, CKEDITOR.env.air ? 200 : 0, this );\u000a				this.visible = 1;\u000a\u000a				if ( this.onShow )\u000a					this.onShow.call( this );\u000a			},\u000a\u000a			/**\u000a			 * Restores last focused element or simply focus panel window.\u000a			 */\u000a			focus: function() {\u000a				// Webkit requires to blur any previous focused page element, in\u000a				// order to properly fire the "focus" event.\u000a				if ( CKEDITOR.env.webkit ) {\u000a					var active = CKEDITOR.document.getActive();\u000a					active && !active.equals( this._.iframe ) && active.$.blur();\u000a				}\u000a\u000a				// Restore last focused element or simply focus panel window.\u000a				var focus = this._.lastFocused || this._.iframe.getFrameDocument().getWindow();\u000a				focus.focus();\u000a			},\u000a\u000a			/**\u000a			 * @todo\u000a			 */\u000a			blur: function() {\u000a				var doc = this._.iframe.getFrameDocument(),\u000a					active = doc.getActive();\u000a\u000a				active && active.is( 'a' ) && ( this._.lastFocused = active );\u000a			},\u000a\u000a			/**\u000a			 * Hides panel.\u000a			 *\u000a			 * @todo\u000a			 */\u000a			hide: function( returnFocus ) {\u000a				if ( this.visible && ( !this.onHide || this.onHide.call( this ) !== true ) ) {\u000a					this.hideChild();\u000a					// Blur previously focused element. (#6671)\u000a					CKEDITOR.env.gecko && this._.iframe.getFrameDocument().$.activeElement.blur();\u000a					this.element.setStyle( 'display', 'none' );\u000a					this.visible = 0;\u000a					this.element.getFirst().removeCustomData( 'activePanel' );\u000a\u000a					// Return focus properly. (#6247)\u000a					var focusReturn = returnFocus && this._.returnFocus;\u000a					if ( focusReturn ) {\u000a						// Webkit requires focus moved out panel iframe first.\u000a						if ( CKEDITOR.env.webkit && focusReturn.type )\u000a							focusReturn.getWindow().$.focus();\u000a\u000a						focusReturn.focus();\u000a					}\u000a\u000a					delete this._.lastFocused;\u000a\u000a					this._.editor.fire( 'panelHide', this );\u000a				}\u000a			},\u000a\u000a			/**\u000a			 * @todo\u000a			 */\u000a			allowBlur: function( allow ) // Prevent editor from hiding the panel. #3222.\u000a			{\u000a				var panel = this._.panel;\u000a				if ( allow != undefined )\u000a					panel.allowBlur = allow;\u000a\u000a				return panel.allowBlur;\u000a			},\u000a\u000a			/**\u000a			 * Shows specified panel as a child of one block of this one.\u000a			 *\u000a			 * @param {CKEDITOR.ui.floatPanel} panel\u000a			 * @param {String} blockName\u000a			 * @param {CKEDITOR.dom.element} offsetParent Positioned parent.\u000a			 * @param {Number} corner\u000a			 *\u000a			 * * For LTR (left to right) oriented editor:\u000a			 *      * `1` = top-left\u000a			 *      * `2` = top-right\u000a			 *      * `3` = bottom-right\u000a			 *      * `4` = bottom-left\u000a			 * * For RTL (right to left):\u000a			 *      * `1` = top-right\u000a			 *      * `2` = top-left\u000a			 *      * `3` = bottom-left\u000a			 *      * `4` = bottom-right\u000a			 *\u000a			 * @param {Number} [offsetX=0]\u000a			 * @param {Number} [offsetY=0]\u000a			 * @todo\u000a			 */\u000a			showAsChild: function( panel, blockName, offsetParent, corner, offsetX, offsetY ) {\u000a				// Skip reshowing of child which is already visible.\u000a				if ( this._.activeChild == panel && panel._.panel._.offsetParentId == offsetParent.getId() )\u000a					return;\u000a\u000a				this.hideChild();\u000a\u000a				panel.onHide = CKEDITOR.tools.bind( function() {\u000a					// Use a timeout, so we give time for this menu to get\u000a					// potentially focused.\u000a					CKEDITOR.tools.setTimeout( function() {\u000a						if ( !this._.focused )\u000a							this.hide();\u000a					}, 0, this );\u000a				}, this );\u000a\u000a				this._.activeChild = panel;\u000a				this._.focused = false;\u000a\u000a				panel.showBlock( blockName, offsetParent, corner, offsetX, offsetY );\u000a				this.blur();\u000a\u000a				/* #3767 IE: Second level menu may not have borders */\u000a				if ( CKEDITOR.env.ie7Compat || CKEDITOR.env.ie6Compat ) {\u000a					setTimeout( function() {\u000a						panel.element.getChild( 0 ).$.style.cssText += '';\u000a					}, 100 );\u000a				}\u000a			},\u000a\u000a			/**\u000a			 * @todo\u000a			 */\u000a			hideChild: function( restoreFocus ) {\u000a				var activeChild = this._.activeChild;\u000a\u000a				if ( activeChild ) {\u000a					delete activeChild.onHide;\u000a					delete this._.activeChild;\u000a					activeChild.hide();\u000a\u000a					// At this point focus should be moved back to parent panel.\u000a					restoreFocus && this.focus();\u000a				}\u000a			}\u000a		}\u000a	} );\u000a\u000a	CKEDITOR.on( 'instanceDestroyed', function() {\u000a		var isLastInstance = CKEDITOR.tools.isEmpty( CKEDITOR.instances );\u000a\u000a		for ( var i in panels ) {\u000a			var panel = panels[ i ];\u000a			// Safe to destroy it since there're no more instances.(#4241)\u000a			if ( isLastInstance )\u000a				panel.destroy();\u000a			// Panel might be used by other instances, just hide them.(#4552)\u000a			else\u000a				panel.element.hide();\u000a		}\u000a		// Remove the registration.\u000a		isLastInstance && ( panels = {} );\u000a\u000a	} );\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000aCKEDITOR.plugins.add( 'listblock', {\u000a	requires: 'panel',\u000a\u000a	onLoad: function() {\u000a		var list = CKEDITOR.addTemplate( 'panel-list', '<ul role="presentation" class="cke_panel_list">{items}</ul>' ),\u000a			listItem = CKEDITOR.addTemplate( 'panel-list-item', '<li id="{id}" class="cke_panel_listItem" role=presentation>' +\u000a				'<a id="{id}_option" _cke_focus=1 hidefocus=true' +\u000a					' title="{title}"' +\u000a					' href="javascript:void(\u005c'{val}\u005c')" ' +\u000a					' {onclick}="CKEDITOR.tools.callFunction({clickFn},\u005c'{val}\u005c'); return false;"' + // #188\u000a						' role="option">' +\u000a					'{text}' +\u000a				'</a>' +\u000a				'</li>' ),\u000a			listGroup = CKEDITOR.addTemplate( 'panel-list-group', '<h1 id="{id}" class="cke_panel_grouptitle" role="presentation" >{label}</h1>' ),\u000a			reSingleQuote = /\u005c'/g,\u000a			escapeSingleQuotes = function( str ) {\u000a				return str.replace( reSingleQuote, '\u005c\u005c\u005c'' );\u000a			};\u000a\u000a		CKEDITOR.ui.panel.prototype.addListBlock = function( name, definition ) {\u000a			return this.addBlock( name, new CKEDITOR.ui.listBlock( this.getHolderElement(), definition ) );\u000a		};\u000a\u000a		CKEDITOR.ui.listBlock = CKEDITOR.tools.createClass( {\u000a			base: CKEDITOR.ui.panel.block,\u000a\u000a			$: function( blockHolder, blockDefinition ) {\u000a				blockDefinition = blockDefinition || {};\u000a\u000a				var attribs = blockDefinition.attributes || ( blockDefinition.attributes = {} );\u000a				( this.multiSelect = !!blockDefinition.multiSelect ) && ( attribs[ 'aria-multiselectable' ] = true );\u000a				// Provide default role of 'listbox'.\u000a				!attribs.role && ( attribs.role = 'listbox' );\u000a\u000a				// Call the base contructor.\u000a				this.base.apply( this, arguments );\u000a\u000a				// Set the proper a11y attributes.\u000a				this.element.setAttribute( 'role', attribs.role );\u000a\u000a				var keys = this.keys;\u000a				keys[ 40 ] = 'next'; // ARROW-DOWN\u000a				keys[ 9 ] = 'next'; // TAB\u000a				keys[ 38 ] = 'prev'; // ARROW-UP\u000a				keys[ CKEDITOR.SHIFT + 9 ] = 'prev'; // SHIFT + TAB\u000a				keys[ 32 ] = CKEDITOR.env.ie ? 'mouseup' : 'click'; // SPACE\u000a				CKEDITOR.env.ie && ( keys[ 13 ] = 'mouseup' ); // Manage ENTER, since onclick is blocked in IE (#8041).\u000a\u000a				this._.pendingHtml = [];\u000a				this._.pendingList = [];\u000a				this._.items = {};\u000a				this._.groups = {};\u000a			},\u000a\u000a			_: {\u000a				close: function() {\u000a					if ( this._.started ) {\u000a						var output = list.output( { items: this._.pendingList.join( '' ) } );\u000a						this._.pendingList = [];\u000a						this._.pendingHtml.push( output );\u000a						delete this._.started;\u000a					}\u000a				},\u000a\u000a				getClick: function() {\u000a					if ( !this._.click ) {\u000a						this._.click = CKEDITOR.tools.addFunction( function( value ) {\u000a							var marked = this.toggle( value );\u000a							if ( this.onClick )\u000a								this.onClick( value, marked );\u000a						}, this );\u000a					}\u000a					return this._.click;\u000a				}\u000a			},\u000a\u000a			proto: {\u000a				add: function( value, html, title ) {\u000a					var id = CKEDITOR.tools.getNextId();\u000a\u000a					if ( !this._.started ) {\u000a						this._.started = 1;\u000a						this._.size = this._.size || 0;\u000a					}\u000a\u000a					this._.items[ value ] = id;\u000a\u000a					var data = {\u000a						id: id,\u000a						val: escapeSingleQuotes( CKEDITOR.tools.htmlEncodeAttr( value ) ),\u000a						onclick: CKEDITOR.env.ie ? 'onclick="return false;" onmouseup' : 'onclick',\u000a						clickFn: this._.getClick(),\u000a						title: CKEDITOR.tools.htmlEncodeAttr( title || value ),\u000a						text: html || value\u000a					};\u000a\u000a					this._.pendingList.push( listItem.output( data ) );\u000a				},\u000a\u000a				startGroup: function( title ) {\u000a					this._.close();\u000a\u000a					var id = CKEDITOR.tools.getNextId();\u000a\u000a					this._.groups[ title ] = id;\u000a\u000a					this._.pendingHtml.push( listGroup.output( { id: id, label: title } ) );\u000a				},\u000a\u000a				commit: function() {\u000a					this._.close();\u000a					this.element.appendHtml( this._.pendingHtml.join( '' ) );\u000a					delete this._.size;\u000a\u000a					this._.pendingHtml = [];\u000a				},\u000a\u000a				toggle: function( value ) {\u000a					var isMarked = this.isMarked( value );\u000a\u000a					if ( isMarked )\u000a						this.unmark( value );\u000a					else\u000a						this.mark( value );\u000a\u000a					return !isMarked;\u000a				},\u000a\u000a				hideGroup: function( groupTitle ) {\u000a					var group = this.element.getDocument().getById( this._.groups[ groupTitle ] ),\u000a						list = group && group.getNext();\u000a\u000a					if ( group ) {\u000a						group.setStyle( 'display', 'none' );\u000a\u000a						if ( list && list.getName() == 'ul' )\u000a							list.setStyle( 'display', 'none' );\u000a					}\u000a				},\u000a\u000a				hideItem: function( value ) {\u000a					this.element.getDocument().getById( this._.items[ value ] ).setStyle( 'display', 'none' );\u000a				},\u000a\u000a				showAll: function() {\u000a					var items = this._.items,\u000a						groups = this._.groups,\u000a						doc = this.element.getDocument();\u000a\u000a					for ( var value in items ) {\u000a						doc.getById( items[ value ] ).setStyle( 'display', '' );\u000a					}\u000a\u000a					for ( var title in groups ) {\u000a						var group = doc.getById( groups[ title ] ),\u000a							list = group.getNext();\u000a\u000a						group.setStyle( 'display', '' );\u000a\u000a						if ( list && list.getName() == 'ul' )\u000a							list.setStyle( 'display', '' );\u000a					}\u000a				},\u000a\u000a				mark: function( value ) {\u000a					if ( !this.multiSelect )\u000a						this.unmarkAll();\u000a\u000a					var itemId = this._.items[ value ],\u000a						item = this.element.getDocument().getById( itemId );\u000a					item.addClass( 'cke_selected' );\u000a\u000a					this.element.getDocument().getById( itemId + '_option' ).setAttribute( 'aria-selected', true );\u000a					this.onMark && this.onMark( item );\u000a				},\u000a\u000a				unmark: function( value ) {\u000a					var doc = this.element.getDocument(),\u000a						itemId = this._.items[ value ],\u000a						item = doc.getById( itemId );\u000a\u000a					item.removeClass( 'cke_selected' );\u000a					doc.getById( itemId + '_option' ).removeAttribute( 'aria-selected' );\u000a\u000a					this.onUnmark && this.onUnmark( item );\u000a				},\u000a\u000a				unmarkAll: function() {\u000a					var items = this._.items,\u000a						doc = this.element.getDocument();\u000a\u000a					for ( var value in items ) {\u000a						var itemId = items[ value ];\u000a\u000a						doc.getById( itemId ).removeClass( 'cke_selected' );\u000a						doc.getById( itemId + '_option' ).removeAttribute( 'aria-selected' );\u000a					}\u000a\u000a					this.onUnmark && this.onUnmark();\u000a				},\u000a\u000a				isMarked: function( value ) {\u000a					return this.element.getDocument().getById( this._.items[ value ] ).hasClass( 'cke_selected' );\u000a				},\u000a\u000a				focus: function( value ) {\u000a					this._.focusIndex = -1;\u000a\u000a					var links = this.element.getElementsByTag( 'a' ),\u000a						link,\u000a						selected,\u000a						i = -1;\u000a\u000a					if ( value ) {\u000a						selected = this.element.getDocument().getById( this._.items[ value ] ).getFirst();\u000a\u000a						while ( ( link = links.getItem( ++i ) ) ) {\u000a							if ( link.equals( selected ) ) {\u000a								this._.focusIndex = i;\u000a								break;\u000a							}\u000a						}\u000a					}\u000a					else\u000a						this.element.focus();\u000a\u000a					selected && setTimeout( function() {\u000a						selected.focus();\u000a					}, 0 );\u000a				}\u000a			}\u000a		} );\u000a	}\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000aCKEDITOR.plugins.add( 'richcombo', {\u000a	requires: 'floatpanel,listblock,button',\u000a\u000a	beforeInit: function( editor ) {\u000a		editor.ui.addHandler( CKEDITOR.UI_RICHCOMBO, CKEDITOR.ui.richCombo.handler );\u000a	}\u000a} );\u000a\u000a( function() {\u000a	var template = '<span id="{id}"' +\u000a		' class="cke_combo cke_combo__{name} {cls}"' +\u000a		' role="presentation">' +\u000a			'<span id="{id}_label" class="cke_combo_label">{label}</span>' +\u000a			'<a class="cke_combo_button" title="{title}" tabindex="-1"' +\u000a			( CKEDITOR.env.gecko && !CKEDITOR.env.hc ? '' : ' href="javascript:void(\u005c'{titleJs}\u005c')"' ) +\u000a			' hidefocus="true"' +\u000a			' role="button"' +\u000a			' aria-labelledby="{id}_label"' +\u000a			' aria-haspopup="true"';\u000a\u000a	// Some browsers don't cancel key events in the keydown but in the\u000a	// keypress.\u000a	// TODO: Check if really needed.\u000a	if ( CKEDITOR.env.gecko && CKEDITOR.env.mac )\u000a		template += ' onkeypress="return false;"';\u000a\u000a	// With Firefox, we need to force the button to redraw, otherwise it\u000a	// will remain in the focus state.\u000a	if ( CKEDITOR.env.gecko )\u000a		template += ' onblur="this.style.cssText = this.style.cssText;"';\u000a\u000a	template +=\u000a		' onkeydown="return CKEDITOR.tools.callFunction({keydownFn},event,this);"' +\u000a		' onfocus="return CKEDITOR.tools.callFunction({focusFn},event);" ' +\u000a			( CKEDITOR.env.ie ? 'onclick="return false;" onmouseup' : 'onclick' ) + // #188\u000a				'="CKEDITOR.tools.callFunction({clickFn},this);return false;">' +\u000a			'<span id="{id}_text" class="cke_combo_text cke_combo_inlinelabel">{label}</span>' +\u000a			'<span class="cke_combo_open">' +\u000a				'<span class="cke_combo_arrow">' +\u000a				// BLACK DOWN-POINTING TRIANGLE\u000a	( CKEDITOR.env.hc ? '&#9660;' : CKEDITOR.env.air ? '&nbsp;' : '' ) +\u000a				'</span>' +\u000a			'</span>' +\u000a		'</a>' +\u000a		'</span>';\u000a\u000a	var rcomboTpl = CKEDITOR.addTemplate( 'combo', template );\u000a\u000a	/**\u000a	 * Button UI element.\u000a	 *\u000a	 * @readonly\u000a	 * @property {String} [='richcombo']\u000a	 * @member CKEDITOR\u000a	 */\u000a	CKEDITOR.UI_RICHCOMBO = 'richcombo';\u000a\u000a	/**\u000a	 * @class\u000a	 * @todo\u000a	 */\u000a	CKEDITOR.ui.richCombo = CKEDITOR.tools.createClass( {\u000a		$: function( definition ) {\u000a			// Copy all definition properties to this object.\u000a			CKEDITOR.tools.extend( this, definition,\u000a			// Set defaults.\u000a			{\u000a				// The combo won't participate in toolbar grouping.\u000a				canGroup: false,\u000a				title: definition.label,\u000a				modes: { wysiwyg: 1 },\u000a				editorFocus: 1\u000a			} );\u000a\u000a			// We don't want the panel definition in this object.\u000a			var panelDefinition = this.panel || {};\u000a			delete this.panel;\u000a\u000a			this.id = CKEDITOR.tools.getNextNumber();\u000a\u000a			this.document = ( panelDefinition.parent && panelDefinition.parent.getDocument() ) || CKEDITOR.document;\u000a\u000a			panelDefinition.className = 'cke_combopanel';\u000a			panelDefinition.block = {\u000a				multiSelect: panelDefinition.multiSelect,\u000a				attributes: panelDefinition.attributes\u000a			};\u000a			panelDefinition.toolbarRelated = true;\u000a\u000a			this._ = {\u000a				panelDefinition: panelDefinition,\u000a				items: {}\u000a			};\u000a		},\u000a\u000a		proto: {\u000a			renderHtml: function( editor ) {\u000a				var output = [];\u000a				this.render( editor, output );\u000a				return output.join( '' );\u000a			},\u000a\u000a			/**\u000a			 * Renders the combo.\u000a			 *\u000a			 * @param {CKEDITOR.editor} editor The editor instance which this button is\u000a			 * to be used by.\u000a			 * @param {Array} output The output array to which append the HTML relative\u000a			 * to this button.\u000a			 */\u000a			render: function( editor, output ) {\u000a				var env = CKEDITOR.env;\u000a\u000a				var id = 'cke_' + this.id;\u000a				var clickFn = CKEDITOR.tools.addFunction( function( el ) {\u000a					// Restore locked selection in Opera.\u000a					if ( selLocked ) {\u000a						editor.unlockSelection( 1 );\u000a						selLocked = 0;\u000a					}\u000a					instance.execute( el );\u000a				}, this );\u000a\u000a				var combo = this;\u000a				var instance = {\u000a					id: id,\u000a					combo: this,\u000a					focus: function() {\u000a						var element = CKEDITOR.document.getById( id ).getChild( 1 );\u000a						element.focus();\u000a					},\u000a					execute: function( el ) {\u000a						var _ = combo._;\u000a\u000a						if ( _.state == CKEDITOR.TRISTATE_DISABLED )\u000a							return;\u000a\u000a						combo.createPanel( editor );\u000a\u000a						if ( _.on ) {\u000a							_.panel.hide();\u000a							return;\u000a						}\u000a\u000a						combo.commit();\u000a						var value = combo.getValue();\u000a						if ( value )\u000a							_.list.mark( value );\u000a						else\u000a							_.list.unmarkAll();\u000a\u000a						_.panel.showBlock( combo.id, new CKEDITOR.dom.element( el ), 4 );\u000a					},\u000a					clickFn: clickFn\u000a				};\u000a\u000a				function updateState() {\u000a					// Don't change state while richcombo is active (#11793).\u000a					if ( this.getState() == CKEDITOR.TRISTATE_ON )\u000a						return;\u000a\u000a					var state = this.modes[ editor.mode ] ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED;\u000a\u000a					if ( editor.readOnly && !this.readOnly )\u000a						state = CKEDITOR.TRISTATE_DISABLED;\u000a\u000a					this.setState( state );\u000a					this.setValue( '' );\u000a\u000a					// Let plugin to disable button.\u000a					if ( state != CKEDITOR.TRISTATE_DISABLED && this.refresh )\u000a						this.refresh();\u000a				}\u000a\u000a				// Update status when activeFilter, mode, selection or readOnly changes.\u000a				editor.on( 'activeFilterChange', updateState, this );\u000a				editor.on( 'mode', updateState, this );\u000a				editor.on( 'selectionChange', updateState, this );\u000a				// If this combo is sensitive to readOnly state, update it accordingly.\u000a				!this.readOnly && editor.on( 'readOnly', updateState, this );\u000a\u000a				var keyDownFn = CKEDITOR.tools.addFunction( function( ev, element ) {\u000a					ev = new CKEDITOR.dom.event( ev );\u000a\u000a					var keystroke = ev.getKeystroke();\u000a\u000a					// ARROW-DOWN\u000a					// This call is duplicated in plugins/toolbar/plugin.js in itemKeystroke().\u000a					// Move focus to the first element after drop down was opened by the arrow down key.\u000a					if ( keystroke == 40 ) {\u000a						editor.once( 'panelShow', function( evt ) {\u000a							evt.data._.panel._.currentBlock.onKeyDown( 40 );\u000a						} );\u000a					}\u000a\u000a					switch ( keystroke ) {\u000a						case 13: // ENTER\u000a						case 32: // SPACE\u000a						case 40: // ARROW-DOWN\u000a							// Show panel\u000a							CKEDITOR.tools.callFunction( clickFn, element );\u000a							break;\u000a						default:\u000a							// Delegate the default behavior to toolbar button key handling.\u000a							instance.onkey( instance, keystroke );\u000a					}\u000a\u000a					// Avoid subsequent focus grab on editor document.\u000a					ev.preventDefault();\u000a				} );\u000a\u000a				var focusFn = CKEDITOR.tools.addFunction( function() {\u000a					instance.onfocus && instance.onfocus();\u000a				} );\u000a\u000a				var selLocked = 0;\u000a\u000a				// For clean up\u000a				instance.keyDownFn = keyDownFn;\u000a\u000a				var params = {\u000a					id: id,\u000a					name: this.name || this.command,\u000a					label: this.label,\u000a					title: this.title,\u000a					cls: this.className || '',\u000a					titleJs: env.gecko && !env.hc ? '' : ( this.title || '' ).replace( "'", '' ),\u000a					keydownFn: keyDownFn,\u000a					focusFn: focusFn,\u000a					clickFn: clickFn\u000a				};\u000a\u000a				rcomboTpl.output( params, output );\u000a\u000a				if ( this.onRender )\u000a					this.onRender();\u000a\u000a				return instance;\u000a			},\u000a\u000a			createPanel: function( editor ) {\u000a				if ( this._.panel )\u000a					return;\u000a\u000a				var panelDefinition = this._.panelDefinition,\u000a					panelBlockDefinition = this._.panelDefinition.block,\u000a					panelParentElement = panelDefinition.parent || CKEDITOR.document.getBody(),\u000a					namedPanelCls = 'cke_combopanel__' + this.name,\u000a					panel = new CKEDITOR.ui.floatPanel( editor, panelParentElement, panelDefinition ),\u000a					list = panel.addListBlock( this.id, panelBlockDefinition ),\u000a					me = this;\u000a\u000a				panel.onShow = function() {\u000a					this.element.addClass( namedPanelCls );\u000a\u000a					me.setState( CKEDITOR.TRISTATE_ON );\u000a\u000a					me._.on = 1;\u000a\u000a					me.editorFocus && !editor.focusManager.hasFocus && editor.focus();\u000a\u000a					if ( me.onOpen )\u000a						me.onOpen();\u000a\u000a					// The "panelShow" event is fired assinchronously, after the\u000a					// onShow method call.\u000a					editor.once( 'panelShow', function() {\u000a						list.focus( !list.multiSelect && me.getValue() );\u000a					} );\u000a				};\u000a\u000a				panel.onHide = function( preventOnClose ) {\u000a					this.element.removeClass( namedPanelCls );\u000a\u000a					me.setState( me.modes && me.modes[ editor.mode ] ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED );\u000a\u000a					me._.on = 0;\u000a\u000a					if ( !preventOnClose && me.onClose )\u000a						me.onClose();\u000a				};\u000a\u000a				panel.onEscape = function() {\u000a					// Hide drop-down with focus returned.\u000a					panel.hide( 1 );\u000a				};\u000a\u000a				list.onClick = function( value, marked ) {\u000a\u000a					if ( me.onClick )\u000a						me.onClick.call( me, value, marked );\u000a\u000a					panel.hide();\u000a				};\u000a\u000a				this._.panel = panel;\u000a				this._.list = list;\u000a\u000a				panel.getBlock( this.id ).onHide = function() {\u000a					me._.on = 0;\u000a					me.setState( CKEDITOR.TRISTATE_OFF );\u000a				};\u000a\u000a				if ( this.init )\u000a					this.init();\u000a			},\u000a\u000a			setValue: function( value, text ) {\u000a				this._.value = value;\u000a\u000a				var textElement = this.document.getById( 'cke_' + this.id + '_text' );\u000a				if ( textElement ) {\u000a					if ( !( value || text ) ) {\u000a						text = this.label;\u000a						textElement.addClass( 'cke_combo_inlinelabel' );\u000a					} else\u000a						textElement.removeClass( 'cke_combo_inlinelabel' );\u000a\u000a					textElement.setText( typeof text != 'undefined' ? text : value );\u000a				}\u000a			},\u000a\u000a			getValue: function() {\u000a				return this._.value || '';\u000a			},\u000a\u000a			unmarkAll: function() {\u000a				this._.list.unmarkAll();\u000a			},\u000a\u000a			mark: function( value ) {\u000a				this._.list.mark( value );\u000a			},\u000a\u000a			hideItem: function( value ) {\u000a				this._.list.hideItem( value );\u000a			},\u000a\u000a			hideGroup: function( groupTitle ) {\u000a				this._.list.hideGroup( groupTitle );\u000a			},\u000a\u000a			showAll: function() {\u000a				this._.list.showAll();\u000a			},\u000a\u000a			add: function( value, html, text ) {\u000a				this._.items[ value ] = text || value;\u000a				this._.list.add( value, html, text );\u000a			},\u000a\u000a			startGroup: function( title ) {\u000a				this._.list.startGroup( title );\u000a			},\u000a\u000a			commit: function() {\u000a				if ( !this._.committed ) {\u000a					this._.list.commit();\u000a					this._.committed = 1;\u000a					CKEDITOR.ui.fire( 'ready', this );\u000a				}\u000a				this._.committed = 1;\u000a			},\u000a\u000a			setState: function( state ) {\u000a				if ( this._.state == state )\u000a					return;\u000a\u000a				var el = this.document.getById( 'cke_' + this.id );\u000a				el.setState( state, 'cke_combo' );\u000a\u000a				state == CKEDITOR.TRISTATE_DISABLED ?\u000a					el.setAttribute( 'aria-disabled', true ) :\u000a					el.removeAttribute( 'aria-disabled' );\u000a\u000a				this._.state = state;\u000a			},\u000a\u000a			getState: function() {\u000a				return this._.state;\u000a			},\u000a\u000a			enable: function() {\u000a				if ( this._.state == CKEDITOR.TRISTATE_DISABLED )\u000a					this.setState( this._.lastState );\u000a			},\u000a\u000a			disable: function() {\u000a				if ( this._.state != CKEDITOR.TRISTATE_DISABLED ) {\u000a					this._.lastState = this._.state;\u000a					this.setState( CKEDITOR.TRISTATE_DISABLED );\u000a				}\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Represents richCombo handler object.\u000a		 *\u000a		 * @class CKEDITOR.ui.richCombo.handler\u000a		 * @singleton\u000a		 * @extends CKEDITOR.ui.handlerDefinition\u000a		 */\u000a		statics: {\u000a			handler: {\u000a				/**\u000a				 * Transforms a richCombo definition in a {@link CKEDITOR.ui.richCombo} instance.\u000a				 *\u000a				 * @param {Object} definition\u000a				 * @returns {CKEDITOR.ui.richCombo}\u000a				 */\u000a				create: function( definition ) {\u000a					return new CKEDITOR.ui.richCombo( definition );\u000a				}\u000a			}\u000a		}\u000a	} );\u000a\u000a	/**\u000a	 * @param {String} name\u000a	 * @param {Object} definition\u000a	 * @member CKEDITOR.ui\u000a	 * @todo\u000a	 */\u000a	CKEDITOR.ui.prototype.addRichCombo = function( name, definition ) {\u000a		this.add( name, CKEDITOR.UI_RICHCOMBO, definition );\u000a	};\u000a\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000aCKEDITOR.plugins.add( 'basicstyles', {\u000a	lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en,en-au,en-ca,en-gb,eo,es,et,eu,fa,fi,fo,fr,fr-ca,gl,gu,he,hi,hr,hu,id,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt,pt-br,ro,ru,si,sk,sl,sq,sr,sr-latn,sv,th,tr,tt,ug,uk,vi,zh,zh-cn', // %REMOVE_LINE_CORE%\u000a	// icons: 'bold,italic,underline,strike,subscript,superscript', // %REMOVE_LINE_CORE%\u000a	// hidpi: true, // %REMOVE_LINE_CORE%\u000a	init: function( editor ) {\u000a		var order = 0;\u000a		// All buttons use the same code to register. So, to avoid\u000a		// duplications, let's use this tool function.\u000a		var addButtonCommand = function( buttonName, buttonLabel, commandName, styleDefiniton, icon) {\u000a				// Disable the command if no definition is configured.\u000a				if ( !styleDefiniton )\u000a					return;\u000a\u000a				var style = new CKEDITOR.style( styleDefiniton ),\u000a					forms = contentForms[ commandName ];\u000a\u000a				// Put the style as the most important form.\u000a				forms.unshift( style );\u000a\u000a				// Listen to contextual style activation.\u000a				editor.attachStyleStateChange( style, function( state ) {\u000a					!editor.readOnly && editor.getCommand( commandName ).setState( state );\u000a				} );\u000a\u000a				// Create the command that can be used to apply the style.\u000a				editor.addCommand( commandName, new CKEDITOR.styleCommand( style, {\u000a					contentForms: forms\u000a				} ) );\u000a\u000a				// Register the button, if the button plugin is loaded.\u000a				if ( editor.ui.addButton ) {\u000a					editor.ui.addButton( buttonName, {\u000a						icon: icon,\u000a						label: buttonLabel,\u000a						command: commandName,\u000a						toolbar: 'basicstyles,' + ( order += 10 )\u000a					} );\u000a				}\u000a			};\u000a\u000a		var contentForms = {\u000a				bold: [\u000a					'strong',\u000a					'b',\u000a					[ 'span', function( el ) {\u000a						var fw = el.styles[ 'font-weight' ];\u000a						return fw == 'bold' || +fw >= 700;\u000a					} ]\u000a				],\u000a\u000a				italic: [\u000a					'em',\u000a					'i',\u000a					[ 'span', function( el ) {\u000a						return el.styles[ 'font-style' ] == 'italic';\u000a					} ]\u000a				],\u000a\u000a				underline: [\u000a					'u',\u000a					[ 'span', function( el ) {\u000a						return el.styles[ 'text-decoration' ] == 'underline';\u000a					} ]\u000a				],\u000a\u000a				strike: [\u000a					's',\u000a					'strike',\u000a					[ 'span', function( el ) {\u000a						return el.styles[ 'text-decoration' ] == 'line-through';\u000a					} ]\u000a				],\u000a\u000a				subscript: [\u000a					'sub'\u000a				],\u000a\u000a				superscript: [\u000a					'sup'\u000a				]\u000a			},\u000a			config = editor.config,\u000a			lang = editor.lang.basicstyles;\u000a\u000a		addButtonCommand( 'Bold', lang.bold, 'bold', config.coreStyles_bold, 'bold fa fa-bold bold' );\u000a		addButtonCommand( 'Italic', lang.italic, 'italic', config.coreStyles_italic, 'italic fa fa-italic italic' );\u000a		addButtonCommand( 'Underline', lang.underline, 'underline', config.coreStyles_underline, 'underline fa fa-underline underline' );\u000a		addButtonCommand( 'Strike', lang.strike, 'strike', config.coreStyles_strike, 'strike fa fa-strikethrough strike' );\u000a		addButtonCommand( 'Subscript', lang.subscript, 'subscript', config.coreStyles_subscript, 'subscript fa fa-subscript subscript' );\u000a		addButtonCommand( 'Superscript', lang.superscript, 'superscript', config.coreStyles_superscript, 'superscript fa fa-superscript superscript' );\u000a\u000a		editor.setKeystroke( [\u000a			[ CKEDITOR.CTRL + 66 /*B*/, 'bold' ],\u000a			[ CKEDITOR.CTRL + 73 /*I*/, 'italic' ],\u000a			[ CKEDITOR.CTRL + 85 /*U*/, 'underline' ]\u000a			] );\u000a	}\u000a} );\u000a\u000a// Basic Inline Styles.\u000a\u000a/**\u000a * The style definition that applies the **bold** style to the text.\u000a *\u000a *		config.coreStyles_bold = { element: 'b', overrides: 'strong' };\u000a *\u000a *		config.coreStyles_bold = {\u000a *			element: 'span',\u000a *			attributes: { 'class': 'Bold' }\u000a *		};\u000a *\u000a * @cfg\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.coreStyles_bold = { element: 'strong', overrides: 'b' };\u000a\u000a/**\u000a * The style definition that applies the *italics* style to the text.\u000a *\u000a *		config.coreStyles_italic = { element: 'i', overrides: 'em' };\u000a *\u000a *		CKEDITOR.config.coreStyles_italic = {\u000a *			element: 'span',\u000a *			attributes: { 'class': 'Italic' }\u000a *		};\u000a *\u000a * @cfg\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.coreStyles_italic = { element: 'em', overrides: 'i' };\u000a\u000a/**\u000a * The style definition that applies the <u>underline</u> style to the text.\u000a *\u000a *		CKEDITOR.config.coreStyles_underline = {\u000a *			element: 'span',\u000a *			attributes: { 'class': 'Underline' }\u000a *		};\u000a *\u000a * @cfg\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.coreStyles_underline = { element: 'u' };\u000a\u000a/**\u000a * The style definition that applies the <strike>strike-through</strike> style to the text.\u000a *\u000a *		CKEDITOR.config.coreStyles_strike = {\u000a *			element: 'span',\u000a *			attributes: { 'class': 'StrikeThrough' },\u000a *			overrides: 'strike'\u000a *		};\u000a *\u000a * @cfg\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.coreStyles_strike = { element: 's', overrides: 'strike' };\u000a\u000a/**\u000a * The style definition that applies the subscript style to the text.\u000a *\u000a *		CKEDITOR.config.coreStyles_subscript = {\u000a *			element: 'span',\u000a *			attributes: { 'class': 'Subscript' },\u000a *			overrides: 'sub'\u000a *		};\u000a *\u000a * @cfg\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.coreStyles_subscript = { element: 'sub' };\u000a\u000a/**\u000a * The style definition that applies the superscript style to the text.\u000a *\u000a *		CKEDITOR.config.coreStyles_superscript = {\u000a *			element: 'span',\u000a *			attributes: { 'class': 'Superscript' },\u000a *			overrides: 'sup'\u000a *		};\u000a *\u000a * @cfg\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.coreStyles_superscript = { element: 'sup' };\u000a\u000a\ufeff/*\u000aCopyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000aFor licensing, see LICENSE.md or http://ckeditor.com/license\u000a*/\u000aCKEDITOR.plugins.setLang( 'basicstyles', 'en', {\u000a	bold: 'Bold',\u000a	italic: 'Italic',\u000a	strike: 'Strike Through',\u000a	subscript: 'Subscript',\u000a	superscript: 'Superscript',\u000a	underline: 'Underline'\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @ignore\u000a * File overview: Clipboard support.\u000a */\u000a\u000a//\u000a// EXECUTION FLOWS:\u000a// -- CTRL+C\u000a//		* browser's default behaviour\u000a// -- CTRL+V\u000a//		* listen onKey (onkeydown)\u000a//		* simulate 'beforepaste' for non-IEs on editable\u000a//		* simulate 'paste' for Fx2/Opera on editable\u000a//		* listen 'onpaste' on editable ('onbeforepaste' for IE)\u000a//		* fire 'beforePaste' on editor\u000a//		* !canceled && getClipboardDataByPastebin\u000a//		* fire 'paste' on editor\u000a//		* !canceled && fire 'afterPaste' on editor\u000a// -- CTRL+X\u000a//		* listen onKey (onkeydown)\u000a//		* fire 'saveSnapshot' on editor\u000a//		* browser's default behaviour\u000a//		* deferred second 'saveSnapshot' event\u000a// -- Copy command\u000a//		* tryToCutCopy\u000a//			* execCommand\u000a//		* !success && alert\u000a// -- Cut command\u000a//		* fixCut\u000a//		* tryToCutCopy\u000a//			* execCommand\u000a//		* !success && alert\u000a// -- Paste command\u000a//		* fire 'paste' on editable ('beforepaste' for IE)\u000a//		* !canceled && execCommand 'paste'\u000a//		* !success && fire 'pasteDialog' on editor\u000a// -- Paste from native context menu & menubar\u000a//		(Fx & Webkits are handled in 'paste' default listner.\u000a//		Opera cannot be handled at all because it doesn't fire any events\u000a//		Special treatment is needed for IE, for which is this part of doc)\u000a//		* listen 'onpaste'\u000a//		* cancel native event\u000a//		* fire 'beforePaste' on editor\u000a//		* !canceled && getClipboardDataByPastebin\u000a//		* execIECommand( 'paste' ) -> this fires another 'paste' event, so cancel it\u000a//		* fire 'paste' on editor\u000a//		* !canceled && fire 'afterPaste' on editor\u000a//\u000a//\u000a// PASTE EVENT - PREPROCESSING:\u000a// -- Possible dataValue types: auto, text, html.\u000a// -- Possible dataValue contents:\u000a//		* text (possible \u005cn\u005cr)\u000a//		* htmlified text (text + br,div,p - no presentional markup & attrs - depends on browser)\u000a//		* html\u000a// -- Possible flags:\u000a//		* htmlified - if true then content is a HTML even if no markup inside. This flag is set\u000a//			for content from editable pastebins, because they 'htmlify' pasted content.\u000a//\u000a// -- Type: auto:\u000a//		* content: htmlified text ->	filter, unify text markup (brs, ps, divs), set type: text\u000a//		* content: html ->				filter, set type: html\u000a// -- Type: text:\u000a//		* content: htmlified text ->	filter, unify text markup\u000a//		* content: html ->				filter, strip presentional markup, unify text markup\u000a// -- Type: html:\u000a//		* content: htmlified text ->	filter, unify text markup\u000a//		* content: html ->				filter\u000a//\u000a// -- Phases:\u000a//		* filtering (priorities 3-5) - e.g. pastefromword filters\u000a//		* content type sniffing (priority 6)\u000a//		* markup transformations for text (priority 6)\u000a//\u000a\u000a'use strict';\u000a\u000a( function() {\u000a	// Register the plugin.\u000a	CKEDITOR.plugins.add( 'clipboard', {\u000a		requires: 'dialog',\u000a		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en,en-au,en-ca,en-gb,eo,es,et,eu,fa,fi,fo,fr,fr-ca,gl,gu,he,hi,hr,hu,id,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt,pt-br,ro,ru,si,sk,sl,sq,sr,sr-latn,sv,th,tr,tt,ug,uk,vi,zh,zh-cn', // %REMOVE_LINE_CORE%\u000a		// icons: 'copy,copy-rtl,cut,cut-rtl,paste,paste-rtl', // %REMOVE_LINE_CORE%\u000a		// hidpi: true, // %REMOVE_LINE_CORE%\u000a		init: function( editor ) {\u000a			var textificationFilter;\u000a\u000a			initClipboard( editor );\u000a\u000a			CKEDITOR.dialog.add( 'paste', CKEDITOR.getUrl( this.path + 'dialogs/paste.js' ) );\u000a\u000a			editor.on( 'paste', function( evt ) {\u000a				var data = evt.data.dataValue,\u000a					blockElements = CKEDITOR.dtd.$block;\u000a\u000a				// Filter webkit garbage.\u000a				if ( data.indexOf( 'Apple-' ) > -1 ) {\u000a					// Replace special webkit's &nbsp; with simple space, because webkit\u000a					// produces them even for normal spaces.\u000a					data = data.replace( /<span class="Apple-converted-space">&nbsp;<\u005c/span>/gi, ' ' );\u000a\u000a					// Strip <span> around white-spaces when not in forced 'html' content type.\u000a					// This spans are created only when pasting plain text into Webkit,\u000a					// but for safety reasons remove them always.\u000a					if ( evt.data.type != 'html' )\u000a						data = data.replace( /<span class="Apple-tab-span"[^>]*>([^<]*)<\u005c/span>/gi, function( all, spaces ) {\u000a						// Replace tabs with 4 spaces like Fx does.\u000a						return spaces.replace( /\u005ct/g, '&nbsp;&nbsp; &nbsp;' );\u000a					} );\u000a\u000a					// This br is produced only when copying & pasting HTML content.\u000a					if ( data.indexOf( '<br class="Apple-interchange-newline">' ) > -1 ) {\u000a						evt.data.startsWithEOL = 1;\u000a						evt.data.preSniffing = 'html'; // Mark as not text.\u000a						data = data.replace( /<br class="Apple-interchange-newline">/, '' );\u000a					}\u000a\u000a					// Remove all other classes.\u000a					data = data.replace( /(<[^>]+) class="Apple-[^"]*"/gi, '$1' );\u000a				}\u000a\u000a				// Strip editable that was copied from inside. (#9534)\u000a				if ( data.match( /^<[^<]+cke_(editable|contents)/i ) ) {\u000a					var tmp,\u000a						editable_wrapper,\u000a						wrapper = new CKEDITOR.dom.element( 'div' );\u000a\u000a					wrapper.setHtml( data );\u000a					// Verify for sure and check for nested editor UI parts. (#9675)\u000a					while ( wrapper.getChildCount() == 1 &&\u000a							( tmp = wrapper.getFirst() ) &&\u000a							tmp.type == CKEDITOR.NODE_ELEMENT &&	// Make sure first-child is element.\u000a							( tmp.hasClass( 'cke_editable' ) || tmp.hasClass( 'cke_contents' ) ) ) {\u000a						wrapper = editable_wrapper = tmp;\u000a					}\u000a\u000a					// If editable wrapper was found strip it and bogus <br> (added on FF).\u000a					if ( editable_wrapper )\u000a						data = editable_wrapper.getHtml().replace( /<br>$/i, '' );\u000a				}\u000a\u000a				if ( CKEDITOR.env.ie ) {\u000a					// &nbsp; <p> -> <p> (br.cke-pasted-remove will be removed later)\u000a					data = data.replace( /^&nbsp;(?: |\u005cr\u005cn)?<(\u005cw+)/g, function( match, elementName ) {\u000a						if ( elementName.toLowerCase() in blockElements ) {\u000a							evt.data.preSniffing = 'html'; // Mark as not a text.\u000a							return '<' + elementName;\u000a						}\u000a						return match;\u000a					} );\u000a				} else if ( CKEDITOR.env.webkit ) {\u000a					// </p><div><br></div> -> </p><br>\u000a					// We don't mark br, because this situation can happen for htmlified text too.\u000a					data = data.replace( /<\u005c/(\u005cw+)><div><br><\u005c/div>$/, function( match, elementName ) {\u000a						if ( elementName in blockElements ) {\u000a							evt.data.endsWithEOL = 1;\u000a							return '</' + elementName + '>';\u000a						}\u000a						return match;\u000a					} );\u000a				} else if ( CKEDITOR.env.gecko ) {\u000a					// Firefox adds bogus <br> when user pasted text followed by space(s).\u000a					data = data.replace( /(\u005cs)<br>$/, '$1' );\u000a				}\u000a\u000a				evt.data.dataValue = data;\u000a			}, null, null, 3 );\u000a\u000a			editor.on( 'paste', function( evt ) {\u000a				var dataObj = evt.data,\u000a					type = dataObj.type,\u000a					data = dataObj.dataValue,\u000a					trueType,\u000a					// Default is 'html'.\u000a					defaultType = editor.config.clipboard_defaultContentType || 'html';\u000a\u000a				// If forced type is 'html' we don't need to know true data type.\u000a				if ( type == 'html' || dataObj.preSniffing == 'html' )\u000a					trueType = 'html';\u000a				else\u000a					trueType = recogniseContentType( data );\u000a\u000a				// Unify text markup.\u000a				if ( trueType == 'htmlifiedtext' )\u000a					data = htmlifiedTextHtmlification( editor.config, data );\u000a				// Strip presentional markup & unify text markup.\u000a				else if ( type == 'text' && trueType == 'html' ) {\u000a					// Init filter only if needed and cache it.\u000a					data = htmlTextification( editor.config, data, textificationFilter || ( textificationFilter = getTextificationFilter( editor ) ) );\u000a				}\u000a\u000a				if ( dataObj.startsWithEOL )\u000a					data = '<br data-cke-eol="1">' + data;\u000a				if ( dataObj.endsWithEOL )\u000a					data += '<br data-cke-eol="1">';\u000a\u000a				if ( type == 'auto' )\u000a					type = ( trueType == 'html' || defaultType == 'html' ) ? 'html' : 'text';\u000a\u000a				dataObj.type = type;\u000a				dataObj.dataValue = data;\u000a				delete dataObj.preSniffing;\u000a				delete dataObj.startsWithEOL;\u000a				delete dataObj.endsWithEOL;\u000a			}, null, null, 6 );\u000a\u000a			// Inserts processed data into the editor at the end of the\u000a			// events chain.\u000a			editor.on( 'paste', function( evt ) {\u000a				var data = evt.data;\u000a\u000a				editor.insertHtml( data.dataValue, data.type );\u000a\u000a				// Deferr 'afterPaste' so all other listeners for 'paste' will be fired first.\u000a				setTimeout( function() {\u000a					editor.fire( 'afterPaste' );\u000a				}, 0 );\u000a			}, null, null, 1000 );\u000a\u000a			editor.on( 'pasteDialog', function( evt ) {\u000a				// TODO it's possible that this setTimeout is not needed any more,\u000a				// because of changes introduced in the same commit as this comment.\u000a				// Editor.getClipboardData adds listner to the dialog's events which are\u000a				// fired after a while (not like 'showDialog').\u000a				setTimeout( function() {\u000a					// Open default paste dialog.\u000a					editor.openDialog( 'paste', evt.data );\u000a				}, 0 );\u000a			} );\u000a		}\u000a	} );\u000a\u000a	function initClipboard( editor ) {\u000a		var preventBeforePasteEvent = 0,\u000a			preventPasteEvent = 0,\u000a			inReadOnly = 0,\u000a			// Safari doesn't like 'beforepaste' event - it sometimes doesn't\u000a			// properly handles ctrl+c. Probably some race-condition between events.\u000a			// Chrome and Firefox works well with both events, so better to use 'paste'\u000a			// which will handle pasting from e.g. browsers' menu bars.\u000a			// IE7/8 doesn't like 'paste' event for which it's throwing random errors.\u000a			mainPasteEvent = CKEDITOR.env.ie ? 'beforepaste' : 'paste';\u000a\u000a		addListeners();\u000a		addButtonsCommands();\u000a\u000a		/**\u000a		 * Gets clipboard data by directly accessing the clipboard (IE only) or opening paste dialog.\u000a		 *\u000a		 *		editor.getClipboardData( { title: 'Get my data' }, function( data ) {\u000a		 *			if ( data )\u000a		 *				alert( data.type + ' ' + data.dataValue );\u000a		 *		} );\u000a		 *\u000a		 * @member CKEDITOR.editor\u000a		 * @param {Object} options\u000a		 * @param {String} [options.title] Title of paste dialog.\u000a		 * @param {Function} callback Function that will be executed with `data.type` and `data.dataValue`\u000a		 * or `null` if none of the capturing method succeeded.\u000a		 */\u000a		editor.getClipboardData = function( options, callback ) {\u000a			var beforePasteNotCanceled = false,\u000a				dataType = 'auto',\u000a				dialogCommited = false;\u000a\u000a			// Options are optional - args shift.\u000a			if ( !callback ) {\u000a				callback = options;\u000a				options = null;\u000a			}\u000a\u000a			// Listen with maximum priority to handle content before everyone else.\u000a			// This callback will handle paste event that will be fired if direct\u000a			// access to the clipboard succeed in IE.\u000a			editor.on( 'paste', onPaste, null, null, 0 );\u000a\u000a			// Listen at the end of listeners chain to see if event wasn't canceled\u000a			// and to retrieve modified data.type.\u000a			editor.on( 'beforePaste', onBeforePaste, null, null, 1000 );\u000a\u000a			// getClipboardDataDirectly() will fire 'beforePaste' synchronously, so we can\u000a			// check if it was canceled and if any listener modified data.type.\u000a\u000a			// If command didn't succeed (only IE allows to access clipboard and only if\u000a			// user agrees) open and handle paste dialog.\u000a			if ( getClipboardDataDirectly() === false ) {\u000a				// Direct access to the clipboard wasn't successful so remove listener.\u000a				editor.removeListener( 'paste', onPaste );\u000a\u000a				// If beforePaste was canceled do not open dialog.\u000a				// Add listeners only if dialog really opened. 'pasteDialog' can be canceled.\u000a				if ( beforePasteNotCanceled && editor.fire( 'pasteDialog', onDialogOpen ) ) {\u000a					editor.on( 'pasteDialogCommit', onDialogCommit );\u000a\u000a					// 'dialogHide' will be fired after 'pasteDialogCommit'.\u000a					editor.on( 'dialogHide', function( evt ) {\u000a						evt.removeListener();\u000a						evt.data.removeListener( 'pasteDialogCommit', onDialogCommit );\u000a\u000a						// Because Opera has to wait a while in pasteDialog we have to wait here.\u000a						setTimeout( function() {\u000a							// Notify even if user canceled dialog (clicked 'cancel', ESC, etc).\u000a							if ( !dialogCommited )\u000a								callback( null );\u000a						}, 10 );\u000a					} );\u000a				} else\u000a					callback( null );\u000a			}\u000a\u000a			function onPaste( evt ) {\u000a				evt.removeListener();\u000a				evt.cancel();\u000a				callback( evt.data );\u000a			}\u000a\u000a			function onBeforePaste( evt ) {\u000a				evt.removeListener();\u000a				beforePasteNotCanceled = true;\u000a				dataType = evt.data.type;\u000a			}\u000a\u000a			function onDialogCommit( evt ) {\u000a				evt.removeListener();\u000a				// Cancel pasteDialogCommit so paste dialog won't automatically fire\u000a				// 'paste' evt by itself.\u000a				evt.cancel();\u000a				dialogCommited = true;\u000a				callback( { type: dataType, dataValue: evt.data } );\u000a			}\u000a\u000a			function onDialogOpen() {\u000a				this.customTitle = ( options && options.title );\u000a			}\u000a		};\u000a\u000a		function addButtonsCommands() {\u000a			addButtonCommand( 'Cut', 'cut', createCutCopyCmd( 'cut' ), 10, 1, 'cut fa fa-cut cut' );\u000a			addButtonCommand( 'Copy', 'copy', createCutCopyCmd( 'copy' ), 20, 4, 'copy fa fa-copy copy' );\u000a			addButtonCommand( 'Paste', 'paste', createPasteCmd(), 30, 8, 'paste fa fa-paste paste' );\u000a\u000a			function addButtonCommand( buttonName, commandName, command, toolbarOrder, ctxMenuOrder, icon ) {\u000a				var lang = editor.lang.clipboard[ commandName ];\u000a\u000a				editor.addCommand( commandName, command );\u000a				editor.ui.addButton && editor.ui.addButton( buttonName, {\u000a					icon: icon,\u000a					label: lang,\u000a					command: commandName,\u000a					toolbar: 'clipboard,' + toolbarOrder\u000a				} );\u000a\u000a				// If the "menu" plugin is loaded, register the menu item.\u000a				if ( editor.addMenuItems ) {\u000a					editor.addMenuItem( commandName, {\u000a						label: lang,\u000a						command: commandName,\u000a						group: 'clipboard',\u000a						order: ctxMenuOrder\u000a					} );\u000a				}\u000a			}\u000a		}\u000a\u000a		function addListeners() {\u000a			editor.on( 'key', onKey );\u000a			editor.on( 'contentDom', addListenersToEditable );\u000a\u000a			// For improved performance, we're checking the readOnly state on selectionChange instead of hooking a key event for that.\u000a			editor.on( 'selectionChange', function( evt ) {\u000a				inReadOnly = evt.data.selection.getRanges()[ 0 ].checkReadOnly();\u000a				setToolbarStates();\u000a			} );\u000a\u000a			// If the "contextmenu" plugin is loaded, register the listeners.\u000a			if ( editor.contextMenu ) {\u000a				editor.contextMenu.addListener( function( element, selection ) {\u000a					inReadOnly = selection.getRanges()[ 0 ].checkReadOnly();\u000a					return {\u000a						cut: stateFromNamedCommand( 'cut' ),\u000a						copy: stateFromNamedCommand( 'copy' ),\u000a						paste: stateFromNamedCommand( 'paste' )\u000a					};\u000a				} );\u000a			}\u000a		}\u000a\u000a		// Add events listeners to editable.\u000a		function addListenersToEditable() {\u000a			var editable = editor.editable();\u000a\u000a			// We'll be catching all pasted content in one line, regardless of whether\u000a			// it's introduced by a document command execution (e.g. toolbar buttons) or\u000a			// user paste behaviors (e.g. CTRL+V).\u000a			editable.on( mainPasteEvent, function( evt ) {\u000a				if ( CKEDITOR.env.ie && preventBeforePasteEvent )\u000a					return;\u000a\u000a				// If you've just asked yourself why preventPasteEventNow() is not here, but\u000a				// in listener for CTRL+V and exec method of 'paste' command\u000a				// you've asked the same question we did.\u000a				//\u000a				// THE ANSWER:\u000a				//\u000a				// First thing to notice - this answer makes sense only for IE,\u000a				// because other browsers don't listen for 'paste' event.\u000a				//\u000a				// What would happen if we move preventPasteEventNow() here?\u000a				// For:\u000a				// * CTRL+V - IE fires 'beforepaste', so we prevent 'paste' and pasteDataFromClipboard(). OK.\u000a				// * editor.execCommand( 'paste' ) - we fire 'beforepaste', so we prevent\u000a				//		'paste' and pasteDataFromClipboard() and doc.execCommand( 'Paste' ). OK.\u000a				// * native context menu - IE fires 'beforepaste', so we prevent 'paste', but unfortunately\u000a				//		on IE we fail with pasteDataFromClipboard() here, because of... we don't know why, but\u000a				//		we just fail, so... we paste nothing. FAIL.\u000a				// * native menu bar - the same as for native context menu.\u000a				//\u000a				// But don't you know any way to distinguish first two cases from last two?\u000a				// Only one - special flag set in CTRL+V handler and exec method of 'paste'\u000a				// command. And that's what we did using preventPasteEventNow().\u000a\u000a				pasteDataFromClipboard( evt );\u000a			} );\u000a\u000a			// It's not possible to clearly handle all four paste methods (ctrl+v, native menu bar\u000a			// native context menu, editor's command) in one 'paste/beforepaste' event in IE.\u000a			//\u000a			// For ctrl+v & editor's command it's easy to handle pasting in 'beforepaste' listener,\u000a			// so we do this. For another two methods it's better to use 'paste' event.\u000a			//\u000a			// 'paste' is always being fired after 'beforepaste' (except of weird one on opening native\u000a			// context menu), so for two methods handled in 'beforepaste' we're canceling 'paste'\u000a			// using preventPasteEvent state.\u000a			//\u000a			// 'paste' event in IE is being fired before getClipboardDataByPastebin executes its callback.\u000a			//\u000a			// QUESTION: Why didn't you handle all 4 paste methods in handler for 'paste'?\u000a			//		Wouldn't this just be simpler?\u000a			// ANSWER: Then we would have to evt.data.preventDefault() only for native\u000a			//		context menu and menu bar pastes. The same with execIECommand().\u000a			//		That would force us to mark CTRL+V and editor's paste command with\u000a			//		special flag, other than preventPasteEvent. But we still would have to\u000a			//		have preventPasteEvent for the second event fired by execIECommand.\u000a			//		Code would be longer and not cleaner.\u000a			CKEDITOR.env.ie && editable.on( 'paste', function( evt ) {\u000a				if ( preventPasteEvent )\u000a					return;\u000a				// Cancel next 'paste' event fired by execIECommand( 'paste' )\u000a				// at the end of this callback.\u000a				preventPasteEventNow();\u000a\u000a				// Prevent native paste.\u000a				evt.data.preventDefault();\u000a\u000a				pasteDataFromClipboard( evt );\u000a\u000a				// Force IE to paste content into pastebin so pasteDataFromClipboard will work.\u000a				if ( !execIECommand( 'paste' ) )\u000a					editor.openDialog( 'paste' );\u000a			} );\u000a\u000a			// [IE] Dismiss the (wrong) 'beforepaste' event fired on context/toolbar menu open. (#7953)\u000a			if ( CKEDITOR.env.ie ) {\u000a				editable.on( 'contextmenu', preventBeforePasteEventNow, null, null, 0 );\u000a\u000a				editable.on( 'beforepaste', function( evt ) {\u000a					// Do not prevent event on CTRL+V and SHIFT+INS because it blocks paste (#11970).\u000a					if ( evt.data && !evt.data.$.ctrlKey && !evt.data.$.shiftKey )\u000a						preventBeforePasteEventNow();\u000a				}, null, null, 0 );\u000a\u000a			}\u000a\u000a			editable.on( 'beforecut', function() {\u000a				!preventBeforePasteEvent && fixCut( editor );\u000a			} );\u000a\u000a			var mouseupTimeout;\u000a\u000a			// Use editor.document instead of editable in non-IEs for observing mouseup\u000a			// since editable won't fire the event if selection process started within\u000a			// iframe and ended out of the editor (#9851).\u000a			editable.attachListener( CKEDITOR.env.ie ? editable : editor.document.getDocumentElement(), 'mouseup', function() {\u000a				mouseupTimeout = setTimeout( function() {\u000a					setToolbarStates();\u000a				}, 0 );\u000a			} );\u000a\u000a			// Make sure that deferred mouseup callback isn't executed after editor instance\u000a			// had been destroyed. This may happen when editor.destroy() is called in parallel\u000a			// with mouseup event (i.e. a button with onclick callback) (#10219).\u000a			editor.on( 'destroy', function() {\u000a				clearTimeout( mouseupTimeout );\u000a			} );\u000a\u000a			editable.on( 'keyup', setToolbarStates );\u000a		}\u000a\u000a		// Create object representing Cut or Copy commands.\u000a		function createCutCopyCmd( type ) {\u000a			return {\u000a				type: type,\u000a				canUndo: type == 'cut', // We can't undo copy to clipboard.\u000a				startDisabled: true,\u000a				exec: function( data ) {\u000a					// Attempts to execute the Cut and Copy operations.\u000a					function tryToCutCopy( type ) {\u000a						if ( CKEDITOR.env.ie )\u000a							return execIECommand( type );\u000a\u000a						// non-IEs part\u000a						try {\u000a							// Other browsers throw an error if the command is disabled.\u000a							return editor.document.$.execCommand( type, false, null );\u000a						} catch ( e ) {\u000a							return false;\u000a						}\u000a					}\u000a\u000a					this.type == 'cut' && fixCut();\u000a\u000a					var success = tryToCutCopy( this.type );\u000a\u000a					if ( !success )\u000a						alert( editor.lang.clipboard[ this.type + 'Error' ] ); // Show cutError or copyError.\u000a\u000a					return success;\u000a				}\u000a			};\u000a		}\u000a\u000a		function createPasteCmd() {\u000a			return {\u000a				// Snapshots are done manually by editable.insertXXX methods.\u000a				canUndo: false,\u000a				async: true,\u000a\u000a				exec: function( editor, data ) {\u000a					var fire = function( data, withBeforePaste ) {\u000a							data && firePasteEvents( data.type, data.dataValue, !!withBeforePaste );\u000a\u000a							editor.fire( 'afterCommandExec', {\u000a								name: 'paste',\u000a								command: cmd,\u000a								returnValue: !!data\u000a							} );\u000a						},\u000a						cmd = this;\u000a\u000a					// Check data precisely - don't open dialog on empty string.\u000a					if ( typeof data == 'string' )\u000a						fire( { type: 'auto', dataValue: data }, 1 );\u000a					else\u000a						editor.getClipboardData( fire );\u000a				}\u000a			};\u000a		}\u000a\u000a		function preventPasteEventNow() {\u000a			preventPasteEvent = 1;\u000a			// For safety reason we should wait longer than 0/1ms.\u000a			// We don't know how long execution of quite complex getClipboardData will take\u000a			// and in for example 'paste' listner execCommand() (which fires 'paste') is called\u000a			// after getClipboardData finishes.\u000a			// Luckily, it's impossible to immediately fire another 'paste' event we want to handle,\u000a			// because we only handle there native context menu and menu bar.\u000a			setTimeout( function() {\u000a				preventPasteEvent = 0;\u000a			}, 100 );\u000a		}\u000a\u000a		function preventBeforePasteEventNow() {\u000a			preventBeforePasteEvent = 1;\u000a			setTimeout( function() {\u000a				preventBeforePasteEvent = 0;\u000a			}, 10 );\u000a		}\u000a\u000a		// Tries to execute any of the paste, cut or copy commands in IE. Returns a\u000a		// boolean indicating that the operation succeeded.\u000a		// @param {String} command *LOWER CASED* name of command ('paste', 'cut', 'copy').\u000a		function execIECommand( command ) {\u000a			var doc = editor.document,\u000a				body = doc.getBody(),\u000a				enabled = false,\u000a				onExec = function() {\u000a					enabled = true;\u000a				};\u000a\u000a			// The following seems to be the only reliable way to detect that\u000a			// clipboard commands are enabled in IE. It will fire the\u000a			// onpaste/oncut/oncopy events only if the security settings allowed\u000a			// the command to execute.\u000a			body.on( command, onExec );\u000a\u000a			// IE7: document.execCommand has problem to paste into positioned element.\u000a			( CKEDITOR.env.version > 7 ? doc.$ : doc.$.selection.createRange() )[ 'execCommand' ]( command );\u000a\u000a			body.removeListener( command, onExec );\u000a\u000a			return enabled;\u000a		}\u000a\u000a		function firePasteEvents( type, data, withBeforePaste ) {\u000a			var eventData = { type: type };\u000a\u000a			if ( withBeforePaste ) {\u000a				// Fire 'beforePaste' event so clipboard flavor get customized\u000a				// by other plugins.\u000a				if ( editor.fire( 'beforePaste', eventData ) === false )\u000a					return false; // Event canceled\u000a			}\u000a\u000a			// The very last guard to make sure the paste has successfully happened.\u000a			// This check should be done after firing 'beforePaste' because for native paste\u000a			// 'beforePaste' is by default fired even for empty clipboard.\u000a			if ( !data )\u000a				return false;\u000a\u000a			// Reuse eventData.type because the default one could be changed by beforePaste listeners.\u000a			eventData.dataValue = data;\u000a\u000a			return editor.fire( 'paste', eventData );\u000a		}\u000a\u000a		// Cutting off control type element in IE standards breaks the selection entirely. (#4881)\u000a		function fixCut() {\u000a			if ( !CKEDITOR.env.ie || CKEDITOR.env.quirks )\u000a				return;\u000a\u000a			var sel = editor.getSelection(),\u000a				control, range, dummy;\u000a\u000a			if ( ( sel.getType() == CKEDITOR.SELECTION_ELEMENT ) && ( control = sel.getSelectedElement() ) ) {\u000a				range = sel.getRanges()[ 0 ];\u000a				dummy = editor.document.createText( '' );\u000a				dummy.insertBefore( control );\u000a				range.setStartBefore( dummy );\u000a				range.setEndAfter( control );\u000a				sel.selectRanges( [ range ] );\u000a\u000a				// Clear up the fix if the paste wasn't succeeded.\u000a				setTimeout( function() {\u000a					// Element still online?\u000a					if ( control.getParent() ) {\u000a						dummy.remove();\u000a						sel.selectElement( control );\u000a					}\u000a				}, 0 );\u000a			}\u000a		}\u000a\u000a		// Allow to peek clipboard content by redirecting the\u000a		// pasting content into a temporary bin and grab the content of it.\u000a		function getClipboardDataByPastebin( evt, callback ) {\u000a			var doc = editor.document,\u000a				editable = editor.editable(),\u000a				cancel = function( evt ) {\u000a					evt.cancel();\u000a				},\u000a				blurListener;\u000a\u000a			// Avoid recursions on 'paste' event or consequent paste too fast. (#5730)\u000a			if ( doc.getById( 'cke_pastebin' ) )\u000a				return;\u000a\u000a			var sel = editor.getSelection();\u000a			var bms = sel.createBookmarks();\u000a\u000a			// #11384. On IE9+ we use native selectionchange (i.e. editor#selectionCheck) to cache the most\u000a			// recent selection which we then lock on editable blur. See selection.js for more info.\u000a			// selectionchange fired before getClipboardDataByPastebin() cached selection\u000a			// before creating bookmark (cached selection will be invalid, because bookmarks modified the DOM),\u000a			// so we need to fire selectionchange one more time, to store current seleciton.\u000a			// Selection will be locked when we focus pastebin.\u000a			if ( CKEDITOR.env.ie )\u000a				sel.root.fire( 'selectionchange' );\u000a\u000a			// Create container to paste into.\u000a			// For rich content we prefer to use "body" since it holds\u000a			// the least possibility to be splitted by pasted content, while this may\u000a			// breaks the text selection on a frame-less editable, "div" would be\u000a			// the best one in that case.\u000a			// In another case on old IEs moving the selection into a "body" paste bin causes error panic.\u000a			// Body can't be also used for Opera which fills it with <br>\u000a			// what is indistinguishable from pasted <br> (copying <br> in Opera isn't possible,\u000a			// but it can be copied from other browser).\u000a			var pastebin = new CKEDITOR.dom.element(\u000a				( CKEDITOR.env.webkit || editable.is( 'body' ) ) && !CKEDITOR.env.ie ? 'body' : 'div', doc );\u000a\u000a			pastebin.setAttributes( {\u000a				id: 'cke_pastebin',\u000a				'data-cke-temp': '1'\u000a			} );\u000a\u000a			var containerOffset = 0,\u000a				offsetParent,\u000a				win = doc.getWindow();\u000a\u000a			if ( CKEDITOR.env.webkit ) {\u000a				// It's better to paste close to the real paste destination, so inherited styles\u000a				// (which Webkits will try to compensate by styling span) differs less from the destination's one.\u000a				editable.append( pastebin );\u000a				// Style pastebin like .cke_editable, to minimize differences between origin and destination. (#9754)\u000a				pastebin.addClass( 'cke_editable' );\u000a\u000a				// Compensate position of offsetParent.\u000a				if ( !editable.is( 'body' ) ) {\u000a					// We're not able to get offsetParent from pastebin (body element), so check whether\u000a					// its parent (editable) is positioned.\u000a					if ( editable.getComputedStyle( 'position' ) != 'static' )\u000a						offsetParent = editable;\u000a					// And if not - safely get offsetParent from editable.\u000a					else\u000a						offsetParent = CKEDITOR.dom.element.get( editable.$.offsetParent );\u000a\u000a					containerOffset = offsetParent.getDocumentPosition().y;\u000a				}\u000a			} else {\u000a				// Opera and IE doesn't allow to append to html element.\u000a				editable.getAscendant( CKEDITOR.env.ie ? 'body' : 'html', 1 ).append( pastebin );\u000a			}\u000a\u000a			pastebin.setStyles( {\u000a				position: 'absolute',\u000a				// Position the bin at the top (+10 for safety) of viewport to avoid any subsequent document scroll.\u000a				top: ( win.getScrollPosition().y - containerOffset + 10 ) + 'px',\u000a				width: '1px',\u000a				// Caret has to fit in that height, otherwise browsers like Chrome & Opera will scroll window to show it.\u000a				// Set height equal to viewport's height - 20px (safety gaps), minimum 1px.\u000a				height: Math.max( 1, win.getViewPaneSize().height - 20 ) + 'px',\u000a				overflow: 'hidden',\u000a				// Reset styles that can mess up pastebin position.\u000a				margin: 0,\u000a				padding: 0\u000a			} );\u000a\u000a			// Paste fails in Safari when the body tag has 'user-select: none'. (#12506)\u000a			if ( CKEDITOR.env.safari )\u000a				pastebin.setStyles( CKEDITOR.tools.cssVendorPrefix( 'user-select', 'text' ) );\u000a\u000a			// Check if the paste bin now establishes new editing host.\u000a			var isEditingHost = pastebin.getParent().isReadOnly();\u000a\u000a			if ( isEditingHost ) {\u000a				// Hide the paste bin.\u000a				pastebin.setOpacity( 0 );\u000a				// And make it editable.\u000a				pastebin.setAttribute( 'contenteditable', true );\u000a			}\u000a			// Transparency is not enough since positioned non-editing host always shows\u000a			// resize handler, pull it off the screen instead.\u000a			else\u000a				pastebin.setStyle( editor.config.contentsLangDirection == 'ltr' ? 'left' : 'right', '-1000px' );\u000a\u000a			editor.on( 'selectionChange', cancel, null, null, 0 );\u000a\u000a			// Webkit fill fire blur on editable when moving selection to\u000a			// pastebin (if body is used). Cancel it because it causes incorrect\u000a			// selection lock in case of inline editor (#10644).\u000a			// The same seems to apply to Firefox (#10787).\u000a			if ( CKEDITOR.env.webkit || CKEDITOR.env.gecko )\u000a				blurListener = editable.once( 'blur', cancel, null, null, -100 );\u000a\u000a			// Temporarily move selection to the pastebin.\u000a			isEditingHost && pastebin.focus();\u000a			var range = new CKEDITOR.dom.range( pastebin );\u000a			range.selectNodeContents( pastebin );\u000a			var selPastebin = range.select();\u000a\u000a			// If non-native paste is executed, IE will open security alert and blur editable.\u000a			// Editable will then lock selection inside itself and after accepting security alert\u000a			// this selection will be restored. We overwrite stored selection, so it's restored\u000a			// in pastebin. (#9552)\u000a			if ( CKEDITOR.env.ie ) {\u000a				blurListener = editable.once( 'blur', function( evt ) {\u000a					editor.lockSelection( selPastebin );\u000a				} );\u000a			}\u000a\u000a			var scrollTop = CKEDITOR.document.getWindow().getScrollPosition().y;\u000a\u000a			// Wait a while and grab the pasted contents.\u000a			setTimeout( function() {\u000a				// Restore main window's scroll position which could have been changed\u000a				// by browser in cases described in #9771.\u000a				if ( CKEDITOR.env.webkit )\u000a					CKEDITOR.document.getBody().$.scrollTop = scrollTop;\u000a\u000a				// Blur will be fired only on non-native paste. In other case manually remove listener.\u000a				blurListener && blurListener.removeListener();\u000a\u000a				// Restore properly the document focus. (#8849)\u000a				if ( CKEDITOR.env.ie )\u000a					editable.focus();\u000a\u000a				// IE7: selection must go before removing pastebin. (#8691)\u000a				sel.selectBookmarks( bms );\u000a				pastebin.remove();\u000a\u000a				// Grab the HTML contents.\u000a				// We need to look for a apple style wrapper on webkit it also adds\u000a				// a div wrapper if you copy/paste the body of the editor.\u000a				// Remove hidden div and restore selection.\u000a				var bogusSpan;\u000a				if ( CKEDITOR.env.webkit && ( bogusSpan = pastebin.getFirst() ) && ( bogusSpan.is && bogusSpan.hasClass( 'Apple-style-span' ) ) )\u000a					pastebin = bogusSpan;\u000a\u000a				editor.removeListener( 'selectionChange', cancel );\u000a				callback( pastebin.getHtml() );\u000a			}, 0 );\u000a		}\u000a\u000a		// Try to get content directly from clipboard, without native event\u000a		// being fired before. In other words - synthetically get clipboard data\u000a		// if it's possible.\u000a		// mainPasteEvent will be fired, so if forced native paste:\u000a		// * worked, getClipboardDataByPastebin will grab it,\u000a		// * didn't work, pastebin will be empty and editor#paste won't be fired.\u000a		function getClipboardDataDirectly() {\u000a			if ( CKEDITOR.env.ie ) {\u000a				// Prevent IE from pasting at the begining of the document.\u000a				editor.focus();\u000a\u000a				// Command will be handled by 'beforepaste', but as\u000a				// execIECommand( 'paste' ) will fire also 'paste' event\u000a				// we're canceling it.\u000a				preventPasteEventNow();\u000a\u000a				// #9247: Lock focus to prevent IE from hiding toolbar for inline editor.\u000a				var focusManager = editor.focusManager;\u000a				focusManager.lock();\u000a\u000a				if ( editor.editable().fire( mainPasteEvent ) && !execIECommand( 'paste' ) ) {\u000a					focusManager.unlock();\u000a					return false;\u000a				}\u000a				focusManager.unlock();\u000a			} else {\u000a				try {\u000a					if ( editor.editable().fire( mainPasteEvent ) && !editor.document.$.execCommand( 'Paste', false, null ) )\u000a						throw 0;\u000a\u000a				} catch ( e ) {\u000a					return false;\u000a				}\u000a			}\u000a\u000a			return true;\u000a		}\u000a\u000a		// Listens for some clipboard related keystrokes, so they get customized.\u000a		// Needs to be bind to keydown event.\u000a		function onKey( event ) {\u000a			if ( editor.mode != 'wysiwyg' )\u000a				return;\u000a\u000a			switch ( event.data.keyCode ) {\u000a				// Paste\u000a				case CKEDITOR.CTRL + 86: // CTRL+V\u000a				case CKEDITOR.SHIFT + 45: // SHIFT+INS\u000a					var editable = editor.editable();\u000a\u000a					// Cancel 'paste' event because ctrl+v is for IE handled\u000a					// by 'beforepaste'.\u000a					preventPasteEventNow();\u000a\u000a					// Simulate 'beforepaste' event for all none-IEs.\u000a					!CKEDITOR.env.ie && editable.fire( 'beforepaste' );\u000a\u000a					return;\u000a\u000a					// Cut\u000a				case CKEDITOR.CTRL + 88: // CTRL+X\u000a				case CKEDITOR.SHIFT + 46: // SHIFT+DEL\u000a					// Save Undo snapshot.\u000a					editor.fire( 'saveSnapshot' ); // Save before cut\u000a					setTimeout( function() {\u000a						editor.fire( 'saveSnapshot' ); // Save after cut\u000a					}, 50 ); // OSX is slow (#11416).\u000a			}\u000a		}\u000a\u000a		function pasteDataFromClipboard( evt ) {\u000a			// Default type is 'auto', but can be changed by beforePaste listeners.\u000a			var eventData = { type: 'auto' };\u000a			// Fire 'beforePaste' event so clipboard flavor get customized by other plugins.\u000a			// If 'beforePaste' is canceled continue executing getClipboardDataByPastebin and then do nothing\u000a			// (do not fire 'paste', 'afterPaste' events). This way we can grab all - synthetically\u000a			// and natively pasted content and prevent its insertion into editor\u000a			// after canceling 'beforePaste' event.\u000a			var beforePasteNotCanceled = editor.fire( 'beforePaste', eventData );\u000a\u000a			getClipboardDataByPastebin( evt, function( data ) {\u000a				// Clean up.\u000a				data = data.replace( /<span[^>]+data-cke-bookmark[^<]*?<\u005c/span>/ig, '' );\u000a\u000a				// Fire remaining events (without beforePaste)\u000a				beforePasteNotCanceled && firePasteEvents( eventData.type, data, 0, 1 );\u000a			} );\u000a		}\u000a\u000a		function setToolbarStates() {\u000a			if ( editor.mode != 'wysiwyg' )\u000a				return;\u000a\u000a			var pasteState = stateFromNamedCommand( 'paste' );\u000a\u000a			editor.getCommand( 'cut' ).setState( stateFromNamedCommand( 'cut' ) );\u000a			editor.getCommand( 'copy' ).setState( stateFromNamedCommand( 'copy' ) );\u000a			editor.getCommand( 'paste' ).setState( pasteState );\u000a			editor.fire( 'pasteState', pasteState );\u000a		}\u000a\u000a		function stateFromNamedCommand( command ) {\u000a			if ( inReadOnly && command in { paste: 1, cut: 1 } )\u000a				return CKEDITOR.TRISTATE_DISABLED;\u000a\u000a			if ( command == 'paste' )\u000a				return CKEDITOR.TRISTATE_OFF;\u000a\u000a			// Cut, copy - check if the selection is not empty.\u000a			var sel = editor.getSelection(),\u000a				ranges = sel.getRanges(),\u000a				selectionIsEmpty = sel.getType() == CKEDITOR.SELECTION_NONE || ( ranges.length == 1 && ranges[ 0 ].collapsed );\u000a\u000a			return selectionIsEmpty ? CKEDITOR.TRISTATE_DISABLED : CKEDITOR.TRISTATE_OFF;\u000a		}\u000a	}\u000a\u000a	// Returns:\u000a	// * 'htmlifiedtext' if content looks like transformed by browser from plain text.\u000a	//		See clipboard/paste.html TCs for more info.\u000a	// * 'html' if it is not 'htmlifiedtext'.\u000a	function recogniseContentType( data ) {\u000a		if ( CKEDITOR.env.webkit ) {\u000a			// Plain text or ( <div><br></div> and text inside <div> ).\u000a			if ( !data.match( /^[^<]*$/g ) && !data.match( /^(<div><br( ?\u005c/)?><\u005c/div>|<div>[^<]*<\u005c/div>)*$/gi ) )\u000a				return 'html';\u000a		} else if ( CKEDITOR.env.ie ) {\u000a			// Text and <br> or ( text and <br> in <p> - paragraphs can be separated by new \u005cr\u005cn ).\u000a			if ( !data.match( /^([^<]|<br( ?\u005c/)?>)*$/gi ) && !data.match( /^(<p>([^<]|<br( ?\u005c/)?>)*<\u005c/p>|(\u005cr\u005cn))*$/gi ) )\u000a				return 'html';\u000a		} else if ( CKEDITOR.env.gecko ) {\u000a			// Text or <br>.\u000a			if ( !data.match( /^([^<]|<br( ?\u005c/)?>)*$/gi ) )\u000a				return 'html';\u000a		} else\u000a			return 'html';\u000a\u000a		return 'htmlifiedtext';\u000a	}\u000a\u000a	// This function transforms what browsers produce when\u000a	// pasting plain text into editable element (see clipboard/paste.html TCs\u000a	// for more info) into correct HTML (similar to that produced by text2Html).\u000a	function htmlifiedTextHtmlification( config, data ) {\u000a		function repeatParagraphs( repeats ) {\u000a			// Repeat blocks floor((n+1)/2) times.\u000a			// Even number of repeats - add <br> at the beginning of last <p>.\u000a			return CKEDITOR.tools.repeat( '</p><p>', ~~ ( repeats / 2 ) ) + ( repeats % 2 == 1 ? '<br>' : '' );\u000a		}\u000a\u000a			// Replace adjacent white-spaces (EOLs too - Fx sometimes keeps them) with one space.\u000a		data = data.replace( /\u005cs+/g, ' ' )\u000a			// Remove spaces from between tags.\u000a			.replace( /> +</g, '><' )\u000a			// Normalize XHTML syntax and upper cased <br> tags.\u000a			.replace( /<br ?\u005c/>/gi, '<br>' );\u000a\u000a		// IE - lower cased tags.\u000a		data = data.replace( /<\u005c/?[A-Z]+>/g, function( match ) {\u000a			return match.toLowerCase();\u000a		} );\u000a\u000a		// Don't touch single lines (no <br|p|div>) - nothing to do here.\u000a		if ( data.match( /^[^<]$/ ) )\u000a			return data;\u000a\u000a		// Webkit.\u000a		if ( CKEDITOR.env.webkit && data.indexOf( '<div>' ) > -1 ) {\u000a				// One line break at the beginning - insert <br>\u000a			data = data.replace( /^(<div>(<br>|)<\u005c/div>)(?!$|(<div>(<br>|)<\u005c/div>))/g, '<br>' )\u000a				// Two or more - reduce number of new lines by one.\u000a				.replace( /^(<div>(<br>|)<\u005c/div>){2}(?!$)/g, '<div></div>' );\u000a\u000a			// Two line breaks create one paragraph in Webkit.\u000a			if ( data.match( /<div>(<br>|)<\u005c/div>/ ) ) {\u000a				data = '<p>' + data.replace( /(<div>(<br>|)<\u005c/div>)+/g, function( match ) {\u000a					return repeatParagraphs( match.split( '</div><div>' ).length + 1 );\u000a				} ) + '</p>';\u000a			}\u000a\u000a			// One line break create br.\u000a			data = data.replace( /<\u005c/div><div>/g, '<br>' );\u000a\u000a			// Remove remaining divs.\u000a			data = data.replace( /<\u005c/?div>/g, '' );\u000a		}\u000a\u000a		// Opera and Firefox and enterMode != BR.\u000a		if ( CKEDITOR.env.gecko && config.enterMode != CKEDITOR.ENTER_BR ) {\u000a			// Remove bogus <br> - Fx generates two <brs> for one line break.\u000a			// For two line breaks it still produces two <brs>, but it's better to ignore this case than the first one.\u000a			if ( CKEDITOR.env.gecko )\u000a				data = data.replace( /^<br><br>$/, '<br>' );\u000a\u000a			// This line satisfy edge case when for Opera we have two line breaks\u000a			//data = data.replace( /)\u000a\u000a			if ( data.indexOf( '<br><br>' ) > -1 ) {\u000a				// Two line breaks create one paragraph, three - 2, four - 3, etc.\u000a				data = '<p>' + data.replace( /(<br>){2,}/g, function( match ) {\u000a					return repeatParagraphs( match.length / 4 );\u000a				} ) + '</p>';\u000a			}\u000a		}\u000a\u000a		return switchEnterMode( config, data );\u000a	}\u000a\u000a	// Filter can be editor dependent.\u000a	function getTextificationFilter( editor ) {\u000a		var filter = new CKEDITOR.htmlParser.filter();\u000a\u000a		// Elements which creates vertical breaks (have vert margins) - took from HTML5 spec.\u000a		// http://dev.w3.org/html5/markup/Overview.html#toc\u000a		var replaceWithParaIf = { blockquote: 1, dl: 1, fieldset: 1, h1: 1, h2: 1, h3: 1, h4: 1, h5: 1, h6: 1, ol: 1, p: 1, table: 1, ul: 1 },\u000a\u000a			// All names except of <br>.\u000a			stripInlineIf = CKEDITOR.tools.extend( { br: 0 }, CKEDITOR.dtd.$inline ),\u000a\u000a			// What's finally allowed (cke:br will be removed later).\u000a			allowedIf = { p: 1, br: 1, 'cke:br': 1 },\u000a\u000a			knownIf = CKEDITOR.dtd,\u000a\u000a			// All names that will be removed (with content).\u000a			removeIf = CKEDITOR.tools.extend( { area: 1, basefont: 1, embed: 1, iframe: 1, map: 1, object: 1, param: 1 }, CKEDITOR.dtd.$nonBodyContent, CKEDITOR.dtd.$cdata );\u000a\u000a		var flattenTableCell = function( element ) {\u000a				delete element.name;\u000a				element.add( new CKEDITOR.htmlParser.text( ' ' ) );\u000a			},\u000a			// Squash adjacent headers into one. <h1>A</h1><h2>B</h2> -> <h1>A<br>B</h1><h2></h2>\u000a			// Empty ones will be removed later.\u000a			squashHeader = function( element ) {\u000a				var next = element,\u000a					br, el;\u000a\u000a				while ( ( next = next.next ) && next.name && next.name.match( /^h\u005cd$/ ) ) {\u000a					// TODO shitty code - waitin' for htmlParse.element fix.\u000a					br = new CKEDITOR.htmlParser.element( 'cke:br' );\u000a					br.isEmpty = true;\u000a					element.add( br );\u000a					while ( ( el = next.children.shift() ) )\u000a						element.add( el );\u000a				}\u000a			};\u000a\u000a		filter.addRules( {\u000a			elements: {\u000a				h1: squashHeader,\u000a				h2: squashHeader,\u000a				h3: squashHeader,\u000a				h4: squashHeader,\u000a				h5: squashHeader,\u000a				h6: squashHeader,\u000a\u000a				img: function( element ) {\u000a					var alt = CKEDITOR.tools.trim( element.attributes.alt || '' ),\u000a						txt = ' ';\u000a\u000a					// Replace image with its alt if it doesn't look like an url or is empty.\u000a					if ( alt && !alt.match( /(^http|\u005c.(jpe?g|gif|png))/i ) )\u000a						txt = ' [' + alt + '] ';\u000a\u000a					return new CKEDITOR.htmlParser.text( txt );\u000a				},\u000a\u000a				td: flattenTableCell,\u000a				th: flattenTableCell,\u000a\u000a				$: function( element ) {\u000a					var initialName = element.name,\u000a						br;\u000a\u000a					// Remove entirely.\u000a					if ( removeIf[ initialName ] )\u000a						return false;\u000a\u000a					// Remove all attributes.\u000a					element.attributes = {};\u000a\u000a					// Pass brs.\u000a					if ( initialName == 'br' )\u000a						return element;\u000a\u000a					// Elements that we want to replace with paragraphs.\u000a					if ( replaceWithParaIf[ initialName ] )\u000a						element.name = 'p';\u000a\u000a					// Elements that we want to strip (tags only, without the content).\u000a					else if ( stripInlineIf[ initialName ] )\u000a						delete element.name;\u000a\u000a					// Surround other known element with <brs> and strip tags.\u000a					else if ( knownIf[ initialName ] ) {\u000a						// TODO shitty code - waitin' for htmlParse.element fix.\u000a						br = new CKEDITOR.htmlParser.element( 'cke:br' );\u000a						br.isEmpty = true;\u000a\u000a						// Replace hrs (maybe sth else too?) with only one br.\u000a						if ( CKEDITOR.dtd.$empty[ initialName ] )\u000a							return br;\u000a\u000a						element.add( br, 0 );\u000a						br = br.clone();\u000a						br.isEmpty = true;\u000a						element.add( br );\u000a						delete element.name;\u000a					}\u000a\u000a					// Final cleanup - if we can still find some not allowed elements then strip their names.\u000a					if ( !allowedIf[ element.name ] )\u000a						delete element.name;\u000a\u000a					return element;\u000a				}\u000a			}\u000a		}, {\u000a			// Apply this filter to every element.\u000a			applyToAll: true\u000a		} );\u000a\u000a		return filter;\u000a	}\u000a\u000a	function htmlTextification( config, data, filter ) {\u000a		var fragment = new CKEDITOR.htmlParser.fragment.fromHtml( data ),\u000a			writer = new CKEDITOR.htmlParser.basicWriter();\u000a\u000a		fragment.writeHtml( writer, filter );\u000a		data = writer.getHtml();\u000a\u000a		// Cleanup cke:brs.\u000a		data = data.replace( /\u005cs*(<\u005c/?[a-z:]+ ?\u005c/?>)\u005cs*/g, '$1' )	// Remove spaces around tags.\u000a			.replace( /(<cke:br \u005c/>){2,}/g, '<cke:br />' )			// Join multiple adjacent cke:brs\u000a			.replace( /(<cke:br \u005c/>)(<\u005c/?p>|<br \u005c/>)/g, '$2' )		// Strip cke:brs adjacent to original brs or ps.\u000a			.replace( /(<\u005c/?p>|<br \u005c/>)(<cke:br \u005c/>)/g, '$1' )\u000a			.replace( /<(cke:)?br( \u005c/)?>/g, '<br>' )				// Finally - rename cke:brs to brs and fix <br /> to <br>.\u000a			.replace( /<p><\u005c/p>/g, '' );							// Remove empty paragraphs.\u000a\u000a		// Fix nested ps. E.g.:\u000a		// <p>A<p>B<p>C</p>D<p>E</p>F</p>G\u000a		// <p>A</p><p>B</p><p>C</p><p>D</p><p>E</p><p>F</p>G\u000a		var nested = 0;\u000a		data = data.replace( /<\u005c/?p>/g, function( match ) {\u000a			if ( match == '<p>' ) {\u000a				if ( ++nested > 1 )\u000a					return '</p><p>';\u000a			} else {\u000a				if ( --nested > 0 )\u000a					return '</p><p>';\u000a			}\u000a\u000a			return match;\u000a		} ).replace( /<p><\u005c/p>/g, '' ); // Step before: </p></p> -> </p><p></p><p>. Fix this here.\u000a\u000a		return switchEnterMode( config, data );\u000a	}\u000a\u000a	function switchEnterMode( config, data ) {\u000a		if ( config.enterMode == CKEDITOR.ENTER_BR ) {\u000a			data = data.replace( /(<\u005c/p><p>)+/g, function( match ) {\u000a				return CKEDITOR.tools.repeat( '<br>', match.length / 7 * 2 );\u000a			} ).replace( /<\u005c/?p>/g, '' );\u000a		} else if ( config.enterMode == CKEDITOR.ENTER_DIV )\u000a			data = data.replace( /<(\u005c/)?p>/g, '<$1div>' );\u000a\u000a		return data;\u000a	}\u000a} )();\u000a\u000a/**\u000a * The default content type is used when pasted data cannot be clearly recognized as HTML or text.\u000a *\u000a * For example: `'foo'` may come from a plain text editor or a website. It isn't possible to recognize content\u000a * type in this case, so default will be used. However, it's clear that `'<b>example</b> text'` is an HTML\u000a * and its origin is webpage, email or other rich text editor.\u000a *\u000a * **Note:** If content type is text, then styles of context of paste are preserved.\u000a *\u000a *		CKEDITOR.config.clipboard_defaultContentType = 'text';\u000a *\u000a * @since 4.0\u000a * @cfg {'html'/'text'} [clipboard_defaultContentType='html']\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * Fired when a clipboard operation is about to be taken into the editor.\u000a * Listeners can manipulate the data to be pasted before having it effectively\u000a * inserted into the document.\u000a *\u000a * @since 3.1\u000a * @event paste\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param data\u000a * @param {String} data.type Type of data in `data.dataValue`. Usually `html` or `text`, but for listeners\u000a * with priority less than 6 it may be also `auto`, what means that content type hasn't been recognised yet\u000a * (this will be done by content type sniffer that listens with priority 6).\u000a * @param {String} data.dataValue HTML to be pasted.\u000a */\u000a\u000a/**\u000a * Fired before the {@link #paste} event. Allows to preset data type.\u000a *\u000a * **Note:** This event is deprecated. Add a `0` priority listener for the\u000a * {@link #paste} event instead.\u000a *\u000a * @deprecated\u000a * @event beforePaste\u000a * @member CKEDITOR.editor\u000a */\u000a\u000a/**\u000a * Internal event to open the Paste dialog.\u000a *\u000a * @private\u000a * @event pasteDialog\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @param {Function} [data] Callback that will be passed to {@link CKEDITOR.editor#openDialog}.\u000a */\u000a\u000a\ufeff/*\u000aCopyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000aFor licensing, see LICENSE.md or http://ckeditor.com/license\u000a*/\u000aCKEDITOR.plugins.setLang( 'clipboard', 'en', {\u000a	copy: 'Copy',\u000a	copyError: 'Your browser security settings don\u005c't permit the editor to automatically execute copying operations. Please use the keyboard for that (Ctrl/Cmd+C).',\u000a	cut: 'Cut',\u000a	cutError: 'Your browser security settings don\u005c't permit the editor to automatically execute cutting operations. Please use the keyboard for that (Ctrl/Cmd+X).',\u000a	paste: 'Paste',\u000a	pasteArea: 'Paste Area',\u000a	pasteMsg: 'Please paste inside the following box using the keyboard (<strong>Ctrl/Cmd+V</strong>) and hit OK',\u000a	securityMsg: 'Because of your browser security settings, the editor is not able to access your clipboard data directly. You are required to paste it again in this window.',\u000a	title: 'Paste'\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000aCKEDITOR.dialog.add( 'paste', function( editor ) {\u000a	var lang = editor.lang.clipboard;\u000a\u000a	function onPasteFrameLoad( win ) {\u000a		var doc = new CKEDITOR.dom.document( win.document ),\u000a			body = doc.getBody(),\u000a			script = doc.getById( 'cke_actscrpt' );\u000a\u000a		script && script.remove();\u000a\u000a		body.setAttribute( 'contenteditable', true );\u000a\u000a		// IE before version 8 will leave cursor blinking inside the document after\u000a		// editor blurred unless we clean up the selection. (#4716)\u000a		if ( CKEDITOR.env.ie && CKEDITOR.env.version < 8 ) {\u000a			doc.getWindow().on( 'blur', function() {\u000a				doc.$.selection.empty();\u000a			} );\u000a		}\u000a\u000a		doc.on( 'keydown', function( e ) {\u000a			var domEvent = e.data,\u000a				key = domEvent.getKeystroke(),\u000a				processed;\u000a\u000a			switch ( key ) {\u000a				case 27:\u000a					this.hide();\u000a					processed = 1;\u000a					break;\u000a\u000a				case 9:\u000a				case CKEDITOR.SHIFT + 9:\u000a					this.changeFocus( 1 );\u000a					processed = 1;\u000a			}\u000a\u000a			processed && domEvent.preventDefault();\u000a		}, this );\u000a\u000a		editor.fire( 'ariaWidget', new CKEDITOR.dom.element( win.frameElement ) );\u000a\u000a		// Handle pending focus.\u000a		if ( doc.getWindow().getFrame().removeCustomData( 'pendingFocus' ) )\u000a			body.focus();\u000a	}\u000a\u000a	// If pasteDialogCommit wasn't canceled by e.g. editor.getClipboardData\u000a	// then fire paste event.\u000a	// Do not use editor#paste, because it would start from beforePaste event.\u000a	editor.on( 'pasteDialogCommit', function( evt ) {\u000a		if ( evt.data )\u000a			editor.fire( 'paste', { type: 'auto', dataValue: evt.data } );\u000a	}, null, null, 1000 );\u000a\u000a	return {\u000a		title: lang.title,\u000a\u000a		minWidth: CKEDITOR.env.ie && CKEDITOR.env.quirks ? 370 : 350,\u000a		minHeight: CKEDITOR.env.quirks ? 250 : 245,\u000a		onShow: function() {\u000a			// FIREFOX BUG: Force the browser to render the dialog to make the to-be-\u000a			// inserted iframe editable. (#3366)\u000a			this.parts.dialog.$.offsetHeight;\u000a\u000a			this.setupContent();\u000a\u000a			// Set dialog title to the custom value (set e.g. in editor.openDialog callback) and reset this value.\u000a			// If custom title not set, use default one.\u000a			this.parts.title.setHtml( this.customTitle || lang.title );\u000a			this.customTitle = null;\u000a		},\u000a\u000a		onLoad: function() {\u000a			if ( ( CKEDITOR.env.ie7Compat || CKEDITOR.env.ie6Compat ) && editor.lang.dir == 'rtl' )\u000a				this.parts.contents.setStyle( 'overflow', 'hidden' );\u000a		},\u000a\u000a		onOk: function() {\u000a			this.commitContent();\u000a		},\u000a\u000a		contents: [\u000a			{\u000a			id: 'general',\u000a			label: editor.lang.common.generalTab,\u000a			elements: [\u000a				{\u000a				type: 'html',\u000a				id: 'securityMsg',\u000a				html: '<div style="white-space:normal;width:340px">' + lang.securityMsg + '</div>'\u000a			},\u000a				{\u000a				type: 'html',\u000a				id: 'pasteMsg',\u000a				html: '<div style="white-space:normal;width:340px">' + lang.pasteMsg + '</div>'\u000a			},\u000a				{\u000a				type: 'html',\u000a				id: 'editing_area',\u000a				style: 'width:100%;height:100%',\u000a				html: '',\u000a				focus: function() {\u000a					var iframe = this.getInputElement(),\u000a						doc = iframe.getFrameDocument(),\u000a						body = doc.getBody();\u000a\u000a					// Frame content may not loaded at the moment.\u000a					if ( !body || body.isReadOnly() )\u000a						iframe.setCustomData( 'pendingFocus', 1 );\u000a					else\u000a						body.focus();\u000a				},\u000a				setup: function() {\u000a					var dialog = this.getDialog();\u000a					var htmlToLoad = '<html dir="' + editor.config.contentsLangDirection + '"' +\u000a						' lang="' + ( editor.config.contentsLanguage || editor.langCode ) + '">' +\u000a						'<head><style>body{margin:3px;height:95%}</style></head><body>' +\u000a						'<script id="cke_actscrpt" type="text/javascript">' +\u000a						'window.parent.CKEDITOR.tools.callFunction(' + CKEDITOR.tools.addFunction( onPasteFrameLoad, dialog ) + ',this);' +\u000a						'</script></body>' +\u000a						'</html>';\u000a\u000a					var src =\u000a							CKEDITOR.env.air ?\u000a								'javascript:void(0)' :\u000a							CKEDITOR.env.ie ?\u000a								'javascript:void((function(){' + encodeURIComponent(\u000a									'document.open();' +\u000a									'(' + CKEDITOR.tools.fixDomain + ')();' +\u000a									'document.close();'\u000a								) + '})())"'\u000a							: '';\u000a\u000a					var iframe = CKEDITOR.dom.element.createFromHtml( '<iframe' +\u000a						' class="cke_pasteframe"' +\u000a						' frameborder="0" ' +\u000a						' allowTransparency="true"' +\u000a						' src="' + src + '"' +\u000a						' role="region"' +\u000a						' aria-label="' + lang.pasteArea + '"' +\u000a						' aria-describedby="' + dialog.getContentElement( 'general', 'pasteMsg' ).domId + '"' +\u000a						' aria-multiple="true"' +\u000a						'></iframe>' );\u000a\u000a					iframe.on( 'load', function( e ) {\u000a						e.removeListener();\u000a\u000a						var doc = iframe.getFrameDocument();\u000a						doc.write( htmlToLoad );\u000a\u000a						editor.focusManager.add( doc.getBody() );\u000a\u000a						if ( CKEDITOR.env.air )\u000a							onPasteFrameLoad.call( this, doc.getWindow().$ );\u000a					}, dialog );\u000a\u000a					iframe.setCustomData( 'dialog', dialog );\u000a\u000a					var container = this.getElement();\u000a					container.setHtml( '' );\u000a					container.append( iframe );\u000a\u000a					// IE need a redirect on focus to make\u000a					// the cursor blinking inside iframe. (#5461)\u000a					if ( CKEDITOR.env.ie ) {\u000a						var focusGrabber = CKEDITOR.dom.element.createFromHtml( '<span tabindex="-1" style="position:absolute" role="presentation"></span>' );\u000a						focusGrabber.on( 'focus', function() {\u000a							// Since fixDomain is called in src attribute,\u000a							// IE needs some slight delay to correctly move focus.\u000a							setTimeout( function() {\u000a								iframe.$.contentWindow.focus();\u000a							} );\u000a						} );\u000a						container.append( focusGrabber );\u000a\u000a						// Override focus handler on field.\u000a						this.focus = function() {\u000a							focusGrabber.focus();\u000a							this.fire( 'focus' );\u000a						};\u000a					}\u000a\u000a					this.getInputElement = function() {\u000a						return iframe;\u000a					};\u000a\u000a					// Force container to scale in IE.\u000a					if ( CKEDITOR.env.ie ) {\u000a						container.setStyle( 'display', 'block' );\u000a						container.setStyle( 'height', ( iframe.$.offsetHeight + 2 ) + 'px' );\u000a					}\u000a				},\u000a				commit: function( data ) {\u000a					var editor = this.getDialog().getParentEditor(),\u000a						body = this.getInputElement().getFrameDocument().getBody(),\u000a						bogus = body.getBogus(),\u000a						html;\u000a					bogus && bogus.remove();\u000a\u000a					// Saving the contents so changes until paste is complete will not take place (#7500)\u000a					html = body.getHtml();\u000a\u000a					// Opera needs some time to think about what has happened and what it should do now.\u000a					setTimeout( function() {\u000a						editor.fire( 'pasteDialogCommit', html );\u000a					}, 0 );\u000a				}\u000a			}\u000a			]\u000a		}\u000a		]\u000a	};\u000a} );\u000a\u000a/**\u000a * Internal event to pass paste dialog's data to the listeners.\u000a *\u000a * @private\u000a * @event pasteDialogCommit\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	CKEDITOR.plugins.add( 'enterkey', {\u000a		init: function( editor ) {\u000a			editor.addCommand( 'enter', {\u000a				modes: { wysiwyg: 1 },\u000a				editorFocus: false,\u000a				exec: function( editor ) {\u000a					enter( editor );\u000a				}\u000a			} );\u000a\u000a			editor.addCommand( 'shiftEnter', {\u000a				modes: { wysiwyg: 1 },\u000a				editorFocus: false,\u000a				exec: function( editor ) {\u000a					shiftEnter( editor );\u000a				}\u000a			} );\u000a\u000a			editor.setKeystroke( [\u000a				[ 13, 'enter' ],\u000a				[ CKEDITOR.SHIFT + 13, 'shiftEnter' ]\u000a			] );\u000a		}\u000a	} );\u000a\u000a	var whitespaces = CKEDITOR.dom.walker.whitespaces(),\u000a		bookmark = CKEDITOR.dom.walker.bookmark();\u000a\u000a	CKEDITOR.plugins.enterkey = {\u000a		enterBlock: function( editor, mode, range, forceMode ) {\u000a			// Get the range for the current selection.\u000a			range = range || getRange( editor );\u000a\u000a			// We may not have valid ranges to work on, like when inside a\u000a			// contenteditable=false element.\u000a			if ( !range )\u000a				return;\u000a\u000a			// When range is in nested editable, we have to replace range with this one,\u000a			// which have root property set to closest editable, to make auto paragraphing work. (#12162)\u000a			range = replaceRangeWithClosestEditableRoot( range );\u000a\u000a			var doc = range.document;\u000a\u000a			var atBlockStart = range.checkStartOfBlock(),\u000a				atBlockEnd = range.checkEndOfBlock(),\u000a				path = editor.elementPath( range.startContainer ),\u000a				block = path.block,\u000a\u000a				// Determine the block element to be used.\u000a				blockTag = ( mode == CKEDITOR.ENTER_DIV ? 'div' : 'p' ),\u000a\u000a				newBlock;\u000a\u000a			// Exit the list when we're inside an empty list item block. (#5376)\u000a			if ( atBlockStart && atBlockEnd ) {\u000a				// Exit the list when we're inside an empty list item block. (#5376)\u000a				if ( block && ( block.is( 'li' ) || block.getParent().is( 'li' ) ) ) {\u000a					// Make sure to point to the li when dealing with empty list item.\u000a					if ( !block.is( 'li' ) )\u000a						block = block.getParent();\u000a\u000a					var blockParent = block.getParent(),\u000a						blockGrandParent = blockParent.getParent(),\u000a\u000a						firstChild = !block.hasPrevious(),\u000a						lastChild = !block.hasNext(),\u000a\u000a						selection = editor.getSelection(),\u000a						bookmarks = selection.createBookmarks(),\u000a\u000a						orgDir = block.getDirection( 1 ),\u000a						className = block.getAttribute( 'class' ),\u000a						style = block.getAttribute( 'style' ),\u000a						dirLoose = blockGrandParent.getDirection( 1 ) != orgDir,\u000a\u000a						enterMode = editor.enterMode,\u000a						needsBlock = enterMode != CKEDITOR.ENTER_BR || dirLoose || style || className,\u000a\u000a						child;\u000a\u000a					if ( blockGrandParent.is( 'li' ) ) {\u000a\u000a						// If block is the first or the last child of the parent\u000a						// list, degrade it and move to the outer list:\u000a						// before the parent list if block is first child and after\u000a						// the parent list if block is the last child, respectively.\u000a						//\u000a						//  <ul>                         =>      <ul>\u000a						//      <li>                     =>          <li>\u000a						//          <ul>                 =>              <ul>\u000a						//              <li>x</li>       =>                  <li>x</li>\u000a						//              <li>^</li>       =>              </ul>\u000a						//          </ul>                =>          </li>\u000a						//      </li>                    =>          <li>^</li>\u000a						//  </ul>                        =>      </ul>\u000a						//\u000a						//                              AND\u000a						//\u000a						//  <ul>                         =>      <ul>\u000a						//      <li>                     =>          <li>^</li>\u000a						//          <ul>                 =>          <li>\u000a						//              <li>^</li>       =>              <ul>\u000a						//              <li>x</li>       =>                  <li>x</li>\u000a						//          </ul>                =>              </ul>\u000a						//      </li>                    =>          </li>\u000a						//  </ul>                        =>      </ul>\u000a\u000a						if ( firstChild || lastChild )\u000a							block[ firstChild ? 'insertBefore' : 'insertAfter' ]( blockGrandParent );\u000a\u000a						// If the empty block is neither first nor last child\u000a						// then split the list and the block as an element\u000a						// of outer list.\u000a						//\u000a						//                              =>      <ul>\u000a						//                              =>          <li>\u000a						//  <ul>                        =>              <ul>\u000a						//      <li>                    =>                  <li>x</li>\u000a						//          <ul>                =>              </ul>\u000a						//              <li>x</li>      =>          </li>\u000a						//              <li>^</li>      =>          <li>^</li>\u000a						//              <li>y</li>      =>          <li>\u000a						//          </ul>               =>              <ul>\u000a						//      </li>                   =>                  <li>y</li>\u000a						//  </ul>                       =>              </ul>\u000a						//                              =>          </li>\u000a						//                              =>      </ul>\u000a\u000a						else\u000a							block.breakParent( blockGrandParent );\u000a					}\u000a\u000a					else if ( !needsBlock ) {\u000a						block.appendBogus( true );\u000a\u000a						// If block is the first or last child of the parent\u000a						// list, move all block's children out of the list:\u000a						// before the list if block is first child and after the list\u000a						// if block is the last child, respectively.\u000a						//\u000a						//  <ul>                       =>      <ul>\u000a						//      <li>x</li>             =>          <li>x</li>\u000a						//      <li>^</li>             =>      </ul>\u000a						//  </ul>                      =>      ^\u000a						//\u000a						//                            AND\u000a						//\u000a						//  <ul>                       =>      ^\u000a						//      <li>^</li>             =>      <ul>\u000a						//      <li>x</li>             =>          <li>x</li>\u000a						//  </ul>                      =>      </ul>\u000a\u000a						if ( firstChild || lastChild ) {\u000a							while ( ( child = block[ firstChild ? 'getFirst' : 'getLast' ]() ) )\u000a								child[ firstChild ? 'insertBefore' : 'insertAfter' ]( blockParent );\u000a						}\u000a\u000a						// If the empty block is neither first nor last child\u000a						// then split the list and put all the block contents\u000a						// between two lists.\u000a						//\u000a						//  <ul>                       =>      <ul>\u000a						//      <li>x</li>             =>          <li>x</li>\u000a						//      <li>^</li>             =>      </ul>\u000a						//      <li>y</li>             =>      ^\u000a						//  </ul>                      =>      <ul>\u000a						//                             =>          <li>y</li>\u000a						//                             =>      </ul>\u000a\u000a						else {\u000a							block.breakParent( blockParent );\u000a\u000a							while ( ( child = block.getLast() ) )\u000a								child.insertAfter( blockParent );\u000a						}\u000a\u000a						block.remove();\u000a					} else {\u000a						// Original path block is the list item, create new block for the list item content.\u000a						if ( path.block.is( 'li' ) ) {\u000a							// Use <div> block for ENTER_BR and ENTER_DIV.\u000a							newBlock = doc.createElement( mode == CKEDITOR.ENTER_P ? 'p' : 'div' );\u000a\u000a							if ( dirLoose )\u000a								newBlock.setAttribute( 'dir', orgDir );\u000a\u000a							style && newBlock.setAttribute( 'style', style );\u000a							className && newBlock.setAttribute( 'class', className );\u000a\u000a							// Move all the child nodes to the new block.\u000a							block.moveChildren( newBlock );\u000a						}\u000a						// The original path block is not a list item, just copy the block to out side of the list.\u000a						else {\u000a							newBlock = path.block;\u000a						}\u000a\u000a						// If block is the first or last child of the parent\u000a						// list, move it out of the list:\u000a						// before the list if block is first child and after the list\u000a						// if block is the last child, respectively.\u000a						//\u000a						//  <ul>                       =>      <ul>\u000a						//      <li>x</li>             =>          <li>x</li>\u000a						//      <li>^</li>             =>      </ul>\u000a						//  </ul>                      =>      <p>^</p>\u000a						//\u000a						//                            AND\u000a						//\u000a						//  <ul>                       =>      <p>^</p>\u000a						//      <li>^</li>             =>      <ul>\u000a						//      <li>x</li>             =>          <li>x</li>\u000a						//  </ul>                      =>      </ul>\u000a\u000a						if ( firstChild || lastChild )\u000a							newBlock[ firstChild ? 'insertBefore' : 'insertAfter' ]( blockParent );\u000a\u000a						// If the empty block is neither first nor last child\u000a						// then split the list and put the new block between\u000a						// two lists.\u000a						//\u000a						//                             =>       <ul>\u000a						//     <ul>                    =>           <li>x</li>\u000a						//         <li>x</li>          =>       </ul>\u000a						//         <li>^</li>          =>       <p>^</p>\u000a						//         <li>y</li>          =>       <ul>\u000a						//     </ul>                   =>           <li>y</li>\u000a						//                             =>       </ul>\u000a\u000a						else {\u000a							block.breakParent( blockParent );\u000a							newBlock.insertAfter( blockParent );\u000a						}\u000a\u000a						block.remove();\u000a					}\u000a\u000a					selection.selectBookmarks( bookmarks );\u000a\u000a					return;\u000a				}\u000a\u000a				if ( block && block.getParent().is( 'blockquote' ) ) {\u000a					block.breakParent( block.getParent() );\u000a\u000a					// If we were at the start of <blockquote>, there will be an empty element before it now.\u000a					if ( !block.getPrevious().getFirst( CKEDITOR.dom.walker.invisible( 1 ) ) )\u000a						block.getPrevious().remove();\u000a\u000a					// If we were at the end of <blockquote>, there will be an empty element after it now.\u000a					if ( !block.getNext().getFirst( CKEDITOR.dom.walker.invisible( 1 ) ) )\u000a						block.getNext().remove();\u000a\u000a					range.moveToElementEditStart( block );\u000a					range.select();\u000a					return;\u000a				}\u000a			}\u000a			// Don't split <pre> if we're in the middle of it, act as shift enter key.\u000a			else if ( block && block.is( 'pre' ) ) {\u000a				if ( !atBlockEnd ) {\u000a					enterBr( editor, mode, range, forceMode );\u000a					return;\u000a				}\u000a			}\u000a\u000a			// Split the range.\u000a			var splitInfo = range.splitBlock( blockTag );\u000a\u000a			if ( !splitInfo )\u000a				return;\u000a\u000a			// Get the current blocks.\u000a			var previousBlock = splitInfo.previousBlock,\u000a				nextBlock = splitInfo.nextBlock;\u000a\u000a			var isStartOfBlock = splitInfo.wasStartOfBlock,\u000a				isEndOfBlock = splitInfo.wasEndOfBlock;\u000a\u000a			var node;\u000a\u000a			// If this is a block under a list item, split it as well. (#1647)\u000a			if ( nextBlock ) {\u000a				node = nextBlock.getParent();\u000a				if ( node.is( 'li' ) ) {\u000a					nextBlock.breakParent( node );\u000a					nextBlock.move( nextBlock.getNext(), 1 );\u000a				}\u000a			} else if ( previousBlock && ( node = previousBlock.getParent() ) && node.is( 'li' ) ) {\u000a				previousBlock.breakParent( node );\u000a				node = previousBlock.getNext();\u000a				range.moveToElementEditStart( node );\u000a				previousBlock.move( previousBlock.getPrevious() );\u000a			}\u000a\u000a			// If we have both the previous and next blocks, it means that the\u000a			// boundaries were on separated blocks, or none of them where on the\u000a			// block limits (start/end).\u000a			if ( !isStartOfBlock && !isEndOfBlock ) {\u000a				// If the next block is an <li> with another list tree as the first\u000a				// child, we'll need to append a filler (<br>/NBSP) or the list item\u000a				// wouldn't be editable. (#1420)\u000a				if ( nextBlock.is( 'li' ) ) {\u000a					var walkerRange = range.clone();\u000a					walkerRange.selectNodeContents( nextBlock );\u000a					var walker = new CKEDITOR.dom.walker( walkerRange );\u000a					walker.evaluator = function( node ) {\u000a						return !( bookmark( node ) || whitespaces( node ) || node.type == CKEDITOR.NODE_ELEMENT && node.getName() in CKEDITOR.dtd.$inline && !( node.getName() in CKEDITOR.dtd.$empty ) );\u000a					};\u000a\u000a					node = walker.next();\u000a					if ( node && node.type == CKEDITOR.NODE_ELEMENT && node.is( 'ul', 'ol' ) )\u000a						( CKEDITOR.env.needsBrFiller ? doc.createElement( 'br' ) : doc.createText( '\u005cxa0' ) ).insertBefore( node );\u000a				}\u000a\u000a				// Move the selection to the end block.\u000a				if ( nextBlock )\u000a					range.moveToElementEditStart( nextBlock );\u000a			} else {\u000a				var newBlockDir;\u000a\u000a				if ( previousBlock ) {\u000a					// Do not enter this block if it's a header tag, or we are in\u000a					// a Shift+Enter (#77). Create a new block element instead\u000a					// (later in the code).\u000a					if ( previousBlock.is( 'li' ) || !( headerTagRegex.test( previousBlock.getName() ) || previousBlock.is( 'pre' ) ) ) {\u000a						// Otherwise, duplicate the previous block.\u000a						newBlock = previousBlock.clone();\u000a					}\u000a				} else if ( nextBlock ) {\u000a					newBlock = nextBlock.clone();\u000a				}\u000a\u000a				if ( !newBlock ) {\u000a					// We have already created a new list item. (#6849)\u000a					if ( node && node.is( 'li' ) )\u000a						newBlock = node;\u000a					else {\u000a						newBlock = doc.createElement( blockTag );\u000a						if ( previousBlock && ( newBlockDir = previousBlock.getDirection() ) )\u000a							newBlock.setAttribute( 'dir', newBlockDir );\u000a					}\u000a				}\u000a				// Force the enter block unless we're talking of a list item.\u000a				else if ( forceMode && !newBlock.is( 'li' ) ) {\u000a					newBlock.renameNode( blockTag );\u000a				}\u000a\u000a				// Recreate the inline elements tree, which was available\u000a				// before hitting enter, so the same styles will be available in\u000a				// the new block.\u000a				var elementPath = splitInfo.elementPath;\u000a				if ( elementPath ) {\u000a					for ( var i = 0, len = elementPath.elements.length; i < len; i++ ) {\u000a						var element = elementPath.elements[ i ];\u000a\u000a						if ( element.equals( elementPath.block ) || element.equals( elementPath.blockLimit ) )\u000a							break;\u000a\u000a						if ( CKEDITOR.dtd.$removeEmpty[ element.getName() ] ) {\u000a							element = element.clone();\u000a							newBlock.moveChildren( element );\u000a							newBlock.append( element );\u000a						}\u000a					}\u000a				}\u000a\u000a				newBlock.appendBogus();\u000a\u000a				if ( !newBlock.getParent() )\u000a					range.insertNode( newBlock );\u000a\u000a				// list item start number should not be duplicated (#7330), but we need\u000a				// to remove the attribute after it's onto the DOM tree because of old IEs (#7581).\u000a				newBlock.is( 'li' ) && newBlock.removeAttribute( 'value' );\u000a\u000a				// This is tricky, but to make the new block visible correctly\u000a				// we must select it.\u000a				// The previousBlock check has been included because it may be\u000a				// empty if we have fixed a block-less space (like ENTER into an\u000a				// empty table cell).\u000a				if ( CKEDITOR.env.ie && isStartOfBlock && ( !isEndOfBlock || !previousBlock.getChildCount() ) ) {\u000a					// Move the selection to the new block.\u000a					range.moveToElementEditStart( isEndOfBlock ? previousBlock : newBlock );\u000a					range.select();\u000a				}\u000a\u000a				// Move the selection to the new block.\u000a				range.moveToElementEditStart( isStartOfBlock && !isEndOfBlock ? nextBlock : newBlock );\u000a			}\u000a\u000a			range.select();\u000a			range.scrollIntoView();\u000a		},\u000a\u000a		enterBr: function( editor, mode, range, forceMode ) {\u000a			// Get the range for the current selection.\u000a			range = range || getRange( editor );\u000a\u000a			// We may not have valid ranges to work on, like when inside a\u000a			// contenteditable=false element.\u000a			if ( !range )\u000a				return;\u000a\u000a			var doc = range.document;\u000a\u000a			var isEndOfBlock = range.checkEndOfBlock();\u000a\u000a			var elementPath = new CKEDITOR.dom.elementPath( editor.getSelection().getStartElement() );\u000a\u000a			var startBlock = elementPath.block,\u000a				startBlockTag = startBlock && elementPath.block.getName();\u000a\u000a			if ( !forceMode && startBlockTag == 'li' ) {\u000a				enterBlock( editor, mode, range, forceMode );\u000a				return;\u000a			}\u000a\u000a			// If we are at the end of a header block.\u000a			if ( !forceMode && isEndOfBlock && headerTagRegex.test( startBlockTag ) ) {\u000a				var newBlock, newBlockDir;\u000a\u000a				if ( ( newBlockDir = startBlock.getDirection() ) ) {\u000a					newBlock = doc.createElement( 'div' );\u000a					newBlock.setAttribute( 'dir', newBlockDir );\u000a					newBlock.insertAfter( startBlock );\u000a					range.setStart( newBlock, 0 );\u000a				} else {\u000a					// Insert a <br> after the current paragraph.\u000a					doc.createElement( 'br' ).insertAfter( startBlock );\u000a\u000a					// A text node is required by Gecko only to make the cursor blink.\u000a					if ( CKEDITOR.env.gecko )\u000a						doc.createText( '' ).insertAfter( startBlock );\u000a\u000a					// IE has different behaviors regarding position.\u000a					range.setStartAt( startBlock.getNext(), CKEDITOR.env.ie ? CKEDITOR.POSITION_BEFORE_START : CKEDITOR.POSITION_AFTER_START );\u000a				}\u000a			} else {\u000a				var lineBreak;\u000a\u000a				// IE<8 prefers text node as line-break inside of <pre> (#4711).\u000a				if ( startBlockTag == 'pre' && CKEDITOR.env.ie && CKEDITOR.env.version < 8 )\u000a					lineBreak = doc.createText( '\u005cr' );\u000a				else\u000a					lineBreak = doc.createElement( 'br' );\u000a\u000a				range.deleteContents();\u000a				range.insertNode( lineBreak );\u000a\u000a				// Old IEs have different behavior regarding position.\u000a				if ( !CKEDITOR.env.needsBrFiller )\u000a					range.setStartAt( lineBreak, CKEDITOR.POSITION_AFTER_END );\u000a				else {\u000a					// A text node is required by Gecko only to make the cursor blink.\u000a					// We need some text inside of it, so the bogus <br> is properly\u000a					// created.\u000a					doc.createText( '\u005cufeff' ).insertAfter( lineBreak );\u000a\u000a					// If we are at the end of a block, we must be sure the bogus node is available in that block.\u000a					if ( isEndOfBlock ) {\u000a						// In most situations we've got an elementPath.block (e.g. <p>), but in a\u000a						// blockless editor or when autoP is false that needs to be a block limit.\u000a						( startBlock || elementPath.blockLimit ).appendBogus();\u000a					}\u000a\u000a					// Now we can remove the text node contents, so the caret doesn't\u000a					// stop on it.\u000a					lineBreak.getNext().$.nodeValue = '';\u000a\u000a					range.setStartAt( lineBreak.getNext(), CKEDITOR.POSITION_AFTER_START );\u000a\u000a				}\u000a			}\u000a\u000a			// This collapse guarantees the cursor will be blinking.\u000a			range.collapse( true );\u000a\u000a			range.select();\u000a			range.scrollIntoView();\u000a		}\u000a	};\u000a\u000a	var plugin = CKEDITOR.plugins.enterkey,\u000a		enterBr = plugin.enterBr,\u000a		enterBlock = plugin.enterBlock,\u000a		headerTagRegex = /^h[1-6]$/;\u000a\u000a	function shiftEnter( editor ) {\u000a		// On SHIFT+ENTER:\u000a		// 1. We want to enforce the mode to be respected, instead\u000a		// of cloning the current block. (#77)\u000a		return enter( editor, editor.activeShiftEnterMode, 1 );\u000a	}\u000a\u000a	function enter( editor, mode, forceMode ) {\u000a		forceMode = editor.config.forceEnterMode || forceMode;\u000a\u000a		// Only effective within document.\u000a		if ( editor.mode != 'wysiwyg' )\u000a			return;\u000a\u000a		if ( !mode )\u000a			mode = editor.activeEnterMode;\u000a\u000a		// TODO this should be handled by setting editor.activeEnterMode on selection change.\u000a		// Check path block specialities:\u000a		// 1. Cannot be a un-splittable element, e.g. table caption;\u000a		var path = editor.elementPath();\u000a		if ( !path.isContextFor( 'p' ) ) {\u000a			mode = CKEDITOR.ENTER_BR;\u000a			forceMode = 1;\u000a		}\u000a\u000a		editor.fire( 'saveSnapshot' ); // Save undo step.\u000a\u000a		if ( mode == CKEDITOR.ENTER_BR )\u000a			enterBr( editor, mode, null, forceMode );\u000a		else\u000a			enterBlock( editor, mode, null, forceMode );\u000a\u000a		editor.fire( 'saveSnapshot' );\u000a	}\u000a\u000a	function getRange( editor ) {\u000a		// Get the selection ranges.\u000a		var ranges = editor.getSelection().getRanges( true );\u000a\u000a		// Delete the contents of all ranges except the first one.\u000a		for ( var i = ranges.length - 1; i > 0; i-- ) {\u000a			ranges[ i ].deleteContents();\u000a		}\u000a\u000a		// Return the first range.\u000a		return ranges[ 0 ];\u000a	}\u000a\u000a	function replaceRangeWithClosestEditableRoot( range ) {\u000a		var closestEditable = range.startContainer.getAscendant( function( node ) {\u000a			return node.type == CKEDITOR.NODE_ELEMENT && node.getAttribute( 'contenteditable' ) == 'true';\u000a		}, true );\u000a\u000a		if ( range.root.equals( closestEditable ) ) {\u000a			return range;\u000a		} else {\u000a			var newRange = new CKEDITOR.dom.range( closestEditable );\u000a\u000a			newRange.moveToRange( range );\u000a			return newRange;\u000a		}\u000a	}\u000a} )();\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	// Basic HTML entities.\u000a	var htmlbase = 'nbsp,gt,lt,amp';\u000a\u000a	var entities =\u000a	// Latin-1 entities\u000a	'quot,iexcl,cent,pound,curren,yen,brvbar,sect,uml,copy,ordf,laquo,' +\u000a		'not,shy,reg,macr,deg,plusmn,sup2,sup3,acute,micro,para,middot,' +\u000a		'cedil,sup1,ordm,raquo,frac14,frac12,frac34,iquest,times,divide,' +\u000a\u000a		// Symbols\u000a		'fnof,bull,hellip,prime,Prime,oline,frasl,weierp,image,real,trade,' +\u000a		'alefsym,larr,uarr,rarr,darr,harr,crarr,lArr,uArr,rArr,dArr,hArr,' +\u000a		'forall,part,exist,empty,nabla,isin,notin,ni,prod,sum,minus,lowast,' +\u000a		'radic,prop,infin,ang,and,or,cap,cup,int,there4,sim,cong,asymp,ne,' +\u000a		'equiv,le,ge,sub,sup,nsub,sube,supe,oplus,otimes,perp,sdot,lceil,' +\u000a		'rceil,lfloor,rfloor,lang,rang,loz,spades,clubs,hearts,diams,' +\u000a\u000a		// Other special characters\u000a		'circ,tilde,ensp,emsp,thinsp,zwnj,zwj,lrm,rlm,ndash,mdash,lsquo,' +\u000a		'rsquo,sbquo,ldquo,rdquo,bdquo,dagger,Dagger,permil,lsaquo,rsaquo,' +\u000a		'euro';\u000a\u000a	// Latin letters entities\u000a	var latin = 'Agrave,Aacute,Acirc,Atilde,Auml,Aring,AElig,Ccedil,Egrave,Eacute,' +\u000a		'Ecirc,Euml,Igrave,Iacute,Icirc,Iuml,ETH,Ntilde,Ograve,Oacute,Ocirc,' +\u000a		'Otilde,Ouml,Oslash,Ugrave,Uacute,Ucirc,Uuml,Yacute,THORN,szlig,' +\u000a		'agrave,aacute,acirc,atilde,auml,aring,aelig,ccedil,egrave,eacute,' +\u000a		'ecirc,euml,igrave,iacute,icirc,iuml,eth,ntilde,ograve,oacute,ocirc,' +\u000a		'otilde,ouml,oslash,ugrave,uacute,ucirc,uuml,yacute,thorn,yuml,' +\u000a		'OElig,oelig,Scaron,scaron,Yuml';\u000a\u000a	// Greek letters entities.\u000a	var greek = 'Alpha,Beta,Gamma,Delta,Epsilon,Zeta,Eta,Theta,Iota,Kappa,Lambda,Mu,' +\u000a		'Nu,Xi,Omicron,Pi,Rho,Sigma,Tau,Upsilon,Phi,Chi,Psi,Omega,alpha,' +\u000a		'beta,gamma,delta,epsilon,zeta,eta,theta,iota,kappa,lambda,mu,nu,xi,' +\u000a		'omicron,pi,rho,sigmaf,sigma,tau,upsilon,phi,chi,psi,omega,thetasym,' +\u000a		'upsih,piv';\u000a\u000a	// Create a mapping table between one character and its entity form from a list of entity names.\u000a	// @param reverse {Boolean} Whether to create a reverse map from the entity string form to an actual character.\u000a	function buildTable( entities, reverse ) {\u000a		var table = {},\u000a			regex = [];\u000a\u000a		// Entities that the browsers' DOM does not automatically transform to the\u000a		// final character.\u000a		var specialTable = {\u000a			nbsp: '\u005cu00A0', // IE | FF\u000a			shy: '\u005cu00AD', // IE\u000a			gt: '\u005cu003E', // IE | FF |   --   | Opera\u000a			lt: '\u005cu003C', // IE | FF | Safari | Opera\u000a			amp: '\u005cu0026', // ALL\u000a			apos: '\u005cu0027', // IE\u000a			quot: '\u005cu0022' // IE\u000a		};\u000a\u000a		entities = entities.replace( /\u005cb(nbsp|shy|gt|lt|amp|apos|quot)(?:,|$)/g, function( match, entity ) {\u000a			var org = reverse ? '&' + entity + ';' : specialTable[ entity ],\u000a				result = reverse ? specialTable[ entity ] : '&' + entity + ';';\u000a\u000a			table[ org ] = result;\u000a			regex.push( org );\u000a			return '';\u000a		} );\u000a\u000a		if ( !reverse && entities ) {\u000a			// Transforms the entities string into an array.\u000a			entities = entities.split( ',' );\u000a\u000a			// Put all entities inside a DOM element, transforming them to their\u000a			// final characters.\u000a			var div = document.createElement( 'div' ),\u000a				chars;\u000a			div.innerHTML = '&' + entities.join( ';&' ) + ';';\u000a			chars = div.innerHTML;\u000a			div = null;\u000a\u000a			// Add all characters to the table.\u000a			for ( var i = 0; i < chars.length; i++ ) {\u000a				var charAt = chars.charAt( i );\u000a				table[ charAt ] = '&' + entities[ i ] + ';';\u000a				regex.push( charAt );\u000a			}\u000a		}\u000a\u000a		table.regex = regex.join( reverse ? '|' : '' );\u000a\u000a		return table;\u000a	}\u000a\u000a	CKEDITOR.plugins.add( 'entities', {\u000a		afterInit: function( editor ) {\u000a			var config = editor.config;\u000a\u000a			var dataProcessor = editor.dataProcessor,\u000a				htmlFilter = dataProcessor && dataProcessor.htmlFilter;\u000a\u000a			if ( htmlFilter ) {\u000a				// Mandatory HTML basic entities.\u000a				var selectedEntities = [];\u000a\u000a				if ( config.basicEntities !== false )\u000a					selectedEntities.push( htmlbase );\u000a\u000a				if ( config.entities ) {\u000a					if ( selectedEntities.length )\u000a						selectedEntities.push( entities );\u000a\u000a					if ( config.entities_latin )\u000a						selectedEntities.push( latin );\u000a\u000a					if ( config.entities_greek )\u000a						selectedEntities.push( greek );\u000a\u000a					if ( config.entities_additional )\u000a						selectedEntities.push( config.entities_additional );\u000a				}\u000a\u000a				var entitiesTable = buildTable( selectedEntities.join( ',' ) );\u000a\u000a				// Create the Regex used to find entities in the text, leave it matches nothing if entities are empty.\u000a				var entitiesRegex = entitiesTable.regex ? '[' + entitiesTable.regex + ']' : 'a^';\u000a				delete entitiesTable.regex;\u000a\u000a				if ( config.entities && config.entities_processNumerical )\u000a					entitiesRegex = '[^ -~]|' + entitiesRegex;\u000a\u000a				entitiesRegex = new RegExp( entitiesRegex, 'g' );\u000a\u000a				function getEntity( character ) {\u000a					return config.entities_processNumerical == 'force' || !entitiesTable[ character ] ? '&#' + character.charCodeAt( 0 ) + ';'\u000a						: entitiesTable[ character ];\u000a				}\u000a\u000a				// Decode entities that the browsers has transformed\u000a				// at first place.\u000a				var baseEntitiesTable = buildTable( [ htmlbase, 'shy' ].join( ',' ), true ),\u000a					baseEntitiesRegex = new RegExp( baseEntitiesTable.regex, 'g' );\u000a\u000a				function getChar( character ) {\u000a					return baseEntitiesTable[ character ];\u000a				}\u000a\u000a				htmlFilter.addRules( {\u000a					text: function( text ) {\u000a						return text.replace( baseEntitiesRegex, getChar ).replace( entitiesRegex, getEntity );\u000a					}\u000a				}, {\u000a					applyToAll: true,\u000a					excludeNestedEditable: true\u000a				} );\u000a			}\u000a		}\u000a	} );\u000a} )();\u000a\u000a/**\u000a * Whether to escape basic HTML entities in the document, including:\u000a *\u000a * * `&nbsp;`\u000a * * `&gt;`\u000a * * `&lt;`\u000a * * `&amp;`\u000a *\u000a * **Note:** This option should not be changed unless when outputting a non-HTML data format like BBCode.\u000a *\u000a *		config.basicEntities = false;\u000a *\u000a * @cfg {Boolean} [basicEntities=true]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.basicEntities = true;\u000a\u000a/**\u000a * Whether to use HTML entities in the editor output.\u000a *\u000a *		config.entities = false;\u000a *\u000a * @cfg {Boolean} [entities=true]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.entities = true;\u000a\u000a/**\u000a * Whether to convert some Latin characters (Latin alphabet No. 1, ISO 8859-1)\u000a * to HTML entities. The list of entities can be found in the\u000a * [W3C HTML 4.01 Specification, section 24.2.1](http://www.w3.org/TR/html4/sgml/entities.html#h-24.2.1).\u000a *\u000a *		config.entities_latin = false;\u000a *\u000a * @cfg {Boolean} [entities_latin=true]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.entities_latin = true;\u000a\u000a/**\u000a * Whether to convert some symbols, mathematical symbols, and Greek letters to\u000a * HTML entities. This may be more relevant for users typing text written in Greek.\u000a * The list of entities can be found in the\u000a * [W3C HTML 4.01 Specification, section 24.3.1](http://www.w3.org/TR/html4/sgml/entities.html#h-24.3.1).\u000a *\u000a *		config.entities_greek = false;\u000a *\u000a * @cfg {Boolean} [entities_greek=true]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.entities_greek = true;\u000a\u000a/**\u000a * Whether to convert all remaining characters not included in the ASCII\u000a * character table to their relative decimal numeric representation of HTML entity.\u000a * When set to `force`, it will convert all entities into this format.\u000a *\u000a * For example the phrase: `'This is Chinese: \u6c49\u8bed.'` would be output\u000a * as: `'This is Chinese: &#27721;&#35821;.'`\u000a *\u000a *		config.entities_processNumerical = true;\u000a *		config.entities_processNumerical = 'force'; // Converts from '&nbsp;' into '&#160;';\u000a *\u000a * @cfg {Boolean/String} [entities_processNumerical=false]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * A comma-separated list of  additional entities to be used. Entity names\u000a * or numbers must be used in a form that excludes the `'&amp;'` prefix and the `';'` ending.\u000a *\u000a *		config.entities_additional = '#1049'; // Adds Cyrillic capital letter Short I (\u0419).\u000a *\u000a * @cfg {String} [entities_additional='#39' (The single quote (') character)]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.entities_additional = '#39';\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	var win = CKEDITOR.document.getWindow(),\u000a		pixelate = CKEDITOR.tools.cssLength;\u000a\u000a	CKEDITOR.plugins.add( 'floatingspace', {\u000a		init: function( editor ) {\u000a			// Add listener with lower priority than that in themedui creator.\u000a			// Thereby floatingspace will be created only if themedui wasn't used.\u000a			editor.on( 'loaded', function() {\u000a				attach( this );\u000a			}, null, null, 20 );\u000a		}\u000a	} );\u000a\u000a	function scrollOffset( side ) {\u000a		var pageOffset = side == 'left' ? 'pageXOffset' : 'pageYOffset',\u000a			docScrollOffset = side == 'left' ? 'scrollLeft' : 'scrollTop';\u000a\u000a		return ( pageOffset in win.$ ) ?\u000a				win.$[ pageOffset ]\u000a			:\u000a				CKEDITOR.document.$.documentElement[ docScrollOffset ];\u000a	}\u000a\u000a	function attach( editor ) {\u000a		var config = editor.config,\u000a\u000a			// Get the HTML for the predefined spaces.\u000a			topHtml = editor.fire( 'uiSpace', { space: 'top', html: '' } ).html,\u000a\u000a			// Re-positioning of the space.\u000a			layout = ( function() {\u000a				// Mode indicates the vertical aligning mode.\u000a				var mode, editable,\u000a					spaceRect, editorRect, viewRect, spaceHeight, pageScrollX,\u000a\u000a					// Allow minor adjustments of the float space from custom configs.\u000a					dockedOffsetX = config.floatSpaceDockedOffsetX || 0,\u000a					dockedOffsetY = config.floatSpaceDockedOffsetY || 0,\u000a					pinnedOffsetX = config.floatSpacePinnedOffsetX || 0,\u000a					pinnedOffsetY = config.floatSpacePinnedOffsetY || 0;\u000a\u000a				// Update the float space position.\u000a				function updatePos( pos, prop, val ) {\u000a					floatSpace.setStyle( prop, pixelate( val ) );\u000a					floatSpace.setStyle( 'position', pos );\u000a				}\u000a\u000a				// Change the current mode and update float space position accordingly.\u000a				function changeMode( newMode ) {\u000a					var editorPos = editable.getDocumentPosition();\u000a\u000a					switch ( newMode ) {\u000a						case 'top':\u000a							updatePos( 'absolute', 'top', editorPos.y - spaceHeight - dockedOffsetY );\u000a							break;\u000a						case 'pin':\u000a							updatePos( 'fixed', 'top', pinnedOffsetY );\u000a							break;\u000a						case 'bottom':\u000a							updatePos( 'absolute', 'top', editorPos.y + ( editorRect.height || editorRect.bottom - editorRect.top ) + dockedOffsetY );\u000a							break;\u000a					}\u000a\u000a					mode = newMode;\u000a				}\u000a\u000a				return function( evt ) {\u000a					// #10112 Do not fail on editable-less editor.\u000a					if ( !( editable = editor.editable() ) )\u000a						return;\u000a\u000a					// Show up the space on focus gain.\u000a					evt && evt.name == 'focus' && floatSpace.show();\u000a\u000a					// Reset the horizontal position for below measurement.\u000a					floatSpace.removeStyle( 'left' );\u000a					floatSpace.removeStyle( 'right' );\u000a\u000a					// Compute the screen position from the TextRectangle object would\u000a					// be very simple, even though the "width"/"height" property is not\u000a					// available for all, it's safe to figure that out from the rest.\u000a\u000a					// http://help.dottoro.com/ljgupwlp.php\u000a					spaceRect = floatSpace.getClientRect();\u000a					editorRect = editable.getClientRect();\u000a					viewRect = win.getViewPaneSize();\u000a					spaceHeight = spaceRect.height;\u000a					pageScrollX = scrollOffset( 'left' );\u000a\u000a					// We initialize it as pin mode.\u000a					if ( !mode ) {\u000a						mode = 'pin';\u000a						changeMode( 'pin' );\u000a						// Call for a refresh to the actual layout.\u000a						layout( evt );\u000a						return;\u000a					}\u000a\u000a					// +------------------------ Viewport -+ \u005c\u000a					// |                                   |  |-> floatSpaceDockedOffsetY\u000a					// | ................................. | /\u000a					// |                                   |\u000a					// |   +------ Space -+                |\u000a					// |   |              |                |\u000a					// |   +--------------+                |\u000a					// |   +------------------ Editor -+   |\u000a					// |   |                           |   |\u000a					//\u000a					if ( spaceHeight + dockedOffsetY <= editorRect.top )\u000a						changeMode( 'top' );\u000a\u000a					//     +- - - - - - - - -  Editor -+\u000a					//     |                           |\u000a					// +------------------------ Viewport -+ \u005c\u000a					// |   |                           |   |  |-> floatSpacePinnedOffsetY\u000a					// | ................................. | /\u000a					// |   +------ Space -+            |   |\u000a					// |   |              |            |   |\u000a					// |   +--------------+            |   |\u000a					// |   |                           |   |\u000a					// |   +---------------------------+   |\u000a					// +-----------------------------------+\u000a					//\u000a					else if ( spaceHeight + dockedOffsetY > viewRect.height - editorRect.bottom )\u000a						changeMode( 'pin' );\u000a\u000a					//     +- - - - - - - - -  Editor -+\u000a					//     |                           |\u000a					// +------------------------ Viewport -+ \u005c\u000a					// |   |                           |   |  |-> floatSpacePinnedOffsetY\u000a					// | ................................. | /\u000a					// |   |                           |   |\u000a					// |   |                           |   |\u000a					// |   +---------------------------+   |\u000a					// |   +------ Space -+                |\u000a					// |   |              |                |\u000a					// |   +--------------+                |\u000a					//\u000a					else\u000a						changeMode( 'bottom' );\u000a\u000a					var mid = viewRect.width / 2,\u000a						alignSide =\u000a								( editorRect.left > 0 && editorRect.right < viewRect.width && editorRect.width > spaceRect.width ) ?\u000a										( editor.config.contentsLangDirection == 'rtl' ? 'right' : 'left' )\u000a									:\u000a										( mid - editorRect.left > editorRect.right - mid ? 'left' : 'right' ),\u000a						offset;\u000a\u000a					// (#9769) If viewport width is less than space width,\u000a					// make sure space never cross the left boundary of the viewport.\u000a					// In other words: top-left corner of the space is always visible.\u000a					if ( spaceRect.width > viewRect.width ) {\u000a						alignSide = 'left';\u000a						offset = 0;\u000a					}\u000a					else {\u000a						if ( alignSide == 'left' ) {\u000a							// If the space rect fits into viewport, align it\u000a							// to the left edge of editor:\u000a							//\u000a							// +------------------------ Viewport -+\u000a							// |                                   |\u000a							// |   +------------- Space -+         |\u000a							// |   |                     |         |\u000a							// |   +---------------------+         |\u000a							// |   +------------------ Editor -+   |\u000a							// |   |                           |   |\u000a							//\u000a							if ( editorRect.left > 0 )\u000a								offset = editorRect.left;\u000a\u000a							// If the left part of the editor is cut off by the left\u000a							// edge of the viewport, stick the space to the viewport:\u000a							//\u000a							//       +------------------------ Viewport -+\u000a							//       |                                   |\u000a							//       +---------------- Space -+          |\u000a							//       |                        |          |\u000a							//       +------------------------+          |\u000a							//  +----|------------- Editor -+            |\u000a							//  |    |                      |            |\u000a							//\u000a							else\u000a								offset = 0;\u000a						}\u000a						else {\u000a							// If the space rect fits into viewport, align it\u000a							// to the right edge of editor:\u000a							//\u000a							// +------------------------ Viewport -+\u000a							// |                                   |\u000a							// |         +------------- Space -+   |\u000a							// |         |                     |   |\u000a							// |         +---------------------+   |\u000a							// |   +------------------ Editor -+   |\u000a							// |   |                           |   |\u000a							//\u000a							if ( editorRect.right < viewRect.width )\u000a								offset = viewRect.width - editorRect.right;\u000a\u000a							// If the right part of the editor is cut off by the right\u000a							// edge of the viewport, stick the space to the viewport:\u000a							//\u000a							// +------------------------ Viewport -+\u000a							// |                                   |\u000a							// |             +------------- Space -+\u000a							// |             |                     |\u000a							// |             +---------------------+\u000a							// |                 +-----------------|- Editor -+\u000a							// |                 |                 |          |\u000a							//\u000a							else\u000a								offset = 0;\u000a						}\u000a\u000a						// (#9769) Finally, stick the space to the opposite side of\u000a						// the viewport when it's cut off horizontally on the left/right\u000a						// side like below.\u000a						//\u000a						// This trick reveals cut off space in some edge cases and\u000a						// hence it improves accessibility.\u000a						//\u000a						// +------------------------ Viewport -+\u000a						// |                                   |\u000a						// |              +--------------------|-- Space -+\u000a						// |              |                    |          |\u000a						// |              +--------------------|----------+\u000a						// |              +------- Editor -+   |\u000a						// |              |                |   |\u000a						//\u000a						//				becomes:\u000a						//\u000a						// +------------------------ Viewport -+\u000a						// |                                   |\u000a						// |   +----------------------- Space -+\u000a						// |   |                               |\u000a						// |   +-------------------------------+\u000a						// |              +------- Editor -+   |\u000a						// |              |                |   |\u000a						//\u000a						if ( offset + spaceRect.width > viewRect.width ) {\u000a							alignSide = alignSide == 'left' ? 'right' : 'left';\u000a							offset = 0;\u000a						}\u000a					}\u000a\u000a					// Pin mode is fixed, so don't include scroll-x.\u000a					// (#9903) For mode is "top" or "bottom", add opposite scroll-x for right-aligned space.\u000a					var scroll = mode == 'pin' ?\u000a							0\u000a						:\u000a							alignSide == 'left' ? pageScrollX : -pageScrollX;\u000a\u000a					floatSpace.setStyle( alignSide, pixelate( ( mode == 'pin' ? pinnedOffsetX : dockedOffsetX ) + offset + scroll ) );\u000a				};\u000a			} )();\u000a\u000a		if ( topHtml ) {\u000a			var floatSpaceTpl = new CKEDITOR.template(\u000a				'<div' +\u000a					' id="cke_{name}"' +\u000a					' class="cke {id} cke_reset_all cke_chrome cke_editor_{name} cke_float cke_{langDir} ' + CKEDITOR.env.cssClass + '"' +\u000a					' dir="{langDir}"' +\u000a					' title="' + ( CKEDITOR.env.gecko ? ' ' : '' ) + '"' +\u000a					' lang="{langCode}"' +\u000a					' role="application"' +\u000a					' style="{style}"' +\u000a					( editor.title ? ' aria-labelledby="cke_{name}_arialbl"' : ' ' ) +\u000a					'>' +\u000a					( editor.title ? '<span id="cke_{name}_arialbl" class="cke_voice_label">{voiceLabel}</span>' : ' ' ) +\u000a					'<div class="cke_inner">' +\u000a						'<div id="{topId}" class="cke_top" role="presentation">{content}</div>' +\u000a					'</div>' +\u000a				'</div>' ),\u000a                floatSpace = CKEDITOR.document.getBody().append( CKEDITOR.dom.element.createFromHtml( floatSpaceTpl.output( {\u000a					content: topHtml,\u000a					id: editor.id,\u000a					langDir: editor.lang.dir,\u000a					langCode: editor.langCode,\u000a					name: editor.name,\u000a					style: 'display:none;z-index:' + ( config.baseFloatZIndex - 1 ),\u000a					topId: editor.ui.spaceId( 'top' ),\u000a					voiceLabel: editor.title\u000a				} ) ) ),\u000a\u000a				// Use event buffers to reduce CPU load when tons of events are fired.\u000a				changeBuffer = CKEDITOR.tools.eventsBuffer( 500, layout ),\u000a				uiBuffer = CKEDITOR.tools.eventsBuffer( 100, layout );\u000a\u000a			// There's no need for the floatSpace to be selectable.\u000a			floatSpace.unselectable();\u000a\u000a			// Prevent clicking on non-buttons area of the space from blurring editor.\u000a			floatSpace.on( 'mousedown', function( evt ) {\u000a				evt = evt.data;\u000a				if ( !evt.getTarget().hasAscendant( 'a', 1 ) )\u000a					evt.preventDefault();\u000a			} );\u000a\u000a			editor.on( 'focus', function( evt ) {\u000a				layout( evt );\u000a				editor.on( 'change', changeBuffer.input );\u000a				win.on( 'scroll', uiBuffer.input );\u000a				win.on( 'resize', uiBuffer.input );\u000a			} );\u000a\u000a			editor.on( 'blur', function() {\u000a				floatSpace.hide();\u000a				editor.removeListener( 'change', changeBuffer.input );\u000a				win.removeListener( 'scroll', uiBuffer.input );\u000a				win.removeListener( 'resize', uiBuffer.input );\u000a			} );\u000a\u000a			editor.on( 'destroy', function() {\u000a				win.removeListener( 'scroll', uiBuffer.input );\u000a				win.removeListener( 'resize', uiBuffer.input );\u000a				floatSpace.clearCustomData();\u000a				floatSpace.remove();\u000a			} );\u000a\u000a			// Handle initial focus.\u000a			if ( editor.focusManager.hasFocus )\u000a				floatSpace.show();\u000a\u000a			// Register this UI space to the focus manager.\u000a			editor.focusManager.add( floatSpace, 1 );\u000a		}\u000a	}\u000a} )();\u000a\u000a/**\u000a * Along with {@link #floatSpaceDockedOffsetY} it defines the\u000a * amount of offset (in pixels) between float space and the editable left/right\u000a * boundaries when space element is docked at either side of the editable.\u000a *\u000a *		config.floatSpaceDockedOffsetX = 10;\u000a *\u000a * @cfg {Number} [floatSpaceDockedOffsetX=0]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * Along with {@link #floatSpaceDockedOffsetX} it defines the\u000a * amount of offset (in pixels) between float space and the editable top/bottom\u000a * boundaries when space element is docked at either side of the editable.\u000a *\u000a *		config.floatSpaceDockedOffsetY = 10;\u000a *\u000a * @cfg {Number} [floatSpaceDockedOffsetY=0]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * Along with {@link #floatSpacePinnedOffsetY} it defines the\u000a * amount of offset (in pixels) between float space and the view port boundaries\u000a * when space element is pinned.\u000a *\u000a *		config.floatSpacePinnedOffsetX = 20;\u000a *\u000a * @cfg {Number} [floatSpacePinnedOffsetX=0]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * Along with {@link #floatSpacePinnedOffsetX} it defines the\u000a * amount of offset (in pixels) between float space and the view port boundaries\u000a * when space element is pinned.\u000a *\u000a *		config.floatSpacePinnedOffsetY = 20;\u000a *\u000a * @cfg {Number} [floatSpacePinnedOffsetY=0]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Handles the indentation of lists.\u000a */\u000a\u000a( function() {\u000a	'use strict';\u000a\u000a	var isNotWhitespaces = CKEDITOR.dom.walker.whitespaces( true ),\u000a		isNotBookmark = CKEDITOR.dom.walker.bookmark( false, true ),\u000a		TRISTATE_DISABLED = CKEDITOR.TRISTATE_DISABLED,\u000a		TRISTATE_OFF = CKEDITOR.TRISTATE_OFF;\u000a\u000a	CKEDITOR.plugins.add( 'indentlist', {\u000a		requires: 'indent',\u000a		init: function( editor ) {\u000a			var globalHelpers = CKEDITOR.plugins.indent,\u000a				editable = editor;\u000a\u000a			// Register commands.\u000a			globalHelpers.registerCommands( editor, {\u000a				indentlist: new commandDefinition( editor, 'indentlist', true ),\u000a				outdentlist: new commandDefinition( editor, 'outdentlist' )\u000a			} );\u000a\u000a			function commandDefinition( editor, name ) {\u000a				globalHelpers.specificDefinition.apply( this, arguments );\u000a\u000a				// Require ul OR ol list.\u000a				this.requiredContent = [ 'ul', 'ol' ];\u000a\u000a				// Indent and outdent lists with TAB/SHIFT+TAB key. Indenting can\u000a				// be done for any list item that isn't the first child of the parent.\u000a				editor.on( 'key', function( evt ) {\u000a					if ( editor.mode != 'wysiwyg' )\u000a						return;\u000a\u000a					if ( evt.data.keyCode == this.indentKey ) {\u000a						var list = this.getContext( editor.elementPath() );\u000a\u000a						if ( list ) {\u000a							// Don't indent if in first list item of the parent.\u000a							// Outdent, however, can always be done to collapse\u000a							// the list into a paragraph (div).\u000a							if ( this.isIndent && firstItemInPath.call( this, editor.elementPath(), list ) )\u000a								return;\u000a\u000a							// Exec related global indentation command. Global\u000a							// commands take care of bookmarks and selection,\u000a							// so it's much easier to use them instead of\u000a							// content-specific commands.\u000a							editor.execCommand( this.relatedGlobal );\u000a\u000a							// Cancel the key event so editor doesn't lose focus.\u000a							evt.cancel();\u000a						}\u000a					}\u000a				}, this );\u000a\u000a				// There are two different jobs for this plugin:\u000a				//\u000a				//	* Indent job (priority=10), before indentblock.\u000a				//\u000a				//	  This job is before indentblock because, if this plugin is\u000a				//	  loaded it has higher priority over indentblock. It means that,\u000a				//	  if possible, nesting is performed, and then block manipulation,\u000a				//	  if necessary.\u000a				//\u000a				//	* Outdent job (priority=30), after outdentblock.\u000a				//\u000a				//	  This job got to be after outdentblock because in some cases\u000a				//	  (margin, config#indentClass on list) outdent must be done on\u000a				//	  block-level.\u000a\u000a				this.jobs[ this.isIndent ? 10 : 30 ] = {\u000a					refresh: this.isIndent ?\u000a							function( editor, path ) {\u000a								var list = this.getContext( path ),\u000a									inFirstListItem = firstItemInPath.call( this, path, list );\u000a\u000a								if ( !list || !this.isIndent || inFirstListItem )\u000a									return TRISTATE_DISABLED;\u000a\u000a								return TRISTATE_OFF;\u000a							}\u000a						:\u000a							function( editor, path ) {\u000a								var list = this.getContext( path );\u000a\u000a								if ( !list || this.isIndent )\u000a									return TRISTATE_DISABLED;\u000a\u000a								return TRISTATE_OFF;\u000a							},\u000a\u000a					exec: CKEDITOR.tools.bind( indentList, this )\u000a				};\u000a			}\u000a\u000a			CKEDITOR.tools.extend( commandDefinition.prototype, globalHelpers.specificDefinition.prototype, {\u000a				// Elements that, if in an elementpath, will be handled by this\u000a				// command. They restrict the scope of the plugin.\u000a				context: { ol: 1, ul: 1 }\u000a			} );\u000a		}\u000a	} );\u000a\u000a	function indentList( editor ) {\u000a		var that = this,\u000a			database = this.database,\u000a			context = this.context;\u000a\u000a		function indent( listNode ) {\u000a			// Our starting and ending points of the range might be inside some blocks under a list item...\u000a			// So before playing with the iterator, we need to expand the block to include the list items.\u000a			var startContainer = range.startContainer,\u000a				endContainer = range.endContainer;\u000a			while ( startContainer && !startContainer.getParent().equals( listNode ) )\u000a				startContainer = startContainer.getParent();\u000a			while ( endContainer && !endContainer.getParent().equals( listNode ) )\u000a				endContainer = endContainer.getParent();\u000a\u000a			if ( !startContainer || !endContainer )\u000a				return false;\u000a\u000a			// Now we can iterate over the individual items on the same tree depth.\u000a			var block = startContainer,\u000a				itemsToMove = [],\u000a				stopFlag = false;\u000a\u000a			while ( !stopFlag ) {\u000a				if ( block.equals( endContainer ) )\u000a					stopFlag = true;\u000a\u000a				itemsToMove.push( block );\u000a				block = block.getNext();\u000a			}\u000a\u000a			if ( itemsToMove.length < 1 )\u000a				return false;\u000a\u000a			// Do indent or outdent operations on the array model of the list, not the\u000a			// list's DOM tree itself. The array model demands that it knows as much as\u000a			// possible about the surrounding lists, we need to feed it the further\u000a			// ancestor node that is still a list.\u000a			var listParents = listNode.getParents( true );\u000a			for ( var i = 0; i < listParents.length; i++ ) {\u000a				if ( listParents[ i ].getName && context[ listParents[ i ].getName() ] ) {\u000a					listNode = listParents[ i ];\u000a					break;\u000a				}\u000a			}\u000a\u000a			var indentOffset = that.isIndent ? 1 : -1,\u000a				startItem = itemsToMove[ 0 ],\u000a				lastItem = itemsToMove[ itemsToMove.length - 1 ],\u000a\u000a				// Convert the list DOM tree into a one dimensional array.\u000a				listArray = CKEDITOR.plugins.list.listToArray( listNode, database ),\u000a\u000a				// Apply indenting or outdenting on the array.\u000a				baseIndent = listArray[ lastItem.getCustomData( 'listarray_index' ) ].indent;\u000a\u000a			for ( i = startItem.getCustomData( 'listarray_index' ); i <= lastItem.getCustomData( 'listarray_index' ); i++ ) {\u000a				listArray[ i ].indent += indentOffset;\u000a				// Make sure the newly created sublist get a brand-new element of the same type. (#5372)\u000a				if ( indentOffset > 0 ) {\u000a					var listRoot = listArray[ i ].parent;\u000a					listArray[ i ].parent = new CKEDITOR.dom.element( listRoot.getName(), listRoot.getDocument() );\u000a				}\u000a			}\u000a\u000a			for ( i = lastItem.getCustomData( 'listarray_index' ) + 1; i < listArray.length && listArray[ i ].indent > baseIndent; i++ )\u000a				listArray[ i ].indent += indentOffset;\u000a\u000a			// Convert the array back to a DOM forest (yes we might have a few subtrees now).\u000a			// And replace the old list with the new forest.\u000a			var newList = CKEDITOR.plugins.list.arrayToList( listArray, database, null, editor.config.enterMode, listNode.getDirection() );\u000a\u000a			// Avoid nested <li> after outdent even they're visually same,\u000a			// recording them for later refactoring.(#3982)\u000a			if ( !that.isIndent ) {\u000a				var parentLiElement;\u000a				if ( ( parentLiElement = listNode.getParent() ) && parentLiElement.is( 'li' ) ) {\u000a					var children = newList.listNode.getChildren(),\u000a						pendingLis = [],\u000a						count = children.count(),\u000a						child;\u000a\u000a					for ( i = count - 1; i >= 0; i-- ) {\u000a						if ( ( child = children.getItem( i ) ) && child.is && child.is( 'li' ) )\u000a							pendingLis.push( child );\u000a					}\u000a				}\u000a			}\u000a\u000a			if ( newList )\u000a				newList.listNode.replace( listNode );\u000a\u000a			// Move the nested <li> to be appeared after the parent.\u000a			if ( pendingLis && pendingLis.length ) {\u000a				for ( i = 0; i < pendingLis.length; i++ ) {\u000a					var li = pendingLis[ i ],\u000a						followingList = li;\u000a\u000a					// Nest preceding <ul>/<ol> inside current <li> if any.\u000a					while ( ( followingList = followingList.getNext() ) && followingList.is && followingList.getName() in context ) {\u000a						// IE requires a filler NBSP for nested list inside empty list item,\u000a						// otherwise the list item will be inaccessiable. (#4476)\u000a						if ( CKEDITOR.env.needsNbspFiller && !li.getFirst( neitherWhitespacesNorBookmark ) )\u000a							li.append( range.document.createText( '\u005cu00a0' ) );\u000a\u000a						li.append( followingList );\u000a					}\u000a\u000a					li.insertAfter( parentLiElement );\u000a				}\u000a			}\u000a\u000a			if ( newList )\u000a				editor.fire( 'contentDomInvalidated' );\u000a\u000a			return true;\u000a		}\u000a\u000a		var selection = editor.getSelection(),\u000a			ranges = selection && selection.getRanges(),\u000a			iterator = ranges.createIterator(),\u000a			range;\u000a\u000a		while ( ( range = iterator.getNextRange() ) ) {\u000a			var rangeRoot = range.getCommonAncestor(),\u000a				nearestListBlock = rangeRoot;\u000a\u000a			while ( nearestListBlock && !( nearestListBlock.type == CKEDITOR.NODE_ELEMENT && context[ nearestListBlock.getName() ] ) )\u000a				nearestListBlock = nearestListBlock.getParent();\u000a\u000a			// Avoid having selection boundaries out of the list.\u000a			// <ul><li>[...</li></ul><p>...]</p> => <ul><li>[...]</li></ul><p>...</p>\u000a			if ( !nearestListBlock ) {\u000a				if ( ( nearestListBlock = range.startPath().contains( context ) ) )\u000a					range.setEndAt( nearestListBlock, CKEDITOR.POSITION_BEFORE_END );\u000a			}\u000a\u000a			// Avoid having selection enclose the entire list. (#6138)\u000a			// [<ul><li>...</li></ul>] =><ul><li>[...]</li></ul>\u000a			if ( !nearestListBlock ) {\u000a				var selectedNode = range.getEnclosedNode();\u000a				if ( selectedNode && selectedNode.type == CKEDITOR.NODE_ELEMENT && selectedNode.getName() in context ) {\u000a					range.setStartAt( selectedNode, CKEDITOR.POSITION_AFTER_START );\u000a					range.setEndAt( selectedNode, CKEDITOR.POSITION_BEFORE_END );\u000a					nearestListBlock = selectedNode;\u000a				}\u000a			}\u000a\u000a			// Avoid selection anchors under list root.\u000a			// <ul>[<li>...</li>]</ul> =>	<ul><li>[...]</li></ul>\u000a			if ( nearestListBlock && range.startContainer.type == CKEDITOR.NODE_ELEMENT && range.startContainer.getName() in context ) {\u000a				var walker = new CKEDITOR.dom.walker( range );\u000a				walker.evaluator = listItem;\u000a				range.startContainer = walker.next();\u000a			}\u000a\u000a			if ( nearestListBlock && range.endContainer.type == CKEDITOR.NODE_ELEMENT && range.endContainer.getName() in context ) {\u000a				walker = new CKEDITOR.dom.walker( range );\u000a				walker.evaluator = listItem;\u000a				range.endContainer = walker.previous();\u000a			}\u000a\u000a			if ( nearestListBlock )\u000a				return indent( nearestListBlock );\u000a		}\u000a		return 0;\u000a	}\u000a\u000a	// Check whether a first child of a list is in the path.\u000a	// The list can be extracted from path or given explicitly\u000a	// e.g. for better performance if cached.\u000a	function firstItemInPath( path, list ) {\u000a		if ( !list )\u000a			list = path.contains( this.context );\u000a\u000a		return list && path.block && path.block.equals( list.getFirst( listItem ) );\u000a	}\u000a\u000a	// Determines whether a node is a list <li> element.\u000a	function listItem( node ) {\u000a		return node.type == CKEDITOR.NODE_ELEMENT && node.is( 'li' );\u000a	}\u000a\u000a	function neitherWhitespacesNorBookmark( node ) {\u000a		return isNotWhitespaces( node ) && isNotBookmark( node );\u000a	}\u000a} )();\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a'use strict';\u000a\u000a( function() {\u000a	CKEDITOR.plugins.add( 'link', {\u000a		requires: 'dialog,fakeobjects',\u000a		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en,en-au,en-ca,en-gb,eo,es,et,eu,fa,fi,fo,fr,fr-ca,gl,gu,he,hi,hr,hu,id,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt,pt-br,ro,ru,si,sk,sl,sq,sr,sr-latn,sv,th,tr,tt,ug,uk,vi,zh,zh-cn', // %REMOVE_LINE_CORE%\u000a		// icons: 'anchor,anchor-rtl,link,unlink', // %REMOVE_LINE_CORE%\u000a		// hidpi: true, // %REMOVE_LINE_CORE%\u000a		onLoad: function() {\u000a			// Add the CSS styles for anchor placeholders.\u000a			var iconPath = CKEDITOR.getUrl( this.path + 'images' + ( CKEDITOR.env.hidpi ? '/hidpi' : '' ) + '/anchor.png' ),\u000a				baseStyle = 'background:url(' + iconPath + ') no-repeat %1 center;border:1px dotted #00f;background-size:16px;';\u000a\u000a			var template = '.%2 a.cke_anchor,' +\u000a				'.%2 a.cke_anchor_empty' +\u000a				',.cke_editable.%2 a[name]' +\u000a				',.cke_editable.%2 a[data-cke-saved-name]' +\u000a				'{' +\u000a					baseStyle +\u000a					'padding-%1:18px;' +\u000a					// Show the arrow cursor for the anchor image (FF at least).\u000a					'cursor:auto;' +\u000a				'}' +\u000a				'.%2 img.cke_anchor' +\u000a				'{' +\u000a					baseStyle +\u000a					'width:16px;' +\u000a					'min-height:15px;' +\u000a					// The default line-height on IE.\u000a					'height:1.15em;' +\u000a					// Opera works better with "middle" (even if not perfect)\u000a					'vertical-align:text-bottom;' +\u000a				'}';\u000a\u000a			// Styles with contents direction awareness.\u000a			function cssWithDir( dir ) {\u000a				return template.replace( /%1/g, dir == 'rtl' ? 'right' : 'left' ).replace( /%2/g, 'cke_contents_' + dir );\u000a			}\u000a\u000a			CKEDITOR.addCss( cssWithDir( 'ltr' ) + cssWithDir( 'rtl' ) );\u000a		},\u000a\u000a		init: function( editor ) {\u000a			var allowed = 'a[!href]',\u000a				required = 'a[href]';\u000a\u000a			if ( CKEDITOR.dialog.isTabEnabled( editor, 'link', 'advanced' ) )\u000a				allowed = allowed.replace( ']', ',accesskey,charset,dir,id,lang,name,rel,tabindex,title,type]{*}(*)' );\u000a			if ( CKEDITOR.dialog.isTabEnabled( editor, 'link', 'target' ) )\u000a				allowed = allowed.replace( ']', ',target,onclick]' );\u000a\u000a			// Add the link and unlink buttons.\u000a			editor.addCommand( 'link', new CKEDITOR.dialogCommand( 'link', {\u000a				allowedContent: allowed,\u000a				requiredContent: required\u000a			} ) );\u000a			editor.addCommand( 'anchor', new CKEDITOR.dialogCommand( 'anchor', {\u000a				allowedContent: 'a[!name,id]',\u000a				requiredContent: 'a[name]'\u000a			} ) );\u000a			editor.addCommand( 'unlink', new CKEDITOR.unlinkCommand() );\u000a			editor.addCommand( 'removeAnchor', new CKEDITOR.removeAnchorCommand() );\u000a\u000a			editor.setKeystroke( CKEDITOR.CTRL + 76 /*L*/, 'link' );\u000a\u000a			if ( editor.ui.addButton ) {\u000a				editor.ui.addButton( 'Link', {\u000a					icon: 'link fa fa-link link',\u000a					label: editor.lang.link.toolbar,\u000a					command: 'link',\u000a					toolbar: 'links,10'\u000a				} );\u000a				editor.ui.addButton( 'Unlink', {\u000a					icon: 'unlink fa fa-unlink unlink',\u000a					label: editor.lang.link.unlink,\u000a					command: 'unlink',\u000a					toolbar: 'links,20'\u000a				} );\u000a				editor.ui.addButton( 'Anchor', {\u000a					icon: 'anchor fa fa-anchor anchor',\u000a					label: editor.lang.link.anchor.toolbar,\u000a					command: 'anchor',\u000a					toolbar: 'links,30'\u000a				} );\u000a			}\u000a\u000a			CKEDITOR.dialog.add( 'link', this.path + 'dialogs/link.js' );\u000a			CKEDITOR.dialog.add( 'anchor', this.path + 'dialogs/anchor.js' );\u000a\u000a			editor.on( 'doubleclick', function( evt ) {\u000a				var element = CKEDITOR.plugins.link.getSelectedLink( editor ) || evt.data.element;\u000a\u000a				if ( !element.isReadOnly() ) {\u000a					if ( element.is( 'a' ) ) {\u000a						evt.data.dialog = ( element.getAttribute( 'name' ) && ( !element.getAttribute( 'href' ) || !element.getChildCount() ) ) ? 'anchor' : 'link';\u000a\u000a						// Pass the link to be selected along with event data.\u000a						evt.data.link = element;\u000a					} else if ( CKEDITOR.plugins.link.tryRestoreFakeAnchor( editor, element ) )\u000a						evt.data.dialog = 'anchor';\u000a				}\u000a			}, null, null, 0 );\u000a\u000a			// If event was cancelled, link passed in event data will not be selected.\u000a			editor.on( 'doubleclick', function( evt ) {\u000a				// Make sure both links and anchors are selected (#11822).\u000a				if ( evt.data.dialog in { link: 1, anchor: 1 } && evt.data.link )\u000a					editor.getSelection().selectElement( evt.data.link );\u000a			}, null, null, 20 );\u000a\u000a			// If the "menu" plugin is loaded, register the menu items.\u000a			if ( editor.addMenuItems ) {\u000a				editor.addMenuItems( {\u000a					anchor: {\u000a						label: editor.lang.link.anchor.menu,\u000a						command: 'anchor',\u000a						group: 'anchor',\u000a						order: 1\u000a					},\u000a\u000a					removeAnchor: {\u000a						label: editor.lang.link.anchor.remove,\u000a						command: 'removeAnchor',\u000a						group: 'anchor',\u000a						order: 5\u000a					},\u000a\u000a					link: {\u000a						label: editor.lang.link.menu,\u000a						command: 'link',\u000a						group: 'link',\u000a						order: 1\u000a					},\u000a\u000a					unlink: {\u000a						label: editor.lang.link.unlink,\u000a						command: 'unlink',\u000a						group: 'link',\u000a						order: 5\u000a					}\u000a				} );\u000a			}\u000a\u000a			// If the "contextmenu" plugin is loaded, register the listeners.\u000a			if ( editor.contextMenu ) {\u000a				editor.contextMenu.addListener( function( element, selection ) {\u000a					if ( !element || element.isReadOnly() )\u000a						return null;\u000a\u000a					var anchor = CKEDITOR.plugins.link.tryRestoreFakeAnchor( editor, element );\u000a\u000a					if ( !anchor && !( anchor = CKEDITOR.plugins.link.getSelectedLink( editor ) ) )\u000a						return null;\u000a\u000a					var menu = {};\u000a\u000a					if ( anchor.getAttribute( 'href' ) && anchor.getChildCount() )\u000a						menu = { link: CKEDITOR.TRISTATE_OFF, unlink: CKEDITOR.TRISTATE_OFF };\u000a\u000a					if ( anchor && anchor.hasAttribute( 'name' ) )\u000a						menu.anchor = menu.removeAnchor = CKEDITOR.TRISTATE_OFF;\u000a\u000a					return menu;\u000a				} );\u000a			}\u000a\u000a			this.compiledProtectionFunction = getCompiledProtectionFunction( editor );\u000a		},\u000a\u000a		afterInit: function( editor ) {\u000a			// Empty anchors upcasting to fake objects.\u000a			editor.dataProcessor.dataFilter.addRules( {\u000a				elements: {\u000a					a: function( element ) {\u000a						if ( !element.attributes.name )\u000a							return null;\u000a\u000a						if ( !element.children.length )\u000a							return editor.createFakeParserElement( element, 'cke_anchor', 'anchor' );\u000a\u000a						return null;\u000a					}\u000a				}\u000a			} );\u000a\u000a			var pathFilters = editor._.elementsPath && editor._.elementsPath.filters;\u000a			if ( pathFilters ) {\u000a				pathFilters.push( function( element, name ) {\u000a					if ( name == 'a' ) {\u000a						if ( CKEDITOR.plugins.link.tryRestoreFakeAnchor( editor, element ) || ( element.getAttribute( 'name' ) && ( !element.getAttribute( 'href' ) || !element.getChildCount() ) ) )\u000a							return 'anchor';\u000a					}\u000a				} );\u000a			}\u000a		}\u000a	} );\u000a\u000a	// Loads the parameters in a selected link to the link dialog fields.\u000a	var javascriptProtocolRegex = /^javascript:/,\u000a		emailRegex = /^mailto:([^?]+)(?:\u005c?(.+))?$/,\u000a		emailSubjectRegex = /subject=([^;?:@&=$,\u005c/]*)/,\u000a		emailBodyRegex = /body=([^;?:@&=$,\u005c/]*)/,\u000a		anchorRegex = /^#(.*)$/,\u000a		urlRegex = /^((?:http|https|ftp|news):\u005c/\u005c/)?(.*)$/,\u000a		selectableTargets = /^(_(?:self|top|parent|blank))$/,\u000a		encodedEmailLinkRegex = /^javascript:void\u005c(location\u005c.href='mailto:'\u005c+String\u005c.fromCharCode\u005c(([^)]+)\u005c)(?:\u005c+'(.*)')?\u005c)$/,\u000a		functionCallProtectedEmailLinkRegex = /^javascript:([^(]+)\u005c(([^)]+)\u005c)$/,\u000a		popupRegex = /\u005cs*window.open\u005c(\u005cs*this\u005c.href\u005cs*,\u005cs*(?:'([^']*)'|null)\u005cs*,\u005cs*'([^']*)'\u005cs*\u005c)\u005cs*;\u005cs*return\u005cs*false;*\u005cs*/,\u000a		popupFeaturesRegex = /(?:^|,)([^=]+)=(\u005cd+|yes|no)/gi;\u000a\u000a	var advAttrNames = {\u000a		id: 'advId',\u000a		dir: 'advLangDir',\u000a		accessKey: 'advAccessKey',\u000a		// 'data-cke-saved-name': 'advName',\u000a		name: 'advName',\u000a		lang: 'advLangCode',\u000a		tabindex: 'advTabIndex',\u000a		title: 'advTitle',\u000a		type: 'advContentType',\u000a		'class': 'advCSSClasses',\u000a		charset: 'advCharset',\u000a		style: 'advStyles',\u000a		rel: 'advRel'\u000a	};\u000a\u000a	function unescapeSingleQuote( str ) {\u000a		return str.replace( /\u005c\u005c'/g, '\u005c'' );\u000a	}\u000a\u000a	function escapeSingleQuote( str ) {\u000a		return str.replace( /'/g, '\u005c\u005c$&' );\u000a	}\u000a\u000a	function protectEmailAddressAsEncodedString( address ) {\u000a		var charCode,\u000a			length = address.length,\u000a			encodedChars = [];\u000a\u000a		for ( var i = 0; i < length; i++ ) {\u000a			charCode = address.charCodeAt( i );\u000a			encodedChars.push( charCode );\u000a		}\u000a\u000a		return 'String.fromCharCode(' + encodedChars.join( ',' ) + ')';\u000a	}\u000a\u000a	function protectEmailLinkAsFunction( editor, email ) {\u000a		var plugin = editor.plugins.link,\u000a			name = plugin.compiledProtectionFunction.name,\u000a			params = plugin.compiledProtectionFunction.params,\u000a			paramName, paramValue, retval;\u000a\u000a		retval = [ name, '(' ];\u000a		for ( var i = 0; i < params.length; i++ ) {\u000a			paramName = params[ i ].toLowerCase();\u000a			paramValue = email[ paramName ];\u000a\u000a			i > 0 && retval.push( ',' );\u000a			retval.push( '\u005c'', paramValue ? escapeSingleQuote( encodeURIComponent( email[ paramName ] ) ) : '', '\u005c'' );\u000a		}\u000a		retval.push( ')' );\u000a		return retval.join( '' );\u000a	}\u000a\u000a	function getCompiledProtectionFunction( editor ) {\u000a		var emailProtection = editor.config.emailProtection || '',\u000a			compiledProtectionFunction;\u000a\u000a		// Compile the protection function pattern.\u000a		if ( emailProtection && emailProtection != 'encode' ) {\u000a			compiledProtectionFunction = {};\u000a\u000a			emailProtection.replace( /^([^(]+)\u005c(([^)]+)\u005c)$/, function( match, funcName, params ) {\u000a				compiledProtectionFunction.name = funcName;\u000a				compiledProtectionFunction.params = [];\u000a				params.replace( /[^,\u005cs]+/g, function( param ) {\u000a					compiledProtectionFunction.params.push( param );\u000a				} );\u000a			} );\u000a		}\u000a\u000a		return compiledProtectionFunction;\u000a	}\u000a\u000a	/**\u000a	 * Set of Link plugin helpers.\u000a	 *\u000a	 * @class\u000a	 * @singleton\u000a	 */\u000a	CKEDITOR.plugins.link = {\u000a		/**\u000a		 * Get the surrounding link element of the current selection.\u000a		 *\u000a		 *		CKEDITOR.plugins.link.getSelectedLink( editor );\u000a		 *\u000a		 *		// The following selections will all return the link element.\u000a		 *\u000a		 *		<a href="#">li^nk</a>\u000a		 *		<a href="#">[link]</a>\u000a		 *		text[<a href="#">link]</a>\u000a		 *		<a href="#">li[nk</a>]\u000a		 *		[<b><a href="#">li]nk</a></b>]\u000a		 *		[<a href="#"><b>li]nk</b></a>\u000a		 *\u000a		 * @since 3.2.1\u000a		 * @param {CKEDITOR.editor} editor\u000a		 */\u000a		getSelectedLink: function( editor ) {\u000a			var selection = editor.getSelection();\u000a			var selectedElement = selection.getSelectedElement();\u000a			if ( selectedElement && selectedElement.is( 'a' ) )\u000a				return selectedElement;\u000a\u000a			var range = selection.getRanges()[ 0 ];\u000a\u000a			if ( range ) {\u000a				range.shrink( CKEDITOR.SHRINK_TEXT );\u000a				return editor.elementPath( range.getCommonAncestor() ).contains( 'a', 1 );\u000a			}\u000a			return null;\u000a		},\u000a\u000a		/**\u000a		 * Collects anchors available in the editor (i.e. used by the Link plugin).\u000a		 * Note that the scope of search is different for inline (the "global" document) and\u000a		 * classic (`iframe`-based) editors (the "inner" document).\u000a		 *\u000a		 * @since 4.3.3\u000a		 * @param {CKEDITOR.editor} editor\u000a		 * @returns {CKEDITOR.dom.element[]} An array of anchor elements.\u000a		 */\u000a		getEditorAnchors: function( editor ) {\u000a			var editable = editor.editable(),\u000a\u000a				// The scope of search for anchors is the entire document for inline editors\u000a				// and editor's editable for classic editor/divarea (#11359).\u000a				scope = ( editable.isInline() && !editor.plugins.divarea ) ? editor.document : editable,\u000a\u000a				links = scope.getElementsByTag( 'a' ),\u000a				imgs = scope.getElementsByTag( 'img' ),\u000a				anchors = [],\u000a				i = 0,\u000a				item;\u000a\u000a			// Retrieve all anchors within the scope.\u000a			while ( ( item = links.getItem( i++ ) ) ) {\u000a				if ( item.data( 'cke-saved-name' ) || item.hasAttribute( 'name' ) ) {\u000a					anchors.push( {\u000a						name: item.data( 'cke-saved-name' ) || item.getAttribute( 'name' ),\u000a						id: item.getAttribute( 'id' )\u000a					} );\u000a				}\u000a			}\u000a			// Retrieve all "fake anchors" within the scope.\u000a			i = 0;\u000a\u000a			while ( ( item = imgs.getItem( i++ ) ) ) {\u000a				if ( ( item = this.tryRestoreFakeAnchor( editor, item ) ) ) {\u000a					anchors.push( {\u000a						name: item.getAttribute( 'name' ),\u000a						id: item.getAttribute( 'id' )\u000a					} );\u000a				}\u000a			}\u000a\u000a			return anchors;\u000a		},\u000a\u000a		/**\u000a		 * Opera and WebKit do not make it possible to select empty anchors. Fake\u000a		 * elements must be used for them.\u000a		 *\u000a		 * @readonly\u000a		 * @deprecated 4.3.3 It is set to `true` in every browser.\u000a		 * @property {Boolean}\u000a		 */\u000a		fakeAnchor: true,\u000a\u000a		/**\u000a		 * For browsers that do not support CSS3 `a[name]:empty()`. Note that IE9 is included because of #7783.\u000a		 *\u000a		 * @readonly\u000a		 * @deprecated 4.3.3 It is set to `false` in every browser.\u000a		 * @property {Boolean} synAnchorSelector\u000a		 */\u000a\u000a		/**\u000a		 * For browsers that have editing issues with an empty anchor.\u000a		 *\u000a		 * @readonly\u000a		 * @deprecated 4.3.3 It is set to `false` in every browser.\u000a		 * @property {Boolean} emptyAnchorFix\u000a		 */\u000a\u000a		/**\u000a		 * Returns an element representing a real anchor restored from a fake anchor.\u000a		 *\u000a		 * @param {CKEDITOR.editor} editor\u000a		 * @param {CKEDITOR.dom.element} element\u000a		 * @returns {CKEDITOR.dom.element} Restored anchor element or nothing if the\u000a		 * passed element was not a fake anchor.\u000a		 */\u000a		tryRestoreFakeAnchor: function( editor, element ) {\u000a			if ( element && element.data( 'cke-real-element-type' ) && element.data( 'cke-real-element-type' ) == 'anchor' ) {\u000a				var link = editor.restoreRealElement( element );\u000a				if ( link.data( 'cke-saved-name' ) )\u000a					return link;\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Parses attributes of the link element and returns an object representing\u000a		 * the current state (data) of the link. This data format is accepted e.g. by\u000a		 * the Link dialog window and {@link #getLinkAttributes}.\u000a		 *\u000a		 * @since 4.4\u000a		 * @param {CKEDITOR.editor} editor\u000a		 * @param {CKEDITOR.dom.element} element\u000a		 * @returns {Object} An object of link data.\u000a		 */\u000a		parseLinkAttributes: function( editor, element ) {\u000a			var href = ( element && ( element.data( 'cke-saved-href' ) || element.getAttribute( 'href' ) ) ) || '',\u000a				compiledProtectionFunction = editor.plugins.link.compiledProtectionFunction,\u000a				emailProtection = editor.config.emailProtection,\u000a				javascriptMatch, emailMatch, anchorMatch, urlMatch,\u000a				retval = {};\u000a\u000a			if ( ( javascriptMatch = href.match( javascriptProtocolRegex ) ) ) {\u000a				if ( emailProtection == 'encode' ) {\u000a					href = href.replace( encodedEmailLinkRegex, function( match, protectedAddress, rest ) {\u000a						return 'mailto:' +\u000a							String.fromCharCode.apply( String, protectedAddress.split( ',' ) ) +\u000a							( rest && unescapeSingleQuote( rest ) );\u000a					} );\u000a				}\u000a				// Protected email link as function call.\u000a				else if ( emailProtection ) {\u000a					href.replace( functionCallProtectedEmailLinkRegex, function( match, funcName, funcArgs ) {\u000a						if ( funcName == compiledProtectionFunction.name ) {\u000a							retval.type = 'email';\u000a							var email = retval.email = {};\u000a\u000a							var paramRegex = /[^,\u005cs]+/g,\u000a								paramQuoteRegex = /(^')|('$)/g,\u000a								paramsMatch = funcArgs.match( paramRegex ),\u000a								paramsMatchLength = paramsMatch.length,\u000a								paramName, paramVal;\u000a\u000a							for ( var i = 0; i < paramsMatchLength; i++ ) {\u000a								paramVal = decodeURIComponent( unescapeSingleQuote( paramsMatch[ i ].replace( paramQuoteRegex, '' ) ) );\u000a								paramName = compiledProtectionFunction.params[ i ].toLowerCase();\u000a								email[ paramName ] = paramVal;\u000a							}\u000a							email.address = [ email.name, email.domain ].join( '@' );\u000a						}\u000a					} );\u000a				}\u000a			}\u000a\u000a			if ( !retval.type ) {\u000a				if ( ( anchorMatch = href.match( anchorRegex ) ) ) {\u000a					retval.type = 'anchor';\u000a					retval.anchor = {};\u000a					retval.anchor.name = retval.anchor.id = anchorMatch[ 1 ];\u000a				}\u000a				// Protected email link as encoded string.\u000a				else if ( ( emailMatch = href.match( emailRegex ) ) ) {\u000a					var subjectMatch = href.match( emailSubjectRegex ),\u000a						bodyMatch = href.match( emailBodyRegex );\u000a\u000a					retval.type = 'email';\u000a					var email = ( retval.email = {} );\u000a					email.address = emailMatch[ 1 ];\u000a					subjectMatch && ( email.subject = decodeURIComponent( subjectMatch[ 1 ] ) );\u000a					bodyMatch && ( email.body = decodeURIComponent( bodyMatch[ 1 ] ) );\u000a				}\u000a				// urlRegex matches empty strings, so need to check for href as well.\u000a				else if ( href && ( urlMatch = href.match( urlRegex ) ) ) {\u000a					retval.type = 'url';\u000a					retval.url = {};\u000a					retval.url.protocol = urlMatch[ 1 ];\u000a					retval.url.url = urlMatch[ 2 ];\u000a				}\u000a			}\u000a\u000a			// Load target and popup settings.\u000a			if ( element ) {\u000a				var target = element.getAttribute( 'target' );\u000a\u000a				// IE BUG: target attribute is an empty string instead of null in IE if it's not set.\u000a				if ( !target ) {\u000a					var onclick = element.data( 'cke-pa-onclick' ) || element.getAttribute( 'onclick' ),\u000a						onclickMatch = onclick && onclick.match( popupRegex );\u000a\u000a					if ( onclickMatch ) {\u000a						retval.target = {\u000a							type: 'popup',\u000a							name: onclickMatch[ 1 ]\u000a						};\u000a\u000a						var featureMatch;\u000a						while ( ( featureMatch = popupFeaturesRegex.exec( onclickMatch[ 2 ] ) ) ) {\u000a							// Some values should remain numbers (#7300)\u000a							if ( ( featureMatch[ 2 ] == 'yes' || featureMatch[ 2 ] == '1' ) && !( featureMatch[ 1 ] in { height: 1, width: 1, top: 1, left: 1 } ) )\u000a								retval.target[ featureMatch[ 1 ] ] = true;\u000a							else if ( isFinite( featureMatch[ 2 ] ) )\u000a								retval.target[ featureMatch[ 1 ] ] = featureMatch[ 2 ];\u000a						}\u000a					}\u000a				} else {\u000a					retval.target = {\u000a						type: target.match( selectableTargets ) ? target : 'frame',\u000a						name: target\u000a					};\u000a				}\u000a\u000a				var advanced = {};\u000a\u000a				for ( var a in advAttrNames ) {\u000a					var val = element.getAttribute( a );\u000a\u000a					if ( val )\u000a						advanced[ advAttrNames[ a ] ] = val;\u000a				}\u000a\u000a				var advName = element.data( 'cke-saved-name' ) || advanced.advName;\u000a\u000a				if ( advName )\u000a					advanced.advName = advName;\u000a\u000a				if ( !CKEDITOR.tools.isEmpty( advanced ) )\u000a					retval.advanced = advanced;\u000a			}\u000a\u000a			return retval;\u000a		},\u000a\u000a		/**\u000a		 * Converts link data into an object which consists of attributes to be set\u000a		 * (with their values) and an array of attributes to be removed. This method\u000a		 * can be used to synthesise or to update any link element with the given data.\u000a		 *\u000a		 * @since 4.4\u000a		 * @param {CKEDITOR.editor} editor\u000a		 * @param {Object} data Data in {@link #parseLinkAttributes} format.\u000a		 * @returns {Object} An object consisting of two keys, i.e.:\u000a		 *\u000a		 *		{\u000a		 *			// Attributes to be set.\u000a		 *			set: {\u000a		 *				href: 'http://foo.bar',\u000a		 *				target: 'bang'\u000a		 *			},\u000a		 *			// Attributes to be removed.\u000a		 *			removed: [\u000a		 *				'id', 'style'\u000a		 *			]\u000a		 *		}\u000a		 *\u000a		 */\u000a		getLinkAttributes: function( editor, data ) {\u000a			var emailProtection = editor.config.emailProtection || '',\u000a				set = {};\u000a\u000a			// Compose the URL.\u000a			switch ( data.type ) {\u000a				case 'url':\u000a					var protocol = ( data.url && data.url.protocol != undefined ) ? data.url.protocol : 'http://',\u000a						url = ( data.url && CKEDITOR.tools.trim( data.url.url ) ) || '';\u000a\u000a					set[ 'data-cke-saved-href' ] = ( url.indexOf( '/' ) === 0 ) ? url : protocol + url;\u000a\u000a					break;\u000a				case 'anchor':\u000a					var name = ( data.anchor && data.anchor.name ),\u000a						id = ( data.anchor && data.anchor.id );\u000a\u000a					set[ 'data-cke-saved-href' ] = '#' + ( name || id || '' );\u000a\u000a					break;\u000a				case 'email':\u000a					var email = data.email,\u000a						address = email.address,\u000a						linkHref;\u000a\u000a					switch ( emailProtection ) {\u000a						case '':\u000a						case 'encode':\u000a							var subject = encodeURIComponent( email.subject || '' ),\u000a								body = encodeURIComponent( email.body || '' ),\u000a								argList = [];\u000a\u000a							// Build the e-mail parameters first.\u000a							subject && argList.push( 'subject=' + subject );\u000a							body && argList.push( 'body=' + body );\u000a							argList = argList.length ? '?' + argList.join( '&' ) : '';\u000a\u000a							if ( emailProtection == 'encode' ) {\u000a								linkHref = [\u000a									'javascript:void(location.href=\u005c'mailto:\u005c'+',\u000a									protectEmailAddressAsEncodedString( address )\u000a								];\u000a								// parameters are optional.\u000a								argList && linkHref.push( '+\u005c'', escapeSingleQuote( argList ), '\u005c'' );\u000a\u000a								linkHref.push( ')' );\u000a							} else\u000a								linkHref = [ 'mailto:', address, argList ];\u000a\u000a							break;\u000a						default:\u000a							// Separating name and domain.\u000a							var nameAndDomain = address.split( '@', 2 );\u000a							email.name = nameAndDomain[ 0 ];\u000a							email.domain = nameAndDomain[ 1 ];\u000a\u000a							linkHref = [ 'javascript:', protectEmailLinkAsFunction( editor, email ) ];\u000a					}\u000a\u000a					set[ 'data-cke-saved-href' ] = linkHref.join( '' );\u000a					break;\u000a			}\u000a\u000a			// Popups and target.\u000a			if ( data.target ) {\u000a				if ( data.target.type == 'popup' ) {\u000a					var onclickList = [\u000a							'window.open(this.href, \u005c'', data.target.name || '', '\u005c', \u005c''\u000a						],\u000a						featureList = [\u000a							'resizable', 'status', 'location', 'toolbar', 'menubar', 'fullscreen', 'scrollbars', 'dependent'\u000a						],\u000a						featureLength = featureList.length,\u000a						addFeature = function( featureName ) {\u000a							if ( data.target[ featureName ] )\u000a								featureList.push( featureName + '=' + data.target[ featureName ] );\u000a						};\u000a\u000a					for ( var i = 0; i < featureLength; i++ )\u000a						featureList[ i ] = featureList[ i ] + ( data.target[ featureList[ i ] ] ? '=yes' : '=no' );\u000a\u000a					addFeature( 'width' );\u000a					addFeature( 'left' );\u000a					addFeature( 'height' );\u000a					addFeature( 'top' );\u000a\u000a					onclickList.push( featureList.join( ',' ), '\u005c'); return false;' );\u000a					set[ 'data-cke-pa-onclick' ] = onclickList.join( '' );\u000a				}\u000a				else if ( data.target.type != 'notSet' && data.target.name )\u000a					set.target = data.target.name;\u000a			}\u000a\u000a			// Advanced attributes.\u000a			if ( data.advanced ) {\u000a				for ( var a in advAttrNames ) {\u000a					var val = data.advanced[ advAttrNames[ a ] ];\u000a\u000a					if ( val )\u000a						set[ a ] = val;\u000a				}\u000a\u000a				if ( set.name )\u000a					set[ 'data-cke-saved-name' ] = set.name;\u000a			}\u000a\u000a			// Browser need the "href" fro copy/paste link to work. (#6641)\u000a			if ( set[ 'data-cke-saved-href' ] )\u000a				set.href = set[ 'data-cke-saved-href' ];\u000a\u000a			var removed = CKEDITOR.tools.extend( {\u000a				target: 1,\u000a				onclick: 1,\u000a				'data-cke-pa-onclick': 1,\u000a				'data-cke-saved-name': 1\u000a			}, advAttrNames );\u000a\u000a			// Remove all attributes which are not currently set.\u000a			for ( var s in set )\u000a				delete removed[ s ];\u000a\u000a			return {\u000a				set: set,\u000a				removed: CKEDITOR.tools.objectKeys( removed )\u000a			};\u000a		}\u000a	};\u000a\u000a	// TODO Much probably there's no need to expose these as public objects.\u000a\u000a	CKEDITOR.unlinkCommand = function() {};\u000a	CKEDITOR.unlinkCommand.prototype = {\u000a		exec: function( editor ) {\u000a			var style = new CKEDITOR.style( { element: 'a', type: CKEDITOR.STYLE_INLINE, alwaysRemoveElement: 1 } );\u000a			editor.removeStyle( style );\u000a		},\u000a\u000a		refresh: function( editor, path ) {\u000a			// Despite our initial hope, document.queryCommandEnabled() does not work\u000a			// for this in Firefox. So we must detect the state by element paths.\u000a\u000a			var element = path.lastElement && path.lastElement.getAscendant( 'a', true );\u000a\u000a			if ( element && element.getName() == 'a' && element.getAttribute( 'href' ) && element.getChildCount() )\u000a				this.setState( CKEDITOR.TRISTATE_OFF );\u000a			else\u000a				this.setState( CKEDITOR.TRISTATE_DISABLED );\u000a		},\u000a\u000a		contextSensitive: 1,\u000a		startDisabled: 1,\u000a		requiredContent: 'a[href]'\u000a	};\u000a\u000a	CKEDITOR.removeAnchorCommand = function() {};\u000a	CKEDITOR.removeAnchorCommand.prototype = {\u000a		exec: function( editor ) {\u000a			var sel = editor.getSelection(),\u000a				bms = sel.createBookmarks(),\u000a				anchor;\u000a			if ( sel && ( anchor = sel.getSelectedElement() ) && ( !anchor.getChildCount() ? CKEDITOR.plugins.link.tryRestoreFakeAnchor( editor, anchor ) : anchor.is( 'a' ) ) )\u000a				anchor.remove( 1 );\u000a			else {\u000a				if ( ( anchor = CKEDITOR.plugins.link.getSelectedLink( editor ) ) ) {\u000a					if ( anchor.hasAttribute( 'href' ) ) {\u000a						anchor.removeAttributes( { name: 1, 'data-cke-saved-name': 1 } );\u000a						anchor.removeClass( 'cke_anchor' );\u000a					} else\u000a						anchor.remove( 1 );\u000a				}\u000a			}\u000a			sel.selectBookmarks( bms );\u000a		},\u000a		requiredContent: 'a[name]'\u000a	};\u000a\u000a	CKEDITOR.tools.extend( CKEDITOR.config, {\u000a		/**\u000a		 * Whether to show the Advanced tab in the Link dialog window.\u000a		 *\u000a		 * @cfg {Boolean} [linkShowAdvancedTab=true]\u000a		 * @member CKEDITOR.config\u000a		 */\u000a		linkShowAdvancedTab: true,\u000a\u000a		/**\u000a		 * Whether to show the Target tab in the Link dialog window.\u000a		 *\u000a		 * @cfg {Boolean} [linkShowTargetTab=true]\u000a		 * @member CKEDITOR.config\u000a		 */\u000a		linkShowTargetTab: true\u000a\u000a		/**\u000a		 * Whether JavaScript code is allowed as a `href` attribute in an anchor tag.\u000a		 * With this option enabled it is possible to create links like:\u000a		 *\u000a		 *		<a href="javascript:alert('Hello world!')">hello world</a>\u000a		 *\u000a		 * By default JavaScript links are not allowed and will not pass\u000a		 * the Link dialog window validation.\u000a		 *\u000a		 * @since 4.4.1\u000a		 * @cfg {Boolean} [linkJavaScriptLinksAllowed=false]\u000a		 * @member CKEDITOR.config\u000a		 */\u000a	} );\u000a} )();\u000a\ufeff/*\u000aCopyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000aFor licensing, see LICENSE.md or http://ckeditor.com/license\u000a*/\u000aCKEDITOR.plugins.setLang( 'link', 'en', {\u000a	acccessKey: 'Access Key',\u000a	advanced: 'Advanced',\u000a	advisoryContentType: 'Advisory Content Type',\u000a	advisoryTitle: 'Advisory Title',\u000a	anchor: {\u000a		toolbar: 'Anchor',\u000a		menu: 'Edit Anchor',\u000a		title: 'Anchor Properties',\u000a		name: 'Anchor Name',\u000a		errorName: 'Please type the anchor name',\u000a		remove: 'Remove Anchor'\u000a	},\u000a	anchorId: 'By Element Id',\u000a	anchorName: 'By Anchor Name',\u000a	charset: 'Linked Resource Charset',\u000a	cssClasses: 'Stylesheet Classes',\u000a	emailAddress: 'E-Mail Address',\u000a	emailBody: 'Message Body',\u000a	emailSubject: 'Message Subject',\u000a	id: 'Id',\u000a	info: 'Link Info',\u000a	langCode: 'Language Code',\u000a	langDir: 'Language Direction',\u000a	langDirLTR: 'Left to Right (LTR)',\u000a	langDirRTL: 'Right to Left (RTL)',\u000a	menu: 'Edit Link',\u000a	name: 'Name',\u000a	noAnchors: '(No anchors available in the document)',\u000a	noEmail: 'Please type the e-mail address',\u000a	noUrl: 'Please type the link URL',\u000a	other: '<other>',\u000a	popupDependent: 'Dependent (Netscape)',\u000a	popupFeatures: 'Popup Window Features',\u000a	popupFullScreen: 'Full Screen (IE)',\u000a	popupLeft: 'Left Position',\u000a	popupLocationBar: 'Location Bar',\u000a	popupMenuBar: 'Menu Bar',\u000a	popupResizable: 'Resizable',\u000a	popupScrollBars: 'Scroll Bars',\u000a	popupStatusBar: 'Status Bar',\u000a	popupToolbar: 'Toolbar',\u000a	popupTop: 'Top Position',\u000a	rel: 'Relationship',\u000a	selectAnchor: 'Select an Anchor',\u000a	styles: 'Style',\u000a	tabIndex: 'Tab Index',\u000a	target: 'Target',\u000a	targetFrame: '<frame>',\u000a	targetFrameName: 'Target Frame Name',\u000a	targetPopup: '<popup window>',\u000a	targetPopupName: 'Popup Window Name',\u000a	title: 'Link',\u000a	toAnchor: 'Link to anchor in the text',\u000a	toEmail: 'E-mail',\u000a	toUrl: 'URL',\u000a	toolbar: 'Link',\u000a	type: 'Link Type',\u000a	unlink: 'Unlink',\u000a	upload: 'Upload'\u000a} );\u000a\u000a/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a'use strict';\u000a\u000a( function() {\u000a	CKEDITOR.dialog.add( 'link', function( editor ) {\u000a		var plugin = CKEDITOR.plugins.link;\u000a\u000a		// Handles the event when the "Target" selection box is changed.\u000a		var targetChanged = function() {\u000a				var dialog = this.getDialog(),\u000a					popupFeatures = dialog.getContentElement( 'target', 'popupFeatures' ),\u000a					targetName = dialog.getContentElement( 'target', 'linkTargetName' ),\u000a					value = this.getValue();\u000a\u000a				if ( !popupFeatures || !targetName )\u000a					return;\u000a\u000a				popupFeatures = popupFeatures.getElement();\u000a				popupFeatures.hide();\u000a				targetName.setValue( '' );\u000a\u000a				switch ( value ) {\u000a					case 'frame':\u000a						targetName.setLabel( editor.lang.link.targetFrameName );\u000a						targetName.getElement().show();\u000a						break;\u000a					case 'popup':\u000a						popupFeatures.show();\u000a						targetName.setLabel( editor.lang.link.targetPopupName );\u000a						targetName.getElement().show();\u000a						break;\u000a					default:\u000a						targetName.setValue( value );\u000a						targetName.getElement().hide();\u000a						break;\u000a				}\u000a\u000a			};\u000a\u000a		// Handles the event when the "Type" selection box is changed.\u000a		var linkTypeChanged = function() {\u000a				var dialog = this.getDialog(),\u000a					partIds = [ 'urlOptions', 'anchorOptions', 'emailOptions' ],\u000a					typeValue = this.getValue(),\u000a					uploadTab = dialog.definition.getContents( 'upload' ),\u000a					uploadInitiallyHidden = uploadTab && uploadTab.hidden;\u000a\u000a				if ( typeValue == 'url' ) {\u000a					if ( editor.config.linkShowTargetTab )\u000a						dialog.showPage( 'target' );\u000a					if ( !uploadInitiallyHidden )\u000a						dialog.showPage( 'upload' );\u000a				} else {\u000a					dialog.hidePage( 'target' );\u000a					if ( !uploadInitiallyHidden )\u000a						dialog.hidePage( 'upload' );\u000a				}\u000a\u000a				for ( var i = 0; i < partIds.length; i++ ) {\u000a					var element = dialog.getContentElement( 'info', partIds[ i ] );\u000a					if ( !element )\u000a						continue;\u000a\u000a					element = element.getElement().getParent().getParent();\u000a					if ( partIds[ i ] == typeValue + 'Options' )\u000a						element.show();\u000a					else\u000a						element.hide();\u000a				}\u000a\u000a				dialog.layout();\u000a			};\u000a\u000a		var setupParams = function( page, data ) {\u000a				if ( data[ page ] )\u000a					this.setValue( data[ page ][ this.id ] || '' );\u000a			};\u000a\u000a		var setupPopupParams = function( data ) {\u000a				return setupParams.call( this, 'target', data );\u000a			};\u000a\u000a		var setupAdvParams = function( data ) {\u000a				return setupParams.call( this, 'advanced', data );\u000a			};\u000a\u000a		var commitParams = function( page, data ) {\u000a				if ( !data[ page ] )\u000a					data[ page ] = {};\u000a\u000a				data[ page ][ this.id ] = this.getValue() || '';\u000a			};\u000a\u000a		var commitPopupParams = function( data ) {\u000a				return commitParams.call( this, 'target', data );\u000a			};\u000a\u000a		var commitAdvParams = function( data ) {\u000a				return commitParams.call( this, 'advanced', data );\u000a			};\u000a\u000a		var commonLang = editor.lang.common,\u000a			linkLang = editor.lang.link,\u000a			anchors;\u000a\u000a		return {\u000a			title: linkLang.title,\u000a			minWidth: 350,\u000a			minHeight: 230,\u000a			contents: [\u000a				{\u000a				id: 'info',\u000a				label: linkLang.info,\u000a				title: linkLang.info,\u000a				elements: [\u000a					{\u000a					id: 'linkType',\u000a					type: 'select',\u000a					label: linkLang.type,\u000a					'default': 'url',\u000a					items: [\u000a						[ linkLang.toUrl, 'url' ],\u000a						[ linkLang.toAnchor, 'anchor' ],\u000a						[ linkLang.toEmail, 'email' ]\u000a						],\u000a					onChange: linkTypeChanged,\u000a					setup: function( data ) {\u000a						this.setValue( data.type || 'url' );\u000a					},\u000a					commit: function( data ) {\u000a						data.type = this.getValue();\u000a					}\u000a				},\u000a					{\u000a					type: 'vbox',\u000a					id: 'urlOptions',\u000a					children: [\u000a						{\u000a						type: 'hbox',\u000a						widths: [ '25%', '75%' ],\u000a						children: [\u000a							{\u000a							id: 'protocol',\u000a							type: 'select',\u000a							label: commonLang.protocol,\u000a							'default': 'http://',\u000a							items: [\u000a								// Force 'ltr' for protocol names in BIDI. (#5433)\u000a								[ 'http://\u005cu200E', 'http://' ],\u000a								[ 'https://\u005cu200E', 'https://' ],\u000a								[ 'ftp://\u005cu200E', 'ftp://' ],\u000a								[ 'news://\u005cu200E', 'news://' ],\u000a								[ linkLang.other, '' ]\u000a								],\u000a							setup: function( data ) {\u000a								if ( data.url )\u000a									this.setValue( data.url.protocol || '' );\u000a							},\u000a							commit: function( data ) {\u000a								if ( !data.url )\u000a									data.url = {};\u000a\u000a								data.url.protocol = this.getValue();\u000a							}\u000a						},\u000a							{\u000a							type: 'text',\u000a							id: 'url',\u000a							label: commonLang.url,\u000a							required: true,\u000a							onLoad: function() {\u000a								this.allowOnChange = true;\u000a							},\u000a							onKeyUp: function() {\u000a								this.allowOnChange = false;\u000a								var protocolCmb = this.getDialog().getContentElement( 'info', 'protocol' ),\u000a									url = this.getValue(),\u000a									urlOnChangeProtocol = /^(http|https|ftp|news):\u005c/\u005c/(?=.)/i,\u000a									urlOnChangeTestOther = /^((javascript:)|[#\u005c/\u005c.\u005c?])/i;\u000a\u000a								var protocol = urlOnChangeProtocol.exec( url );\u000a								if ( protocol ) {\u000a									this.setValue( url.substr( protocol[ 0 ].length ) );\u000a									protocolCmb.setValue( protocol[ 0 ].toLowerCase() );\u000a								} else if ( urlOnChangeTestOther.test( url ) )\u000a									protocolCmb.setValue( '' );\u000a\u000a								this.allowOnChange = true;\u000a							},\u000a							onChange: function() {\u000a								if ( this.allowOnChange ) // Dont't call on dialog load.\u000a								this.onKeyUp();\u000a							},\u000a							validate: function() {\u000a								var dialog = this.getDialog();\u000a\u000a								if ( dialog.getContentElement( 'info', 'linkType' ) && dialog.getValueOf( 'info', 'linkType' ) != 'url' )\u000a									return true;\u000a\u000a								if ( !editor.config.linkJavaScriptLinksAllowed && ( /javascript\u005c:/ ).test( this.getValue() ) ) {\u000a									alert( commonLang.invalidValue );\u000a									return false;\u000a								}\u000a\u000a								if ( this.getDialog().fakeObj ) // Edit Anchor.\u000a								return true;\u000a\u000a								var func = CKEDITOR.dialog.validate.notEmpty( linkLang.noUrl );\u000a								return func.apply( this );\u000a							},\u000a							setup: function( data ) {\u000a								this.allowOnChange = false;\u000a								if ( data.url )\u000a									this.setValue( data.url.url );\u000a								this.allowOnChange = true;\u000a\u000a							},\u000a							commit: function( data ) {\u000a								// IE will not trigger the onChange event if the mouse has been used\u000a								// to carry all the operations #4724\u000a								this.onChange();\u000a\u000a								if ( !data.url )\u000a									data.url = {};\u000a\u000a								data.url.url = this.getValue();\u000a								this.allowOnChange = false;\u000a							}\u000a						}\u000a						],\u000a						setup: function( data ) {\u000a							if ( !this.getDialog().getContentElement( 'info', 'linkType' ) )\u000a								this.getElement().show();\u000a						}\u000a					},\u000a						{\u000a						type: 'button',\u000a						id: 'browse',\u000a						hidden: 'true',\u000a						filebrowser: 'info:url',\u000a						label: commonLang.browseServer\u000a					}\u000a					]\u000a				},\u000a					{\u000a					type: 'vbox',\u000a					id: 'anchorOptions',\u000a					width: 260,\u000a					align: 'center',\u000a					padding: 0,\u000a					children: [\u000a						{\u000a						type: 'fieldset',\u000a						id: 'selectAnchorText',\u000a						label: linkLang.selectAnchor,\u000a						setup: function( data ) {\u000a							anchors = plugin.getEditorAnchors( editor );\u000a\u000a							this.getElement()[ anchors && anchors.length ? 'show' : 'hide' ]();\u000a						},\u000a						children: [\u000a							{\u000a							type: 'hbox',\u000a							id: 'selectAnchor',\u000a							children: [\u000a								{\u000a								type: 'select',\u000a								id: 'anchorName',\u000a								'default': '',\u000a								label: linkLang.anchorName,\u000a								style: 'width: 100%;',\u000a								items: [\u000a									[ '' ]\u000a									],\u000a								setup: function( data ) {\u000a									this.clear();\u000a									this.add( '' );\u000a\u000a									if ( anchors ) {\u000a										for ( var i = 0; i < anchors.length; i++ ) {\u000a											if ( anchors[ i ].name )\u000a												this.add( anchors[ i ].name );\u000a										}\u000a									}\u000a\u000a									if ( data.anchor )\u000a										this.setValue( data.anchor.name );\u000a\u000a									var linkType = this.getDialog().getContentElement( 'info', 'linkType' );\u000a									if ( linkType && linkType.getValue() == 'email' )\u000a										this.focus();\u000a								},\u000a								commit: function( data ) {\u000a									if ( !data.anchor )\u000a										data.anchor = {};\u000a\u000a									data.anchor.name = this.getValue();\u000a								}\u000a							},\u000a								{\u000a								type: 'select',\u000a								id: 'anchorId',\u000a								'default': '',\u000a								label: linkLang.anchorId,\u000a								style: 'width: 100%;',\u000a								items: [\u000a									[ '' ]\u000a									],\u000a								setup: function( data ) {\u000a									this.clear();\u000a									this.add( '' );\u000a\u000a									if ( anchors ) {\u000a										for ( var i = 0; i < anchors.length; i++ ) {\u000a											if ( anchors[ i ].id )\u000a												this.add( anchors[ i ].id );\u000a										}\u000a									}\u000a\u000a									if ( data.anchor )\u000a										this.setValue( data.anchor.id );\u000a								},\u000a								commit: function( data ) {\u000a									if ( !data.anchor )\u000a										data.anchor = {};\u000a\u000a									data.anchor.id = this.getValue();\u000a								}\u000a							}\u000a							],\u000a							setup: function( data ) {\u000a								this.getElement()[ anchors && anchors.length ? 'show' : 'hide' ]();\u000a							}\u000a						}\u000a						]\u000a					},\u000a						{\u000a						type: 'html',\u000a						id: 'noAnchors',\u000a						style: 'text-align: center;',\u000a						html: '<div role="note" tabIndex="-1">' + CKEDITOR.tools.htmlEncode( linkLang.noAnchors ) + '</div>',\u000a						// Focus the first element defined in above html.\u000a						focus: true,\u000a						setup: function( data ) {\u000a							this.getElement()[ anchors && anchors.length ? 'hide' : 'show' ]();\u000a						}\u000a					}\u000a					],\u000a					setup: function( data ) {\u000a						if ( !this.getDialog().getContentElement( 'info', 'linkType' ) )\u000a							this.getElement().hide();\u000a					}\u000a				},\u000a					{\u000a					type: 'vbox',\u000a					id: 'emailOptions',\u000a					padding: 1,\u000a					children: [\u000a						{\u000a						type: 'text',\u000a						id: 'emailAddress',\u000a						label: linkLang.emailAddress,\u000a						required: true,\u000a						validate: function() {\u000a							var dialog = this.getDialog();\u000a\u000a							if ( !dialog.getContentElement( 'info', 'linkType' ) || dialog.getValueOf( 'info', 'linkType' ) != 'email' )\u000a								return true;\u000a\u000a							var func = CKEDITOR.dialog.validate.notEmpty( linkLang.noEmail );\u000a							return func.apply( this );\u000a						},\u000a						setup: function( data ) {\u000a							if ( data.email )\u000a								this.setValue( data.email.address );\u000a\u000a							var linkType = this.getDialog().getContentElement( 'info', 'linkType' );\u000a							if ( linkType && linkType.getValue() == 'email' )\u000a								this.select();\u000a						},\u000a						commit: function( data ) {\u000a							if ( !data.email )\u000a								data.email = {};\u000a\u000a							data.email.address = this.getValue();\u000a						}\u000a					},\u000a						{\u000a						type: 'text',\u000a						id: 'emailSubject',\u000a						label: linkLang.emailSubject,\u000a						setup: function( data ) {\u000a							if ( data.email )\u000a								this.setValue( data.email.subject );\u000a						},\u000a						commit: function( data ) {\u000a							if ( !data.email )\u000a								data.email = {};\u000a\u000a							data.email.subject = this.getValue();\u000a						}\u000a					},\u000a						{\u000a						type: 'textarea',\u000a						id: 'emailBody',\u000a						label: linkLang.emailBody,\u000a						rows: 3,\u000a						'default': '',\u000a						setup: function( data ) {\u000a							if ( data.email )\u000a								this.setValue( data.email.body );\u000a						},\u000a						commit: function( data ) {\u000a							if ( !data.email )\u000a								data.email = {};\u000a\u000a							data.email.body = this.getValue();\u000a						}\u000a					}\u000a					],\u000a					setup: function( data ) {\u000a						if ( !this.getDialog().getContentElement( 'info', 'linkType' ) )\u000a							this.getElement().hide();\u000a					}\u000a				}\u000a				]\u000a			},\u000a				{\u000a				id: 'target',\u000a				requiredContent: 'a[target]', // This is not fully correct, because some target option requires JS.\u000a				label: linkLang.target,\u000a				title: linkLang.target,\u000a				elements: [\u000a					{\u000a					type: 'hbox',\u000a					widths: [ '50%', '50%' ],\u000a					children: [\u000a						{\u000a						type: 'select',\u000a						id: 'linkTargetType',\u000a						label: commonLang.target,\u000a						'default': 'notSet',\u000a						style: 'width : 100%;',\u000a						'items': [\u000a							[ commonLang.notSet, 'notSet' ],\u000a							[ linkLang.targetFrame, 'frame' ],\u000a							[ linkLang.targetPopup, 'popup' ],\u000a							[ commonLang.targetNew, '_blank' ],\u000a							[ commonLang.targetTop, '_top' ],\u000a							[ commonLang.targetSelf, '_self' ],\u000a							[ commonLang.targetParent, '_parent' ]\u000a							],\u000a						onChange: targetChanged,\u000a						setup: function( data ) {\u000a							if ( data.target )\u000a								this.setValue( data.target.type || 'notSet' );\u000a							targetChanged.call( this );\u000a						},\u000a						commit: function( data ) {\u000a							if ( !data.target )\u000a								data.target = {};\u000a\u000a							data.target.type = this.getValue();\u000a						}\u000a					},\u000a						{\u000a						type: 'text',\u000a						id: 'linkTargetName',\u000a						label: linkLang.targetFrameName,\u000a						'default': '',\u000a						setup: function( data ) {\u000a							if ( data.target )\u000a								this.setValue( data.target.name );\u000a						},\u000a						commit: function( data ) {\u000a							if ( !data.target )\u000a								data.target = {};\u000a\u000a							data.target.name = this.getValue().replace( /\u005cW/gi, '' );\u000a						}\u000a					}\u000a					]\u000a				},\u000a					{\u000a					type: 'vbox',\u000a					width: '100%',\u000a					align: 'center',\u000a					padding: 2,\u000a					id: 'popupFeatures',\u000a					children: [\u000a						{\u000a						type: 'fieldset',\u000a						label: linkLang.popupFeatures,\u000a						children: [\u000a							{\u000a							type: 'hbox',\u000a							children: [\u000a								{\u000a								type: 'checkbox',\u000a								id: 'resizable',\u000a								label: linkLang.popupResizable,\u000a								setup: setupPopupParams,\u000a								commit: commitPopupParams\u000a							},\u000a								{\u000a								type: 'checkbox',\u000a								id: 'status',\u000a								label: linkLang.popupStatusBar,\u000a								setup: setupPopupParams,\u000a								commit: commitPopupParams\u000a\u000a							}\u000a							]\u000a						},\u000a							{\u000a							type: 'hbox',\u000a							children: [\u000a								{\u000a								type: 'checkbox',\u000a								id: 'location',\u000a								label: linkLang.popupLocationBar,\u000a								setup: setupPopupParams,\u000a								commit: commitPopupParams\u000a\u000a							},\u000a								{\u000a								type: 'checkbox',\u000a								id: 'toolbar',\u000a								label: linkLang.popupToolbar,\u000a								setup: setupPopupParams,\u000a								commit: commitPopupParams\u000a\u000a							}\u000a							]\u000a						},\u000a							{\u000a							type: 'hbox',\u000a							children: [\u000a								{\u000a								type: 'checkbox',\u000a								id: 'menubar',\u000a								label: linkLang.popupMenuBar,\u000a								setup: setupPopupParams,\u000a								commit: commitPopupParams\u000a\u000a							},\u000a								{\u000a								type: 'checkbox',\u000a								id: 'fullscreen',\u000a								label: linkLang.popupFullScreen,\u000a								setup: setupPopupParams,\u000a								commit: commitPopupParams\u000a\u000a							}\u000a							]\u000a						},\u000a							{\u000a							type: 'hbox',\u000a							children: [\u000a								{\u000a								type: 'checkbox',\u000a								id: 'scrollbars',\u000a								label: linkLang.popupScrollBars,\u000a								setup: setupPopupParams,\u000a								commit: commitPopupParams\u000a\u000a							},\u000a								{\u000a								type: 'checkbox',\u000a								id: 'dependent',\u000a								label: linkLang.popupDependent,\u000a								setup: setupPopupParams,\u000a								commit: commitPopupParams\u000a\u000a							}\u000a							]\u000a						},\u000a							{\u000a							type: 'hbox',\u000a							children: [\u000a								{\u000a								type: 'text',\u000a								widths: [ '50%', '50%' ],\u000a								labelLayout: 'horizontal',\u000a								label: commonLang.width,\u000a								id: 'width',\u000a								setup: setupPopupParams,\u000a								commit: commitPopupParams\u000a\u000a							},\u000a								{\u000a								type: 'text',\u000a								labelLayout: 'horizontal',\u000a								widths: [ '50%', '50%' ],\u000a								label: linkLang.popupLeft,\u000a								id: 'left',\u000a								setup: setupPopupParams,\u000a								commit: commitPopupParams\u000a\u000a							}\u000a							]\u000a						},\u000a							{\u000a							type: 'hbox',\u000a							children: [\u000a								{\u000a								type: 'text',\u000a								labelLayout: 'horizontal',\u000a								widths: [ '50%', '50%' ],\u000a								label: commonLang.height,\u000a								id: 'height',\u000a								setup: setupPopupParams,\u000a								commit: commitPopupParams\u000a\u000a							},\u000a								{\u000a								type: 'text',\u000a								labelLayout: 'horizontal',\u000a								label: linkLang.popupTop,\u000a								widths: [ '50%', '50%' ],\u000a								id: 'top',\u000a								setup: setupPopupParams,\u000a								commit: commitPopupParams\u000a\u000a							}\u000a							]\u000a						}\u000a						]\u000a					}\u000a					]\u000a				}\u000a				]\u000a			},\u000a				{\u000a				id: 'upload',\u000a				label: linkLang.upload,\u000a				title: linkLang.upload,\u000a				hidden: true,\u000a				filebrowser: 'uploadButton',\u000a				elements: [\u000a					{\u000a					type: 'file',\u000a					id: 'upload',\u000a					label: commonLang.upload,\u000a					style: 'height:40px',\u000a					size: 29\u000a				},\u000a					{\u000a					type: 'fileButton',\u000a					id: 'uploadButton',\u000a					label: commonLang.uploadSubmit,\u000a					filebrowser: 'info:url',\u000a					'for': [ 'upload', 'upload' ]\u000a				}\u000a				]\u000a			},\u000a				{\u000a				id: 'advanced',\u000a				label: linkLang.advanced,\u000a				title: linkLang.advanced,\u000a				elements: [\u000a					{\u000a					type: 'vbox',\u000a					padding: 1,\u000a					children: [\u000a						{\u000a						type: 'hbox',\u000a						widths: [ '45%', '35%', '20%' ],\u000a						children: [\u000a							{\u000a							type: 'text',\u000a							id: 'advId',\u000a							requiredContent: 'a[id]',\u000a							label: linkLang.id,\u000a							setup: setupAdvParams,\u000a							commit: commitAdvParams\u000a						},\u000a							{\u000a							type: 'select',\u000a							id: 'advLangDir',\u000a							requiredContent: 'a[dir]',\u000a							label: linkLang.langDir,\u000a							'default': '',\u000a							style: 'width:110px',\u000a							items: [\u000a								[ commonLang.notSet, '' ],\u000a								[ linkLang.langDirLTR, 'ltr' ],\u000a								[ linkLang.langDirRTL, 'rtl' ]\u000a								],\u000a							setup: setupAdvParams,\u000a							commit: commitAdvParams\u000a						},\u000a							{\u000a							type: 'text',\u000a							id: 'advAccessKey',\u000a							requiredContent: 'a[accesskey]',\u000a							width: '80px',\u000a							label: linkLang.acccessKey,\u000a							maxLength: 1,\u000a							setup: setupAdvParams,\u000a							commit: commitAdvParams\u000a\u000a						}\u000a						]\u000a					},\u000a						{\u000a						type: 'hbox',\u000a						widths: [ '45%', '35%', '20%' ],\u000a						children: [\u000a							{\u000a							type: 'text',\u000a							label: linkLang.name,\u000a							id: 'advName',\u000a							requiredContent: 'a[name]',\u000a							setup: setupAdvParams,\u000a							commit: commitAdvParams\u000a\u000a						},\u000a							{\u000a							type: 'text',\u000a							label: linkLang.langCode,\u000a							id: 'advLangCode',\u000a							requiredContent: 'a[lang]',\u000a							width: '110px',\u000a							'default': '',\u000a							setup: setupAdvParams,\u000a							commit: commitAdvParams\u000a\u000a						},\u000a							{\u000a							type: 'text',\u000a							label: linkLang.tabIndex,\u000a							id: 'advTabIndex',\u000a							requiredContent: 'a[tabindex]',\u000a							width: '80px',\u000a							maxLength: 5,\u000a							setup: setupAdvParams,\u000a							commit: commitAdvParams\u000a\u000a						}\u000a						]\u000a					}\u000a					]\u000a				},\u000a					{\u000a					type: 'vbox',\u000a					padding: 1,\u000a					children: [\u000a						{\u000a						type: 'hbox',\u000a						widths: [ '45%', '55%' ],\u000a						children: [\u000a							{\u000a							type: 'text',\u000a							label: linkLang.advisoryTitle,\u000a							requiredContent: 'a[title]',\u000a							'default': '',\u000a							id: 'advTitle',\u000a							setup: setupAdvParams,\u000a							commit: commitAdvParams\u000a\u000a						},\u000a							{\u000a							type: 'text',\u000a							label: linkLang.advisoryContentType,\u000a							requiredContent: 'a[type]',\u000a							'default': '',\u000a							id: 'advContentType',\u000a							setup: setupAdvParams,\u000a							commit: commitAdvParams\u000a\u000a						}\u000a						]\u000a					},\u000a						{\u000a						type: 'hbox',\u000a						widths: [ '45%', '55%' ],\u000a						children: [\u000a							{\u000a							type: 'text',\u000a							label: linkLang.cssClasses,\u000a							requiredContent: 'a(cke-xyz)', // Random text like 'xyz' will check if all are allowed.\u000a							'default': '',\u000a							id: 'advCSSClasses',\u000a							setup: setupAdvParams,\u000a							commit: commitAdvParams\u000a\u000a						},\u000a							{\u000a							type: 'text',\u000a							label: linkLang.charset,\u000a							requiredContent: 'a[charset]',\u000a							'default': '',\u000a							id: 'advCharset',\u000a							setup: setupAdvParams,\u000a							commit: commitAdvParams\u000a\u000a						}\u000a						]\u000a					},\u000a						{\u000a						type: 'hbox',\u000a						widths: [ '45%', '55%' ],\u000a						children: [\u000a							{\u000a							type: 'text',\u000a							label: linkLang.rel,\u000a							requiredContent: 'a[rel]',\u000a							'default': '',\u000a							id: 'advRel',\u000a							setup: setupAdvParams,\u000a							commit: commitAdvParams\u000a						},\u000a							{\u000a							type: 'text',\u000a							label: linkLang.styles,\u000a							requiredContent: 'a{cke-xyz}', // Random text like 'xyz' will check if all are allowed.\u000a							'default': '',\u000a							id: 'advStyles',\u000a							validate: CKEDITOR.dialog.validate.inlineStyle( editor.lang.common.invalidInlineStyle ),\u000a							setup: setupAdvParams,\u000a							commit: commitAdvParams\u000a						}\u000a						]\u000a					}\u000a					]\u000a				}\u000a				]\u000a			}\u000a			],\u000a			onShow: function() {\u000a				var editor = this.getParentEditor(),\u000a					selection = editor.getSelection(),\u000a					element = null;\u000a\u000a				// Fill in all the relevant fields if there's already one link selected.\u000a				if ( ( element = plugin.getSelectedLink( editor ) ) && element.hasAttribute( 'href' ) ) {\u000a					// Don't change selection if some element is already selected.\u000a					// For example - don't destroy fake selection.\u000a					if ( !selection.getSelectedElement() )\u000a						selection.selectElement( element );\u000a				} else\u000a					element = null;\u000a\u000a				var data = plugin.parseLinkAttributes( editor, element );\u000a\u000a				// Record down the selected element in the dialog.\u000a				this._.selectedElement = element;\u000a\u000a				this.setupContent( data );\u000a			},\u000a			onOk: function() {\u000a				var data = {};\u000a\u000a				// Collect data from fields.\u000a				this.commitContent( data );\u000a\u000a				var selection = editor.getSelection(),\u000a					attributes = plugin.getLinkAttributes( editor, data );\u000a\u000a				if ( !this._.selectedElement ) {\u000a					var range = selection.getRanges()[ 0 ];\u000a\u000a					// Use link URL as text with a collapsed cursor.\u000a					if ( range.collapsed ) {\u000a						// Short mailto link text view (#5736).\u000a						var text = new CKEDITOR.dom.text( data.type == 'email' ?\u000a							data.email.address : attributes.set[ 'data-cke-saved-href' ], editor.document );\u000a						range.insertNode( text );\u000a						range.selectNodeContents( text );\u000a					}\u000a\u000a					// Apply style.\u000a					var style = new CKEDITOR.style( {\u000a						element: 'a',\u000a						attributes: attributes.set\u000a					} );\u000a\u000a					style.type = CKEDITOR.STYLE_INLINE; // need to override... dunno why.\u000a					style.applyToRange( range, editor );\u000a					range.select();\u000a				} else {\u000a					// We're only editing an existing link, so just overwrite the attributes.\u000a					var element = this._.selectedElement,\u000a						href = element.data( 'cke-saved-href' ),\u000a						textView = element.getHtml();\u000a\u000a					element.setAttributes( attributes.set );\u000a					element.removeAttributes( attributes.removed );\u000a\u000a					// Update text view when user changes protocol (#4612).\u000a					if ( href == textView || data.type == 'email' && textView.indexOf( '@' ) != -1 ) {\u000a						// Short mailto link text view (#5736).\u000a						element.setHtml( data.type == 'email' ?\u000a							data.email.address : attributes.set[ 'data-cke-saved-href' ] );\u000a\u000a						// We changed the content, so need to select it again.\u000a						selection.selectElement( element );\u000a					}\u000a\u000a					delete this._.selectedElement;\u000a				}\u000a			},\u000a			onLoad: function() {\u000a				if ( !editor.config.linkShowAdvancedTab )\u000a					this.hidePage( 'advanced' ); //Hide Advanded tab.\u000a\u000a				if ( !editor.config.linkShowTargetTab )\u000a					this.hidePage( 'target' ); //Hide Target tab.\u000a			},\u000a			// Inital focus on 'url' field if link is of type URL.\u000a			onFocus: function() {\u000a				var linkType = this.getContentElement( 'info', 'linkType' ),\u000a					urlField;\u000a\u000a				if ( linkType && linkType.getValue() == 'url' ) {\u000a					urlField = this.getContentElement( 'info', 'url' );\u000a					urlField.select();\u000a				}\u000a			}\u000a		};\u000a	} );\u000a} )();\u000a\u000a/**\u000a * The e-mail address anti-spam protection option. The protection will be\u000a * applied when creating or modifying e-mail links through the editor interface.\u000a *\u000a * Two methods of protection can be chosen:\u000a *\u000a * 1. The e-mail parts (name, domain, and any other query string) are\u000a *     assembled into a function call pattern. Such function must be\u000a *     provided by the developer in the pages that will use the contents.\u000a * 2. Only the e-mail address is obfuscated into a special string that\u000a *     has no meaning for humans or spam bots, but which is properly\u000a *     rendered and accepted by the browser.\u000a *\u000a * Both approaches require JavaScript to be enabled.\u000a *\u000a *		// href="mailto:tester@ckeditor.com?subject=subject&body=body"\u000a *		config.emailProtection = '';\u000a *\u000a *		// href="<a href=\u005c"javascript:void(location.href=\u005c'mailto:\u005c'+String.fromCharCode(116,101,115,116,101,114,64,99,107,101,100,105,116,111,114,46,99,111,109)+\u005c'?subject=subject&body=body\u005c')\u005c">e-mail</a>"\u000a *		config.emailProtection = 'encode';\u000a *\u000a *		// href="javascript:mt('tester','ckeditor.com','subject','body')"\u000a *		config.emailProtection = 'mt(NAME,DOMAIN,SUBJECT,BODY)';\u000a *\u000a * @since 3.1\u000a * @cfg {String} [emailProtection='' (empty string = disabled)]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000aCKEDITOR.dialog.add( 'anchor', function( editor ) {\u000a	// Function called in onShow to load selected element.\u000a	var loadElements = function( element ) {\u000a			this._.selectedElement = element;\u000a\u000a			var attributeValue = element.data( 'cke-saved-name' );\u000a			this.setValueOf( 'info', 'txtName', attributeValue || '' );\u000a		};\u000a\u000a	function createFakeAnchor( editor, attributes ) {\u000a		return editor.createFakeElement( editor.document.createElement( 'a', {\u000a			attributes: attributes\u000a		} ), 'cke_anchor', 'anchor' );\u000a	}\u000a\u000a	return {\u000a		title: editor.lang.link.anchor.title,\u000a		minWidth: 300,\u000a		minHeight: 60,\u000a		onOk: function() {\u000a			var name = CKEDITOR.tools.trim( this.getValueOf( 'info', 'txtName' ) );\u000a			var attributes = {\u000a				id: name,\u000a				name: name,\u000a				'data-cke-saved-name': name\u000a			};\u000a\u000a			if ( this._.selectedElement ) {\u000a				if ( this._.selectedElement.data( 'cke-realelement' ) ) {\u000a					var newFake = createFakeAnchor( editor, attributes );\u000a					newFake.replace( this._.selectedElement );\u000a\u000a					// Selecting fake element for IE. (#11377)\u000a					if ( CKEDITOR.env.ie )\u000a						editor.getSelection().selectElement( newFake );\u000a				} else\u000a					this._.selectedElement.setAttributes( attributes );\u000a			} else {\u000a				var sel = editor.getSelection(),\u000a					range = sel && sel.getRanges()[ 0 ];\u000a\u000a				// Empty anchor\u000a				if ( range.collapsed ) {\u000a					var anchor = createFakeAnchor( editor, attributes );\u000a					range.insertNode( anchor );\u000a				} else {\u000a					if ( CKEDITOR.env.ie && CKEDITOR.env.version < 9 )\u000a						attributes[ 'class' ] = 'cke_anchor';\u000a\u000a					// Apply style.\u000a					var style = new CKEDITOR.style( { element: 'a', attributes: attributes } );\u000a					style.type = CKEDITOR.STYLE_INLINE;\u000a					editor.applyStyle( style );\u000a				}\u000a			}\u000a		},\u000a\u000a		onHide: function() {\u000a			delete this._.selectedElement;\u000a		},\u000a\u000a		onShow: function() {\u000a			var sel = editor.getSelection(),\u000a				fullySelected = sel.getSelectedElement(),\u000a				fakeSelected = fullySelected && fullySelected.data( 'cke-realelement' ),\u000a				linkElement = fakeSelected ?\u000a					CKEDITOR.plugins.link.tryRestoreFakeAnchor( editor, fullySelected ) :\u000a					CKEDITOR.plugins.link.getSelectedLink( editor );\u000a\u000a			if ( linkElement ) {\u000a				loadElements.call( this, linkElement );\u000a				!fakeSelected && sel.selectElement( linkElement );\u000a\u000a				if ( fullySelected )\u000a					this._.selectedElement = fullySelected;\u000a			}\u000a\u000a			this.getContentElement( 'info', 'txtName' ).focus();\u000a		},\u000a		contents: [\u000a			{\u000a			id: 'info',\u000a			label: editor.lang.link.anchor.title,\u000a			accessKey: 'I',\u000a			elements: [\u000a				{\u000a				type: 'text',\u000a				id: 'txtName',\u000a				label: editor.lang.link.anchor.name,\u000a				required: true,\u000a				validate: function() {\u000a					if ( !this.getValue() ) {\u000a						alert( editor.lang.link.anchor.errorName );\u000a						return false;\u000a					}\u000a					return true;\u000a				}\u000a			}\u000a			]\u000a		}\u000a		]\u000a	};\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Insert and remove numbered and bulleted lists.\u000a */\u000a\u000a( function() {\u000a	var listNodeNames = { ol: 1, ul: 1 },\u000a		emptyTextRegex = /^[\u005cn\u005cr\u005ct ]*$/;\u000a\u000a	var whitespaces = CKEDITOR.dom.walker.whitespaces(),\u000a		bookmarks = CKEDITOR.dom.walker.bookmark(),\u000a		nonEmpty = function( node ) {\u000a			return !( whitespaces( node ) || bookmarks( node ) );\u000a		},\u000a		blockBogus = CKEDITOR.dom.walker.bogus();\u000a\u000a	function cleanUpDirection( element ) {\u000a		var dir, parent, parentDir;\u000a		if ( ( dir = element.getDirection() ) ) {\u000a			parent = element.getParent();\u000a			while ( parent && !( parentDir = parent.getDirection() ) )\u000a				parent = parent.getParent();\u000a\u000a			if ( dir == parentDir )\u000a				element.removeAttribute( 'dir' );\u000a		}\u000a	}\u000a\u000a	// Inherit inline styles from another element.\u000a	function inheritInlineStyles( parent, el ) {\u000a		var style = parent.getAttribute( 'style' );\u000a\u000a		// Put parent styles before child styles.\u000a		style && el.setAttribute( 'style', style.replace( /([^;])$/, '$1;' ) + ( el.getAttribute( 'style' ) || '' ) );\u000a	}\u000a\u000a	CKEDITOR.plugins.list = {\u000a		/**\u000a		 * Convert a DOM list tree into a data structure that is easier to\u000a		 * manipulate. This operation should be non-intrusive in the sense that it\u000a		 * does not change the DOM tree, with the exception that it may add some\u000a		 * markers to the list item nodes when database is specified.\u000a		 *\u000a		 * @member CKEDITOR.plugins.list\u000a		 * @todo params\u000a		 */\u000a		listToArray: function( listNode, database, baseArray, baseIndentLevel, grandparentNode ) {\u000a			if ( !listNodeNames[ listNode.getName() ] )\u000a				return [];\u000a\u000a			if ( !baseIndentLevel )\u000a				baseIndentLevel = 0;\u000a			if ( !baseArray )\u000a				baseArray = [];\u000a\u000a			// Iterate over all list items to and look for inner lists.\u000a			for ( var i = 0, count = listNode.getChildCount(); i < count; i++ ) {\u000a				var listItem = listNode.getChild( i );\u000a\u000a				// Fixing malformed nested lists by moving it into a previous list item. (#6236)\u000a				if ( listItem.type == CKEDITOR.NODE_ELEMENT && listItem.getName() in CKEDITOR.dtd.$list )\u000a					CKEDITOR.plugins.list.listToArray( listItem, database, baseArray, baseIndentLevel + 1 );\u000a\u000a				// It may be a text node or some funny stuff.\u000a				if ( listItem.$.nodeName.toLowerCase() != 'li' )\u000a					continue;\u000a\u000a				var itemObj = { 'parent': listNode, indent: baseIndentLevel, element: listItem, contents: [] };\u000a				if ( !grandparentNode ) {\u000a					itemObj.grandparent = listNode.getParent();\u000a					if ( itemObj.grandparent && itemObj.grandparent.$.nodeName.toLowerCase() == 'li' )\u000a						itemObj.grandparent = itemObj.grandparent.getParent();\u000a				} else\u000a					itemObj.grandparent = grandparentNode;\u000a\u000a				if ( database )\u000a					CKEDITOR.dom.element.setMarker( database, listItem, 'listarray_index', baseArray.length );\u000a				baseArray.push( itemObj );\u000a\u000a				for ( var j = 0, itemChildCount = listItem.getChildCount(), child; j < itemChildCount; j++ ) {\u000a					child = listItem.getChild( j );\u000a					if ( child.type == CKEDITOR.NODE_ELEMENT && listNodeNames[ child.getName() ] )\u000a					// Note the recursion here, it pushes inner list items with\u000a					// +1 indentation in the correct order.\u000a					CKEDITOR.plugins.list.listToArray( child, database, baseArray, baseIndentLevel + 1, itemObj.grandparent );\u000a					else\u000a						itemObj.contents.push( child );\u000a				}\u000a			}\u000a			return baseArray;\u000a		},\u000a\u000a		/**\u000a		 * Convert our internal representation of a list back to a DOM forest.\u000a		 *\u000a		 * @member CKEDITOR.plugins.list\u000a		 * @todo params\u000a		 */\u000a		arrayToList: function( listArray, database, baseIndex, paragraphMode, dir ) {\u000a			if ( !baseIndex )\u000a				baseIndex = 0;\u000a			if ( !listArray || listArray.length < baseIndex + 1 )\u000a				return null;\u000a			var i,\u000a				doc = listArray[ baseIndex ].parent.getDocument(),\u000a				retval = new CKEDITOR.dom.documentFragment( doc ),\u000a				rootNode = null,\u000a				currentIndex = baseIndex,\u000a				indentLevel = Math.max( listArray[ baseIndex ].indent, 0 ),\u000a				currentListItem = null,\u000a				orgDir, block,\u000a				paragraphName = ( paragraphMode == CKEDITOR.ENTER_P ? 'p' : 'div' );\u000a			while ( 1 ) {\u000a				var item = listArray[ currentIndex ],\u000a					itemGrandParent = item.grandparent;\u000a\u000a				orgDir = item.element.getDirection( 1 );\u000a\u000a				if ( item.indent == indentLevel ) {\u000a					if ( !rootNode || listArray[ currentIndex ].parent.getName() != rootNode.getName() ) {\u000a						rootNode = listArray[ currentIndex ].parent.clone( false, 1 );\u000a						dir && rootNode.setAttribute( 'dir', dir );\u000a						retval.append( rootNode );\u000a					}\u000a					currentListItem = rootNode.append( item.element.clone( 0, 1 ) );\u000a\u000a					if ( orgDir != rootNode.getDirection( 1 ) )\u000a						currentListItem.setAttribute( 'dir', orgDir );\u000a\u000a					for ( i = 0; i < item.contents.length; i++ )\u000a						currentListItem.append( item.contents[ i ].clone( 1, 1 ) );\u000a					currentIndex++;\u000a				} else if ( item.indent == Math.max( indentLevel, 0 ) + 1 ) {\u000a					// Maintain original direction (#6861).\u000a					var currDir = listArray[ currentIndex - 1 ].element.getDirection( 1 ),\u000a						listData = CKEDITOR.plugins.list.arrayToList( listArray, null, currentIndex, paragraphMode, currDir != orgDir ? orgDir : null );\u000a\u000a					// If the next block is an <li> with another list tree as the first\u000a					// child, we'll need to append a filler (<br>/NBSP) or the list item\u000a					// wouldn't be editable. (#6724)\u000a					if ( !currentListItem.getChildCount() && CKEDITOR.env.needsNbspFiller && !( doc.$.documentMode > 7 ) )\u000a						currentListItem.append( doc.createText( '\u005cxa0' ) );\u000a					currentListItem.append( listData.listNode );\u000a					currentIndex = listData.nextIndex;\u000a				} else if ( item.indent == -1 && !baseIndex && itemGrandParent ) {\u000a					if ( listNodeNames[ itemGrandParent.getName() ] ) {\u000a						currentListItem = item.element.clone( false, true );\u000a						if ( orgDir != itemGrandParent.getDirection( 1 ) )\u000a							currentListItem.setAttribute( 'dir', orgDir );\u000a					} else\u000a						currentListItem = new CKEDITOR.dom.documentFragment( doc );\u000a\u000a					// Migrate all children to the new container,\u000a					// apply the proper text direction.\u000a					var dirLoose = itemGrandParent.getDirection( 1 ) != orgDir,\u000a						li = item.element,\u000a						className = li.getAttribute( 'class' ),\u000a						style = li.getAttribute( 'style' );\u000a\u000a					var needsBlock = currentListItem.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT && ( paragraphMode != CKEDITOR.ENTER_BR || dirLoose || style || className );\u000a\u000a					var child,\u000a						count = item.contents.length,\u000a						cachedBookmark;\u000a\u000a					for ( i = 0; i < count; i++ ) {\u000a						child = item.contents[ i ];\u000a\u000a						// Append bookmark if we can, or cache it and append it when we'll know\u000a						// what to do with it. Generally - we want to keep it next to its original neighbour.\u000a						// Exception: if bookmark is the only child it hasn't got any neighbour, so handle it normally\u000a						// (wrap with block if needed).\u000a						if ( bookmarks( child ) && count > 1 ) {\u000a							// If we don't need block, it's simple - append bookmark directly to the current list item.\u000a							if ( !needsBlock )\u000a								currentListItem.append( child.clone( 1, 1 ) );\u000a							else\u000a								cachedBookmark = child.clone( 1, 1 );\u000a						}\u000a						// Block content goes directly to the current list item, without wrapping.\u000a						else if ( child.type == CKEDITOR.NODE_ELEMENT && child.isBlockBoundary() ) {\u000a							// Apply direction on content blocks.\u000a							if ( dirLoose && !child.getDirection() )\u000a								child.setAttribute( 'dir', orgDir );\u000a\u000a							inheritInlineStyles( li, child );\u000a\u000a							className && child.addClass( className );\u000a\u000a							// Close the block which we started for inline content.\u000a							block = null;\u000a							// Append bookmark directly before current child.\u000a							if ( cachedBookmark ) {\u000a								currentListItem.append( cachedBookmark );\u000a								cachedBookmark = null;\u000a							}\u000a							// Append this block element to the list item.\u000a							currentListItem.append( child.clone( 1, 1 ) );\u000a						}\u000a						// Some inline content was found - wrap it with block and append that\u000a						// block to the current list item or append it to the block previously created.\u000a						else if ( needsBlock ) {\u000a							// Establish new block to hold text direction and styles.\u000a							if ( !block ) {\u000a								block = doc.createElement( paragraphName );\u000a								currentListItem.append( block );\u000a								dirLoose && block.setAttribute( 'dir', orgDir );\u000a							}\u000a\u000a							// Copy over styles to new block;\u000a							style && block.setAttribute( 'style', style );\u000a							className && block.setAttribute( 'class', className );\u000a\u000a							// Append bookmark directly before current child.\u000a							if ( cachedBookmark ) {\u000a								block.append( cachedBookmark );\u000a								cachedBookmark = null;\u000a							}\u000a							block.append( child.clone( 1, 1 ) );\u000a						}\u000a						// E.g. BR mode - inline content appended directly to the list item.\u000a						else\u000a							currentListItem.append( child.clone( 1, 1 ) );\u000a					}\u000a\u000a					// No content after bookmark - append it to the block if we had one\u000a					// or directly to the current list item if we finished directly in the current list item.\u000a					if ( cachedBookmark ) {\u000a						( block || currentListItem ).append( cachedBookmark );\u000a						cachedBookmark = null;\u000a					}\u000a\u000a					if ( currentListItem.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT && currentIndex != listArray.length - 1 ) {\u000a						var last;\u000a\u000a						// Remove bogus <br> if this browser uses them.\u000a						if ( CKEDITOR.env.needsBrFiller ) {\u000a							last = currentListItem.getLast();\u000a							if ( last && last.type == CKEDITOR.NODE_ELEMENT && last.is( 'br' ) )\u000a								last.remove();\u000a						}\u000a\u000a						// If the last element is not a block, append <br> to separate merged list items.\u000a						last = currentListItem.getLast( nonEmpty );\u000a						if ( !( last && last.type == CKEDITOR.NODE_ELEMENT && last.is( CKEDITOR.dtd.$block ) ) )\u000a							currentListItem.append( doc.createElement( 'br' ) );\u000a					}\u000a\u000a					var currentListItemName = currentListItem.$.nodeName.toLowerCase();\u000a					if ( currentListItemName == 'div' || currentListItemName == 'p' )\u000a						currentListItem.appendBogus();\u000a					retval.append( currentListItem );\u000a					rootNode = null;\u000a					currentIndex++;\u000a				} else\u000a					return null;\u000a\u000a				block = null;\u000a\u000a				if ( listArray.length <= currentIndex || Math.max( listArray[ currentIndex ].indent, 0 ) < indentLevel )\u000a					break;\u000a			}\u000a\u000a			if ( database ) {\u000a				var currentNode = retval.getFirst(),\u000a					listRoot = listArray[ 0 ].parent;\u000a\u000a				while ( currentNode ) {\u000a					if ( currentNode.type == CKEDITOR.NODE_ELEMENT ) {\u000a						// Clear marker attributes for the new list tree made of cloned nodes, if any.\u000a						CKEDITOR.dom.element.clearMarkers( database, currentNode );\u000a\u000a						// Clear redundant direction attribute specified on list items.\u000a						if ( currentNode.getName() in CKEDITOR.dtd.$listItem )\u000a							cleanUpDirection( currentNode );\u000a					}\u000a\u000a					currentNode = currentNode.getNextSourceNode();\u000a				}\u000a			}\u000a\u000a			return { listNode: retval, nextIndex: currentIndex };\u000a		}\u000a	};\u000a\u000a	function changeListType( editor, groupObj, database, listsCreated ) {\u000a		// This case is easy...\u000a		// 1. Convert the whole list into a one-dimensional array.\u000a		// 2. Change the list type by modifying the array.\u000a		// 3. Recreate the whole list by converting the array to a list.\u000a		// 4. Replace the original list with the recreated list.\u000a		var listArray = CKEDITOR.plugins.list.listToArray( groupObj.root, database ),\u000a			selectedListItems = [];\u000a\u000a		for ( var i = 0; i < groupObj.contents.length; i++ ) {\u000a			var itemNode = groupObj.contents[ i ];\u000a			itemNode = itemNode.getAscendant( 'li', true );\u000a			if ( !itemNode || itemNode.getCustomData( 'list_item_processed' ) )\u000a				continue;\u000a			selectedListItems.push( itemNode );\u000a			CKEDITOR.dom.element.setMarker( database, itemNode, 'list_item_processed', true );\u000a		}\u000a\u000a		var root = groupObj.root,\u000a			doc = root.getDocument(),\u000a			listNode, newListNode;\u000a\u000a		for ( i = 0; i < selectedListItems.length; i++ ) {\u000a			var listIndex = selectedListItems[ i ].getCustomData( 'listarray_index' );\u000a			listNode = listArray[ listIndex ].parent;\u000a\u000a			// Switch to new list node for this particular item.\u000a			if ( !listNode.is( this.type ) ) {\u000a				newListNode = doc.createElement( this.type );\u000a				// Copy all attributes, except from 'start' and 'type'.\u000a				listNode.copyAttributes( newListNode, { start: 1, type: 1 } );\u000a				// The list-style-type property should be ignored.\u000a				newListNode.removeStyle( 'list-style-type' );\u000a				listArray[ listIndex ].parent = newListNode;\u000a			}\u000a		}\u000a\u000a		var newList = CKEDITOR.plugins.list.arrayToList( listArray, database, null, editor.config.enterMode );\u000a		var child,\u000a			length = newList.listNode.getChildCount();\u000a		for ( i = 0; i < length && ( child = newList.listNode.getChild( i ) ); i++ ) {\u000a			if ( child.getName() == this.type )\u000a				listsCreated.push( child );\u000a		}\u000a		newList.listNode.replace( groupObj.root );\u000a\u000a		editor.fire( 'contentDomInvalidated' );\u000a	}\u000a\u000a	function createList( editor, groupObj, listsCreated ) {\u000a		var contents = groupObj.contents,\u000a			doc = groupObj.root.getDocument(),\u000a			listContents = [];\u000a\u000a		// It is possible to have the contents returned by DomRangeIterator to be the same as the root.\u000a		// e.g. when we're running into table cells.\u000a		// In such a case, enclose the childNodes of contents[0] into a <div>.\u000a		if ( contents.length == 1 && contents[ 0 ].equals( groupObj.root ) ) {\u000a			var divBlock = doc.createElement( 'div' );\u000a			contents[ 0 ].moveChildren && contents[ 0 ].moveChildren( divBlock );\u000a			contents[ 0 ].append( divBlock );\u000a			contents[ 0 ] = divBlock;\u000a		}\u000a\u000a		// Calculate the common parent node of all content blocks.\u000a		var commonParent = groupObj.contents[ 0 ].getParent();\u000a		for ( var i = 0; i < contents.length; i++ )\u000a			commonParent = commonParent.getCommonAncestor( contents[ i ].getParent() );\u000a\u000a		var useComputedState = editor.config.useComputedState,\u000a			listDir, explicitDirection;\u000a\u000a		useComputedState = useComputedState === undefined || useComputedState;\u000a\u000a		// We want to insert things that are in the same tree level only, so calculate the contents again\u000a		// by expanding the selected blocks to the same tree level.\u000a		for ( i = 0; i < contents.length; i++ ) {\u000a			var contentNode = contents[ i ],\u000a				parentNode;\u000a			while ( ( parentNode = contentNode.getParent() ) ) {\u000a				if ( parentNode.equals( commonParent ) ) {\u000a					listContents.push( contentNode );\u000a\u000a					// Determine the lists's direction.\u000a					if ( !explicitDirection && contentNode.getDirection() )\u000a						explicitDirection = 1;\u000a\u000a					var itemDir = contentNode.getDirection( useComputedState );\u000a\u000a					if ( listDir !== null ) {\u000a						// If at least one LI have a different direction than current listDir, we can't have listDir.\u000a						if ( listDir && listDir != itemDir )\u000a							listDir = null;\u000a						else\u000a							listDir = itemDir;\u000a					}\u000a\u000a					break;\u000a				}\u000a				contentNode = parentNode;\u000a			}\u000a		}\u000a\u000a		if ( listContents.length < 1 )\u000a			return;\u000a\u000a		// Insert the list to the DOM tree.\u000a		var insertAnchor = listContents[ listContents.length - 1 ].getNext(),\u000a			listNode = doc.createElement( this.type );\u000a\u000a		listsCreated.push( listNode );\u000a\u000a		var contentBlock, listItem;\u000a\u000a		while ( listContents.length ) {\u000a			contentBlock = listContents.shift();\u000a			listItem = doc.createElement( 'li' );\u000a\u000a			// If current block should be preserved, append it to list item instead of\u000a			// transforming it to <li> element.\u000a			if ( shouldPreserveBlock( contentBlock ) )\u000a				contentBlock.appendTo( listItem );\u000a			else {\u000a				contentBlock.copyAttributes( listItem );\u000a				// Remove direction attribute after it was merged into list root. (#7657)\u000a				if ( listDir && contentBlock.getDirection() ) {\u000a					listItem.removeStyle( 'direction' );\u000a					listItem.removeAttribute( 'dir' );\u000a				}\u000a				contentBlock.moveChildren( listItem );\u000a				contentBlock.remove();\u000a			}\u000a\u000a			listItem.appendTo( listNode );\u000a		}\u000a\u000a		// Apply list root dir only if it has been explicitly declared.\u000a		if ( listDir && explicitDirection )\u000a			listNode.setAttribute( 'dir', listDir );\u000a\u000a		if ( insertAnchor )\u000a			listNode.insertBefore( insertAnchor );\u000a		else\u000a			listNode.appendTo( commonParent );\u000a	}\u000a\u000a	function removeList( editor, groupObj, database ) {\u000a		// This is very much like the change list type operation.\u000a		// Except that we're changing the selected items' indent to -1 in the list array.\u000a		var listArray = CKEDITOR.plugins.list.listToArray( groupObj.root, database ),\u000a			selectedListItems = [];\u000a\u000a		for ( var i = 0; i < groupObj.contents.length; i++ ) {\u000a			var itemNode = groupObj.contents[ i ];\u000a			itemNode = itemNode.getAscendant( 'li', true );\u000a			if ( !itemNode || itemNode.getCustomData( 'list_item_processed' ) )\u000a				continue;\u000a			selectedListItems.push( itemNode );\u000a			CKEDITOR.dom.element.setMarker( database, itemNode, 'list_item_processed', true );\u000a		}\u000a\u000a		var lastListIndex = null;\u000a		for ( i = 0; i < selectedListItems.length; i++ ) {\u000a			var listIndex = selectedListItems[ i ].getCustomData( 'listarray_index' );\u000a			listArray[ listIndex ].indent = -1;\u000a			lastListIndex = listIndex;\u000a		}\u000a\u000a		// After cutting parts of the list out with indent=-1, we still have to maintain the array list\u000a		// model's nextItem.indent <= currentItem.indent + 1 invariant. Otherwise the array model of the\u000a		// list cannot be converted back to a real DOM list.\u000a		for ( i = lastListIndex + 1; i < listArray.length; i++ ) {\u000a			if ( listArray[ i ].indent > listArray[ i - 1 ].indent + 1 ) {\u000a				var indentOffset = listArray[ i - 1 ].indent + 1 - listArray[ i ].indent;\u000a				var oldIndent = listArray[ i ].indent;\u000a				while ( listArray[ i ] && listArray[ i ].indent >= oldIndent ) {\u000a					listArray[ i ].indent += indentOffset;\u000a					i++;\u000a				}\u000a				i--;\u000a			}\u000a		}\u000a\u000a		var newList = CKEDITOR.plugins.list.arrayToList( listArray, database, null, editor.config.enterMode, groupObj.root.getAttribute( 'dir' ) );\u000a\u000a		// Compensate <br> before/after the list node if the surrounds are non-blocks.(#3836)\u000a		var docFragment = newList.listNode,\u000a			boundaryNode, siblingNode;\u000a\u000a		function compensateBrs( isStart ) {\u000a			if ( ( boundaryNode = docFragment[ isStart ? 'getFirst' : 'getLast' ]() ) && !( boundaryNode.is && boundaryNode.isBlockBoundary() ) && ( siblingNode = groupObj.root[ isStart ? 'getPrevious' : 'getNext' ]\u000a			( CKEDITOR.dom.walker.invisible( true ) ) ) && !( siblingNode.is && siblingNode.isBlockBoundary( { br: 1 } ) ) )\u000a				editor.document.createElement( 'br' )[ isStart ? 'insertBefore' : 'insertAfter' ]( boundaryNode );\u000a		}\u000a		compensateBrs( true );\u000a		compensateBrs();\u000a\u000a		docFragment.replace( groupObj.root );\u000a\u000a		editor.fire( 'contentDomInvalidated' );\u000a	}\u000a\u000a	var headerTagRegex = /^h[1-6]$/;\u000a\u000a	// Checks wheather this block should be element preserved (not transformed to <li>) when creating list.\u000a	function shouldPreserveBlock( block ) {\u000a		return (\u000a			// #5335\u000a			block.is( 'pre' ) ||\u000a			// #5271 - this is a header.\u000a			headerTagRegex.test( block.getName() ) ||\u000a			// 11083 - this is a non-editable element.\u000a			block.getAttribute( 'contenteditable' ) == 'false'\u000a		);\u000a	}\u000a\u000a	function listCommand( name, type ) {\u000a		this.name = name;\u000a		this.type = type;\u000a		this.context = type;\u000a		this.allowedContent = type + ' li';\u000a		this.requiredContent = type;\u000a	}\u000a\u000a	var elementType = CKEDITOR.dom.walker.nodeType( CKEDITOR.NODE_ELEMENT );\u000a\u000a	// Merge child nodes with direction preserved. (#7448)\u000a	function mergeChildren( from, into, refNode, forward ) {\u000a		var child, itemDir;\u000a		while ( ( child = from[ forward ? 'getLast' : 'getFirst' ]( elementType ) ) ) {\u000a			if ( ( itemDir = child.getDirection( 1 ) ) !== into.getDirection( 1 ) )\u000a				child.setAttribute( 'dir', itemDir );\u000a\u000a			child.remove();\u000a\u000a			refNode ? child[ forward ? 'insertBefore' : 'insertAfter' ]( refNode ) : into.append( child, forward );\u000a		}\u000a	}\u000a\u000a	listCommand.prototype = {\u000a		exec: function( editor ) {\u000a			// Run state check first of all.\u000a			this.refresh( editor, editor.elementPath() );\u000a\u000a			var doc = editor.document,\u000a				config = editor.config,\u000a				selection = editor.getSelection(),\u000a				ranges = selection && selection.getRanges();\u000a\u000a			// Midas lists rule #1 says we can create a list even in an empty document.\u000a			// But DOM iterator wouldn't run if the document is really empty.\u000a			// So create a paragraph if the document is empty and we're going to create a list.\u000a			if ( this.state == CKEDITOR.TRISTATE_OFF ) {\u000a				var editable = editor.editable();\u000a				if ( !editable.getFirst( nonEmpty ) ) {\u000a					config.enterMode == CKEDITOR.ENTER_BR ? editable.appendBogus() : ranges[ 0 ].fixBlock( 1, config.enterMode == CKEDITOR.ENTER_P ? 'p' : 'div' );\u000a\u000a					selection.selectRanges( ranges );\u000a				}\u000a				// Maybe a single range there enclosing the whole list,\u000a				// turn on the list state manually(#4129).\u000a				else {\u000a					var range = ranges.length == 1 && ranges[ 0 ],\u000a						enclosedNode = range && range.getEnclosedNode();\u000a					if ( enclosedNode && enclosedNode.is && this.type == enclosedNode.getName() )\u000a						this.setState( CKEDITOR.TRISTATE_ON );\u000a				}\u000a			}\u000a\u000a			var bookmarks = selection.createBookmarks( true );\u000a\u000a			// Group the blocks up because there are many cases where multiple lists have to be created,\u000a			// or multiple lists have to be cancelled.\u000a			var listGroups = [],\u000a				database = {},\u000a				rangeIterator = ranges.createIterator(),\u000a				index = 0;\u000a\u000a			while ( ( range = rangeIterator.getNextRange() ) && ++index ) {\u000a				var boundaryNodes = range.getBoundaryNodes(),\u000a					startNode = boundaryNodes.startNode,\u000a					endNode = boundaryNodes.endNode;\u000a\u000a				if ( startNode.type == CKEDITOR.NODE_ELEMENT && startNode.getName() == 'td' )\u000a					range.setStartAt( boundaryNodes.startNode, CKEDITOR.POSITION_AFTER_START );\u000a\u000a				if ( endNode.type == CKEDITOR.NODE_ELEMENT && endNode.getName() == 'td' )\u000a					range.setEndAt( boundaryNodes.endNode, CKEDITOR.POSITION_BEFORE_END );\u000a\u000a				var iterator = range.createIterator(),\u000a					block;\u000a\u000a				iterator.forceBrBreak = ( this.state == CKEDITOR.TRISTATE_OFF );\u000a\u000a				while ( ( block = iterator.getNextParagraph() ) ) {\u000a					// Avoid duplicate blocks get processed across ranges.\u000a					if ( block.getCustomData( 'list_block' ) )\u000a						continue;\u000a					else\u000a						CKEDITOR.dom.element.setMarker( database, block, 'list_block', 1 );\u000a\u000a					var path = editor.elementPath( block ),\u000a						pathElements = path.elements,\u000a						pathElementsCount = pathElements.length,\u000a						listNode = null,\u000a						processedFlag = 0,\u000a						blockLimit = path.blockLimit,\u000a						element;\u000a\u000a					// First, try to group by a list ancestor.\u000a					for ( var i = pathElementsCount - 1; i >= 0 && ( element = pathElements[ i ] ); i-- ) {\u000a						if ( listNodeNames[ element.getName() ] && blockLimit.contains( element ) ) // Don't leak outside block limit (#3940).\u000a						{\u000a							// If we've encountered a list inside a block limit\u000a							// The last group object of the block limit element should\u000a							// no longer be valid. Since paragraphs after the list\u000a							// should belong to a different group of paragraphs before\u000a							// the list. (Bug #1309)\u000a							blockLimit.removeCustomData( 'list_group_object_' + index );\u000a\u000a							var groupObj = element.getCustomData( 'list_group_object' );\u000a							if ( groupObj )\u000a								groupObj.contents.push( block );\u000a							else {\u000a								groupObj = { root: element, contents: [ block ] };\u000a								listGroups.push( groupObj );\u000a								CKEDITOR.dom.element.setMarker( database, element, 'list_group_object', groupObj );\u000a							}\u000a							processedFlag = 1;\u000a							break;\u000a						}\u000a					}\u000a\u000a					if ( processedFlag )\u000a						continue;\u000a\u000a					// No list ancestor? Group by block limit, but don't mix contents from different ranges.\u000a					var root = blockLimit;\u000a					if ( root.getCustomData( 'list_group_object_' + index ) )\u000a						root.getCustomData( 'list_group_object_' + index ).contents.push( block );\u000a					else {\u000a						groupObj = { root: root, contents: [ block ] };\u000a						CKEDITOR.dom.element.setMarker( database, root, 'list_group_object_' + index, groupObj );\u000a						listGroups.push( groupObj );\u000a					}\u000a				}\u000a			}\u000a\u000a			// Now we have two kinds of list groups, groups rooted at a list, and groups rooted at a block limit element.\u000a			// We either have to build lists or remove lists, for removing a list does not makes sense when we are looking\u000a			// at the group that's not rooted at lists. So we have three cases to handle.\u000a			var listsCreated = [];\u000a			while ( listGroups.length > 0 ) {\u000a				groupObj = listGroups.shift();\u000a				if ( this.state == CKEDITOR.TRISTATE_OFF ) {\u000a					if ( listNodeNames[ groupObj.root.getName() ] )\u000a						changeListType.call( this, editor, groupObj, database, listsCreated );\u000a					else\u000a						createList.call( this, editor, groupObj, listsCreated );\u000a				} else if ( this.state == CKEDITOR.TRISTATE_ON && listNodeNames[ groupObj.root.getName() ] )\u000a					removeList.call( this, editor, groupObj, database );\u000a			}\u000a\u000a			// For all new lists created, merge into adjacent, same type lists.\u000a			for ( i = 0; i < listsCreated.length; i++ )\u000a				mergeListSiblings( listsCreated[ i ] );\u000a\u000a			// Clean up, restore selection and update toolbar button states.\u000a			CKEDITOR.dom.element.clearAllMarkers( database );\u000a			selection.selectBookmarks( bookmarks );\u000a			editor.focus();\u000a		},\u000a\u000a		refresh: function( editor, path ) {\u000a			var list = path.contains( listNodeNames, 1 ),\u000a				limit = path.blockLimit || path.root;\u000a\u000a			// 1. Only a single type of list activate.\u000a			// 2. Do not show list outside of block limit.\u000a			if ( list && limit.contains( list ) )\u000a				this.setState( list.is( this.type ) ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF );\u000a			else\u000a				this.setState( CKEDITOR.TRISTATE_OFF );\u000a		}\u000a	};\u000a\u000a	var dtd = CKEDITOR.dtd;\u000a	var tailNbspRegex = /[\u005ct\u005cr\u005cn ]*(?:&nbsp;|\u005cxa0)$/;\u000a\u000a		// Merge list adjacent, of same type lists.\u000a	function mergeListSiblings( listNode )\u000a	{\u000a		var mergeSibling;\u000a		( mergeSibling = function( rtl )\u000a		{\u000a			var sibling = listNode[ rtl ? 'getPrevious' : 'getNext' ]( nonEmpty );\u000a			if ( sibling &&\u000a			     sibling.type == CKEDITOR.NODE_ELEMENT &&\u000a			     sibling.is( listNode.getName() ) )\u000a			{\u000a				// Move children order by merge direction.(#3820)\u000a				mergeChildren( listNode, sibling, null, !rtl );\u000a\u000a				listNode.remove();\u000a				listNode = sibling;\u000a			}\u000a		} )();\u000a		mergeSibling( 1 );\u000a	}\u000a\u000a	function indexOfFirstChildElement( element, tagNameList ) {\u000a		var child,\u000a			children = element.children,\u000a			length = children.length;\u000a\u000a		for ( var i = 0; i < length; i++ ) {\u000a			child = children[ i ];\u000a			if ( child.name && ( child.name in tagNameList ) )\u000a				return i;\u000a		}\u000a\u000a		return length;\u000a	}\u000a\u000a	// Check if node is block element that recieves text.\u000a	function isTextBlock( node ) {\u000a		return node.type == CKEDITOR.NODE_ELEMENT && ( node.getName() in CKEDITOR.dtd.$block || node.getName() in CKEDITOR.dtd.$listItem ) && CKEDITOR.dtd[ node.getName() ][ '#' ];\u000a	}\u000a\u000a	// Join visually two block lines.\u000a	function joinNextLineToCursor( editor, cursor, nextCursor ) {\u000a		editor.fire( 'saveSnapshot' );\u000a\u000a		// Merge with previous block's content.\u000a		nextCursor.enlarge( CKEDITOR.ENLARGE_LIST_ITEM_CONTENTS );\u000a		var frag = nextCursor.extractContents();\u000a\u000a		cursor.trim( false, true );\u000a		var bm = cursor.createBookmark();\u000a\u000a		// Kill original bogus;\u000a		var currentPath = new CKEDITOR.dom.elementPath( cursor.startContainer ),\u000a				pathBlock = currentPath.block,\u000a				currentBlock = currentPath.lastElement.getAscendant( 'li', 1 ) || pathBlock,\u000a				nextPath = new CKEDITOR.dom.elementPath( nextCursor.startContainer ),\u000a				nextLi = nextPath.contains( CKEDITOR.dtd.$listItem ),\u000a				nextList = nextPath.contains( CKEDITOR.dtd.$list ),\u000a				last;\u000a\u000a		// Remove bogus node the current block/pseudo block.\u000a		if ( pathBlock ) {\u000a			var bogus = pathBlock.getBogus();\u000a			bogus && bogus.remove();\u000a		}\u000a		else if ( nextList ) {\u000a			last = nextList.getPrevious( nonEmpty );\u000a			if ( last && blockBogus( last ) )\u000a				last.remove();\u000a		}\u000a\u000a		// Kill the tail br in extracted.\u000a		last = frag.getLast();\u000a		if ( last && last.type == CKEDITOR.NODE_ELEMENT && last.is( 'br' ) )\u000a			last.remove();\u000a\u000a		// Insert fragment at the range position.\u000a		var nextNode = cursor.startContainer.getChild( cursor.startOffset );\u000a		if ( nextNode )\u000a			frag.insertBefore( nextNode );\u000a		else\u000a			cursor.startContainer.append( frag );\u000a\u000a		// Move the sub list nested in the next list item.\u000a		if ( nextLi ) {\u000a			var sublist = getSubList( nextLi );\u000a			if ( sublist ) {\u000a				// If next line is in the sub list of the current list item.\u000a				if ( currentBlock.contains( nextLi ) ) {\u000a					mergeChildren( sublist, nextLi.getParent(), nextLi );\u000a					sublist.remove();\u000a				}\u000a				// Migrate the sub list to current list item.\u000a				else\u000a					currentBlock.append( sublist );\u000a			}\u000a		}\u000a\u000a		var nextBlock, parent;\u000a		// Remove any remaining zombies path blocks at the end after line merged.\u000a		while ( nextCursor.checkStartOfBlock() && nextCursor.checkEndOfBlock() ) {\u000a			nextPath = nextCursor.startPath();\u000a			nextBlock = nextPath.block;\u000a\u000a			// Abort when nothing to be removed (#10890).\u000a			if ( !nextBlock )\u000a				break;\u000a\u000a			// Check if also to remove empty list.\u000a			if ( nextBlock.is( 'li' ) ) {\u000a				parent = nextBlock.getParent();\u000a				if ( nextBlock.equals( parent.getLast( nonEmpty ) ) && nextBlock.equals( parent.getFirst( nonEmpty ) ) )\u000a					nextBlock = parent;\u000a			}\u000a\u000a			nextCursor.moveToPosition( nextBlock, CKEDITOR.POSITION_BEFORE_START );\u000a			nextBlock.remove();\u000a		}\u000a\u000a		// Check if need to further merge with the list resides after the merged block. (#9080)\u000a		var walkerRng = nextCursor.clone(), editable = editor.editable();\u000a		walkerRng.setEndAt( editable, CKEDITOR.POSITION_BEFORE_END );\u000a		var walker = new CKEDITOR.dom.walker( walkerRng );\u000a		walker.evaluator = function( node ) { return nonEmpty( node ) && !blockBogus( node ); };\u000a		var next = walker.next();\u000a		if ( next && next.type == CKEDITOR.NODE_ELEMENT && next.getName() in CKEDITOR.dtd.$list )\u000a			mergeListSiblings( next );\u000a\u000a		cursor.moveToBookmark( bm );\u000a\u000a		// Make fresh selection.\u000a		cursor.select();\u000a\u000a		editor.fire( 'saveSnapshot' );\u000a	}\u000a\u000a	function getSubList( li ) {\u000a		var last = li.getLast( nonEmpty );\u000a		return last && last.type == CKEDITOR.NODE_ELEMENT && last.getName() in listNodeNames ? last : null;\u000a	}\u000a\u000a	CKEDITOR.plugins.add( 'list', {\u000a		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en,en-au,en-ca,en-gb,eo,es,et,eu,fa,fi,fo,fr,fr-ca,gl,gu,he,hi,hr,hu,id,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt,pt-br,ro,ru,si,sk,sl,sq,sr,sr-latn,sv,th,tr,tt,ug,uk,vi,zh,zh-cn', // %REMOVE_LINE_CORE%\u000a		// icons: 'bulletedlist,bulletedlist-rtl,numberedlist,numberedlist-rtl', // %REMOVE_LINE_CORE%\u000a		// hidpi: true, // %REMOVE_LINE_CORE%\u000a		requires: 'indentlist',\u000a		init: function( editor ) {\u000a			if ( editor.blockless )\u000a				return;\u000a\u000a			// Register commands.\u000a			editor.addCommand( 'numberedlist', new listCommand( 'numberedlist', 'ol' ) );\u000a			editor.addCommand( 'bulletedlist', new listCommand( 'bulletedlist', 'ul' ) );\u000a\u000a			// Register the toolbar button.\u000a			if ( editor.ui.addButton ) {\u000a				editor.ui.addButton( 'NumberedList', {\u000a					icon: 'numberedlist fa fa-list-ol numberedlist',\u000a					label: editor.lang.list.numberedlist,\u000a					command: 'numberedlist',\u000a					directional: true,\u000a					toolbar: 'list,10'\u000a				} );\u000a				editor.ui.addButton( 'BulletedList', {\u000a					icon: 'numberedlist fa fa-list-ul numberedlist',\u000a					label: editor.lang.list.bulletedlist,\u000a					command: 'bulletedlist',\u000a					directional: true,\u000a					toolbar: 'list,20'\u000a				} );\u000a			}\u000a\u000a			// Handled backspace/del key to join list items. (#8248,#9080)\u000a			editor.on( 'key', function( evt ) {\u000a				// Use getKey directly in order to ignore modifiers.\u000a				// Justification: http://dev.ckeditor.com/ticket/11861#comment:13\u000a				var key = evt.data.domEvent.getKey();\u000a\u000a				// DEl/BACKSPACE\u000a				if ( editor.mode == 'wysiwyg' && key in { 8: 1, 46: 1 } ) {\u000a					var sel = editor.getSelection(),\u000a						range = sel.getRanges()[ 0 ],\u000a						path = range && range.startPath();\u000a\u000a					if ( !range || !range.collapsed )\u000a						return;\u000a\u000a					var isBackspace = key == 8;\u000a					var editable = editor.editable();\u000a					var walker = new CKEDITOR.dom.walker( range.clone() );\u000a					walker.evaluator = function( node ) {\u000a						return nonEmpty( node ) && !blockBogus( node );\u000a					};\u000a					// Backspace/Del behavior at the start/end of table is handled in core.\u000a					walker.guard = function( node, isOut ) {\u000a						return !( isOut && node.type == CKEDITOR.NODE_ELEMENT && node.is( 'table' ) );\u000a					};\u000a\u000a					var cursor = range.clone();\u000a\u000a					if ( isBackspace ) {\u000a						var previous, joinWith;\u000a\u000a						// Join a sub list's first line, with the previous visual line in parent.\u000a						if ( ( previous = path.contains( listNodeNames ) ) &&\u000a						     range.checkBoundaryOfElement( previous, CKEDITOR.START ) &&\u000a						     ( previous = previous.getParent() ) && previous.is( 'li' ) &&\u000a						     ( previous = getSubList( previous ) ) ) {\u000a							joinWith = previous;\u000a							previous = previous.getPrevious( nonEmpty );\u000a							// Place cursor before the nested list.\u000a							cursor.moveToPosition(\u000a								previous && blockBogus( previous ) ? previous : joinWith,\u000a								CKEDITOR.POSITION_BEFORE_START );\u000a						}\u000a						// Join any line following a list, with the last visual line of the list.\u000a						else {\u000a							walker.range.setStartAt( editable, CKEDITOR.POSITION_AFTER_START );\u000a							walker.range.setEnd( range.startContainer, range.startOffset );\u000a\u000a							previous = walker.previous();\u000a\u000a							if ( previous && previous.type == CKEDITOR.NODE_ELEMENT &&\u000a							     ( previous.getName() in listNodeNames ||\u000a							       previous.is( 'li' ) ) ) {\u000a								if ( !previous.is( 'li' ) ) {\u000a									walker.range.selectNodeContents( previous );\u000a									walker.reset();\u000a									walker.evaluator = isTextBlock;\u000a									previous = walker.previous();\u000a								}\u000a\u000a								joinWith = previous;\u000a								// Place cursor at the end of previous block.\u000a								cursor.moveToElementEditEnd( joinWith );\u000a							}\u000a						}\u000a\u000a						if ( joinWith ) {\u000a							joinNextLineToCursor( editor, cursor, range );\u000a							evt.cancel();\u000a						}\u000a						else {\u000a							var list = path.contains( listNodeNames );\u000a							// Backspace pressed at the start of list outdents the first list item. (#9129)\u000a							if ( list && range.checkBoundaryOfElement( list, CKEDITOR.START ) ) {\u000a								li = list.getFirst( nonEmpty );\u000a\u000a								if ( range.checkBoundaryOfElement( li, CKEDITOR.START ) ) {\u000a									previous = list.getPrevious( nonEmpty );\u000a\u000a									// Only if the list item contains a sub list, do nothing but\u000a									// simply move cursor backward one character.\u000a									if ( getSubList( li ) ) {\u000a										if ( previous ) {\u000a											range.moveToElementEditEnd( previous );\u000a											range.select();\u000a										}\u000a\u000a										evt.cancel();\u000a									}\u000a									else {\u000a										editor.execCommand( 'outdent' );\u000a										evt.cancel();\u000a									}\u000a								}\u000a							}\u000a						}\u000a\u000a					} else {\u000a\u000a						var next, nextLine, li = path.contains( 'li' );\u000a\u000a						if ( li ) {\u000a							walker.range.setEndAt( editable, CKEDITOR.POSITION_BEFORE_END );\u000a\u000a							var last = li.getLast( nonEmpty );\u000a							var block = last && isTextBlock( last ) ? last : li;\u000a\u000a							// Indicate cursor at the visual end of an list item.\u000a							var isAtEnd = 0;\u000a\u000a							next = walker.next();\u000a\u000a							// When list item contains a sub list.\u000a							if ( next && next.type == CKEDITOR.NODE_ELEMENT &&\u000a								 next.getName() in listNodeNames &&\u000a								 next.equals( last ) )\u000a							{\u000a								isAtEnd = 1;\u000a\u000a								// Move to the first item in sub list.\u000a								next = walker.next();\u000a							}\u000a							// Right at the end of list item.\u000a							else if ( range.checkBoundaryOfElement( block, CKEDITOR.END ) )\u000a								isAtEnd = 1;\u000a\u000a\u000a							if ( isAtEnd && next ) {\u000a								// Put cursor range there.\u000a								nextLine = range.clone();\u000a								nextLine.moveToElementEditStart( next );\u000a\u000a								joinNextLineToCursor( editor, cursor, nextLine );\u000a								evt.cancel();\u000a							}\u000a						}\u000a						else\u000a						{\u000a							// Handle Del key pressed before the list.\u000a							walker.range.setEndAt( editable, CKEDITOR.POSITION_BEFORE_END );\u000a							next = walker.next();\u000a\u000a							if ( next && next.type == CKEDITOR.NODE_ELEMENT &&\u000a							     next.is( listNodeNames ) ) {\u000a								// The start <li>\u000a								next = next.getFirst( nonEmpty );\u000a\u000a								// Simply remove the current empty block, move cursor to the\u000a								// subsequent list.\u000a								if ( path.block &&\u000a								     range.checkStartOfBlock() &&\u000a								     range.checkEndOfBlock() ) {\u000a									path.block.remove();\u000a									range.moveToElementEditStart( next );\u000a									range.select();\u000a									evt.cancel();\u000a								}\u000a								// Preventing the default (merge behavior), but simply move\u000a								// the cursor one character forward if subsequent list item\u000a								// contains sub list.\u000a								else if ( getSubList( next )  ) {\u000a									range.moveToElementEditStart( next );\u000a									range.select();\u000a									evt.cancel();\u000a								}\u000a								// Merge the first list item with the current line.\u000a								else {\u000a									nextLine = range.clone();\u000a									nextLine.moveToElementEditStart( next );\u000a									joinNextLineToCursor( editor, cursor, nextLine );\u000a									evt.cancel();\u000a								}\u000a							}\u000a						}\u000a\u000a					}\u000a\u000a					// The backspace/del could potentially put cursor at a bad position,\u000a					// being it handled or not, check immediately the selection to have it fixed.\u000a					setTimeout( function() { editor.selectionChange( 1 ); } );\u000a				}\u000a			} );\u000a		}\u000a	} );\u000a} )();\u000a\u000a\ufeff/*\u000aCopyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000aFor licensing, see LICENSE.md or http://ckeditor.com/license\u000a*/\u000aCKEDITOR.plugins.setLang( 'list', 'en', {\u000a	bulletedlist: 'Insert/Remove Bulleted List',\u000a	numberedlist: 'Insert/Remove Numbered List'\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview The "toolbar" plugin. Renders the default toolbar interface in\u000a * the editor.\u000a */\u000a\u000a( function() {\u000a	var toolbox = function() {\u000a			this.toolbars = [];\u000a			this.focusCommandExecuted = false;\u000a		};\u000a\u000a	toolbox.prototype.focus = function() {\u000a		for ( var t = 0, toolbar; toolbar = this.toolbars[ t++ ]; ) {\u000a			for ( var i = 0, item; item = toolbar.items[ i++ ]; ) {\u000a				if ( item.focus ) {\u000a					item.focus();\u000a					return;\u000a				}\u000a			}\u000a		}\u000a	};\u000a\u000a	var commands = {\u000a		toolbarFocus: {\u000a			modes: { wysiwyg: 1, source: 1 },\u000a			readOnly: 1,\u000a\u000a			exec: function( editor ) {\u000a				if ( editor.toolbox ) {\u000a					editor.toolbox.focusCommandExecuted = true;\u000a\u000a					// Make the first button focus accessible for IE. (#3417)\u000a					// Adobe AIR instead need while of delay.\u000a					if ( CKEDITOR.env.ie || CKEDITOR.env.air )\u000a						setTimeout( function() {\u000a						editor.toolbox.focus();\u000a					}, 100 );\u000a					else\u000a						editor.toolbox.focus();\u000a				}\u000a			}\u000a		}\u000a	};\u000a\u000a	CKEDITOR.plugins.add( 'toolbar', {\u000a		requires: 'button',\u000a		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en,en-au,en-ca,en-gb,eo,es,et,eu,fa,fi,fo,fr,fr-ca,gl,gu,he,hi,hr,hu,id,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt,pt-br,ro,ru,si,sk,sl,sq,sr,sr-latn,sv,th,tr,tt,ug,uk,vi,zh,zh-cn', // %REMOVE_LINE_CORE%\u000a\u000a		init: function( editor ) {\u000a			var endFlag;\u000a\u000a			var itemKeystroke = function( item, keystroke ) {\u000a					var next, toolbar;\u000a					var rtl = editor.lang.dir == 'rtl',\u000a						toolbarGroupCycling = editor.config.toolbarGroupCycling,\u000a						// Picking right/left key codes.\u000a						rightKeyCode = rtl ? 37 : 39,\u000a						leftKeyCode = rtl ? 39 : 37;\u000a\u000a					toolbarGroupCycling = toolbarGroupCycling === undefined || toolbarGroupCycling;\u000a\u000a					switch ( keystroke ) {\u000a						case 9: // TAB\u000a						case CKEDITOR.SHIFT + 9: // SHIFT + TAB\u000a							// Cycle through the toolbars, starting from the one\u000a							// closest to the current item.\u000a							while ( !toolbar || !toolbar.items.length ) {\u000a								toolbar = keystroke == 9 ? ( ( toolbar ? toolbar.next : item.toolbar.next ) || editor.toolbox.toolbars[ 0 ] ) : ( ( toolbar ? toolbar.previous : item.toolbar.previous ) || editor.toolbox.toolbars[ editor.toolbox.toolbars.length - 1 ] );\u000a\u000a								// Look for the first item that accepts focus.\u000a								if ( toolbar.items.length ) {\u000a									item = toolbar.items[ endFlag ? ( toolbar.items.length - 1 ) : 0 ];\u000a									while ( item && !item.focus ) {\u000a										item = endFlag ? item.previous : item.next;\u000a\u000a										if ( !item )\u000a											toolbar = 0;\u000a									}\u000a								}\u000a							}\u000a\u000a							if ( item )\u000a								item.focus();\u000a\u000a							return false;\u000a\u000a						case rightKeyCode:\u000a							next = item;\u000a							do {\u000a								// Look for the next item in the toolbar.\u000a								next = next.next;\u000a\u000a								// If it's the last item, cycle to the first one.\u000a								if ( !next && toolbarGroupCycling ) next = item.toolbar.items[ 0 ];\u000a							}\u000a							while ( next && !next.focus );\u000a\u000a							// If available, just focus it, otherwise focus the\u000a							// first one.\u000a							if ( next )\u000a								next.focus();\u000a							else\u000a								// Send a TAB.\u000a								itemKeystroke( item, 9 );\u000a\u000a							return false;\u000a						case 40: // DOWN-ARROW\u000a							if ( item.button && item.button.hasArrow ) {\u000a								// Note: code is duplicated in plugins\u005crichcombo\u005cplugin.js in keyDownFn().\u000a								editor.once( 'panelShow', function( evt ) {\u000a									evt.data._.panel._.currentBlock.onKeyDown( 40 );\u000a								} );\u000a								item.execute();\u000a							} else {\u000a								// Send left arrow key.\u000a								itemKeystroke( item, keystroke == 40 ? rightKeyCode : leftKeyCode );\u000a							}\u000a							return false;\u000a						case leftKeyCode:\u000a						case 38: // UP-ARROW\u000a							next = item;\u000a							do {\u000a								// Look for the previous item in the toolbar.\u000a								next = next.previous;\u000a\u000a								// If it's the first item, cycle to the last one.\u000a								if ( !next && toolbarGroupCycling ) next = item.toolbar.items[ item.toolbar.items.length - 1 ];\u000a							}\u000a							while ( next && !next.focus );\u000a\u000a							// If available, just focus it, otherwise focus the\u000a							// last one.\u000a							if ( next )\u000a								next.focus();\u000a							else {\u000a								endFlag = 1;\u000a								// Send a SHIFT + TAB.\u000a								itemKeystroke( item, CKEDITOR.SHIFT + 9 );\u000a								endFlag = 0;\u000a							}\u000a\u000a							return false;\u000a\u000a						case 27: // ESC\u000a							editor.focus();\u000a							return false;\u000a\u000a						case 13: // ENTER\u000a						case 32: // SPACE\u000a							item.execute();\u000a							return false;\u000a					}\u000a					return true;\u000a				};\u000a\u000a			editor.on( 'uiSpace', function( event ) {\u000a				if ( event.data.space != editor.config.toolbarLocation )\u000a					return;\u000a\u000a				// Create toolbar only once.\u000a				event.removeListener();\u000a\u000a				editor.toolbox = new toolbox();\u000a\u000a				var labelId = CKEDITOR.tools.getNextId();\u000a\u000a				var output = [\u000a					'<span id="', labelId, '" class="cke_voice_label">', editor.lang.toolbar.toolbars, '</span>',\u000a					'<span id="' + editor.ui.spaceId( 'toolbox' ) + '" class="cke_toolbox" role="group" aria-labelledby="', labelId, '" onmousedown="return false;">' ];\u000a\u000a				var expanded = editor.config.toolbarStartupExpanded !== false,\u000a					groupStarted, pendingSeparator;\u000a\u000a				// If the toolbar collapser will be available, we'll have\u000a				// an additional container for all toolbars.\u000a				if ( editor.config.toolbarCanCollapse && editor.elementMode != CKEDITOR.ELEMENT_MODE_INLINE )\u000a					output.push( '<span class="cke_toolbox_main"' + ( expanded ? '>' : ' style="display:none">' ) );\u000a\u000a				var toolbars = editor.toolbox.toolbars,\u000a					toolbar = getToolbarConfig( editor );\u000a\u000a				for ( var r = 0; r < toolbar.length; r++ ) {\u000a					var toolbarId,\u000a						toolbarObj = 0,\u000a						toolbarName,\u000a						row = toolbar[ r ],\u000a						items;\u000a\u000a					// It's better to check if the row object is really\u000a					// available because it's a common mistake to leave\u000a					// an extra comma in the toolbar definition\u000a					// settings, which leads on the editor not loading\u000a					// at all in IE. (#3983)\u000a					if ( !row )\u000a						continue;\u000a\u000a					if ( groupStarted ) {\u000a						output.push( '</span>' );\u000a						groupStarted = 0;\u000a						pendingSeparator = 0;\u000a					}\u000a\u000a					if ( row === '/' ) {\u000a						output.push( '<span class="cke_toolbar_break"></span>' );\u000a						continue;\u000a					}\u000a\u000a					items = row.items || row;\u000a\u000a					// Create all items defined for this toolbar.\u000a					for ( var i = 0; i < items.length; i++ ) {\u000a						var item = items[ i ],\u000a							canGroup;\u000a\u000a						if ( item ) {\u000a							if ( item.type == CKEDITOR.UI_SEPARATOR ) {\u000a								// Do not add the separator immediately. Just save\u000a								// it be included if we already have something in\u000a								// the toolbar and if a new item is to be added (later).\u000a								pendingSeparator = groupStarted && item;\u000a								continue;\u000a							}\u000a\u000a							canGroup = item.canGroup !== false;\u000a\u000a							// Initialize the toolbar first, if needed.\u000a							if ( !toolbarObj ) {\u000a								// Create the basic toolbar object.\u000a								toolbarId = CKEDITOR.tools.getNextId();\u000a								toolbarObj = { id: toolbarId, items: [] };\u000a								toolbarName = row.name && ( editor.lang.toolbar.toolbarGroups[ row.name ] || row.name );\u000a\u000a								// Output the toolbar opener.\u000a								output.push( '<span id="', toolbarId, '" class="cke_toolbar"', ( toolbarName ? ' aria-labelledby="' + toolbarId + '_label"' : '' ), ' role="toolbar">' );\u000a\u000a								// If a toolbar name is available, send the voice label.\u000a								toolbarName && output.push( '<span id="', toolbarId, '_label" class="cke_voice_label">', toolbarName, '</span>' );\u000a\u000a								output.push( '<span class="cke_toolbar_start"></span>' );\u000a\u000a								// Add the toolbar to the "editor.toolbox.toolbars"\u000a								// array.\u000a								var index = toolbars.push( toolbarObj ) - 1;\u000a\u000a								// Create the next/previous reference.\u000a								if ( index > 0 ) {\u000a									toolbarObj.previous = toolbars[ index - 1 ];\u000a									toolbarObj.previous.next = toolbarObj;\u000a								}\u000a							}\u000a\u000a							if ( canGroup ) {\u000a								if ( !groupStarted ) {\u000a									output.push( '<span class="cke_toolgroup" role="presentation">' );\u000a									groupStarted = 1;\u000a								}\u000a							} else if ( groupStarted ) {\u000a								output.push( '</span>' );\u000a								groupStarted = 0;\u000a							}\u000a\u000a							function addItem( item ) {\u000a								var itemObj = item.render( editor, output );\u000a								index = toolbarObj.items.push( itemObj ) - 1;\u000a\u000a								if ( index > 0 ) {\u000a									itemObj.previous = toolbarObj.items[ index - 1 ];\u000a									itemObj.previous.next = itemObj;\u000a								}\u000a\u000a								itemObj.toolbar = toolbarObj;\u000a								itemObj.onkey = itemKeystroke;\u000a\u000a								// Fix for #3052:\u000a								// Prevent JAWS from focusing the toolbar after document load.\u000a								itemObj.onfocus = function() {\u000a									if ( !editor.toolbox.focusCommandExecuted )\u000a										editor.focus();\u000a								};\u000a							}\u000a\u000a							if ( pendingSeparator ) {\u000a								addItem( pendingSeparator );\u000a								pendingSeparator = 0;\u000a							}\u000a\u000a							addItem( item );\u000a						}\u000a					}\u000a\u000a					if ( groupStarted ) {\u000a						output.push( '</span>' );\u000a						groupStarted = 0;\u000a						pendingSeparator = 0;\u000a					}\u000a\u000a					if ( toolbarObj )\u000a						output.push( '<span class="cke_toolbar_end"></span></span>' );\u000a				}\u000a\u000a				if ( editor.config.toolbarCanCollapse )\u000a					output.push( '</span>' );\u000a\u000a				// Not toolbar collapser for inline mode.\u000a				if ( editor.config.toolbarCanCollapse && editor.elementMode != CKEDITOR.ELEMENT_MODE_INLINE ) {\u000a					var collapserFn = CKEDITOR.tools.addFunction( function() {\u000a						editor.execCommand( 'toolbarCollapse' );\u000a					} );\u000a\u000a					editor.on( 'destroy', function() {\u000a						CKEDITOR.tools.removeFunction( collapserFn );\u000a					} );\u000a\u000a					editor.addCommand( 'toolbarCollapse', {\u000a						readOnly: 1,\u000a						exec: function( editor ) {\u000a							var collapser = editor.ui.space( 'toolbar_collapser' ),\u000a								toolbox = collapser.getPrevious(),\u000a								contents = editor.ui.space( 'contents' ),\u000a								toolboxContainer = toolbox.getParent(),\u000a								contentHeight = parseInt( contents.$.style.height, 10 ),\u000a								previousHeight = toolboxContainer.$.offsetHeight,\u000a								minClass = 'cke_toolbox_collapser_min',\u000a								collapsed = collapser.hasClass( minClass );\u000a\u000a							if ( !collapsed ) {\u000a								toolbox.hide();\u000a								collapser.addClass( minClass );\u000a								collapser.setAttribute( 'title', editor.lang.toolbar.toolbarExpand );\u000a							} else {\u000a								toolbox.show();\u000a								collapser.removeClass( minClass );\u000a								collapser.setAttribute( 'title', editor.lang.toolbar.toolbarCollapse );\u000a							}\u000a\u000a							// Update collapser symbol.\u000a							collapser.getFirst().setText( collapsed ? '\u005cu25B2' : // BLACK UP-POINTING TRIANGLE\u000a							'\u005cu25C0' ); // BLACK LEFT-POINTING TRIANGLE\u000a\u000a							var dy = toolboxContainer.$.offsetHeight - previousHeight;\u000a							contents.setStyle( 'height', ( contentHeight - dy ) + 'px' );\u000a\u000a							editor.fire( 'resize' );\u000a						},\u000a\u000a						modes: { wysiwyg: 1, source: 1 }\u000a					} );\u000a\u000a					editor.setKeystroke( CKEDITOR.ALT + ( CKEDITOR.env.ie || CKEDITOR.env.webkit ? 189 : 109 ) /*-*/, 'toolbarCollapse' );\u000a\u000a					output.push( '<a title="' + ( expanded ? editor.lang.toolbar.toolbarCollapse : editor.lang.toolbar.toolbarExpand )\u000a						+ '" id="' + editor.ui.spaceId( 'toolbar_collapser' )\u000a						+ '" tabIndex="-1" class="cke_toolbox_collapser' );\u000a\u000a					if ( !expanded )\u000a						output.push( ' cke_toolbox_collapser_min' );\u000a\u000a					output.push( '" onclick="CKEDITOR.tools.callFunction(' + collapserFn + ')">', '<span class="cke_arrow">&#9650;</span>', // BLACK UP-POINTING TRIANGLE\u000a						'</a>' );\u000a				}\u000a\u000a				output.push( '</span>' );\u000a				event.data.html += output.join( '' );\u000a			} );\u000a\u000a			editor.on( 'destroy', function() {\u000a\u000a				if ( this.toolbox )\u000a				{\u000a					var toolbars,\u000a						index = 0,\u000a						i, items, instance;\u000a					toolbars = this.toolbox.toolbars;\u000a					for ( ; index < toolbars.length; index++ ) {\u000a						items = toolbars[ index ].items;\u000a						for ( i = 0; i < items.length; i++ ) {\u000a							instance = items[ i ];\u000a							if ( instance.clickFn )\u000a								CKEDITOR.tools.removeFunction( instance.clickFn );\u000a							if ( instance.keyDownFn )\u000a								CKEDITOR.tools.removeFunction( instance.keyDownFn );\u000a						}\u000a					}\u000a				}\u000a			} );\u000a\u000a			// Manage editor focus  when navigating the toolbar.\u000a			editor.on( 'uiReady', function() {\u000a				var toolbox = editor.ui.space( 'toolbox' );\u000a				toolbox && editor.focusManager.add( toolbox, 1 );\u000a			} );\u000a\u000a			editor.addCommand( 'toolbarFocus', commands.toolbarFocus );\u000a			editor.setKeystroke( CKEDITOR.ALT + 121 /*F10*/, 'toolbarFocus' );\u000a\u000a			editor.ui.add( '-', CKEDITOR.UI_SEPARATOR, {} );\u000a			editor.ui.addHandler( CKEDITOR.UI_SEPARATOR, {\u000a				create: function() {\u000a					return {\u000a						render: function( editor, output ) {\u000a							output.push( '<span class="cke_toolbar_separator" role="separator"></span>' );\u000a							return {};\u000a						}\u000a					};\u000a				}\u000a			} );\u000a		}\u000a	} );\u000a\u000a	function getToolbarConfig( editor ) {\u000a		var removeButtons = editor.config.removeButtons;\u000a\u000a		removeButtons = removeButtons && removeButtons.split( ',' );\u000a\u000a		function buildToolbarConfig() {\u000a\u000a			// Object containing all toolbar groups used by ui items.\u000a			var lookup = getItemDefinedGroups();\u000a\u000a			// Take the base for the new toolbar, which is basically a toolbar\u000a			// definition without items.\u000a			var toolbar = CKEDITOR.tools.clone( editor.config.toolbarGroups ) || getPrivateToolbarGroups( editor );\u000a\u000a			// Fill the toolbar groups with the available ui items.\u000a			for ( var i = 0; i < toolbar.length; i++ ) {\u000a				var toolbarGroup = toolbar[ i ];\u000a\u000a				// Skip toolbar break.\u000a				if ( toolbarGroup == '/' )\u000a					continue;\u000a				// Handle simply group name item.\u000a				else if ( typeof toolbarGroup == 'string' )\u000a					toolbarGroup = toolbar[ i ] = { name: toolbarGroup };\u000a\u000a				var items, subGroups = toolbarGroup.groups;\u000a\u000a				// Look for items that match sub groups.\u000a				if ( subGroups ) {\u000a					for ( var j = 0, sub; j < subGroups.length; j++ ) {\u000a						sub = subGroups[ j ];\u000a\u000a						// If any ui item is registered for this subgroup.\u000a						items = lookup[ sub ];\u000a						items && fillGroup( toolbarGroup, items );\u000a					}\u000a				}\u000a\u000a				// Add the main group items as well.\u000a				items = lookup[ toolbarGroup.name ];\u000a				items && fillGroup( toolbarGroup, items );\u000a			}\u000a\u000a			return toolbar;\u000a		}\u000a\u000a		// Returns an object containing all toolbar groups used by ui items.\u000a		function getItemDefinedGroups() {\u000a			var groups = {},\u000a				itemName, item, itemToolbar, group, order;\u000a\u000a			for ( itemName in editor.ui.items ) {\u000a				item = editor.ui.items[ itemName ];\u000a				itemToolbar = item.toolbar || 'others';\u000a				if ( itemToolbar ) {\u000a					// Break the toolbar property into its parts: "group_name[,order]".\u000a					itemToolbar = itemToolbar.split( ',' );\u000a					group = itemToolbar[ 0 ];\u000a					order = parseInt( itemToolbar[ 1 ] || -1, 10 );\u000a\u000a					// Initialize the group, if necessary.\u000a					groups[ group ] || ( groups[ group ] = [] );\u000a\u000a					// Push the data used to build the toolbar later.\u000a					groups[ group ].push( { name: itemName, order: order } );\u000a				}\u000a			}\u000a\u000a			// Put the items in the right order.\u000a			for ( group in groups ) {\u000a				groups[ group ] = groups[ group ].sort( function( a, b ) {\u000a					return a.order == b.order ? 0 :\u000a						b.order < 0 ? -1 :\u000a						a.order < 0 ? 1 :\u000a						a.order < b.order ? -1 :\u000a						1;\u000a				} );\u000a			}\u000a\u000a			return groups;\u000a		}\u000a\u000a		function fillGroup( toolbarGroup, uiItems ) {\u000a			if ( uiItems.length ) {\u000a				if ( toolbarGroup.items )\u000a					toolbarGroup.items.push( editor.ui.create( '-' ) );\u000a				else\u000a					toolbarGroup.items = [];\u000a\u000a				var item, name;\u000a				while ( ( item = uiItems.shift() ) ) {\u000a					name = typeof item == 'string' ? item : item.name;\u000a\u000a					// Ignore items that are configured to be removed.\u000a					if ( !removeButtons || CKEDITOR.tools.indexOf( removeButtons, name ) == -1 ) {\u000a						item = editor.ui.create( name );\u000a\u000a						if ( !item )\u000a							continue;\u000a\u000a						if ( !editor.addFeature( item ) )\u000a							continue;\u000a\u000a						toolbarGroup.items.push( item );\u000a					}\u000a				}\u000a			}\u000a		}\u000a\u000a		function populateToolbarConfig( config ) {\u000a			var toolbar = [],\u000a				i, group, newGroup;\u000a\u000a			for ( i = 0; i < config.length; ++i ) {\u000a				group = config[ i ];\u000a				newGroup = {};\u000a\u000a				if ( group == '/' )\u000a					toolbar.push( group );\u000a				else if ( CKEDITOR.tools.isArray( group ) ) {\u000a					fillGroup( newGroup, CKEDITOR.tools.clone( group ) );\u000a					toolbar.push( newGroup );\u000a				}\u000a				else if ( group.items ) {\u000a					fillGroup( newGroup, CKEDITOR.tools.clone( group.items ) );\u000a					newGroup.name = group.name;\u000a					toolbar.push( newGroup );\u000a				}\u000a			}\u000a\u000a			return toolbar;\u000a		}\u000a\u000a		var toolbar = editor.config.toolbar;\u000a\u000a		// If it is a string, return the relative "toolbar_name" config.\u000a		if ( typeof toolbar == 'string' )\u000a			toolbar = editor.config[ 'toolbar_' + toolbar ];\u000a\u000a		return ( editor.toolbar = toolbar ? populateToolbarConfig( toolbar ) : buildToolbarConfig() );\u000a	}\u000a\u000a	/**\u000a	 * Adds a toolbar group. See {@link CKEDITOR.config#toolbarGroups} for more details.\u000a	 *\u000a	 * **Note:** This method will not modify toolbar groups set explicitly by\u000a	 * {@link CKEDITOR.config#toolbarGroups}. It will only extend the default setting.\u000a	 *\u000a	 * @param {String} name Toolbar group name.\u000a	 * @param {Number/String} previous The name of the toolbar group after which this one\u000a	 * should be added or `0` if this group should be the first one.\u000a	 * @param {String} [subgroupOf] The name of the parent group.\u000a	 * @member CKEDITOR.ui\u000a	 */\u000a	CKEDITOR.ui.prototype.addToolbarGroup = function( name, previous, subgroupOf ) {\u000a		// The toolbarGroups from the privates is the one we gonna use for automatic toolbar creation.\u000a		var toolbarGroups = getPrivateToolbarGroups( this.editor ),\u000a			atStart = previous === 0,\u000a			newGroup = { name: name };\u000a\u000a		if ( subgroupOf ) {\u000a			// Transform the subgroupOf name in the real subgroup object.\u000a			subgroupOf = CKEDITOR.tools.search( toolbarGroups, function( group ) {\u000a				return group.name == subgroupOf;\u000a			} );\u000a\u000a			if ( subgroupOf ) {\u000a				!subgroupOf.groups && ( subgroupOf.groups = [] ) ;\u000a\u000a				if ( previous ) {\u000a					// Search the "previous" item and add the new one after it.\u000a					previous = CKEDITOR.tools.indexOf( subgroupOf.groups, previous );\u000a					if ( previous >= 0 ) {\u000a						subgroupOf.groups.splice( previous + 1, 0, name );\u000a						return;\u000a					}\u000a				}\u000a\u000a				// If no previous found.\u000a\u000a				if ( atStart )\u000a					subgroupOf.groups.splice( 0, 0, name );\u000a				else\u000a					subgroupOf.groups.push(  name );\u000a				return;\u000a			} else {\u000a				// Ignore "previous" if subgroupOf has not been found.\u000a				previous = null;\u000a			}\u000a		}\u000a\u000a		if ( previous ) {\u000a			// Transform the "previous" name into its index.\u000a			previous = CKEDITOR.tools.indexOf( toolbarGroups, function( group ) {\u000a				return group.name == previous;\u000a			} );\u000a		}\u000a\u000a		if ( atStart )\u000a			toolbarGroups.splice( 0, 0, name );\u000a		else if ( typeof previous == 'number' )\u000a			toolbarGroups.splice( previous + 1, 0, newGroup );\u000a		else\u000a			toolbarGroups.push( name );\u000a	};\u000a\u000a	function getPrivateToolbarGroups( editor ) {\u000a		return editor._.toolbarGroups || ( editor._.toolbarGroups = [\u000a			{ name: 'document',	   groups: [ 'mode', 'document', 'doctools' ] },\u000a			{ name: 'clipboard',   groups: [ 'clipboard', 'undo' ] },\u000a			{ name: 'editing',     groups: [ 'find', 'selection', 'spellchecker' ] },\u000a			{ name: 'forms' },\u000a			'/',\u000a			{ name: 'basicstyles', groups: [ 'basicstyles', 'cleanup' ] },\u000a			{ name: 'paragraph',   groups: [ 'list', 'indent', 'blocks', 'align', 'bidi' ] },\u000a			{ name: 'links' },\u000a			{ name: 'insert' },\u000a			'/',\u000a			{ name: 'styles' },\u000a			{ name: 'colors' },\u000a			{ name: 'tools' },\u000a			{ name: 'others' },\u000a			{ name: 'about' }\u000a		] );\u000a	}\u000a} )();\u000a\u000a/**\u000a * Separator UI element.\u000a *\u000a * @readonly\u000a * @property {String} [='separator']\u000a * @member CKEDITOR\u000a */\u000aCKEDITOR.UI_SEPARATOR = 'separator';\u000a\u000a/**\u000a * The part of the user interface where the toolbar will be rendered. For the default\u000a * editor implementation, the recommended options are `'top'` and `'bottom'`.\u000a *\u000a * Please note that this option is only applicable to [classic](#!/guide/dev_framed)\u000a * (`iframe`-based) editor. In case of [inline](#!/guide/dev_inline) editor the toolbar\u000a * position is set dynamically depending on the position of the editable element on the screen.\u000a *\u000a *		config.toolbarLocation = 'bottom';\u000a *\u000a * @cfg\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.toolbarLocation = 'top';\u000a\u000a/**\u000a * The toolbox (alias toolbar) definition. It is a toolbar name or an array of\u000a * toolbars (strips), each one being also an array, containing a list of UI items.\u000a *\u000a * If set to `null`, the toolbar will be generated automatically using all available buttons\u000a * and {@link #toolbarGroups} as a toolbar groups layout.\u000a *\u000a *		// Defines a toolbar with only one strip containing the "Source" button, a\u000a *		// separator, and the "Bold" and "Italic" buttons.\u000a *		config.toolbar = [\u000a *			[ 'Source', '-', 'Bold', 'Italic' ]\u000a *		];\u000a *\u000a *		// Similar to the example above, defines a "Basic" toolbar with only one strip containing three buttons.\u000a *		// Note that this setting is composed by "toolbar_" added to the toolbar name, which in this case is called "Basic".\u000a *		// This second part of the setting name can be anything. You must use this name in the CKEDITOR.config.toolbar setting\u000a *		// in order to instruct the editor which `toolbar_(name)` setting should be used.\u000a *		config.toolbar_Basic = [\u000a *			[ 'Source', '-', 'Bold', 'Italic' ]\u000a *		];\u000a *		// Load toolbar_Name where Name = Basic.\u000a *		config.toolbar = 'Basic';\u000a *\u000a * @cfg {Array/String} [toolbar=null]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * The toolbar groups definition.\u000a *\u000a * If the toolbar layout is not explicitly defined by the {@link #toolbar} setting, then\u000a * this setting is used to group all defined buttons (see {@link CKEDITOR.ui#addButton}).\u000a * Buttons are associated with toolbar groups by the `toolbar` property in their definition objects.\u000a *\u000a * New groups may be dynamically added during the editor and plugin initialization by\u000a * {@link CKEDITOR.ui#addToolbarGroup}. This is only possible if the default setting was used.\u000a *\u000a *		// Default setting.\u000a *		config.toolbarGroups = [\u000a *			{ name: 'document',	   groups: [ 'mode', 'document', 'doctools' ] },\u000a *			{ name: 'clipboard',   groups: [ 'clipboard', 'undo' ] },\u000a *			{ name: 'editing',     groups: [ 'find', 'selection', 'spellchecker' ] },\u000a *			{ name: 'forms' },\u000a *			'/',\u000a *			{ name: 'basicstyles', groups: [ 'basicstyles', 'cleanup' ] },\u000a *			{ name: 'paragraph',   groups: [ 'list', 'indent', 'blocks', 'align', 'bidi' ] },\u000a *			{ name: 'links' },\u000a *			{ name: 'insert' },\u000a *			'/',\u000a *			{ name: 'styles' },\u000a *			{ name: 'colors' },\u000a *			{ name: 'tools' },\u000a *			{ name: 'others' },\u000a *			{ name: 'about' }\u000a *		];\u000a *\u000a * @cfg {Array} [toolbarGroups=see example]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * Whether the toolbar can be collapsed by the user. If disabled, the Collapse Toolbar\u000a * button will not be displayed.\u000a *\u000a *		config.toolbarCanCollapse = true;\u000a *\u000a * @cfg {Boolean} [toolbarCanCollapse=false]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * Whether the toolbar must start expanded when the editor is loaded.\u000a *\u000a * Setting this option to `false` will affect the toolbar only when\u000a * {@link #toolbarCanCollapse} is set to `true`:\u000a *\u000a *		config.toolbarCanCollapse = true;\u000a *		config.toolbarStartupExpanded = false;\u000a *\u000a * @cfg {Boolean} [toolbarStartupExpanded=true]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * When enabled, causes the *Arrow* keys navigation to cycle within the current\u000a * toolbar group. Otherwise the *Arrow* keys will move through all items available in\u000a * the toolbar. The *Tab* key will still be used to quickly jump among the\u000a * toolbar groups.\u000a *\u000a *		config.toolbarGroupCycling = false;\u000a *\u000a * @since 3.6\u000a * @cfg {Boolean} [toolbarGroupCycling=true]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * List of toolbar button names that must not be rendered. This will also work\u000a * for non-button toolbar items, like the Font drop-down list.\u000a *\u000a *		config.removeButtons = 'Underline,JustifyCenter';\u000a *\u000a * This configuration option should not be overused. The recommended way is to use the\u000a * {@link CKEDITOR.config#removePlugins} setting to remove features from the editor\u000a * or even better, [create a custom editor build](http://ckeditor.com/builder) with\u000a * just the features that you will use.\u000a * In some cases though, a single plugin may define a set of toolbar buttons and\u000a * `removeButtons` may be useful when just a few of them are to be removed.\u000a *\u000a * @cfg {String} [removeButtons]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * The toolbar definition used by the editor. It is created from the\u000a * {@link CKEDITOR.config#toolbar} option if it is set or automatically\u000a * based on {@link CKEDITOR.config#toolbarGroups}.\u000a *\u000a * @readonly\u000a * @property {Object} toolbar\u000a * @member CKEDITOR.editor\u000a */\u000a\u000a\ufeff/*\u000aCopyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000aFor licensing, see LICENSE.md or http://ckeditor.com/license\u000a*/\u000aCKEDITOR.plugins.setLang( 'toolbar', 'en', {\u000a	toolbarCollapse: 'Collapse Toolbar',\u000a	toolbarExpand: 'Expand Toolbar',\u000a	toolbarGroups: {\u000a		document: 'Document',\u000a		clipboard: 'Clipboard/Undo',\u000a		editing: 'Editing',\u000a		forms: 'Forms',\u000a		basicstyles: 'Basic Styles',\u000a		paragraph: 'Paragraph',\u000a		links: 'Links',\u000a		insert: 'Insert',\u000a		styles: 'Styles',\u000a		colors: 'Colors',\u000a		tools: 'Tools'\u000a	},\u000a	toolbars: 'Editor toolbars'\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Undo/Redo system for saving a shapshot for document modification\u000a *		and other recordable changes.\u000a */\u000a\u000a'use strict';\u000a\u000a( function() {\u000a	var keystrokes = [ CKEDITOR.CTRL + 90 /*Z*/, CKEDITOR.CTRL + 89 /*Y*/, CKEDITOR.CTRL + CKEDITOR.SHIFT + 90 /*Z*/ ],\u000a		backspaceOrDelete = { 8: 1, 46: 1 };\u000a\u000a	CKEDITOR.plugins.add( 'undo', {\u000a		// jscs:disable maximumLineLength\u000a		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en,en-au,en-ca,en-gb,eo,es,et,eu,fa,fi,fo,fr,fr-ca,gl,gu,he,hi,hr,hu,id,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt,pt-br,ro,ru,si,sk,sl,sq,sr,sr-latn,sv,th,tr,tt,ug,uk,vi,zh,zh-cn', // %REMOVE_LINE_CORE%\u000a		// jscs:enable maximumLineLength\u000a		// icons: 'redo,redo-rtl,undo,undo-rtl', // %REMOVE_LINE_CORE%\u000a		// hidpi: true, // %REMOVE_LINE_CORE%\u000a		init: function( editor ) {\u000a			var undoManager = editor.undoManager = new UndoManager( editor ),\u000a				editingHandler = undoManager.editingHandler = new NativeEditingHandler( undoManager );\u000a\u000a			var undoCommand = editor.addCommand( 'undo', {\u000a				exec: function() {\u000a					if ( undoManager.undo() ) {\u000a						editor.selectionChange();\u000a						this.fire( 'afterUndo' );\u000a					}\u000a				},\u000a				startDisabled: true,\u000a				canUndo: false\u000a			} );\u000a\u000a			var redoCommand = editor.addCommand( 'redo', {\u000a				exec: function() {\u000a					if ( undoManager.redo() ) {\u000a						editor.selectionChange();\u000a						this.fire( 'afterRedo' );\u000a					}\u000a				},\u000a				startDisabled: true,\u000a				canUndo: false\u000a			} );\u000a\u000a			editor.setKeystroke( [\u000a				[ keystrokes[ 0 ], 'undo' ],\u000a				[ keystrokes[ 1 ], 'redo' ],\u000a				[ keystrokes[ 2 ], 'redo' ]\u000a			] );\u000a\u000a			undoManager.onChange = function() {\u000a				undoCommand.setState( undoManager.undoable() ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED );\u000a				redoCommand.setState( undoManager.redoable() ? CKEDITOR.TRISTATE_OFF : CKEDITOR.TRISTATE_DISABLED );\u000a			};\u000a\u000a			function recordCommand( event ) {\u000a				// If the command hasn't been marked to not support undo.\u000a				if ( undoManager.enabled && event.data.command.canUndo !== false )\u000a					undoManager.save();\u000a			}\u000a\u000a			// We'll save snapshots before and after executing a command.\u000a			editor.on( 'beforeCommandExec', recordCommand );\u000a			editor.on( 'afterCommandExec', recordCommand );\u000a\u000a			// Save snapshots before doing custom changes.\u000a			editor.on( 'saveSnapshot', function( evt ) {\u000a				undoManager.save( evt.data && evt.data.contentOnly );\u000a			} );\u000a\u000a			// Event manager listeners should be attached on contentDom.\u000a			editor.on( 'contentDom', editingHandler.attachListeners, editingHandler );\u000a\u000a			editor.on( 'instanceReady', function() {\u000a				// Saves initial snapshot.\u000a				editor.fire( 'saveSnapshot' );\u000a			} );\u000a\u000a			// Always save an undo snapshot - the previous mode might have\u000a			// changed editor contents.\u000a			editor.on( 'beforeModeUnload', function() {\u000a				editor.mode == 'wysiwyg' && undoManager.save( true );\u000a			} );\u000a\u000a			function toggleUndoManager() {\u000a				undoManager.enabled = editor.readOnly ? false : editor.mode == 'wysiwyg';\u000a				undoManager.onChange();\u000a			}\u000a\u000a			// Make the undo manager available only in wysiwyg mode.\u000a			editor.on( 'mode', toggleUndoManager );\u000a\u000a			// Disable undo manager when in read-only mode.\u000a			editor.on( 'readOnly', toggleUndoManager );\u000a\u000a			if ( editor.ui.addButton ) {\u000a				editor.ui.addButton( 'Undo', {\u000a					icon: 'undo fa fa-undo undo',\u000a					label: editor.lang.undo.undo,\u000a					command: 'undo',\u000a					toolbar: 'undo,10'\u000a				} );\u000a\u000a				editor.ui.addButton( 'Redo', {\u000a					icon: 'repeat fa fa-repeat repeat',\u000a					label: editor.lang.undo.redo,\u000a					command: 'redo',\u000a					toolbar: 'undo,20'\u000a				} );\u000a			}\u000a\u000a			/**\u000a			 * Resets the undo stack.\u000a			 *\u000a			 * @member CKEDITOR.editor\u000a			 */\u000a			editor.resetUndo = function() {\u000a				// Reset the undo stack.\u000a				undoManager.reset();\u000a\u000a				// Create the first image.\u000a				editor.fire( 'saveSnapshot' );\u000a			};\u000a\u000a			/**\u000a			 * Amends the top of the undo stack (last undo image) with the current DOM changes.\u000a			 *\u000a			 *		function() {\u000a			 *			editor.fire( 'saveSnapshot' );\u000a			 *			editor.document.body.append(...);\u000a			 *			// Makes new changes following the last undo snapshot a part of it.\u000a			 *			editor.fire( 'updateSnapshot' );\u000a			 *			..\u000a			 *		}\u000a			 *\u000a			 * @event updateSnapshot\u000a			 * @member CKEDITOR.editor\u000a			 * @param {CKEDITOR.editor} editor This editor instance.\u000a			 */\u000a			editor.on( 'updateSnapshot', function() {\u000a				if ( undoManager.currentImage )\u000a					undoManager.update();\u000a			} );\u000a\u000a			/**\u000a			 * Locks the undo manager to prevent any save/update operations.\u000a			 *\u000a			 * It is convenient to lock the undo manager before performing DOM operations\u000a			 * that should not be recored (e.g. auto paragraphing).\u000a			 *\u000a			 * See {@link CKEDITOR.plugins.undo.UndoManager#lock} for more details.\u000a			 *\u000a			 * **Note:** In order to unlock the undo manager, {@link #unlockSnapshot} has to be fired\u000a			 * the same number of times that `lockSnapshot` has been fired.\u000a			 *\u000a			 * @since 4.0\u000a			 * @event lockSnapshot\u000a			 * @member CKEDITOR.editor\u000a			 * @param {CKEDITOR.editor} editor This editor instance.\u000a			 * @param data\u000a			 * @param {Boolean} [data.dontUpdate] When set to `true`, the last snapshot will not be updated\u000a			 * with the current content and selection. Read more in the {@link CKEDITOR.plugins.undo.UndoManager#lock} method.\u000a			 * @param {Boolean} [data.forceUpdate] When set to `true`, the last snapshot will always be updated\u000a			 * with the current content and selection. Read more in the {@link CKEDITOR.plugins.undo.UndoManager#lock} method.\u000a			 */\u000a			editor.on( 'lockSnapshot', function( evt ) {\u000a				var data = evt.data;\u000a				undoManager.lock( data && data.dontUpdate, data && data.forceUpdate );\u000a			} );\u000a\u000a			/**\u000a			 * Unlocks the undo manager and updates the latest snapshot.\u000a			 *\u000a			 * @since 4.0\u000a			 * @event unlockSnapshot\u000a			 * @member CKEDITOR.editor\u000a			 * @param {CKEDITOR.editor} editor This editor instance.\u000a			 */\u000a			editor.on( 'unlockSnapshot', undoManager.unlock, undoManager );\u000a		}\u000a	} );\u000a\u000a	CKEDITOR.plugins.undo = {};\u000a\u000a	/**\u000a	 * Main logic for the Redo/Undo feature.\u000a	 *\u000a	 * @private\u000a	 * @class CKEDITOR.plugins.undo.UndoManager\u000a	 * @constructor Creates an UndoManager class instance.\u000a	 * @param {CKEDITOR.editor} editor\u000a	 */\u000a	var UndoManager = CKEDITOR.plugins.undo.UndoManager = function( editor ) {\u000a		/**\u000a		 * An array storing the number of key presses, count in a row. Use {@link #keyGroups} members as index.\u000a		 *\u000a		 * **Note:** The keystroke count will be reset after reaching the limit of characters per snapshot.\u000a		 *\u000a		 * @since 4.4.4\u000a		 */\u000a		this.strokesRecorded = [ 0, 0 ];\u000a\u000a		/**\u000a		 * When the `locked` property is not `null`, the undo manager is locked, so\u000a		 * operations like `save` or `update` are forbidden.\u000a		 *\u000a		 * The manager can be locked and unlocked by the {@link #lock} and {@link #unlock}\u000a		 * methods, respectively.\u000a		 *\u000a		 * @readonly\u000a		 * @property {Object} [locked=null]\u000a		 */\u000a		this.locked = null;\u000a\u000a		/**\u000a		 * Contains the previously processed key group, based on {@link #keyGroups}.\u000a		 * `-1` means an unknown group.\u000a		 *\u000a		 * @since 4.4.4\u000a		 * @readonly\u000a		 * @property {Number} [previousKeyGroup=-1]\u000a		 */\u000a		this.previousKeyGroup = -1;\u000a\u000a		/**\u000a		 * The maximum number of snapshots in the stack. Configurable via {@link CKEDITOR.config#undoStackSize}.\u000a		 *\u000a		 * @readonly\u000a		 * @property {Number} [limit]\u000a		 */\u000a		this.limit = editor.config.undoStackSize || 20;\u000a\u000a		/**\u000a		 * The maximum number of characters typed/deleted in one undo step.\u000a		 *\u000a		 * @since 4.4.5\u000a		 * @readonly\u000a		 */\u000a		this.strokesLimit = 25;\u000a\u000a		this.editor = editor;\u000a\u000a		// Reset the undo stack.\u000a		this.reset();\u000a	};\u000a\u000a	UndoManager.prototype = {\u000a		/**\u000a		 * Handles keystroke support for the undo manager. It is called on `keyup` event for\u000a		 * keystrokes that can change the editor content.\u000a		 *\u000a		 * @param {Number} keyCode The key code.\u000a		 * @param {Boolean} [strokesPerSnapshotExceeded] When set to `true`, the method will\u000a		 * behave as if the strokes limit was exceeded regardless of the {@link #strokesRecorded} value.\u000a		 */\u000a		type: function( keyCode, strokesPerSnapshotExceeded ) {\u000a			var keyGroup = UndoManager.getKeyGroup( keyCode ),\u000a				// Count of keystrokes in current a row.\u000a				// Note if strokesPerSnapshotExceeded will be exceeded, it'll be restarted.\u000a				strokesRecorded = this.strokesRecorded[ keyGroup ] + 1;\u000a\u000a			strokesPerSnapshotExceeded =\u000a				( strokesPerSnapshotExceeded || strokesRecorded >= this.strokesLimit );\u000a\u000a			if ( !this.typing )\u000a				onTypingStart( this );\u000a\u000a			if ( strokesPerSnapshotExceeded ) {\u000a				// Reset the count of strokes, so it'll be later assigned to this.strokesRecorded.\u000a				strokesRecorded = 0;\u000a\u000a				this.editor.fire( 'saveSnapshot' );\u000a			} else {\u000a				// Fire change event.\u000a				this.editor.fire( 'change' );\u000a			}\u000a\u000a			// Store recorded strokes count.\u000a			this.strokesRecorded[ keyGroup ] = strokesRecorded;\u000a			// This prop will tell in next itaration what kind of group was processed previously.\u000a			this.previousKeyGroup = keyGroup;\u000a		},\u000a\u000a		/**\u000a		 * Whether the new `keyCode` belongs to a different group than the previous one ({@link #previousKeyGroup}).\u000a		 *\u000a		 * @since 4.4.5\u000a		 * @param {Number} keyCode\u000a		 * @returns {Boolean}\u000a		 */\u000a		keyGroupChanged: function( keyCode ) {\u000a			return UndoManager.getKeyGroup( keyCode ) != this.previousKeyGroup;\u000a		},\u000a\u000a		/**\u000a		 * Resets the undo stack.\u000a		 */\u000a		reset: function() {\u000a			// Stack for all the undo and redo snapshots, they're always created/removed\u000a			// in consistency.\u000a			this.snapshots = [];\u000a\u000a			// Current snapshot history index.\u000a			this.index = -1;\u000a\u000a			this.currentImage = null;\u000a\u000a			this.hasUndo = false;\u000a			this.hasRedo = false;\u000a			this.locked = null;\u000a\u000a			this.resetType();\u000a		},\u000a\u000a		/**\u000a		 * Resets all typing variables.\u000a		 *\u000a		 * @see #type\u000a		 */\u000a		resetType: function() {\u000a			this.strokesRecorded = [ 0, 0 ];\u000a			this.typing = false;\u000a			this.previousKeyGroup = -1;\u000a		},\u000a\u000a		/**\u000a		 * Refreshes the state of the {@link CKEDITOR.plugins.undo.UndoManager undo manager}\u000a		 * as well as the state of the `undo` and `redo` commands.\u000a		 */\u000a		refreshState: function() {\u000a			// These lines can be handled within onChange() too.\u000a			this.hasUndo = !!this.getNextImage( true );\u000a			this.hasRedo = !!this.getNextImage( false );\u000a			// Reset typing\u000a			this.resetType();\u000a			this.onChange();\u000a		},\u000a\u000a		/**\u000a		 * Saves a snapshot of the document image for later retrieval.\u000a		 *\u000a		 * @param {Boolean} onContentOnly If set to `true`, the snapshot will be saved only if the content has changed.\u000a		 * @param {CKEDITOR.plugins.undo.Image} image An optional image to save. If skipped, current editor will be used.\u000a		 * @param {Boolean} autoFireChange If set to `false`, will not trigger the {@link CKEDITOR.editor#change} event to editor.\u000a		 */\u000a		save: function( onContentOnly, image, autoFireChange ) {\u000a			var editor = this.editor;\u000a			// Do not change snapshots stack when locked, editor is not ready,\u000a			// editable is not ready or when editor is in mode difference than 'wysiwyg'.\u000a			if ( this.locked || editor.status != 'ready' || editor.mode != 'wysiwyg' )\u000a				return false;\u000a\u000a			var editable = editor.editable();\u000a			if ( !editable || editable.status != 'ready' )\u000a				return false;\u000a\u000a			var snapshots = this.snapshots;\u000a\u000a			// Get a content image.\u000a			if ( !image )\u000a				image = new Image( editor );\u000a\u000a			// Do nothing if it was not possible to retrieve an image.\u000a			if ( image.contents === false )\u000a				return false;\u000a\u000a			// Check if this is a duplicate. In such case, do nothing.\u000a			if ( this.currentImage ) {\u000a				if ( image.equalsContent( this.currentImage ) ) {\u000a					if ( onContentOnly )\u000a						return false;\u000a\u000a					if ( image.equalsSelection( this.currentImage ) )\u000a						return false;\u000a				} else if ( autoFireChange !== false ) {\u000a					editor.fire( 'change' );\u000a				}\u000a			}\u000a\u000a			// Drop future snapshots.\u000a			snapshots.splice( this.index + 1, snapshots.length - this.index - 1 );\u000a\u000a			// If we have reached the limit, remove the oldest one.\u000a			if ( snapshots.length == this.limit )\u000a				snapshots.shift();\u000a\u000a			// Add the new image, updating the current index.\u000a			this.index = snapshots.push( image ) - 1;\u000a\u000a			this.currentImage = image;\u000a\u000a			if ( autoFireChange !== false )\u000a				this.refreshState();\u000a			return true;\u000a		},\u000a\u000a		/**\u000a		 * Sets editor content/selection to the one stored in `image`.\u000a		 *\u000a		 * @param {CKEDITOR.plugins.undo.Image} image\u000a		 */\u000a		restoreImage: function( image ) {\u000a			// Bring editor focused to restore selection.\u000a			var editor = this.editor,\u000a				sel;\u000a\u000a			if ( image.bookmarks ) {\u000a				editor.focus();\u000a				// Retrieve the selection beforehand. (#8324)\u000a				sel = editor.getSelection();\u000a			}\u000a\u000a			// Start transaction - do not allow any mutations to the\u000a			// snapshots stack done when selecting bookmarks (much probably\u000a			// by selectionChange listener).\u000a			this.locked = { level: 999 };\u000a\u000a			this.editor.loadSnapshot( image.contents );\u000a\u000a			if ( image.bookmarks )\u000a				sel.selectBookmarks( image.bookmarks );\u000a			else if ( CKEDITOR.env.ie ) {\u000a				// IE BUG: If I don't set the selection to *somewhere* after setting\u000a				// document contents, then IE would create an empty paragraph at the bottom\u000a				// the next time the document is modified.\u000a				var $range = this.editor.document.getBody().$.createTextRange();\u000a				$range.collapse( true );\u000a				$range.select();\u000a			}\u000a\u000a			this.locked = null;\u000a\u000a			this.index = image.index;\u000a			this.currentImage = this.snapshots[ this.index ];\u000a\u000a			// Update current image with the actual editor\u000a			// content, since actualy content may differ from\u000a			// the original snapshot due to dom change. (#4622)\u000a			this.update();\u000a			this.refreshState();\u000a\u000a			editor.fire( 'change' );\u000a		},\u000a\u000a		/**\u000a		 * Gets the closest available image.\u000a		 *\u000a		 * @param {Boolean} isUndo If `true`, it will return the previous image.\u000a		 * @returns {CKEDITOR.plugins.undo.Image} Next image or `null`.\u000a		 */\u000a		getNextImage: function( isUndo ) {\u000a			var snapshots = this.snapshots,\u000a				currentImage = this.currentImage,\u000a				image, i;\u000a\u000a			if ( currentImage ) {\u000a				if ( isUndo ) {\u000a					for ( i = this.index - 1; i >= 0; i-- ) {\u000a						image = snapshots[ i ];\u000a						if ( !currentImage.equalsContent( image ) ) {\u000a							image.index = i;\u000a							return image;\u000a						}\u000a					}\u000a				} else {\u000a					for ( i = this.index + 1; i < snapshots.length; i++ ) {\u000a						image = snapshots[ i ];\u000a						if ( !currentImage.equalsContent( image ) ) {\u000a							image.index = i;\u000a							return image;\u000a						}\u000a					}\u000a				}\u000a			}\u000a\u000a			return null;\u000a		},\u000a\u000a		/**\u000a		 * Checks the current redo state.\u000a		 *\u000a		 * @returns {Boolean} Whether the document has a previous state to retrieve.\u000a		 */\u000a		redoable: function() {\u000a			return this.enabled && this.hasRedo;\u000a		},\u000a\u000a		/**\u000a		 * Checks the current undo state.\u000a		 *\u000a		 * @returns {Boolean} Whether the document has a future state to restore.\u000a		 */\u000a		undoable: function() {\u000a			return this.enabled && this.hasUndo;\u000a		},\u000a\u000a		/**\u000a		 * Performs an undo operation on current index.\u000a		 */\u000a		undo: function() {\u000a			if ( this.undoable() ) {\u000a				this.save( true );\u000a\u000a				var image = this.getNextImage( true );\u000a				if ( image )\u000a					return this.restoreImage( image ), true;\u000a			}\u000a\u000a			return false;\u000a		},\u000a\u000a		/**\u000a		 * Performs a redo operation on current index.\u000a		 */\u000a		redo: function() {\u000a			if ( this.redoable() ) {\u000a				// Try to save. If no changes have been made, the redo stack\u000a				// will not change, so it will still be redoable.\u000a				this.save( true );\u000a\u000a				// If instead we had changes, we can't redo anymore.\u000a				if ( this.redoable() ) {\u000a					var image = this.getNextImage( false );\u000a					if ( image )\u000a						return this.restoreImage( image ), true;\u000a				}\u000a			}\u000a\u000a			return false;\u000a		},\u000a\u000a		/**\u000a		 * Updates the last snapshot of the undo stack with the current editor content.\u000a		 *\u000a		 * @param {CKEDITOR.plugins.undo.Image} [newImage] The image which will replace the current one.\u000a		 * If it is not set, it defaults to the image taken from the editor.\u000a		 */\u000a		update: function( newImage ) {\u000a			// Do not change snapshots stack is locked.\u000a			if ( this.locked )\u000a				return;\u000a\u000a			if ( !newImage )\u000a				newImage = new Image( this.editor );\u000a\u000a			var i = this.index,\u000a				snapshots = this.snapshots;\u000a\u000a			// Find all previous snapshots made for the same content (which differ\u000a			// only by selection) and replace all of them with the current image.\u000a			while ( i > 0 && this.currentImage.equalsContent( snapshots[ i - 1 ] ) )\u000a				i -= 1;\u000a\u000a			snapshots.splice( i, this.index - i + 1, newImage );\u000a			this.index = i;\u000a			this.currentImage = newImage;\u000a		},\u000a\u000a		/**\u000a		 * Amends the last snapshot and changes its selection (only in case when content\u000a		 * is equal between these two).\u000a		 *\u000a		 * @since 4.4.4\u000a		 * @param {CKEDITOR.plugins.undo.Image} newSnapshot New snapshot with new selection.\u000a		 * @returns {Boolean} Returns `true` if selection was amended.\u000a		 */\u000a		updateSelection: function( newSnapshot ) {\u000a			if ( !this.snapshots.length )\u000a				return false;\u000a\u000a			var snapshots = this.snapshots,\u000a				lastImage = snapshots[ snapshots.length - 1 ];\u000a\u000a			if ( lastImage.equalsContent( newSnapshot ) ) {\u000a				if ( !lastImage.equalsSelection( newSnapshot ) ) {\u000a					snapshots[ snapshots.length - 1 ] = newSnapshot;\u000a					this.currentImage = newSnapshot;\u000a					return true;\u000a				}\u000a			}\u000a\u000a			return false;\u000a		},\u000a\u000a		/**\u000a		 * Locks the snapshot stack to prevent any save/update operations and when necessary,\u000a		 * updates the tip of the snapshot stack with the DOM changes introduced during the\u000a		 * locked period, after the {@link #unlock} method is called.\u000a		 *\u000a		 * It is mainly used to ensure any DOM operations that should not be recorded\u000a		 * (e.g. auto paragraphing) are not added to the stack.\u000a		 *\u000a		 * **Note:** For every `lock` call you must call {@link #unlock} once to unlock the undo manager.\u000a		 *\u000a		 * @since 4.0\u000a		 * @param {Boolean} [dontUpdate] When set to `true`, the last snapshot will not be updated\u000a		 * with current content and selection. By default, if undo manager was up to date when the lock started,\u000a		 * the last snapshot will be updated to the current state when unlocking. This means that all changes\u000a		 * done during the lock will be merged into the previous snapshot or the next one. Use this option to gain\u000a		 * more control over this behavior. For example, it is possible to group changes done during the lock into\u000a		 * a separate snapshot.\u000a		 * @param {Boolean} [forceUpdate] When set to `true`, the last snapshot will always be updated with the\u000a		 * current content and selection regardless of the current state of the undo manager.\u000a		 * When not set, the last snapshot will be updated only if the undo manager was up to date when locking.\u000a		 * Additionally, this option makes it possible to lock the snapshot when the editor is not in the `wysiwyg` mode,\u000a		 * because when it is passed, the snapshots will not need to be compared.\u000a		 */\u000a		lock: function( dontUpdate, forceUpdate ) {\u000a			if ( !this.locked ) {\u000a				if ( dontUpdate )\u000a					this.locked = { level: 1 };\u000a				else {\u000a					var update = null;\u000a\u000a					if ( forceUpdate )\u000a						update = true;\u000a					else {\u000a						// Make a contents image. Don't include bookmarks, because:\u000a						// * we don't compare them,\u000a						// * there's a chance that DOM has been changed since\u000a						// locked (e.g. fake) selection was made, so createBookmark2 could fail.\u000a						// http://dev.ckeditor.com/ticket/11027#comment:3\u000a						var imageBefore = new Image( this.editor, true );\u000a\u000a						// If current editor content matches the tip of snapshot stack,\u000a						// the stack tip must be updated by unlock, to include any changes made\u000a						// during this period.\u000a						if ( this.currentImage && this.currentImage.equalsContent( imageBefore ) )\u000a							update = imageBefore;\u000a					}\u000a\u000a					this.locked = { update: update, level: 1 };\u000a				}\u000a\u000a			// Increase the level of lock.\u000a			} else {\u000a				this.locked.level++;\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Unlocks the snapshot stack and checks to amend the last snapshot.\u000a		 *\u000a		 * See {@link #lock} for more details.\u000a		 *\u000a		 * @since 4.0\u000a		 */\u000a		unlock: function() {\u000a			if ( this.locked ) {\u000a				// Decrease level of lock and check if equals 0, what means that undoM is completely unlocked.\u000a				if ( !--this.locked.level ) {\u000a					var update = this.locked.update;\u000a\u000a					this.locked = null;\u000a\u000a					// forceUpdate was passed to lock().\u000a					if ( update === true )\u000a						this.update();\u000a					// update is instance of Image.\u000a					else if ( update ) {\u000a						var newImage = new Image( this.editor, true );\u000a\u000a						if ( !update.equalsContent( newImage ) )\u000a							this.update();\u000a					}\u000a				}\u000a			}\u000a		}\u000a	};\u000a\u000a	/**\u000a	 * Codes for navigation keys like *Arrows*, *Page Up/Down*, etc.\u000a	 * Used by the {@link #isNavigationKey} method.\u000a	 *\u000a	 * @since 4.4.5\u000a	 * @readonly\u000a	 * @static\u000a	 */\u000a	UndoManager.navigationKeyCodes = {\u000a		37: 1, 38: 1, 39: 1, 40: 1, // Arrows.\u000a		36: 1, 35: 1, // Home, End.\u000a		33: 1, 34: 1 // PgUp, PgDn.\u000a	};\u000a\u000a	/**\u000a	 * Key groups identifier mapping. Used for accessing members in\u000a	 * {@link #strokesRecorded}.\u000a	 *\u000a	 * * `FUNCTIONAL` &ndash; identifier for the *Backspace* / *Delete* key.\u000a	 * * `PRINTABLE` &ndash; identifier for printable keys.\u000a	 *\u000a	 * Example usage:\u000a	 *\u000a	 *		undoManager.strokesRecorded[ undoManager.keyGroups.FUNCTIONAL ];\u000a	 *\u000a	 * @since 4.4.5\u000a	 * @readonly\u000a	 * @static\u000a	 */\u000a	UndoManager.keyGroups = {\u000a		PRINTABLE: 0,\u000a		FUNCTIONAL: 1\u000a	};\u000a\u000a	/**\u000a	 * Checks whether a key is one of navigation keys (*Arrows*, *Page Up/Down*, etc.).\u000a	 * See also the {@link #navigationKeyCodes} property.\u000a	 *\u000a	 * @since 4.4.5\u000a	 * @static\u000a	 * @param {Number} keyCode\u000a	 * @returns {Boolean}\u000a	 */\u000a	UndoManager.isNavigationKey = function( keyCode ) {\u000a		return !!UndoManager.navigationKeyCodes[ keyCode ];\u000a	};\u000a\u000a	/**\u000a	 * Returns the group to which the passed `keyCode` belongs.\u000a	 *\u000a	 * @since 4.4.5\u000a	 * @static\u000a	 * @param {Number} keyCode\u000a	 * @returns {Number}\u000a	 */\u000a	UndoManager.getKeyGroup = function( keyCode ) {\u000a		var keyGroups = UndoManager.keyGroups;\u000a\u000a		return backspaceOrDelete[ keyCode ] ? keyGroups.FUNCTIONAL : keyGroups.PRINTABLE;\u000a	};\u000a\u000a	/**\u000a	 * @since 4.4.5\u000a	 * @static\u000a	 * @param {Number} keyGroup\u000a	 * @returns {Number}\u000a	 */\u000a	UndoManager.getOppositeKeyGroup = function( keyGroup ) {\u000a		var keyGroups = UndoManager.keyGroups;\u000a		return ( keyGroup == keyGroups.FUNCTIONAL ? keyGroups.PRINTABLE : keyGroups.FUNCTIONAL );\u000a	};\u000a\u000a	/**\u000a	 * Whether we need to use a workaround for functional (*Backspace*, *Delete*) keys not firing\u000a	 * the `keypress` event in Internet Explorer in this environment and for the specified `keyCode`.\u000a	 *\u000a	 * @since 4.4.5\u000a	 * @static\u000a	 * @param {Number} keyCode\u000a	 * @returns {Boolean}\u000a	 */\u000a	UndoManager.ieFunctionalKeysBug = function( keyCode ) {\u000a		return CKEDITOR.env.ie && UndoManager.getKeyGroup( keyCode ) == UndoManager.keyGroups.FUNCTIONAL;\u000a	};\u000a\u000a	// Helper method called when undoManager.typing val was changed to true.\u000a	function onTypingStart( undoManager ) {\u000a		// It's safe to now indicate typing state.\u000a		undoManager.typing = true;\u000a\u000a		// Manually mark snapshot as available.\u000a		undoManager.hasUndo = true;\u000a		undoManager.hasRedo = false;\u000a\u000a		undoManager.onChange();\u000a	}\u000a\u000a	/**\u000a	 * Contains a snapshot of the editor content and selection at a given point in time.\u000a	 *\u000a	 * @private\u000a	 * @class CKEDITOR.plugins.undo.Image\u000a	 * @constructor Creates an Image class instance.\u000a	 * @param {CKEDITOR.editor} editor The editor instance on which the image is created.\u000a	 * @param {Boolean} [contentsOnly] If set to `true`, the image will only contain content without the selection.\u000a	 */\u000a	var Image = CKEDITOR.plugins.undo.Image = function( editor, contentsOnly ) {\u000a			this.editor = editor;\u000a\u000a			editor.fire( 'beforeUndoImage' );\u000a\u000a			var contents = editor.getSnapshot();\u000a\u000a			// In IE, we need to remove the expando attributes.\u000a			if ( CKEDITOR.env.ie && contents )\u000a				contents = contents.replace( /\u005cs+data-cke-expando=".*?"/g, '' );\u000a\u000a			this.contents = contents;\u000a\u000a			if ( !contentsOnly ) {\u000a				var selection = contents && editor.getSelection();\u000a				this.bookmarks = selection && selection.createBookmarks2( true );\u000a			}\u000a\u000a			editor.fire( 'afterUndoImage' );\u000a		};\u000a\u000a	// Attributes that browser may changing them when setting via innerHTML.\u000a	var protectedAttrs = /\u005cb(?:href|src|name)="[^"]*?"/gi;\u000a\u000a	Image.prototype = {\u000a		/**\u000a		 * @param {CKEDITOR.plugins.undo.Image} otherImage Image to compare to.\u000a		 * @returns {Boolean} Returns `true` if content in `otherImage` is the same.\u000a		 */\u000a		equalsContent: function( otherImage ) {\u000a			var thisContents = this.contents,\u000a				otherContents = otherImage.contents;\u000a\u000a			// For IE7 and IE QM: Comparing only the protected attribute values but not the original ones.(#4522)\u000a			if ( CKEDITOR.env.ie && ( CKEDITOR.env.ie7Compat || CKEDITOR.env.quirks ) ) {\u000a				thisContents = thisContents.replace( protectedAttrs, '' );\u000a				otherContents = otherContents.replace( protectedAttrs, '' );\u000a			}\u000a\u000a			if ( thisContents != otherContents )\u000a				return false;\u000a\u000a			return true;\u000a		},\u000a\u000a		/**\u000a		 * @param {CKEDITOR.plugins.undo.Image} otherImage Image to compare to.\u000a		 * @returns {Boolean} Returns `true` if selection in `otherImage` is the same.\u000a		 */\u000a		equalsSelection: function( otherImage ) {\u000a			var bookmarksA = this.bookmarks,\u000a				bookmarksB = otherImage.bookmarks;\u000a\u000a			if ( bookmarksA || bookmarksB ) {\u000a				if ( !bookmarksA || !bookmarksB || bookmarksA.length != bookmarksB.length )\u000a					return false;\u000a\u000a				for ( var i = 0; i < bookmarksA.length; i++ ) {\u000a					var bookmarkA = bookmarksA[ i ],\u000a						bookmarkB = bookmarksB[ i ];\u000a\u000a					if ( bookmarkA.startOffset != bookmarkB.startOffset || bookmarkA.endOffset != bookmarkB.endOffset ||\u000a						!CKEDITOR.tools.arrayCompare( bookmarkA.start, bookmarkB.start ) ||\u000a						!CKEDITOR.tools.arrayCompare( bookmarkA.end, bookmarkB.end ) ) {\u000a						return false;\u000a					}\u000a				}\u000a			}\u000a\u000a			return true;\u000a		}\u000a\u000a		/**\u000a		 * Editor content.\u000a		 *\u000a		 * @readonly\u000a		 * @property {String} contents\u000a		 */\u000a\u000a		/**\u000a		 * Bookmarks representing the selection in an image.\u000a		 *\u000a		 * @readonly\u000a		 * @property {Object[]} bookmarks Array of bookmark2 objects, see {@link CKEDITOR.dom.range#createBookmark2} for definition.\u000a		 */\u000a	};\u000a\u000a	/**\u000a	 * A class encapsulating all native event listeners which have to be used in\u000a	 * order to handle undo manager integration for native editing actions (excluding drag and drop and paste support\u000a	 * handled by the Clipboard plugin).\u000a	 *\u000a	 * @since 4.4.4\u000a	 * @private\u000a	 * @class CKEDITOR.plugins.undo.NativeEditingHandler\u000a	 * @member CKEDITOR.plugins.undo Undo manager owning the handler.\u000a	 * @constructor\u000a	 * @param {CKEDITOR.plugins.undo.UndoManager} undoManager\u000a	 */\u000a	var NativeEditingHandler = CKEDITOR.plugins.undo.NativeEditingHandler = function( undoManager ) {\u000a		// We'll use keyboard + input events to determine if snapshot should be created.\u000a		// Since `input` event is fired before `keyup`. We can tell in `keyup` event if input occured.\u000a		// That will tell us if any printable data was inserted.\u000a		// On `input` event we'll increase input fired counter for proper key code.\u000a		// Eventually it might be canceled by paste/drop using `ignoreInputEvent` flag.\u000a		// Order of events can be found in http://www.w3.org/TR/DOM-Level-3-Events/\u000a\u000a		/**\u000a		 * An undo manager instance owning the editing handler.\u000a		 *\u000a		 * @property {CKEDITOR.plugins.undo.UndoManager} undoManager\u000a		 */\u000a		this.undoManager = undoManager;\u000a\u000a		/**\u000a		 * See {@link #ignoreInputEventListener}.\u000a		 *\u000a		 * @since 4.4.5\u000a		 * @private\u000a		 */\u000a		this.ignoreInputEvent = false;\u000a\u000a		/**\u000a		 * A stack of pressed keys.\u000a		 *\u000a		 * @since 4.4.5\u000a		 * @property {CKEDITOR.plugins.undo.KeyEventsStack} keyEventsStack\u000a		 */\u000a		this.keyEventsStack = new KeyEventsStack();\u000a\u000a		/**\u000a		 * An image of the editor during the `keydown` event (therefore without DOM modification).\u000a		 *\u000a		 * @property {CKEDITOR.plugins.undo.Image} lastKeydownImage\u000a		 */\u000a		this.lastKeydownImage = null;\u000a	};\u000a\u000a	NativeEditingHandler.prototype = {\u000a		/**\u000a		 * The `keydown` event listener.\u000a		 *\u000a		 * @param {CKEDITOR.dom.event} evt\u000a		 */\u000a		onKeydown: function( evt ) {\u000a			// Block undo/redo keystrokes when at the bottom/top of the undo stack (#11126 and #11677).\u000a			if ( CKEDITOR.tools.indexOf( keystrokes, evt.data.getKeystroke() ) > -1 ) {\u000a				evt.data.preventDefault();\u000a				return;\u000a			}\u000a\u000a			// Cleaning tab functional keys.\u000a			this.keyEventsStack.cleanUp( evt );\u000a\u000a			var keyCode = evt.data.getKey(),\u000a				undoManager = this.undoManager;\u000a\u000a			// Gets last record for provided keyCode. If not found will create one.\u000a			var last = this.keyEventsStack.getLast( keyCode );\u000a			if ( !last ) {\u000a				this.keyEventsStack.push( keyCode );\u000a			}\u000a\u000a			// We need to store an image which will be used in case of key group\u000a			// change.\u000a			this.lastKeydownImage = new Image( undoManager.editor );\u000a\u000a			if ( UndoManager.isNavigationKey( keyCode ) || this.undoManager.keyGroupChanged( keyCode ) ) {\u000a				if ( undoManager.strokesRecorded[ 0 ] || undoManager.strokesRecorded[ 1 ] ) {\u000a					// We already have image, so we'd like to reuse it.\u000a					undoManager.save( false, this.lastKeydownImage );\u000a					undoManager.resetType();\u000a				}\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * The `input` event listener.\u000a		 */\u000a		onInput: function() {\u000a			// Input event is ignored if paste/drop event were fired before.\u000a			if ( this.ignoreInputEvent ) {\u000a				// Reset flag - ignore only once.\u000a				this.ignoreInputEvent = false;\u000a				return;\u000a			}\u000a\u000a			var lastInput = this.keyEventsStack.getLast();\u000a			// Nothing in key events stack, but input event called. Interesting...\u000a			// That's because on Android order of events is buggy and also keyCode is set to 0.\u000a			if ( !lastInput ) {\u000a				lastInput = this.keyEventsStack.push( 0 );\u000a			}\u000a\u000a			// Increment inputs counter for provided key code.\u000a			this.keyEventsStack.increment( lastInput.keyCode );\u000a\u000a			// Exceeded limit.\u000a			if ( this.keyEventsStack.getTotalInputs() >= this.undoManager.strokesLimit ) {\u000a				this.undoManager.type( lastInput.keyCode, true );\u000a				this.keyEventsStack.resetInputs();\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * The `keyup` event listener.\u000a		 *\u000a		 * @param {CKEDITOR.dom.event} evt\u000a		 */\u000a		onKeyup: function( evt ) {\u000a			var undoManager = this.undoManager,\u000a				keyCode = evt.data.getKey(),\u000a				totalInputs = this.keyEventsStack.getTotalInputs();\u000a\u000a			// Remove record from stack for provided key code.\u000a			this.keyEventsStack.remove( keyCode );\u000a\u000a			// Second part of the workaround for IEs functional keys bug. We need to check whether something has really\u000a			// changed because we blindly mocked the keypress event.\u000a			// Also we need to be aware that lastKeydownImage might not be available (#12327).\u000a			if ( UndoManager.ieFunctionalKeysBug( keyCode ) && this.lastKeydownImage &&\u000a				this.lastKeydownImage.equalsContent( new Image( undoManager.editor, true ) ) ) {\u000a				return;\u000a			}\u000a\u000a			if ( totalInputs > 0 ) {\u000a				undoManager.type( keyCode );\u000a			} else if ( UndoManager.isNavigationKey( keyCode ) ) {\u000a				// Note content snapshot has been checked in keydown.\u000a				this.onNavigationKey( true );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Method called for navigation change. At first it will check if current content does not differ\u000a		 * from the last saved snapshot.\u000a		 *\u000a		 * * If the content is different, the method creates a standard, extra snapshot.\u000a		 * * If the content is not different, the method will compare the selection, and will\u000a		 * amend the last snapshot selection if it changed.\u000a		 *\u000a		 * @param {Boolean} skipContentCompare If set to `true`, it will not compare content, and only do a selection check.\u000a		 */\u000a		onNavigationKey: function( skipContentCompare ) {\u000a			var undoManager = this.undoManager;\u000a\u000a			// We attempt to save content snapshot, if content didn't change, we'll\u000a			// only amend selection.\u000a			if ( skipContentCompare || !undoManager.save( true, null, false ) )\u000a				undoManager.updateSelection( new Image( undoManager.editor ) );\u000a\u000a			undoManager.resetType();\u000a		},\u000a\u000a		/**\u000a		 * Makes the next `input` event to be ignored.\u000a		 */\u000a		ignoreInputEventListener: function() {\u000a			this.ignoreInputEvent = true;\u000a		},\u000a\u000a		/**\u000a		 * Attaches editable listeners required to provide the undo functionality.\u000a		 */\u000a		attachListeners: function() {\u000a			var editor = this.undoManager.editor,\u000a				editable = editor.editable(),\u000a				that = this;\u000a\u000a			// We'll create a snapshot here (before DOM modification), because we'll\u000a			// need unmodified content when we got keygroup toggled in keyup.\u000a			editable.attachListener( editable, 'keydown', function( evt ) {\u000a				that.onKeydown( evt );\u000a\u000a				// On IE keypress isn't fired for functional (backspace/delete) keys.\u000a				// Let's pretend that something's changed.\u000a				if ( UndoManager.ieFunctionalKeysBug( evt.data.getKey() ) ) {\u000a					that.onInput();\u000a				}\u000a			}, null, null, 999 );\u000a\u000a			// Only IE can't use input event, because it's not fired in contenteditable.\u000a			editable.attachListener( editable, ( CKEDITOR.env.ie ? 'keypress' : 'input' ), that.onInput, that, null, 999 );\u000a\u000a			// Keyup executes main snapshot logic.\u000a			editable.attachListener( editable, 'keyup', that.onKeyup, that, null, 999 );\u000a\u000a			// On paste and drop we need to ignore input event.\u000a			// It would result with calling undoManager.type() on any following key.\u000a			editable.attachListener( editable, 'paste', that.ignoreInputEventListener, that, null, 999 );\u000a			editable.attachListener( editable, 'drop', that.ignoreInputEventListener, that, null, 999 );\u000a\u000a			// Click should create a snapshot if needed, but shouldn't cause change event.\u000a			// Don't pass onNavigationKey directly as a listener because it accepts one argument which\u000a			// will conflict with evt passed to listener.\u000a			// #12324 comment:4\u000a			editable.attachListener( editable.isInline() ? editable : editor.document.getDocumentElement(), 'click', function() {\u000a				that.onNavigationKey();\u000a			}, null, null, 999 );\u000a\u000a			// When pressing `Tab` key while editable is focused, `keyup` event is not fired.\u000a			// Which means that record for `tab` key stays in key events stack.\u000a			// We assume that when editor is blurred `tab` key is already up.\u000a			editable.attachListener( this.undoManager.editor, 'blur', function() {\u000a				that.keyEventsStack.remove( 9 /*Tab*/ );\u000a			}, null, null, 999 );\u000a		}\u000a	};\u000a\u000a	/**\u000a	 * This class represents a stack of pressed keys and stores information\u000a	 * about how many `input` events each key press has caused.\u000a	 *\u000a	 * @since 4.4.5\u000a	 * @private\u000a	 * @class CKEDITOR.plugins.undo.KeyEventsStack\u000a	 * @constructor\u000a	 */\u000a	var KeyEventsStack = CKEDITOR.plugins.undo.KeyEventsStack = function() {\u000a		/**\u000a		 * @readonly\u000a		 */\u000a		this.stack = [];\u000a	};\u000a\u000a	KeyEventsStack.prototype = {\u000a		/**\u000a		 * Pushes a literal object with two keys: `keyCode` and `inputs` (whose initial value is set to `0`) to stack.\u000a		 * It is intended to be called on the `keydown` event.\u000a		 *\u000a		 * @param {Number} keyCode\u000a		 */\u000a		push: function( keyCode ) {\u000a			var length = this.stack.push( { keyCode: keyCode, inputs: 0 } );\u000a			return this.stack[ length - 1 ];\u000a		},\u000a\u000a		/**\u000a		 * Returns the index of the last registered `keyCode` in the stack.\u000a		 * If no `keyCode` is provided, then the function will return the index of the last item.\u000a		 * If an item is not found, it will return `-1`.\u000a		 *\u000a		 * @param {Number} [keyCode]\u000a		 * @returns {Number}\u000a		 */\u000a		getLastIndex: function( keyCode ) {\u000a			if ( typeof keyCode != 'number' ) {\u000a				return this.stack.length - 1; // Last index or -1.\u000a			} else {\u000a				var i = this.stack.length;\u000a				while ( i-- ) {\u000a					if ( this.stack[ i ].keyCode == keyCode ) {\u000a						return i;\u000a					}\u000a				}\u000a				return -1;\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Returns the last key recorded in the stack. If `keyCode` is provided, then it will return\u000a		 * the  last record for this `keyCode`.\u000a		 *\u000a		 * @param {Number} [keyCode]\u000a		 * @returns {Object} Last matching record or `null`.\u000a		 */\u000a		getLast: function( keyCode ) {\u000a			var index = this.getLastIndex( keyCode );\u000a			if ( index != -1 ) {\u000a				return this.stack[ index ];\u000a			} else {\u000a				return null;\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Increments registered input events for stack record for a given `keyCode`.\u000a		 *\u000a		 * @param {Number} keyCode\u000a		 */\u000a		increment: function( keyCode ) {\u000a			var found = this.getLast( keyCode );\u000a			if ( !found ) { // %REMOVE_LINE%\u000a				throw new Error( 'Trying to increment, but could not found by keyCode: ' + keyCode + '.' ); // %REMOVE_LINE%\u000a			} // %REMOVE_LINE%\u000a\u000a			found.inputs++;\u000a		},\u000a\u000a		/**\u000a		 * Removes the last record from the stack for the provided `keyCode`.\u000a		 *\u000a		 * @param {Number} keyCode\u000a		 */\u000a		remove: function( keyCode ) {\u000a			var index = this.getLastIndex( keyCode );\u000a\u000a			if ( index != -1 ) {\u000a				this.stack.splice( index, 1 );\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Resets the `inputs` value to `0` for a given `keyCode` or in entire stack if a\u000a		 * `keyCode` is not specified.\u000a		 *\u000a		 * @param {Number} [keyCode]\u000a		 */\u000a		resetInputs: function( keyCode ) {\u000a			if ( typeof keyCode == 'number' ) {\u000a				var last = this.getLast( keyCode );\u000a\u000a				if ( !last ) { // %REMOVE_LINE%\u000a					throw new Error( 'Trying to reset inputs count, but could not found by keyCode: ' + keyCode + '.' ); // %REMOVE_LINE%\u000a				} // %REMOVE_LINE%\u000a\u000a				last.inputs = 0;\u000a			} else {\u000a				var i = this.stack.length;\u000a				while ( i-- ) {\u000a					this.stack[ i ].inputs = 0;\u000a				}\u000a			}\u000a		},\u000a\u000a		/**\u000a		 * Sums up inputs number for each key code and returns it.\u000a		 *\u000a		 * @returns {Number}\u000a		 */\u000a		getTotalInputs: function() {\u000a			var i = this.stack.length,\u000a				total = 0;\u000a\u000a			while ( i-- ) {\u000a				total += this.stack[ i ].inputs;\u000a			}\u000a			return total;\u000a		},\u000a\u000a		/**\u000a		 * Cleans the stack based on a provided `keydown` event object. The rationale behind this method\u000a		 * is that some keystrokes cause the `keydown` event to be fired in the editor, but not the `keyup` event.\u000a		 * For instance, *Alt+Tab* will fire `keydown`, but since the editor is blurred by it, then there is\u000a		 * no `keyup`, so the keystroke is not removed from the stack.\u000a		 *\u000a		 * @param {CKEDITOR.dom.event} event\u000a		 */\u000a		cleanUp: function( event ) {\u000a			var nativeEvent = event.data.$;\u000a\u000a			if ( !( nativeEvent.ctrlKey || nativeEvent.metaKey ) ) {\u000a				this.remove( 17 );\u000a			}\u000a			if ( !nativeEvent.shiftKey ) {\u000a				this.remove( 16 );\u000a			}\u000a			if ( !nativeEvent.altKey ) {\u000a				this.remove( 18 );\u000a			}\u000a		}\u000a	};\u000a} )();\u000a\u000a/**\u000a * The number of undo steps to be saved. The higher value is set, the more\u000a * memory is used for it.\u000a *\u000a *		config.undoStackSize = 50;\u000a *\u000a * @cfg {Number} [undoStackSize=20]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a/**\u000a * Fired when the editor is about to save an undo snapshot. This event can be\u000a * fired by plugins and customizations to make the editor save undo snapshots.\u000a *\u000a * @event saveSnapshot\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\u000a/**\u000a * Fired before an undo image is to be created. An *undo image* represents the\u000a * editor state at some point. It is saved into the undo store, so the editor is\u000a * able to recover the editor state on undo and redo operations.\u000a *\u000a * @since 3.5.3\u000a * @event beforeUndoImage\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @see CKEDITOR.editor#afterUndoImage\u000a */\u000a\u000a/**\u000a * Fired after an undo image is created. An *undo image* represents the\u000a * editor state at some point. It is saved into the undo store, so the editor is\u000a * able to recover the editor state on undo and redo operations.\u000a *\u000a * @since 3.5.3\u000a * @event afterUndoImage\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a * @see CKEDITOR.editor#beforeUndoImage\u000a */\u000a\u000a/**\u000a * Fired when the content of the editor is changed.\u000a *\u000a * Due to performance reasons, it is not verified if the content really changed.\u000a * The editor instead watches several editing actions that usually result in\u000a * changes. This event may thus in some cases be fired when no changes happen\u000a * or may even get fired twice.\u000a *\u000a * If it is important not to get the `change` event fired too often, you should compare the\u000a * previous and the current editor content inside the event listener. It is\u000a * not recommended to do that on every `change` event.\u000a *\u000a * Please note that the `change` event is only fired in the {@link #property-mode wysiwyg mode}.\u000a * In order to implement similar functionality in the source mode, you can listen for example to the {@link #key}\u000a * event or the native [`input`](https://developer.mozilla.org/en-US/docs/Web/Reference/Events/input)\u000a * event (not supported by Internet Explorer 8).\u000a *\u000a *		editor.on( 'mode', function() {\u000a *			if ( this.mode == 'source' ) {\u000a *				var editable = editor.editable();\u000a *				editable.attachListener( editable, 'input', function() {\u000a *					// Handle changes made in the source mode.\u000a *				} );\u000a *			}\u000a *		} );\u000a *\u000a * @since 4.2\u000a * @event change\u000a * @member CKEDITOR.editor\u000a * @param {CKEDITOR.editor} editor This editor instance.\u000a */\u000a\ufeff/*\u000aCopyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000aFor licensing, see LICENSE.md or http://ckeditor.com/license\u000a*/\u000aCKEDITOR.plugins.setLang( 'undo', 'en', {\u000a	redo: 'Redo',\u000a	undo: 'Undo'\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a/**\u000a * @fileOverview Justify commands.\u000a */\u000a\u000a( function() {\u000a	function getAlignment( element, useComputedState ) {\u000a		useComputedState = useComputedState === undefined || useComputedState;\u000a\u000a		var align;\u000a		if ( useComputedState )\u000a			align = element.getComputedStyle( 'text-align' );\u000a		else {\u000a			while ( !element.hasAttribute || !( element.hasAttribute( 'align' ) || element.getStyle( 'text-align' ) ) ) {\u000a				var parent = element.getParent();\u000a				if ( !parent )\u000a					break;\u000a				element = parent;\u000a			}\u000a			align = element.getStyle( 'text-align' ) || element.getAttribute( 'align' ) || '';\u000a		}\u000a\u000a		// Sometimes computed values doesn't tell.\u000a		align && ( align = align.replace( /(?:-(?:moz|webkit)-)?(?:start|auto)/i, '' ) );\u000a\u000a		!align && useComputedState && ( align = element.getComputedStyle( 'direction' ) == 'rtl' ? 'right' : 'left' );\u000a\u000a		return align;\u000a	}\u000a\u000a	function justifyCommand( editor, name, value ) {\u000a		this.editor = editor;\u000a		this.name = name;\u000a		this.value = value;\u000a		this.context = 'p';\u000a\u000a		var classes = editor.config.justifyClasses,\u000a			blockTag = editor.config.enterMode == CKEDITOR.ENTER_P ? 'p' : 'div';\u000a\u000a		if ( classes ) {\u000a			switch ( value ) {\u000a				case 'left':\u000a					this.cssClassName = classes[ 0 ];\u000a					break;\u000a				case 'center':\u000a					this.cssClassName = classes[ 1 ];\u000a					break;\u000a				case 'right':\u000a					this.cssClassName = classes[ 2 ];\u000a					break;\u000a				case 'justify':\u000a					this.cssClassName = classes[ 3 ];\u000a					break;\u000a			}\u000a\u000a			this.cssClassRegex = new RegExp( '(?:^|\u005c\u005cs+)(?:' + classes.join( '|' ) + ')(?=$|\u005c\u005cs)' );\u000a			this.requiredContent = blockTag + '(' + this.cssClassName + ')';\u000a		}\u000a		else\u000a			this.requiredContent = blockTag + '{text-align}';\u000a\u000a		this.allowedContent = {\u000a			'caption div h1 h2 h3 h4 h5 h6 p pre td th li': {\u000a				// Do not add elements, but only text-align style if element is validated by other rule.\u000a				propertiesOnly: true,\u000a				styles: this.cssClassName ? null : 'text-align',\u000a				classes: this.cssClassName || null\u000a			}\u000a		};\u000a\u000a		// In enter mode BR we need to allow here for div, because when non other\u000a		// feature allows div justify is the only plugin that uses it.\u000a		if ( editor.config.enterMode == CKEDITOR.ENTER_BR )\u000a			this.allowedContent.div = true;\u000a	}\u000a\u000a	function onDirChanged( e ) {\u000a		var editor = e.editor;\u000a\u000a		var range = editor.createRange();\u000a		range.setStartBefore( e.data.node );\u000a		range.setEndAfter( e.data.node );\u000a\u000a		var walker = new CKEDITOR.dom.walker( range ),\u000a			node;\u000a\u000a		while ( ( node = walker.next() ) ) {\u000a			if ( node.type == CKEDITOR.NODE_ELEMENT ) {\u000a				// A child with the defined dir is to be ignored.\u000a				if ( !node.equals( e.data.node ) && node.getDirection() ) {\u000a					range.setStartAfter( node );\u000a					walker = new CKEDITOR.dom.walker( range );\u000a					continue;\u000a				}\u000a\u000a				// Switch the alignment.\u000a				var classes = editor.config.justifyClasses;\u000a				if ( classes ) {\u000a					// The left align class.\u000a					if ( node.hasClass( classes[ 0 ] ) ) {\u000a						node.removeClass( classes[ 0 ] );\u000a						node.addClass( classes[ 2 ] );\u000a					}\u000a					// The right align class.\u000a					else if ( node.hasClass( classes[ 2 ] ) ) {\u000a						node.removeClass( classes[ 2 ] );\u000a						node.addClass( classes[ 0 ] );\u000a					}\u000a				}\u000a\u000a				// Always switch CSS margins.\u000a				var style = 'text-align';\u000a				var align = node.getStyle( style );\u000a\u000a				if ( align == 'left' )\u000a					node.setStyle( style, 'right' );\u000a				else if ( align == 'right' )\u000a					node.setStyle( style, 'left' );\u000a			}\u000a		}\u000a	}\u000a\u000a	justifyCommand.prototype = {\u000a		exec: function( editor ) {\u000a			var selection = editor.getSelection(),\u000a				enterMode = editor.config.enterMode;\u000a\u000a			if ( !selection )\u000a				return;\u000a\u000a			var bookmarks = selection.createBookmarks(),\u000a				ranges = selection.getRanges();\u000a\u000a			var cssClassName = this.cssClassName,\u000a				iterator, block;\u000a\u000a			var useComputedState = editor.config.useComputedState;\u000a			useComputedState = useComputedState === undefined || useComputedState;\u000a\u000a			for ( var i = ranges.length - 1; i >= 0; i-- ) {\u000a				iterator = ranges[ i ].createIterator();\u000a				iterator.enlargeBr = enterMode != CKEDITOR.ENTER_BR;\u000a\u000a				while ( ( block = iterator.getNextParagraph( enterMode == CKEDITOR.ENTER_P ? 'p' : 'div' ) ) ) {\u000a					if ( block.isReadOnly() )\u000a						continue;\u000a\u000a					block.removeAttribute( 'align' );\u000a					block.removeStyle( 'text-align' );\u000a\u000a					// Remove any of the alignment classes from the className.\u000a					var className = cssClassName && ( block.$.className = CKEDITOR.tools.ltrim( block.$.className.replace( this.cssClassRegex, '' ) ) );\u000a\u000a					var apply = ( this.state == CKEDITOR.TRISTATE_OFF ) && ( !useComputedState || ( getAlignment( block, true ) != this.value ) );\u000a\u000a					if ( cssClassName ) {\u000a						// Append the desired class name.\u000a						if ( apply )\u000a							block.addClass( cssClassName );\u000a						else if ( !className )\u000a							block.removeAttribute( 'class' );\u000a					} else if ( apply )\u000a						block.setStyle( 'text-align', this.value );\u000a				}\u000a\u000a			}\u000a\u000a			editor.focus();\u000a			editor.forceNextSelectionCheck();\u000a			selection.selectBookmarks( bookmarks );\u000a		},\u000a\u000a		refresh: function( editor, path ) {\u000a			var firstBlock = path.block || path.blockLimit;\u000a\u000a			this.setState( firstBlock.getName() != 'body' && getAlignment( firstBlock, this.editor.config.useComputedState ) == this.value ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF );\u000a		}\u000a	};\u000a\u000a	CKEDITOR.plugins.add( 'justify', {\u000a		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en,en-au,en-ca,en-gb,eo,es,et,eu,fa,fi,fo,fr,fr-ca,gl,gu,he,hi,hr,hu,id,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt,pt-br,ro,ru,si,sk,sl,sq,sr,sr-latn,sv,th,tr,tt,ug,uk,vi,zh,zh-cn', // %REMOVE_LINE_CORE%\u000a		// icons: 'justifyblock,justifycenter,justifyleft,justifyright', // %REMOVE_LINE_CORE%\u000a		// hidpi: true, // %REMOVE_LINE_CORE%\u000a		init: function( editor ) {\u000a			if ( editor.blockless )\u000a				return;\u000a\u000a			var left = new justifyCommand( editor, 'justifyleft', 'left' ),\u000a				center = new justifyCommand( editor, 'justifycenter', 'center' ),\u000a				right = new justifyCommand( editor, 'justifyright', 'right' ),\u000a				justify = new justifyCommand( editor, 'justifyblock', 'justify' );\u000a\u000a			editor.addCommand( 'justifyleft', left );\u000a			editor.addCommand( 'justifycenter', center );\u000a			editor.addCommand( 'justifyright', right );\u000a			editor.addCommand( 'justifyblock', justify );\u000a\u000a			if ( editor.ui.addButton ) {\u000a				editor.ui.addButton( 'JustifyLeft', {\u000a					icon: 'justifyleft fa fa-align-left justifyleft',\u000a					label: editor.lang.justify.left,\u000a					command: 'justifyleft',\u000a					toolbar: 'align,10'\u000a				} );\u000a				editor.ui.addButton( 'JustifyCenter', {\u000a					icon: 'justifycenter fa fa-align-center justifycenter',\u000a					label: editor.lang.justify.center,\u000a					command: 'justifycenter',\u000a					toolbar: 'align,20'\u000a				} );\u000a				editor.ui.addButton( 'JustifyRight', {\u000a					icon: 'justifyright fa fa-align-right justifyright',\u000a					label: editor.lang.justify.right,\u000a					command: 'justifyright',\u000a					toolbar: 'align,30'\u000a				} );\u000a				editor.ui.addButton( 'JustifyBlock', {\u000a					icon: 'justifyblock fa fa-align-justify justifyblock',\u000a					label: editor.lang.justify.block,\u000a					command: 'justifyblock',\u000a					toolbar: 'align,40'\u000a				} );\u000a			}\u000a\u000a			editor.on( 'dirChanged', onDirChanged );\u000a		}\u000a	} );\u000a} )();\u000a\u000a/**\u000a * List of classes to use for aligning the contents. If it's `null`, no classes will be used\u000a * and instead the corresponding CSS values will be used.\u000a *\u000a * The array should contain 4 members, in the following order: left, center, right, justify.\u000a *\u000a *		// Use the classes 'AlignLeft', 'AlignCenter', 'AlignRight', 'AlignJustify'\u000a *		config.justifyClasses = [ 'AlignLeft', 'AlignCenter', 'AlignRight', 'AlignJustify' ];\u000a *\u000a * @cfg {Array} [justifyClasses=null]\u000a * @member CKEDITOR.config\u000a */\u000a\u000a\ufeff/*\u000aCopyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000aFor licensing, see LICENSE.md or http://ckeditor.com/license\u000a*/\u000aCKEDITOR.plugins.setLang( 'justify', 'en', {\u000a	block: 'Justify',\u000a	center: 'Center',\u000a	left: 'Align Left',\u000a	right: 'Align Right'\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000a( function() {\u000a	function noBlockLeft( bqBlock ) {\u000a		for ( var i = 0, length = bqBlock.getChildCount(), child; i < length && ( child = bqBlock.getChild( i ) ); i++ ) {\u000a			if ( child.type == CKEDITOR.NODE_ELEMENT && child.isBlockBoundary() )\u000a				return false;\u000a		}\u000a		return true;\u000a	}\u000a\u000a	var commandObject = {\u000a		exec: function( editor ) {\u000a			var state = editor.getCommand( 'blockquote' ).state,\u000a				selection = editor.getSelection(),\u000a				range = selection && selection.getRanges()[ 0 ];\u000a\u000a			if ( !range )\u000a				return;\u000a\u000a			var bookmarks = selection.createBookmarks();\u000a\u000a			// Kludge for #1592: if the bookmark nodes are in the beginning of\u000a			// blockquote, then move them to the nearest block element in the\u000a			// blockquote.\u000a			if ( CKEDITOR.env.ie ) {\u000a				var bookmarkStart = bookmarks[ 0 ].startNode,\u000a					bookmarkEnd = bookmarks[ 0 ].endNode,\u000a					cursor;\u000a\u000a				if ( bookmarkStart && bookmarkStart.getParent().getName() == 'blockquote' ) {\u000a					cursor = bookmarkStart;\u000a					while ( ( cursor = cursor.getNext() ) ) {\u000a						if ( cursor.type == CKEDITOR.NODE_ELEMENT && cursor.isBlockBoundary() ) {\u000a							bookmarkStart.move( cursor, true );\u000a							break;\u000a						}\u000a					}\u000a				}\u000a\u000a				if ( bookmarkEnd && bookmarkEnd.getParent().getName() == 'blockquote' ) {\u000a					cursor = bookmarkEnd;\u000a					while ( ( cursor = cursor.getPrevious() ) ) {\u000a						if ( cursor.type == CKEDITOR.NODE_ELEMENT && cursor.isBlockBoundary() ) {\u000a							bookmarkEnd.move( cursor );\u000a							break;\u000a						}\u000a					}\u000a				}\u000a			}\u000a\u000a			var iterator = range.createIterator(),\u000a				block;\u000a			iterator.enlargeBr = editor.config.enterMode != CKEDITOR.ENTER_BR;\u000a\u000a			if ( state == CKEDITOR.TRISTATE_OFF ) {\u000a				var paragraphs = [];\u000a				while ( ( block = iterator.getNextParagraph() ) )\u000a					paragraphs.push( block );\u000a\u000a				// If no paragraphs, create one from the current selection position.\u000a				if ( paragraphs.length < 1 ) {\u000a					var para = editor.document.createElement( editor.config.enterMode == CKEDITOR.ENTER_P ? 'p' : 'div' ),\u000a						firstBookmark = bookmarks.shift();\u000a					range.insertNode( para );\u000a					para.append( new CKEDITOR.dom.text( '\u005cufeff', editor.document ) );\u000a					range.moveToBookmark( firstBookmark );\u000a					range.selectNodeContents( para );\u000a					range.collapse( true );\u000a					firstBookmark = range.createBookmark();\u000a					paragraphs.push( para );\u000a					bookmarks.unshift( firstBookmark );\u000a				}\u000a\u000a				// Make sure all paragraphs have the same parent.\u000a				var commonParent = paragraphs[ 0 ].getParent(),\u000a					tmp = [];\u000a				for ( var i = 0; i < paragraphs.length; i++ ) {\u000a					block = paragraphs[ i ];\u000a					commonParent = commonParent.getCommonAncestor( block.getParent() );\u000a				}\u000a\u000a				// The common parent must not be the following tags: table, tbody, tr, ol, ul.\u000a				var denyTags = { table: 1, tbody: 1, tr: 1, ol: 1, ul: 1 };\u000a				while ( denyTags[ commonParent.getName() ] )\u000a					commonParent = commonParent.getParent();\u000a\u000a				// Reconstruct the block list to be processed such that all resulting blocks\u000a				// satisfy parentNode.equals( commonParent ).\u000a				var lastBlock = null;\u000a				while ( paragraphs.length > 0 ) {\u000a					block = paragraphs.shift();\u000a					while ( !block.getParent().equals( commonParent ) )\u000a						block = block.getParent();\u000a					if ( !block.equals( lastBlock ) )\u000a						tmp.push( block );\u000a					lastBlock = block;\u000a				}\u000a\u000a				// If any of the selected blocks is a blockquote, remove it to prevent\u000a				// nested blockquotes.\u000a				while ( tmp.length > 0 ) {\u000a					block = tmp.shift();\u000a					if ( block.getName() == 'blockquote' ) {\u000a						var docFrag = new CKEDITOR.dom.documentFragment( editor.document );\u000a						while ( block.getFirst() ) {\u000a							docFrag.append( block.getFirst().remove() );\u000a							paragraphs.push( docFrag.getLast() );\u000a						}\u000a\u000a						docFrag.replace( block );\u000a					} else\u000a						paragraphs.push( block );\u000a				}\u000a\u000a				// Now we have all the blocks to be included in a new blockquote node.\u000a				var bqBlock = editor.document.createElement( 'blockquote' );\u000a				bqBlock.insertBefore( paragraphs[ 0 ] );\u000a				while ( paragraphs.length > 0 ) {\u000a					block = paragraphs.shift();\u000a					bqBlock.append( block );\u000a				}\u000a			} else if ( state == CKEDITOR.TRISTATE_ON ) {\u000a				var moveOutNodes = [],\u000a					database = {};\u000a\u000a				while ( ( block = iterator.getNextParagraph() ) ) {\u000a					var bqParent = null,\u000a						bqChild = null;\u000a					while ( block.getParent() ) {\u000a						if ( block.getParent().getName() == 'blockquote' ) {\u000a							bqParent = block.getParent();\u000a							bqChild = block;\u000a							break;\u000a						}\u000a						block = block.getParent();\u000a					}\u000a\u000a					// Remember the blocks that were recorded down in the moveOutNodes array\u000a					// to prevent duplicates.\u000a					if ( bqParent && bqChild && !bqChild.getCustomData( 'blockquote_moveout' ) ) {\u000a						moveOutNodes.push( bqChild );\u000a						CKEDITOR.dom.element.setMarker( database, bqChild, 'blockquote_moveout', true );\u000a					}\u000a				}\u000a\u000a				CKEDITOR.dom.element.clearAllMarkers( database );\u000a\u000a				var movedNodes = [],\u000a					processedBlockquoteBlocks = [];\u000a\u000a				database = {};\u000a				while ( moveOutNodes.length > 0 ) {\u000a					var node = moveOutNodes.shift();\u000a					bqBlock = node.getParent();\u000a\u000a					// If the node is located at the beginning or the end, just take it out\u000a					// without splitting. Otherwise, split the blockquote node and move the\u000a					// paragraph in between the two blockquote nodes.\u000a					if ( !node.getPrevious() )\u000a						node.remove().insertBefore( bqBlock );\u000a					else if ( !node.getNext() )\u000a						node.remove().insertAfter( bqBlock );\u000a					else {\u000a						node.breakParent( node.getParent() );\u000a						processedBlockquoteBlocks.push( node.getNext() );\u000a					}\u000a\u000a					// Remember the blockquote node so we can clear it later (if it becomes empty).\u000a					if ( !bqBlock.getCustomData( 'blockquote_processed' ) ) {\u000a						processedBlockquoteBlocks.push( bqBlock );\u000a						CKEDITOR.dom.element.setMarker( database, bqBlock, 'blockquote_processed', true );\u000a					}\u000a\u000a					movedNodes.push( node );\u000a				}\u000a\u000a				CKEDITOR.dom.element.clearAllMarkers( database );\u000a\u000a				// Clear blockquote nodes that have become empty.\u000a				for ( i = processedBlockquoteBlocks.length - 1; i >= 0; i-- ) {\u000a					bqBlock = processedBlockquoteBlocks[ i ];\u000a					if ( noBlockLeft( bqBlock ) )\u000a						bqBlock.remove();\u000a				}\u000a\u000a				if ( editor.config.enterMode == CKEDITOR.ENTER_BR ) {\u000a					var firstTime = true;\u000a					while ( movedNodes.length ) {\u000a						node = movedNodes.shift();\u000a\u000a						if ( node.getName() == 'div' ) {\u000a							docFrag = new CKEDITOR.dom.documentFragment( editor.document );\u000a							var needBeginBr = firstTime && node.getPrevious() && !( node.getPrevious().type == CKEDITOR.NODE_ELEMENT && node.getPrevious().isBlockBoundary() );\u000a							if ( needBeginBr )\u000a								docFrag.append( editor.document.createElement( 'br' ) );\u000a\u000a							var needEndBr = node.getNext() && !( node.getNext().type == CKEDITOR.NODE_ELEMENT && node.getNext().isBlockBoundary() );\u000a							while ( node.getFirst() )\u000a								node.getFirst().remove().appendTo( docFrag );\u000a\u000a							if ( needEndBr )\u000a								docFrag.append( editor.document.createElement( 'br' ) );\u000a\u000a							docFrag.replace( node );\u000a							firstTime = false;\u000a						}\u000a					}\u000a				}\u000a			}\u000a\u000a			selection.selectBookmarks( bookmarks );\u000a			editor.focus();\u000a		},\u000a\u000a		refresh: function( editor, path ) {\u000a			// Check if inside of blockquote.\u000a			var firstBlock = path.block || path.blockLimit;\u000a			this.setState( editor.elementPath( firstBlock ).contains( 'blockquote', 1 ) ? CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF );\u000a		},\u000a\u000a		context: 'blockquote',\u000a\u000a		allowedContent: 'blockquote',\u000a		requiredContent: 'blockquote'\u000a	};\u000a\u000a	CKEDITOR.plugins.add( 'blockquote', {\u000a		lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en,en-au,en-ca,en-gb,eo,es,et,eu,fa,fi,fo,fr,fr-ca,gl,gu,he,hi,hr,hu,id,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt,pt-br,ro,ru,si,sk,sl,sq,sr,sr-latn,sv,th,tr,tt,ug,uk,vi,zh,zh-cn', // %REMOVE_LINE_CORE%\u000a		// icons: 'blockquote', // %REMOVE_LINE_CORE%\u000a		// hidpi: true, // %REMOVE_LINE_CORE%\u000a		init: function( editor ) {\u000a			if ( editor.blockless )\u000a				return;\u000a\u000a			editor.addCommand( 'blockquote', commandObject );\u000a\u000a			editor.ui.addButton && editor.ui.addButton( 'Blockquote', {\u000a				icon: 'blockquote fa fa-quote-right blockquote',\u000a				label: editor.lang.blockquote.toolbar,\u000a				command: 'blockquote',\u000a				toolbar: 'blocks,10'\u000a			} );\u000a		}\u000a	} );\u000a} )();\u000a\u000a\ufeff/*\u000aCopyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000aFor licensing, see LICENSE.md or http://ckeditor.com/license\u000a*/\u000aCKEDITOR.plugins.setLang( 'blockquote', 'en', {\u000a	toolbar: 'Block Quote'\u000a} );\u000a\u000a\ufeff/**\u000a * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000a * For licensing, see LICENSE.md or http://ckeditor.com/license\u000a */\u000a\u000aCKEDITOR.plugins.add( 'format', {\u000a	requires: 'richcombo',\u000a	lang: 'af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en,en-au,en-ca,en-gb,eo,es,et,eu,fa,fi,fo,fr,fr-ca,gl,gu,he,hi,hr,hu,id,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt,pt-br,ro,ru,si,sk,sl,sq,sr,sr-latn,sv,th,tr,tt,ug,uk,vi,zh,zh-cn', // %REMOVE_LINE_CORE%\u000a	init: function( editor ) {\u000a		if ( editor.blockless )\u000a			return;\u000a\u000a		var config = editor.config,\u000a			lang = editor.lang.format;\u000a\u000a		// Gets the list of tags from the settings.\u000a		var tags = config.format_tags.split( ';' );\u000a\u000a		// Create style objects for all defined styles.\u000a		var styles = {},\u000a			stylesCount = 0,\u000a			allowedContent = [];\u000a		for ( var i = 0; i < tags.length; i++ ) {\u000a			var tag = tags[ i ];\u000a			var style = new CKEDITOR.style( config[ 'format_' + tag ] );\u000a			if ( !editor.filter.customConfig || editor.filter.check( style ) ) {\u000a				stylesCount++;\u000a				styles[ tag ] = style;\u000a				styles[ tag ]._.enterMode = editor.config.enterMode;\u000a				allowedContent.push( style );\u000a			}\u000a		}\u000a\u000a		// Hide entire combo when all formats are rejected.\u000a		if ( stylesCount === 0 )\u000a			return;\u000a\u000a		editor.ui.addRichCombo( 'Format', {\u000a			label: lang.label,\u000a			title: lang.panelTitle,\u000a			toolbar: 'styles,20',\u000a			allowedContent: allowedContent,\u000a\u000a			panel: {\u000a				css: [ CKEDITOR.skin.getPath( 'editor' ) ].concat( config.contentsCss ),\u000a				multiSelect: false,\u000a				attributes: { 'aria-label': lang.panelTitle }\u000a			},\u000a\u000a			init: function() {\u000a				this.startGroup( lang.panelTitle );\u000a\u000a				for ( var tag in styles ) {\u000a					var label = lang[ 'tag_' + tag ];\u000a\u000a					// Add the tag entry to the panel list.\u000a					this.add( tag, styles[ tag ].buildPreview( label ), label );\u000a				}\u000a			},\u000a\u000a			onClick: function( value ) {\u000a				editor.focus();\u000a				editor.fire( 'saveSnapshot' );\u000a\u000a				var style = styles[ value ],\u000a					elementPath = editor.elementPath();\u000a\u000a				editor[ style.checkActive( elementPath, editor ) ? 'removeStyle' : 'applyStyle' ]( style );\u000a\u000a				// Save the undo snapshot after all changes are affected. (#4899)\u000a				setTimeout( function() {\u000a					editor.fire( 'saveSnapshot' );\u000a				}, 0 );\u000a			},\u000a\u000a			onRender: function() {\u000a				editor.on( 'selectionChange', function( ev ) {\u000a					var currentTag = this.getValue(),\u000a						elementPath = ev.data.path;\u000a\u000a					this.refresh();\u000a\u000a					for ( var tag in styles ) {\u000a						if ( styles[ tag ].checkActive( elementPath, editor ) ) {\u000a							if ( tag != currentTag )\u000a								this.setValue( tag, editor.lang.format[ 'tag_' + tag ] );\u000a							return;\u000a						}\u000a					}\u000a\u000a					// If no styles match, just empty it.\u000a					this.setValue( '' );\u000a\u000a				}, this );\u000a			},\u000a\u000a			onOpen: function() {\u000a				this.showAll();\u000a				for ( var name in styles ) {\u000a					var style = styles[ name ];\u000a\u000a					// Check if that style is enabled in activeFilter.\u000a					if ( !editor.activeFilter.check( style ) )\u000a						this.hideItem( name );\u000a\u000a				}\u000a			},\u000a\u000a			refresh: function() {\u000a				var elementPath = editor.elementPath();\u000a\u000a				if ( !elementPath )\u000a						return;\u000a\u000a				// Check if element path contains 'p' element.\u000a				if ( !elementPath.isContextFor( 'p' ) ) {\u000a					this.setState( CKEDITOR.TRISTATE_DISABLED );\u000a					return;\u000a				}\u000a\u000a				// Check if there is any available style.\u000a				for ( var name in styles ) {\u000a					if ( editor.activeFilter.check( styles[ name ] ) )\u000a						return;\u000a				}\u000a				this.setState( CKEDITOR.TRISTATE_DISABLED );\u000a			}\u000a		} );\u000a	}\u000a} );\u000a\u000a/**\u000a * A list of semicolon-separated style names (by default: tags) representing\u000a * the style definition for each entry to be displayed in the Format drop-down list\u000a * in the toolbar. Each entry must have a corresponding configuration in a\u000a * setting named `'format_(tagName)'`. For example, the `'p'` entry has its\u000a * definition taken from [config.format_p](#!/api/CKEDITOR.config-cfg-format_p).\u000a *\u000a *		config.format_tags = 'p;h2;h3;pre';\u000a *\u000a * @cfg {String} [format_tags='p;h1;h2;h3;h4;h5;h6;pre;address;div']\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.format_tags = 'p;h1;h2;h3;h4;h5;h6;pre;address;div';\u000a\u000a/**\u000a * The style definition to be used to apply the `Normal` format.\u000a *\u000a *		config.format_p = { element: 'p', attributes: { 'class': 'normalPara' } };\u000a *\u000a * @cfg {Object} [format_p={ element: 'p' }]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.format_p = { element: 'p' };\u000a\u000a/**\u000a * The style definition to be used to apply the `Normal (DIV)` format.\u000a *\u000a *		config.format_div = { element: 'div', attributes: { 'class': 'normalDiv' } };\u000a *\u000a * @cfg {Object} [format_div={ element: 'div' }]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.format_div = { element: 'div' };\u000a\u000a/**\u000a * The style definition to be used to apply the `Formatted` format.\u000a *\u000a *		config.format_pre = { element: 'pre', attributes: { 'class': 'code' } };\u000a *\u000a * @cfg {Object} [format_pre={ element: 'pre' }]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.format_pre = { element: 'pre' };\u000a\u000a/**\u000a * The style definition to be used to apply the `Address` format.\u000a *\u000a *		config.format_address = { element: 'address', attributes: { 'class': 'styledAddress' } };\u000a *\u000a * @cfg {Object} [format_address={ element: 'address' }]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.format_address = { element: 'address' };\u000a\u000a/**\u000a * The style definition to be used to apply the `Heading 1` format.\u000a *\u000a *		config.format_h1 = { element: 'h1', attributes: { 'class': 'contentTitle1' } };\u000a *\u000a * @cfg {Object} [format_h1={ element: 'h1' }]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.format_h1 = { element: 'h1' };\u000a\u000a/**\u000a * The style definition to be used to apply the `Heading 2` format.\u000a *\u000a *		config.format_h2 = { element: 'h2', attributes: { 'class': 'contentTitle2' } };\u000a *\u000a * @cfg {Object} [format_h2={ element: 'h2' }]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.format_h2 = { element: 'h2' };\u000a\u000a/**\u000a * The style definition to be used to apply the `Heading 3` format.\u000a *\u000a *		config.format_h3 = { element: 'h3', attributes: { 'class': 'contentTitle3' } };\u000a *\u000a * @cfg {Object} [format_h3={ element: 'h3' }]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.format_h3 = { element: 'h3' };\u000a\u000a/**\u000a * The style definition to be used to apply the `Heading 4` format.\u000a *\u000a *		config.format_h4 = { element: 'h4', attributes: { 'class': 'contentTitle4' } };\u000a *\u000a * @cfg {Object} [format_h4={ element: 'h4' }]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.format_h4 = { element: 'h4' };\u000a\u000a/**\u000a * The style definition to be used to apply the `Heading 5` format.\u000a *\u000a *		config.format_h5 = { element: 'h5', attributes: { 'class': 'contentTitle5' } };\u000a *\u000a * @cfg {Object} [format_h5={ element: 'h5' }]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.format_h5 = { element: 'h5' };\u000a\u000a/**\u000a * The style definition to be used to apply the `Heading 6` format.\u000a *\u000a *		config.format_h6 = { element: 'h6', attributes: { 'class': 'contentTitle6' } };\u000a *\u000a * @cfg {Object} [format_h6={ element: 'h6' }]\u000a * @member CKEDITOR.config\u000a */\u000aCKEDITOR.config.format_h6 = { element: 'h6' };\u000a\u000a\ufeff/*\u000aCopyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.\u000aFor licensing, see LICENSE.md or http://ckeditor.com/license\u000a*/\u000aCKEDITOR.plugins.setLang( 'format', 'en', {\u000a	label: 'Format',\u000a	panelTitle: 'Paragraph Format',\u000a	tag_address: 'Address',\u000a	tag_div: 'Normal (DIV)',\u000a	tag_h1: 'Heading 1',\u000a	tag_h2: 'Heading 2',\u000a	tag_h3: 'Heading 3',\u000a	tag_h4: 'Heading 4',\u000a	tag_h5: 'Heading 5',\u000a	tag_h6: 'Heading 6',\u000a	tag_p: 'Normal',\u000a	tag_pre: 'Formatted'\u000a} );\u000a\u000a$(function() {\u000a	var editor = null,\u000a		editor_fnct = null,\u000a		editor_timer = null,\u000a		old_date = new Date() + 10000;\u000a\u000a	function onChange(event) {\u000a		if (editor != event.editor) {\u000a			if (editor_fnct) editor_fnct();\u000a			old_date = new Date() + 10000;\u000a		} else if (new Date() > old_date) {\u000a			return;\u000a		}\u000a		clearTimeout(editor_timer);\u000a		editor = event.editor;\u000a		editor_fnct = function() {\u000a			var id = editor.element.getAttribute('id'),\u000a				idx = id.substr(0, 5) === '_ped_' && id.substr(5),\u000a				data = editor.getData();\u000a			$.post(document.urls.page_editor, {\u000a				idx: idx,\u000a				data: data\u000a			}, announce, 'json');\u000a			editor = null;\u000a			editor_fnct = null;\u000a			editor_timer = null;\u000a			old_date = new Date() + 10000;\u000a		};\u000a		editor_timer = setTimeout(editor_fnct, 1000);\u000a	}\u000a\u000a	CKEDITOR.disableAutoInline = true;\u000a	$('[contenteditable]').each(function() {\u000a		var editor = CKEDITOR.inline(this, {\u000a			allowedContent: true\u000a		});\u000a		editor.on('change', onChange);\u000a		// FIXME: This is an ugly fix to issue http://dev.ckeditor.com/ticket/9814\u000a		// Chrome shows editors as read-only when they're initially not visible.\u000a		editor.on('focus', function () {\u000a			editor.setReadOnly(false);\u000a		});\u000a	});\u000a});\u000a}();
p1
.